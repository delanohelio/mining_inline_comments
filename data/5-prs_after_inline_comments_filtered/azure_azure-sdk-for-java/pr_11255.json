{"pr_number": 11255, "pr_title": "Adding flexibility to parsing serializer encodings.", "pr_createdAt": "2020-05-18T19:28:47Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/11255", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDkxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426850917", "bodyText": "I guess you mean:\nreturn DEFAULT_ENCODING;", "author": "anuchandy", "createdAt": "2020-05-18T19:36:14Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1ODExOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426858119", "bodyText": "Thanks! Good catch.", "author": "conniey", "createdAt": "2020-05-18T19:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426852757", "bodyText": "I think MIME types are case insensitive but good to double-check.", "author": "anuchandy", "createdAt": "2020-05-18T19:40:11Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"\n+                    + rawMimeType);\n+            }\n+\n+            this.type = parts[0];\n+            this.subType = parts[1];\n+        }\n+\n+        private boolean matches(String otherType, String otherSubType) {\n+            return type.equals(otherType) && subType.equals(otherSubType);", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1ODMwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426858302", "bodyText": "in line 59, I do a .toLowerCase(Locale.ROOT), but I can update this to be case insensitive instead.", "author": "conniey", "createdAt": "2020-05-18T19:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDE3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860178", "bodyText": "ah, I missed that, thanks for the reference.", "author": "anuchandy", "createdAt": "2020-05-18T19:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mjc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MzUwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853504", "bodyText": "Going to need a Checkstyle suppression for this.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:41:46Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1Mzc3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853774", "bodyText": "I believe we have static properties for these values in ContentType.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:42:22Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1MzkyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426853927", "bodyText": "Should have a static property for this in ContentType.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:42:40Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg1NDcyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426854727", "bodyText": "Will need a Checkstyle suppression for this.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:44:25Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"\n+                + \"Returning default: {}\", mimeType, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        for (SerializerEncodingMimeTypes serializerEncodingMimeTypes : SUPPORTED_MIME_TYPES) {\n+            if (serializerEncodingMimeTypes.matches(mimeTypeParts[0], mimeTypeParts[1])) {\n+                return serializerEncodingMimeTypes.getEncoding();\n+            }\n+        }\n+\n+        LOGGER.warning(\"Content-Type '{}' does not match any supported one. Returning default: {}\",\n+            mimeType, DEFAULT_ENCODING);\n+\n+        return DEFAULT_ENCODING;\n+    }\n+\n+    /**\n+     * A mapping of serialization type to the supported mime type.\n+     */\n+    private static final class SerializerEncodingMimeTypes {\n+        private final SerializerEncoding encoding;\n+        private final String suffix;\n+        private final List<MimeType> mimeTypes;\n+\n+        private SerializerEncodingMimeTypes(SerializerEncoding encoding, String suffix, MimeType... mimeTypes) {\n+            this.encoding = encoding;\n+            this.suffix = suffix;\n+            this.mimeTypes = Arrays.asList(mimeTypes);\n+        }\n+\n+        private boolean matches(String type, String subtype) {\n+            for (MimeType supported : mimeTypes) {\n+                if (supported.matches(type, subtype)) {\n+                    return true;\n+                }\n             }\n+\n+            // Check the suffix if it does not match the full types.\n+            final int lastIndex = subtype.lastIndexOf(\"+\");\n+            if (lastIndex == -1) {\n+                return false;\n+            }\n+\n+            final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+            return suffix.equals(mimeTypeSuffix);\n         }\n \n-        return JSON;\n+        public SerializerEncoding getEncoding() {\n+            return encoding;\n+        }\n+    }\n+\n+    private static final class MimeType {\n+        private final String type;\n+        private final String subType;\n+\n+        private MimeType(String rawMimeType) {\n+            final String[] parts = rawMimeType.split(\"/\");\n+            if (parts.length != 2) {\n+                throw new IllegalArgumentException(\"mimeType is not properly formatted with {type}/{subtype}: \"", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860213", "bodyText": "Thoughts on making this more simplified using a case insensitive TreeMap. Begin by adding in well known Content-Types such as application/json, text/xml, and application/xml (plus additional in the future as we expand), then add in a simple \"json\" -> SerializerEncoding.JSON and same for XML.\nDuring the conversion from HttpHeaders to SerializerEncoding we use the following checks:\n\nMissing ContentType or it is null or empty, log a warning and return JSON.\nCheck if the ContentType exists in the TreeMap, if it does return that value.\nUse string splitting logic, finding the sub-type and if it exists the + split.\n\nThis would simplify out a lot of the class overhead and generally have the same result. Additionally, the map could be updated with the Content-Types that weren't in the well known set to optimize them in future cases when they appear (this runs a risk of having many Content-Types if they get randomized a lot but I think that would be a bad design).", "author": "alzimmermsft", "createdAt": "2020-05-18T19:55:22Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDYxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426860616", "bodyText": "Another option instead of TreeMap is ConcurrentSkipListMap which also has the option for a key comparator.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MDIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg2MTAxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426861014", "bodyText": "nit: This uses a slightly different error message than the same check in MimeType.", "author": "alzimmermsft", "createdAt": "2020-05-18T19:57:07Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,110 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final List<SerializerEncodingMimeTypes> SUPPORTED_MIME_TYPES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+    static {\n+        SUPPORTED_MIME_TYPES = new ArrayList<>();\n+\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(XML, \"xml\",\n+            new MimeType(\"text/xml\"), new MimeType(\"application/xml\")));\n+        SUPPORTED_MIME_TYPES.add(new SerializerEncodingMimeTypes(JSON, \"json\",\n+            new MimeType(\"application/json\")));\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, JSON);\n+            return JSON;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+\n+        final String mimeType = parts[0].toLowerCase(Locale.ROOT);\n+        final String[] mimeTypeParts = mimeType.split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type/'subtype'. \"", "originalCommit": "4909c72804e1e8bde3e80a40a3f80a309e793c0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "613f26627f0004fc0197b4abc54c2f6b5337f05f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/613f26627f0004fc0197b4abc54c2f6b5337f05f", "message": "Adding more flexible support for encodings.", "committedDate": "2020-05-18T20:42:06Z", "type": "commit"}, {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "message": "Add suppression.", "committedDate": "2020-05-18T20:45:18Z", "type": "commit"}, {"oid": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "message": "Add suppression.", "committedDate": "2020-05-18T20:45:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjAzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426886039", "bodyText": "Could use String.CASE_INSENSITIVE_ORDER.", "author": "alzimmermsft", "createdAt": "2020-05-18T20:50:23Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);", "originalCommit": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjQxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426886412", "bodyText": "Watch out, this could hit transient concurrent modification errors. Mind trying out ConcurrentSkipListMap?", "author": "alzimmermsft", "createdAt": "2020-05-18T20:51:14Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;", "originalCommit": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MTQyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426891421", "bodyText": "We never modify this list other than at static construction.", "author": "conniey", "createdAt": "2020-05-18T21:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NzQ0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426887440", "bodyText": "Should SUPPORTED_MIME_TYPES get updated with the Content-Type-SerializerEncoding value that we deduced.", "author": "alzimmermsft", "createdAt": "2020-05-18T20:53:33Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        final String mimeTypeSuffix = subtype.substring(lastIndex + 1);\n+        final SerializerEncoding serializerEncoding = SUPPORTED_SUFFIXES.get(mimeTypeSuffix);\n+        if (serializerEncoding != null) {\n+            return serializerEncoding;", "originalCommit": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MDkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426890904", "bodyText": "I'm generally not a fan of making this hold some sort of mutable state, especially since this is a static helper method.", "author": "conniey", "createdAt": "2020-05-18T21:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NzQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4ODkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426888901", "bodyText": "This could be slightly wrong if we run across something like text/json, instead we should check:\nfinal String subType = mimeTypeParts[1];\nfinal int lastIndex = subType.lastIndexOf(\"+\");\n\nfinal String mimeType = (lastIndex == -1) ? subtype : subtype.substring(lastIndex + 1);", "author": "alzimmermsft", "createdAt": "2020-05-18T20:56:49Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/SerializerEncoding.java", "diffHunk": "@@ -20,21 +25,70 @@\n      */\n     XML;\n \n+    private static final ClientLogger LOGGER = new ClientLogger(SerializerEncoding.class);\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final Map<String, SerializerEncoding> SUPPORTED_MIME_TYPES;\n+    private static final TreeMap<String, SerializerEncoding> SUPPORTED_SUFFIXES;\n+    private static final SerializerEncoding DEFAULT_ENCODING = JSON;\n+\n+\n+    static {\n+        // Encodings and suffixes from: https://tools.ietf.org/html/rfc6838\n+        final Comparator<String> comparator = Comparator.comparing(Function.identity(), String::compareToIgnoreCase);\n+\n+        SUPPORTED_MIME_TYPES = new TreeMap<>(comparator);\n+        SUPPORTED_MIME_TYPES.put(\"text/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/xml\", XML);\n+        SUPPORTED_MIME_TYPES.put(\"application/json\", JSON);\n+\n+        SUPPORTED_SUFFIXES = new TreeMap<>(comparator);\n+        SUPPORTED_SUFFIXES.put(\"xml\", XML);\n+        SUPPORTED_SUFFIXES.put(\"json\", JSON);\n+    }\n+\n     /**\n      * Determines the serializer encoding to use based on the Content-Type header.\n      *\n-     * @param headers the headers to check the encoding for\n-     * @return the serializer encoding to use for the body\n+     * @param headers the headers to check the encoding for.\n+     * @return the serializer encoding to use for the body. {@link #JSON} if there is no Content-Type header or an\n+     * unrecognized Content-Type encoding is returned.\n      */\n     public static SerializerEncoding fromHeaders(HttpHeaders headers) {\n-        String mimeContentType = headers.getValue(\"Content-Type\");\n-        if (mimeContentType != null) {\n-            String[] parts = mimeContentType.split(\";\");\n-            if (parts[0].equalsIgnoreCase(\"application/xml\") || parts[0].equalsIgnoreCase(\"text/xml\")) {\n-                return XML;\n-            }\n+        final String mimeContentType = headers.getValue(CONTENT_TYPE);\n+        if (mimeContentType == null || mimeContentType.isEmpty()) {\n+            LOGGER.warning(\"'{}' not found. Returning default encoding: {}\", CONTENT_TYPE, DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n         }\n \n-        return JSON;\n+        final SerializerEncoding encoding = SUPPORTED_MIME_TYPES.get(mimeContentType);\n+        if (encoding != null) {\n+            return encoding;\n+        }\n+\n+        final String[] parts = mimeContentType.split(\";\");\n+        final String[] mimeTypeParts = parts[0].split(\"/\");\n+        if (mimeTypeParts.length != 2) {\n+            LOGGER.warning(\"Content-Type '{}' does not match mime-type formatting 'type'/'subtype'. \"\n+                + \"Returning default: {}\", parts[0], DEFAULT_ENCODING);\n+            return DEFAULT_ENCODING;\n+        }\n+\n+        // Check the suffix if it does not match the full types.\n+        final String subtype = mimeTypeParts[1];\n+        final int lastIndex = subtype.lastIndexOf(\"+\");\n+        if (lastIndex == -1) {\n+            return DEFAULT_ENCODING;\n+        }", "originalCommit": "9a9cbe9546597aefb7f51e7e638fe1feaab6e5ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MDEyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11255#discussion_r426890120", "bodyText": "text/json isn't a well-supported mimetype though, nor is it a proper suffix.", "author": "conniey", "createdAt": "2020-05-18T20:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4ODkwMQ=="}], "type": "inlineReview"}, {"oid": "3235bdc30482f381dbf2c16ec08078a434d9f9af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3235bdc30482f381dbf2c16ec08078a434d9f9af", "message": "Change compator", "committedDate": "2020-05-18T21:16:59Z", "type": "commit"}, {"oid": "3d5d9f163deaa95670653ae1890669dad143044f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d5d9f163deaa95670653ae1890669dad143044f", "message": "Remove unused imports.", "committedDate": "2020-05-18T21:44:58Z", "type": "commit"}]}