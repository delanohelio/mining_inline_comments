{"pr_number": 8500, "pr_title": "Nio copy", "pr_createdAt": "2020-02-26T20:20:27Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8500", "timeline": [{"oid": "2efe2c115e70c4f07a6467e5ff3ec83a51e2d65d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2efe2c115e70c4f07a6467e5ff3ec83a51e2d65d", "message": "Worked on copy and some helpers", "committedDate": "2020-02-26T19:55:04Z", "type": "commit"}, {"oid": "c4d256ccd316b1be5f939e2de7be7ba0f5978cf4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4d256ccd316b1be5f939e2de7be7ba0f5978cf4", "message": "Added copy", "committedDate": "2020-02-26T20:03:17Z", "type": "commit"}, {"oid": "2e07f1e8e12eca5de38b463157b86bd4cc2b3177", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e07f1e8e12eca5de38b463157b86bd4cc2b3177", "message": "More tests", "committedDate": "2020-02-26T20:11:30Z", "type": "commit"}, {"oid": "4e3ca5a5a95c3fe2c945e755ba58ee406f0e1bbc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e3ca5a5a95c3fe2c945e755ba58ee406f0e1bbc", "message": "Cleanup and recordings", "committedDate": "2020-02-26T20:11:58Z", "type": "commit"}, {"oid": "7297ab8ac6d23abe0320a90a958976358c45e20e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7297ab8ac6d23abe0320a90a958976358c45e20e", "message": "Pom/style/resources cleanup", "committedDate": "2020-02-26T20:12:37Z", "type": "commit"}, {"oid": "3bf83d19a92b5aec5f890152e811949d6f3b28e1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bf83d19a92b5aec5f890152e811949d6f3b28e1", "message": "Reverted core dependency", "committedDate": "2020-02-26T21:39:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTQxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r384765410", "bodyText": "I know this isnt part of this particular PR but do you think it might be useful to catch the specific Error Code as well here?", "author": "gapra-msft", "createdAt": "2020-02-26T21:06:52Z", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -261,27 +270,22 @@ public void createDirectory(Path path, FileAttribute<?>... fileAttributes) throw\n         }\n         fileAttributes = fileAttributes == null ? new FileAttribute<?>[0] : fileAttributes;\n \n-        // Get the destination for the directory and it's parent container.\n+        // Get the destination for the directory.\n         BlobClient client = ((AzurePath) path).toBlobClient();\n-        BlobContainerClient containerClient = ((AzureFileSystem) path.getFileSystem()).getBlobServiceClient()\n-            .getBlobContainerClient(client.getContainerName());\n \n-        // Determine the path for the parent directory blob. This is the parent path without the root.\n+        // Validate that we are not trying to create a root.\n         Path root = path.getRoot();\n         if (root != null && root.equals(path)) {\n             throw Utility.logError(logger, new IOException(\"Creating a root directory is not supported.\"));\n         }\n-        Path prefix = root == null ? path.getParent() : root.relativize(path).getParent();\n \n         // Check if parent exists. If it does, atomically check if a file already exists and create a new dir if not.\n-        if (checkParentDirectoryExists(containerClient, prefix)) {\n+        if (checkParentDirectoryExists(path)) {\n             try {\n                 List<FileAttribute<?>> attributeList = new ArrayList<>(Arrays.asList(fileAttributes));\n                 BlobHttpHeaders headers = Utility.extractHttpHeaders(attributeList, logger);\n                 Map<String, String> metadata = Utility.convertAttributesToMetadata(attributeList);\n-                metadata = prepareMetadataForDirectory(metadata);\n-                client.getAppendBlobClient().createWithResponse(headers, metadata,\n-                    new BlobRequestConditions().setIfNoneMatch(\"*\"), null, null);\n+                putDirectoryBlob(client, headers, metadata, new BlobRequestConditions().setIfNoneMatch(\"*\"));\n             } catch (BlobStorageException e) {\n                 if (e.getStatusCode() == HttpURLConnection.HTTP_CONFLICT) {", "originalCommit": "7297ab8ac6d23abe0320a90a958976358c45e20e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzOTQ5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r384839490", "bodyText": "Would it be helpful to a user to separate these checks so they know which is illegal?", "author": "gapra-msft", "createdAt": "2020-02-26T23:59:04Z", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -325,13 +369,184 @@ public void delete(Path path) throws IOException {\n     }\n \n     /**\n+     * As stated in the nio docs, this method is not atomic. More specifically, the checks necessary to validate the\n+     * inputs and state of the file system are not atomic with the actual copying of data. If the copy is triggered,\n+     * the copy itself is atomic and only a complete copy will ever be left at the destination.\n+     *\n+     * In addition to those in the nio javadocs, this method has the following requirements for successful completion.\n+     * {@link StandardCopyOption#COPY_ATTRIBUTES} must be passed as it is impossible not to copy blob properties;\n+     * if this option is not passed, an {@link UnsupportedOperationException} will be thrown. Neither the source nor the\n+     * destination can be a root directory; if either is a root directory, an {@link IllegalArgumentException} will be\n+     * thrown. The parent directory of the destination must at least weakly exist; if it does not, an\n+     * {@link IOException} will be thrown. The only supported option other than\n+     * {@link StandardCopyOption#COPY_ATTRIBUTES} is {@link StandardCopyOption#REPLACE_EXISTING}; the presence of any\n+     * other option will result in an {@link UnsupportedOperationException}.\n+     *\n+     * This method supports both virtual and concrete directories as both the source and destination. Unlike when\n+     * creating a directory, the existence of a virtual directory at the destination will cause this operation to fail.\n+     * This is in order to prevent the possibility of overwriting a non-empty virtual directory with a file. Still, as\n+     * mentioned above, this check is not atomic with the creation of the resultant directory.\n+     *\n      * {@inheritDoc}\n+     * @see #createDirectory(Path, FileAttribute[]) for more information about directory existence.\n      */\n     @Override\n-    public void copy(Path path, Path path1, CopyOption... copyOptions) throws IOException {\n+    public void copy(Path source, Path destination, CopyOption... copyOptions) throws IOException {\n+        // Validate instance types.\n+        if (!(source instanceof AzurePath && destination instanceof AzurePath)) {\n+            throw Utility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on subtypes of \"\n+                + \"Path other than AzurePath\"));\n+        }\n+\n+        // If paths point to the same file, operation is a no-op.\n+        if (source.equals(destination)) {\n+            return;\n+        }\n+\n+        // Read and validate options.\n+        // Remove accepted options as we find them. Anything left we don't support.\n+        boolean replaceExisting = false;\n+        List<CopyOption> optionsList = new ArrayList<>(Arrays.asList(copyOptions));\n+        if (!optionsList.contains(StandardCopyOption.COPY_ATTRIBUTES)) {\n+            throw Utility.logError(logger, new UnsupportedOperationException(\"StandardCopyOption.COPY_ATTRIBUTES \"\n+                + \"must be specified as the service will always copy file attributes.\"));\n+        }\n+        optionsList.remove(StandardCopyOption.COPY_ATTRIBUTES);\n+        if (optionsList.contains(StandardCopyOption.REPLACE_EXISTING)) {\n+            replaceExisting = true;\n+            optionsList.remove(StandardCopyOption.REPLACE_EXISTING);\n+        }\n+        if (!optionsList.isEmpty()) {\n+            throw Utility.logError(logger, new UnsupportedOperationException(\"Unsupported copy option found. Only \"\n+                + \"StandardCopyOption.COPY_ATTRIBUTES and StandareCopyOption.REPLACE_EXISTING are supported.\"));\n+        }\n \n+        // Validate paths.\n+        // Copying a root directory or attempting to create/overwrite a root directory is illegal.\n+        if (source.equals(source.getRoot()) || destination.equals(destination.getRoot())) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Neither source nor destination \"", "originalCommit": "3bf83d19a92b5aec5f890152e811949d6f3b28e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MjcwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r384842707", "bodyText": "I actually just refactored this to do exactly that :). It'll be in my next PR.", "author": "rickle-msft", "createdAt": "2020-02-27T00:09:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzOTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MTYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r384841607", "bodyText": "Is there a reason for the duration being 30 here?", "author": "gapra-msft", "createdAt": "2020-02-27T00:05:47Z", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -325,13 +369,184 @@ public void delete(Path path) throws IOException {\n     }\n \n     /**\n+     * As stated in the nio docs, this method is not atomic. More specifically, the checks necessary to validate the\n+     * inputs and state of the file system are not atomic with the actual copying of data. If the copy is triggered,\n+     * the copy itself is atomic and only a complete copy will ever be left at the destination.\n+     *\n+     * In addition to those in the nio javadocs, this method has the following requirements for successful completion.\n+     * {@link StandardCopyOption#COPY_ATTRIBUTES} must be passed as it is impossible not to copy blob properties;\n+     * if this option is not passed, an {@link UnsupportedOperationException} will be thrown. Neither the source nor the\n+     * destination can be a root directory; if either is a root directory, an {@link IllegalArgumentException} will be\n+     * thrown. The parent directory of the destination must at least weakly exist; if it does not, an\n+     * {@link IOException} will be thrown. The only supported option other than\n+     * {@link StandardCopyOption#COPY_ATTRIBUTES} is {@link StandardCopyOption#REPLACE_EXISTING}; the presence of any\n+     * other option will result in an {@link UnsupportedOperationException}.\n+     *\n+     * This method supports both virtual and concrete directories as both the source and destination. Unlike when\n+     * creating a directory, the existence of a virtual directory at the destination will cause this operation to fail.\n+     * This is in order to prevent the possibility of overwriting a non-empty virtual directory with a file. Still, as\n+     * mentioned above, this check is not atomic with the creation of the resultant directory.\n+     *\n      * {@inheritDoc}\n+     * @see #createDirectory(Path, FileAttribute[]) for more information about directory existence.\n      */\n     @Override\n-    public void copy(Path path, Path path1, CopyOption... copyOptions) throws IOException {\n+    public void copy(Path source, Path destination, CopyOption... copyOptions) throws IOException {\n+        // Validate instance types.\n+        if (!(source instanceof AzurePath && destination instanceof AzurePath)) {\n+            throw Utility.logError(logger, new IllegalArgumentException(\"This provider cannot operate on subtypes of \"\n+                + \"Path other than AzurePath\"));\n+        }\n+\n+        // If paths point to the same file, operation is a no-op.\n+        if (source.equals(destination)) {\n+            return;\n+        }\n+\n+        // Read and validate options.\n+        // Remove accepted options as we find them. Anything left we don't support.\n+        boolean replaceExisting = false;\n+        List<CopyOption> optionsList = new ArrayList<>(Arrays.asList(copyOptions));\n+        if (!optionsList.contains(StandardCopyOption.COPY_ATTRIBUTES)) {\n+            throw Utility.logError(logger, new UnsupportedOperationException(\"StandardCopyOption.COPY_ATTRIBUTES \"\n+                + \"must be specified as the service will always copy file attributes.\"));\n+        }\n+        optionsList.remove(StandardCopyOption.COPY_ATTRIBUTES);\n+        if (optionsList.contains(StandardCopyOption.REPLACE_EXISTING)) {\n+            replaceExisting = true;\n+            optionsList.remove(StandardCopyOption.REPLACE_EXISTING);\n+        }\n+        if (!optionsList.isEmpty()) {\n+            throw Utility.logError(logger, new UnsupportedOperationException(\"Unsupported copy option found. Only \"\n+                + \"StandardCopyOption.COPY_ATTRIBUTES and StandareCopyOption.REPLACE_EXISTING are supported.\"));\n+        }\n \n+        // Validate paths.\n+        // Copying a root directory or attempting to create/overwrite a root directory is illegal.\n+        if (source.equals(source.getRoot()) || destination.equals(destination.getRoot())) {\n+            throw Utility.logError(logger, new IllegalArgumentException(String.format(\"Neither source nor destination \"\n+                + \"can be just a root directory. Source: %s. Destination: %s.\", source.toString(),\n+                destination.toString())));\n+        }\n+\n+        // Build clients.\n+        BlobClient sourceBlob = ((AzurePath) source).toBlobClient();\n+        BlobClient destinationBlob = ((AzurePath) destination).toBlobClient();\n+\n+        // Check destination is not a directory with children.\n+        DirectoryStatus destinationStatus = checkDirStatus(destinationBlob);\n+        if (destinationStatus.equals(DirectoryStatus.NOT_EMPTY)) {\n+            throw Utility.logError(logger, new DirectoryNotEmptyException(destination.toString()));\n+        }\n+\n+        /*\n+        Set request conditions if we should not overwrite. We can error out here if we know something already exists,\n+        but we will also create request conditions as a safeguard against overwriting something that was created\n+        between our check and put.\n+         */\n+        BlobRequestConditions requestConditions = null;\n+        if (!replaceExisting) {\n+            if (!destinationStatus.equals(DirectoryStatus.DOES_NOT_EXIST)) {\n+                throw Utility.logError(logger, new FileAlreadyExistsException(destination.toString()));\n+            }\n+            requestConditions = new BlobRequestConditions().setIfNoneMatch(\"*\");\n+        }\n+\n+        /*\n+        More path validation\n+\n+        Check that the parent for the destination exists. We only need to perform this check if there is nothing\n+        currently at the destination, for if the destination exists, its parent at least weakly exists and we\n+        can skip a service call.\n+         */\n+        if (destinationStatus.equals(DirectoryStatus.DOES_NOT_EXIST) && !checkParentDirectoryExists(destination)) {\n+            throw Utility.logError(logger, new IOException(\"Parent directory of destination location does not exist.\"\n+                + \"The destination path is therefore invalid. Destination: \" + destination.toString()));\n+        }\n+\n+        /*\n+        Try to copy the resource at the source path.\n+\n+        There is an optimization here where we try to do the copy first and only check for a virtual directory if\n+        there's a 404. In the cases of files and concrete directories, this only requires one request. For virtual\n+        directories, however, this requires three requests: failed copy, check status, create directory. Depending on\n+        customer scenarios and how many virtual directories they copy, it could be better to check the directory status\n+        first and then do a copy or createDir, which would always be two requests for all resource types.\n+         */\n+        try {\n+            SyncPoller<BlobCopyInfo, Void> pollResponse =\n+                destinationBlob.beginCopy(sourceBlob.getBlobUrl(), null, null, null, null, requestConditions, null);\n+            pollResponse.waitForCompletion(Duration.ofSeconds(30));", "originalCommit": "7297ab8ac6d23abe0320a90a958976358c45e20e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MzI0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r384843243", "bodyText": "Nope. Just a magic number plus being a little lazy about adding a constant/option. I figure we can add an option for it if/when people are dissatisfied with this. Or I can add an option now. :P", "author": "rickle-msft", "createdAt": "2020-02-27T00:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MTYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTgwODA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8500#discussion_r385808043", "bodyText": "might at least be helpful to make it a constant so we dont have to dig around for them later. ya know?", "author": "gapra-msft", "createdAt": "2020-02-28T16:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MTYwNw=="}], "type": "inlineReview"}, {"oid": "11224f2bc546bf26c9e3986dec155cee18f8d2f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/11224f2bc546bf26c9e3986dec155cee18f8d2f1", "message": "PR feedback", "committedDate": "2020-03-06T00:42:19Z", "type": "commit"}, {"oid": "191337e74eb8250cef93169f43097cee82c2586e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/191337e74eb8250cef93169f43097cee82c2586e", "message": "Checkstyle", "committedDate": "2020-03-06T18:49:23Z", "type": "commit"}]}