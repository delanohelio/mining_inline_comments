{"pr_number": 9953, "pr_title": "[FR] implements auto-content-detection method getContentType() ", "pr_createdAt": "2020-04-08T05:58:13Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9953", "timeline": [{"oid": "f2a522130353f54ad0439c600c1f4dd21eb47105", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2a522130353f54ad0439c600c1f4dd21eb47105", "message": "getContentType implementation", "committedDate": "2020-04-08T04:38:15Z", "type": "commit"}, {"oid": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "message": "getContentType impl", "committedDate": "2020-04-08T05:54:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTI3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405569275", "bodyText": "It could be nice to pull out the Byte.toUnsignedInt((byte)) into a separate function", "author": "iscai-msft", "createdAt": "2020-04-08T14:30:08Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDg5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406620896", "bodyText": "updated", "author": "mssfang", "createdAt": "2020-04-10T06:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2OTI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDI5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405570295", "bodyText": "For Jpeg, I think you also need to check the last two bytes are 0xFF and 0xD9", "author": "iscai-msft", "createdAt": "2020-04-08T14:31:32Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x44) && byte3 == Byte.toUnsignedInt((byte) 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0xff) && byte1 == Byte.toUnsignedInt((byte) 0xd8)) {", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NTcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405645724", "bodyText": "I removed this for python (b/c for a buffered stream I didn't want to read the entire file and the first two bytes work)", "author": "kristapratico", "createdAt": "2020-04-08T16:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2NjA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405666041", "bodyText": "ok ignore this", "author": "iscai-msft", "createdAt": "2020-04-08T16:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MDI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MjgwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405572803", "bodyText": "Just making sure that this little edit is all that needs to be changed in the key credential transition", "author": "iscai-msft", "createdAt": "2020-04-08T14:34:49Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/FormRecognizerClientTestBase.java", "diffHunk": "@@ -218,7 +218,7 @@ private static void validatePageMetadata(PageMetadata expectedPageInfo, PageMeta\n      * Create a client builder with endpoint and API key credential.\n      *\n      * @param endpoint the given endpoint\n-     * @param credential the given {@link FormRecognizerApiKeyCredential} credential\n+     * @param credential the given {@link AzureKeyCredential} credential", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406620630", "bodyText": "FormRecognizerApiKeyCredential is a deprecated type", "author": "mssfang", "createdAt": "2020-04-10T06:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MjgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc1NzU1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406757552", "bodyText": "Sounds more like Isa was calling out if there were other places where the change needed to happen.\nLooks like this was the only remaining though", "author": "maririos", "createdAt": "2020-04-10T13:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU3MjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NTM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405645399", "bodyText": "If content type cannot be auto-detected we still need to let the user pass content type themselves. Perhaps include that in this exception message?", "author": "kristapratico", "createdAt": "2020-04-08T16:14:32Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\");\n+        }\n+\n+        final int byte0 = Byte.toUnsignedInt(bytes[0]);\n+        final int byte1 = Byte.toUnsignedInt(bytes[1]);\n+        final int byte2 = Byte.toUnsignedInt(bytes[2]);\n+        final int byte3 = Byte.toUnsignedInt(bytes[3]);\n+\n+        if (byte0 == Byte.toUnsignedInt((byte) 0x25) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x44) && byte3 == Byte.toUnsignedInt((byte) 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0xff) && byte1 == Byte.toUnsignedInt((byte) 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (byte0 == Byte.toUnsignedInt((byte) 0x89) && byte1 == Byte.toUnsignedInt((byte) 0x50) &&\n+            byte2 == Byte.toUnsignedInt((byte) 0x4e) && byte3 == Byte.toUnsignedInt((byte) 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if ((byte0 == Byte.toUnsignedInt((byte) 0x49) && byte1 == Byte.toUnsignedInt((byte) 0x49) &&\n+                byte2 == Byte.toUnsignedInt((byte) 0x2a) && byte3 == Byte.toUnsignedInt((byte) 0x0)) || // little-endian\n+            (byte0 == Byte.toUnsignedInt((byte) 0x4d) && byte1 == Byte.toUnsignedInt((byte) 0x4d) &&\n+                byte2 == Byte.toUnsignedInt((byte) 0x0) && byte3 == Byte.toUnsignedInt((byte) 0x2a))) {  // big-endian\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException (\"content type could not be detected\");", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406620683", "bodyText": "updated", "author": "mssfang", "createdAt": "2020-04-10T06:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0NTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODMwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405648305", "bodyText": "Should this be logger throw?", "author": "samvaity", "createdAt": "2020-04-08T16:18:53Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +16,61 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n-     *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw Exceptions.propagate(ioe);", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDc0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406620741", "bodyText": "updated", "author": "mssfang", "createdAt": "2020-04-10T06:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405648732", "bodyText": "Should we consider moving this to core?\ncc: @srnagar", "author": "samvaity", "createdAt": "2020-04-08T16:19:32Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +16,61 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n-     *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwMzEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406603123", "bodyText": "FYI, I talked to @alzimmermsft  a couple days ago. I will finish this implementation in Form Recognizer first, and then he will decide to move this to core or not.", "author": "mssfang", "createdAt": "2020-04-10T05:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMTQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406831450", "bodyText": "This is something we'll want to add into FluxUtil eventually, mind filing an issue for this.", "author": "alzimmermsft", "createdAt": "2020-04-10T16:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0ODUyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r410348522", "bodyText": "#10337", "author": "mssfang", "createdAt": "2020-04-17T16:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0ODczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0OTY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405649672", "bodyText": "Need tests?", "author": "samvaity", "createdAt": "2020-04-08T16:21:00Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/Transforms.java", "diffHunk": "@@ -183,6 +185,43 @@ private static PageMetadata getPageInfo(ReadResult readResultItem) {\n             readResultItem.getAngle(), DimensionUnit.fromString(readResultItem.getUnit().toString()));\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    static ContentType getContentType(ByteBuffer buffer) {", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyMDgxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406620818", "bodyText": "added a few unit tests", "author": "mssfang", "createdAt": "2020-04-10T06:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY0OTY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTQ0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405661444", "bodyText": "Feels like it shouldn't belong to Trasnform?", "author": "jeremymeng", "createdAt": "2020-04-08T16:38:56Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -30,6 +29,7 @@\n import java.util.UUID;\n import java.util.function.Function;\n \n+import static com.azure.ai.formrecognizer.Transforms.getContentType;", "originalCommit": "43bb49e95e2fdc996cb9489ebffd338f0d39bfe8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MzgxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r405663818", "bodyText": "Yeah, could consider moving this to Utility @mssfang ?", "author": "samvaity", "createdAt": "2020-04-08T16:42:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwMjg0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406602841", "bodyText": "Will move to Utility class", "author": "mssfang", "createdAt": "2020-04-10T05:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY2MTQ0NA=="}], "type": "inlineReview"}, {"oid": "c8b2f54620a69ca479280b9422f295419c25dafe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c8b2f54620a69ca479280b9422f295419c25dafe", "message": "add tests and address feedbacks", "committedDate": "2020-04-10T06:20:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4OTE4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406789183", "bodyText": "nitpick (feel free to ignore)\nYou could make the function isEqual take in a list of bytes and what they should be, so the code could be more like\nisEqual(bytes.subList(0, 4), [0x25, 0x50, 0x44, 0x46])", "author": "iscai-msft", "createdAt": "2020-04-10T14:43:53Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -22,6 +23,41 @@\n     private Utility() {\n     }\n \n+    /**\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n+     *\n+     * @param buffer The byte buffer input.\n+     *\n+     * @return The {@link ContentType} content type.\n+     */\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc4OTY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406789685", "bodyText": "Consider adding a test where the user passes in the content type", "author": "iscai-msft", "createdAt": "2020-04-10T14:45:03Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/ContentTypeDetectionTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.implementation.Utility;\n+import com.azure.ai.formrecognizer.implementation.models.ContentType;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Files;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * Unit tests for automatically detection of content type.\n+ */\n+public class ContentTypeDetectionTest {\n+\n+    /**\n+     * Test for JPG file content type detection.\n+     *\n+     * @throws  IOException if an I/O error occurs reading from the stream\n+     */\n+    @Test\n+    public void jpgContentDetectionTest() throws IOException {", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMDgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406830823", "bodyText": "We generally don't want to block in Reactive code as this could cause a RuntimeException for blocking in a non-blocking thread. We have some control on whether non-blocking threads are being used but not complete control.", "author": "alzimmermsft", "createdAt": "2020-04-10T16:19:25Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -173,11 +170,11 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     }\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n-        Flux<ByteBuffer> buffer, long length, FormContentType formContentType, boolean includeTextDetails) {\n+        Flux<ByteBuffer> buffer, long length, boolean includeTextDetails) {\n         return (pollingContext) -> {\n             try {\n                 return service.analyzeReceiptAsyncWithResponseAsync(includeTextDetails,\n-                    ContentType.fromString(formContentType.toString()), buffer, length)\n+                    getContentType(buffer.blockFirst()), buffer, length)", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406833077", "bodyText": "Instead of casting the byte to an int we could just use the following checks:\nbytes[0] == (byte) 0x25...", "author": "alzimmermsft", "createdAt": "2020-04-10T16:24:45Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTI0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406835241", "bodyText": "If we do want to end up keeping this we shouldn't cast and re-cast the hex value.\nbyteValue == (byte) hexValue should be sufficient.", "author": "alzimmermsft", "createdAt": "2020-04-10T16:29:57Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (isEqual(bytes[0], 0xff) && isEqual(bytes[1], 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (\n+            isEqual(bytes[0], 0x89) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x4e) && isEqual(bytes[3], 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(bytes[0], 0x49) && isEqual(bytes[1], 0x49) && isEqual(bytes[2], 0x2a) && isEqual(bytes[3], 0x0))\n+            // big-endian\n+            || (isEqual(bytes[0], 0x4d) && isEqual(bytes[1], 0x4d) && isEqual(bytes[2], 0x0)\n+                && isEqual(bytes[3], 0x2a))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException(\n+                \"Content type could not be detected. Should use other overload API that takes content type.\");\n+        }\n+    }\n+\n+    /**\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n+     *\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw LOGGER.logExceptionAsError(new RuntimeException(ioe));\n+                }\n+            })\n+            .takeUntil(p -> p.readBytes() == -1)\n+            .filter(p -> p.readBytes() > 0)\n+            .map(Pair::buffer);\n     }\n \n-    private static ByteBuffer toByteArray(InputStream in) {\n-        try {\n-            ByteArrayOutputStream os = new ByteArrayOutputStream();\n-            byte[] buffer = new byte[1024];\n-            int len;\n-\n-            // read bytes from the input stream and store them in buffer\n-            while ((len = in.read(buffer)) != -1) {\n-                // write bytes from the buffer into output stream\n-                os.write(buffer, 0, len);\n-            }\n-            return ByteBuffer.wrap(os.toByteArray());\n-        } catch (IOException e) {\n-            throw LOGGER.logExceptionAsError(new RuntimeException(e));\n+    private static class Pair {\n+        private ByteBuffer byteBuffer;\n+        private int readBytes;\n+\n+        ByteBuffer buffer() {\n+            return this.byteBuffer;\n+        }\n+\n+        int readBytes() {\n+            return this.readBytes;\n+        }\n+\n+        Pair buffer(ByteBuffer byteBuffer) {\n+            this.byteBuffer = byteBuffer;\n+            return this;\n+        }\n+\n+        Pair readBytes(int cnt) {\n+            this.readBytes = cnt;\n+            return this;\n         }\n     }\n+\n+    /**\n+     * Compare if a byte value equals to a hex type value.\n+     *\n+     * @param byteValue the byte type value\n+     * @param hexValue the hex type value\n+     * @return true if two type's values are equal in unsigned int comparision.\n+     */\n+    private static boolean isEqual(byte byteValue, int hexValue) {\n+        return Byte.toUnsignedInt(byteValue) == Byte.toUnsignedInt((byte) hexValue);", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTU5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406835599", "bodyText": "Since we have the static logger we should log this.", "author": "alzimmermsft", "createdAt": "2020-04-10T16:30:48Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 4 bytes of data\"));\n+        }\n+\n+        if (isEqual(bytes[0], 0x25) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x44) && isEqual(bytes[3], 0x46)) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (isEqual(bytes[0], 0xff) && isEqual(bytes[1], 0xd8)) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (\n+            isEqual(bytes[0], 0x89) && isEqual(bytes[1], 0x50) && isEqual(bytes[2], 0x4e) && isEqual(bytes[3], 0x47)) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(bytes[0], 0x49) && isEqual(bytes[1], 0x49) && isEqual(bytes[2], 0x2a) && isEqual(bytes[3], 0x0))\n+            // big-endian\n+            || (isEqual(bytes[0], 0x4d) && isEqual(bytes[1], 0x4d) && isEqual(bytes[2], 0x0)\n+                && isEqual(bytes[3], 0x2a))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw new IllegalArgumentException(", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNjE1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r406836159", "bodyText": "Since we are only checking the first ByteBuffer what would happen if the first buffer is empty due to a disk or networking latency but then the next one contains the byte marking which would properly determine the file type.", "author": "alzimmermsft", "createdAt": "2020-04-10T16:32:19Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -16,37 +17,107 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n \n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 4) {", "originalCommit": "c8b2f54620a69ca479280b9422f295419c25dafe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "646c6a21e87820ee0684bd09ce2dbd523cfe3f34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/646c6a21e87820ee0684bd09ce2dbd523cfe3f34", "message": "resolve conflict", "committedDate": "2020-04-17T23:19:01Z", "type": "commit"}, {"oid": "dcbb1cbcaca0b42e8111048e14895500f63871b6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dcbb1cbcaca0b42e8111048e14895500f63871b6", "message": "refactor without blocking", "committedDate": "2020-04-17T23:35:26Z", "type": "commit"}, {"oid": "e68e9a1a6d2fa5352e213dc476884f27172a6b12", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e68e9a1a6d2fa5352e213dc476884f27172a6b12", "message": "remove unused method", "committedDate": "2020-04-17T23:46:31Z", "type": "commit"}, {"oid": "a0962f82ce2824eb8d0f1fbaba20a9036517675c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0962f82ce2824eb8d0f1fbaba20a9036517675c", "message": "working solution", "committedDate": "2020-04-20T04:12:11Z", "type": "commit"}, {"oid": "3858916ced70778c1c6e5b112c1da51b56c5c007", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3858916ced70778c1c6e5b112c1da51b56c5c007", "message": "add recorded file", "committedDate": "2020-04-20T05:33:57Z", "type": "commit"}, {"oid": "41d15d6b6a5d80725453abee1c079b6821b6f631", "url": "https://github.com/Azure/azure-sdk-for-java/commit/41d15d6b6a5d80725453abee1c079b6821b6f631", "message": "remove unused import", "committedDate": "2020-04-20T06:01:51Z", "type": "commit"}, {"oid": "859c5a05d42735995a9a97fdca305c44d880f0e0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/859c5a05d42735995a9a97fdca305c44d880f0e0", "message": "added sync tests", "committedDate": "2020-04-20T06:22:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwOTg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411509864", "bodyText": "If Content-Type is given we can skip trying to guess the type.", "author": "alzimmermsft", "createdAt": "2020-04-20T16:16:23Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)\n+            .next()\n+            .flatMap(newData -> {\n+                // if content type is not given, do guessing the content type.", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxMTAyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411511021", "bodyText": "I don't feel this abstraction is really worth the overhead, both in maintenance and performance.", "author": "alzimmermsft", "createdAt": "2020-04-20T16:18:00Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -17,37 +17,121 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n+\n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 2) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 2 bytes of data\"));\n+        }\n+\n+        final byte[] firstFourBytesArray = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3]};\n+\n+        if (isEqual(firstFourBytesArray, new int[] {0x25, 0x50, 0x44, 0x46})) {\n+            return ContentType.APPLICATION_PDF;\n+        } else if (bytes[0] == (byte) 0xff && bytes[1] == (byte) 0xd8) {\n+            return ContentType.IMAGE_JPEG;\n+        } else if (isEqual(firstFourBytesArray, new int[] {0x89, 0x50, 0x4e, 0x47})) {\n+            return ContentType.IMAGE_PNG;\n+        } else if (\n+            // little-endian\n+            (isEqual(firstFourBytesArray, new int[] {0x49, 0x49, 0x2a, 0x0}))\n+                // big-endian\n+                || (isEqual(firstFourBytesArray, new int[] {0x4d, 0x4d, 0x0, 0x2a}))) {\n+            return ContentType.IMAGE_TIFF;\n+        } else {\n+            throw LOGGER.logExceptionAsError(new IllegalArgumentException(\n+                \"Content type could not be detected. Should use other overload API that takes content type.\"));\n+        }\n     }\n \n-    private static ByteBuffer toByteArray(InputStream in) {\n-        try {\n-            ByteArrayOutputStream os = new ByteArrayOutputStream();\n-            byte[] buffer = new byte[1024];\n-            int len;\n+    /**\n+     * Creates a Flux of ByteBuffer, with each ByteBuffer wrapping bytes read from the given\n+     * InputStream.\n+     *\n+     * @param inputStream InputStream to back the Flux\n+     * @return Flux of ByteBuffer backed by the InputStream\n+     */\n+    public static Flux<ByteBuffer> toFluxByteBuffer(InputStream inputStream) {\n+        Pair pair = new Pair();\n+        return Flux.just(true)\n+            .repeat()\n+            .map(ignore -> {\n+                byte[] buffer = new byte[BYTE_BUFFER_CHUNK_SIZE];\n+                try {\n+                    int numBytes = inputStream.read(buffer);\n+                    if (numBytes > 0) {\n+                        return pair.buffer(ByteBuffer.wrap(buffer, 0, numBytes)).readBytes(numBytes);\n+                    } else {\n+                        return pair.buffer(null).readBytes(numBytes);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw LOGGER.logExceptionAsError(new RuntimeException(ioe));\n+                }\n+            })\n+            .takeUntil(p -> p.readBytes() == -1)\n+            .filter(p -> p.readBytes() > 0)\n+            .map(Pair::buffer);\n+    }\n+\n+    private static class Pair {\n+        private ByteBuffer byteBuffer;\n+        private int readBytes;\n \n-            // read bytes from the input stream and store them in buffer\n-            while ((len = in.read(buffer)) != -1) {\n-                // write bytes from the buffer into output stream\n-                os.write(buffer, 0, len);\n+        ByteBuffer buffer() {\n+            return this.byteBuffer;\n+        }\n+\n+        int readBytes() {\n+            return this.readBytes;\n+        }\n+\n+        Pair buffer(ByteBuffer byteBuffer) {\n+            this.byteBuffer = byteBuffer;\n+            return this;\n+        }\n+\n+        Pair readBytes(int cnt) {\n+            this.readBytes = cnt;\n+            return this;\n+        }\n+    }\n+\n+    /**\n+     * Compare if a byte value equals to a hex type value.\n+     *\n+     * @param byteValueList An array of byte type values.\n+     * @param hexValueList An array of hex type values.\n+     * @return true if two type's values are equal in unsigned int comparision, otherwise return false.\n+     */\n+    private static boolean isEqual(byte[] byteValueList, int[] hexValueList) {", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411514317", "bodyText": "This logic appears to be duplicated three times, any chance this could be abstracted? Possibly a method that takes Flux<ByteBuffer> and returns Mono<Tuple2<ContentType, Flux<ByteBuffer>>.", "author": "alzimmermsft", "createdAt": "2020-04-20T16:22:36Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -556,19 +623,53 @@ private void throwIfAnalyzeStatusInvalid(SimpleResponse<AnalyzeOperationResult>\n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> analyzeFormStreamActivationOperation(\n         Flux<ByteBuffer> data, String modelId, long length,\n         FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+        Objects.requireNonNull(modelId, \"'modelId' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxODQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411518453", "bodyText": "The logic here is close, but a little off. Right now this will cache the entire data stream, this could be modified to cache until we get the number of bytes required to determine the content type, then join the cached buffers with the remaining buffers.", "author": "alzimmermsft", "createdAt": "2020-04-20T16:28:09Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -442,18 +476,51 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> contentStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeLayoutAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NTQ3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411555471", "bodyText": "If I understand it correctly - there are two cases:\nuser input -> { data = contentTypeHeader+content }\nuser input -> { data = contentTypeHeader+content, contentType=pdf }\ni.e. user can optionally provide contentType as input.\nWe've this windowUntil here to detect the content-type but that comes with a cost i.e. we need to allocate a new ByteBuffer (or multiple ByteBuffers if data emits byte-by-byte), we do that even if user provide us the contentType as an argument. I think when contentType is given we can call the underlying API and give it data as it is, if contentType is not given then apply the windowUntil path.  This way we can also simplify the logic, we don't the var  isGuessed or check like formContentType == null\nComing to the current windowUntil path - I think it may not work correctly if data comes as chunks i.e.\ndata = ByteBuffer_chunk1 (containing contentType and some data),  ByteBuffer_chunk2, ByteBuffer_chunk3\n\nLooks like by doing next() after windowUntil, the newData will be just ByteBuffer_chunk1. Good to double check.\nYou might want to apply buffer operator after windowUntil\n.buffer(2)\n.next()\n.flatMap(fluxes -> {\n    var contentType = getContentType(cachedBuffers);\n    if (fluxes.size() == 1) {\n        return callAPI(Flux.fromIterable(cachedBuffers));\n    } else {\n        return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1)));\n    }\n})", "author": "anuchandy", "createdAt": "2020-04-20T17:22:41Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)\n+            .next()", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU2MTIyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411561226", "bodyText": "Also with explicit contentType check\nif (contentType == null) {\n   return callApi(data, ..);\n} else {\n   return data.windowUntil(..).flatMap(fluxes -> {\n      var contentType = getContentType(cachedBuffers);\n      if (fluxes.size() == 1) {\n          return callAPI(Flux.fromIterable(cachedBuffers));\n      } else {\n          return callAPI(Flux.fromIterable(cachedBuffers).concatWith(fluxes.get(1)));\n      }\n    });\n}\nI think we just have to cache in the windowUntil operator i.e. no contentType check in windowUntil, the check can be deferred to flatmap operator.", "author": "anuchandy", "createdAt": "2020-04-20T17:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4MDA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411580067", "bodyText": "These public async APIs shouldn't throw exceptions. It should be returned as an error.", "author": "srnagar", "createdAt": "2020-04-20T17:59:59Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -355,16 +357,16 @@ public FormRecognizerServiceVersion getServiceVersion() {\n     public PollerFlux<OperationResult, IterableStream<RecognizedReceipt>> beginRecognizeReceipts(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails,\n         Duration pollInterval) {\n-        final Duration interval = pollInterval != null ? pollInterval : DEFAULT_DURATION;\n-        return new PollerFlux<OperationResult, IterableStream<RecognizedReceipt>>(interval,\n+\n+        return new PollerFlux<>(", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4NjcyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411586725", "bodyText": "Why do you need an array? This can just be AtomicBoolean.", "author": "srnagar", "createdAt": "2020-04-20T18:10:45Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411589700", "bodyText": "Is this done to support hot fluxes? I thought this API only supported cold fluxes. If we only support cold fluxes, this can be simplified.", "author": "srnagar", "createdAt": "2020-04-20T18:15:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }\n+                return false;\n+            }, true, Integer.MAX_VALUE)", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyODMwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411628306", "bodyText": "right but like we discussed offline this could be a cold + self-destructed flux, so cloning is required for scanning of content type, and we don't know upfront that its self-destructed flux or not :( .. that's why i thought we should do windowUntil (and the cloning comes with it) only if contentType is missing.", "author": "anuchandy", "createdAt": "2020-04-20T19:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5MDYwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411690604", "bodyText": "@srnagar - Regarding cold (replay-able) Flux, was thinking a bit more on it. Seeing an issue with self-destructible Flux assumption - though we'll manage to read the header here (for content type) with a single subscription, there is still an issue with retry since each retry is a new subscription unless we do ByteBuffer pooling + back-pressure internally. I don't know this API supports chunked upload where pooling can be applied.\nMaybe chunked upload (if supported) could be a future improvement. Keeping that chunk/pooling aside - I think it's better if we make it clear in the doc that this API expects replay-able Flux and go with double subscription, which will anyway happen with retry. Thoughts?", "author": "anuchandy", "createdAt": "2020-04-20T21:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411709492", "bodyText": "My assumption with this API was always that it's going to be a replayable flux. A non-replayable flux would require us to deal with what happens when we want to retry? Storage blob provides a mechanism to have chunk uploads that can be committed once the whole flux is uploaded. Form Recognizer doesn't have this capability.\nSo, having a large media file upload requires us to cache the entire flux in-memory or use storage to upload chunks. Also, I am not sure if a non-replayable stream is supported in other languages. If it's not, then we should also make it clear in our documentation that only cold fluxes are supported.", "author": "srnagar", "createdAt": "2020-04-20T21:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcyMTI4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411721289", "bodyText": "yep, I think good to have this assumption added in our Java guidelines, i.e. all APIs that takes Flux<BuyteBuffer> requires the stream to be replay-able.\nIf form recognizer support recognizing content of a blob then its good to have a note in the FR api that takes Flux<BuyteBuffer>that - for large files use storage optimized-reliable upload and use relevant FR api that takes blob uri.", "author": "anuchandy", "createdAt": "2020-04-20T22:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU4OTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5MjUwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411592501", "bodyText": "The byte array length is checked for < 2 but the first four bytes are accessed. Should the length check be < 4?", "author": "srnagar", "createdAt": "2020-04-20T18:20:16Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/implementation/Utility.java", "diffHunk": "@@ -17,37 +17,121 @@\n  */\n public final class Utility {\n     private static final ClientLogger LOGGER = new ClientLogger(Utility.class);\n+    // using 4K as default buffer size: https://stackoverflow.com/a/237495/1473510\n+    private static final int BYTE_BUFFER_CHUNK_SIZE = 4096;\n+\n     private Utility() {\n     }\n \n     /**\n-     * A utility method for converting the input stream to Flux of ByteBuffer.\n+     * Automatically detect byte buffer's content type.\n+     * Given the source: <a href=\"https://en.wikipedia.org/wiki/Magic_number_(programming)#Magic_numbers_in_files\"/>.\n      *\n-     * @param data The input data which needs to convert to ByteBuffer.\n+     * @param buffer The byte buffer input.\n      *\n-     * @return {@link ByteBuffer} which contains the input data.\n-     * @throws RuntimeException When I/O error occurs.\n+     * @return The {@link ContentType} content type.\n      */\n-    public static Flux<ByteBuffer> convertStreamToByteBuffer(InputStream data) {\n-        return Flux.just(toByteArray(data))\n-            .doOnError(error -> LOGGER.warning(\"Failed to convert stream to byte array - {}\", error));\n+    public static ContentType getContentType(ByteBuffer buffer) {\n+        final byte[] bytes = buffer.array();\n+        if (bytes.length < 2) {\n+            throw LOGGER.logExceptionAsError(\n+                new IllegalArgumentException(\"Invalid input. Expect more than 2 bytes of data\"));\n+        }\n+\n+        final byte[] firstFourBytesArray = new byte[] {bytes[0], bytes[1], bytes[2], bytes[3]};", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU5Mzg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r411593889", "bodyText": "If the buffer data is greater than length, we should stop and throw an exception as the length provided by user is incorrect.", "author": "srnagar", "createdAt": "2020-04-20T18:22:41Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,18 +384,50 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        // Size of buffered data, it used to collect all data from input Flux<ByteBuffer>\n+        final long[] bufferedDataSize = {0};\n+        // Cached byte buffer\n+        final List<ByteBuffer> cachedBuffers = new LinkedList<>();\n+        // A boolean value that only used once for guessing content type on input data\n+        final AtomicBoolean[] isGuessed = {new AtomicBoolean(true)};\n+        // Content type on input data\n+        final ContentType[] contentType = new ContentType[1];\n+\n+        return pollingContext -> data.filter(ByteBuffer::hasRemaining)\n+            .windowUntil(buffer -> {\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return false;\n+                }\n+                bufferedDataSize[0] += buffer.remaining();\n+\n+                // if content type is not given, do guessing the content type.\n+                if (formContentType == null && isGuessed[0].get() && bufferedDataSize[0] >= 4) {\n+                    byte[] bytes = buffer.array();\n+                    contentType[0] = getContentType(ByteBuffer.wrap(bytes));\n+                    isGuessed[0].compareAndSet(true, false);\n+                }\n+                // Cache the data to a list of byte buffers\n+                ByteBuffer cachedBuffer = ByteBuffer.allocate(buffer.remaining()).put(buffer);\n+                cachedBuffer.flip();\n+                cachedBuffers.add(cachedBuffer);\n+\n+                if (bufferedDataSize[0] >= length) {\n+                    return true;\n+                }", "originalCommit": "859c5a05d42735995a9a97fdca305c44d880f0e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1cc991f099d0e5ad296f3585456c68f3fd776162", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1cc991f099d0e5ad296f3585456c68f3fd776162", "message": "working solution", "committedDate": "2020-04-21T01:23:32Z", "type": "commit"}, {"oid": "c3c630720accabc26ddc155c67c3119c6cb70274", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c3c630720accabc26ddc155c67c3119c6cb70274", "message": "fix checkstyle", "committedDate": "2020-04-21T01:27:22Z", "type": "commit"}, {"oid": "f8ff667d898746aae5195beac5a4f8cd0b918c06", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8ff667d898746aae5195beac5a4f8cd0b918c06", "message": "simplicy the imple", "committedDate": "2020-04-21T02:01:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412280864", "bodyText": "Thanks, Shawn, for simplifying this.\nThis looks better, but it assumes that the first ByteBuffer from data is at least 2 or 4 bytes, which may not always the case. For example, if the data arrives in following structure, then next() operator is not sufficient:\nFlux<ByteBuffer> data = Flux.fromArray(new ByteBuffer [] {\n    ByteBuffer.wrap(new byte[]{(byte) 0xff}),\n    ByteBuffer.wrap(new byte[]{(byte) 0xd8}),\n    ByteBuffer.wrap(new byte[]{3}),\n    ByteBuffer.wrap(new byte[]{4})\n});\nmay be something like below which looks for header even if the header bytes are split across chunks, (please test it, also return type should be ContentType)\nprivate static Mono<String> detectContentType(Flux<ByteBuffer> data) {\n    byte[] header = new byte[4];\n    int[] written = new int[] {0};\n    String[] contentType = new String[] {null};\n    return data.map(chunk -> {\n        final int len = chunk.remaining();\n        for (int i = 0 ;i < len; i++) {\n            header[written[0]] = chunk.get(i);\n            written[0]++;\n            if (written[0] == 2) {\n                if (isJpeg(header)) {\n                    contentType[0] = \"IMAGE_JPEG\";\n                    // Got a matching two bytes, return false so that takeWhile\n                    // can cut the subscription on data\n                    return false;\n                } else {\n                    // two bytes didn't match, continue to read next byte\n                    continue;\n                }\n            }\n            if (written[0] == 4) {\n                if (isPdf(header)) {\n                    contentType[0] = \"APPLICATION_PDF\";\n                } else if (isPng(header)) {\n                    contentType[0] = \"IMAGE_PNG\";\n                } else if (isTiff(header)) {\n                    contentType[0] = \"IMAGE_TIFF\";\n                }\n                // Got a four bytes matching or not, either way no need to read more byte return false \n               // so that takeWhile can cut the subscription on data\n                return false;\n            }\n        }\n        // current chunk don't have enough bytes so return true to get next Chunk if there is one.\n        return true;\n    })\n    .takeWhile(doContinue -> doContinue == true)\n    .then(Mono.defer(() -> {\n        if (contentType[0] != null) {\n            return Mono.just(contentType[0]);\n        } else {\n            return Mono.error(new RuntimeException(\"Content type could not be detected. \" +\n                \"Should use other overload API that takes content type.\"));\n        }\n    }));\n}\n\nprivate static boolean isJpeg(byte[] header) {\n    return (header[0] == (byte) 0xff && header[1] == (byte) 0xd8);\n}\n\nprivate static boolean isPdf(byte[] header) {\n    return header[0] == (byte) 0x25\n        && header[1] == (byte) 0x50\n        && header[2] == (byte) 0x44\n        && header[3] == (byte) 0x46;\n}\n\nprivate static boolean isPng(byte[] header) {\n   return header[0] == (byte) 0x89\n        &&  header[1] == (byte) 0x50\n        && header[2] == (byte) 0x4e\n        && header[3] == (byte) 0x47;\n}\n\nprivate static boolean isTiff(byte[] header) {\n    return (header[0] == (byte) 0x49\n        && header[1] == (byte) 0x49\n        && header[2] == (byte) 0x2a\n        && header[3] == (byte) 0x0)\n        // big-endian\n        || (header[0] == (byte) 0x4d\n        && header[1] == (byte) 0x4d\n        && header[2] == (byte) 0x0\n        && header[3] == (byte) 0x2a);\n}", "author": "anuchandy", "createdAt": "2020-04-21T15:21:35Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,14 +381,16 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n+\n+        return pollingContext -> {\n             try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n-                        parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n+                return data.next()", "originalCommit": "f8ff667d898746aae5195beac5a4f8cd0b918c06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM3MjU1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412372553", "bodyText": "also, it may be more clean/readable to have this scanning only if user didn't provide the contentType, so that we can avoid double subscription if not needed.\nif (contentType != null) {\n   return callAPI(data, contentType);\n} else {\n  return detectContentType(data)\n     .flatmap(contentType -> {\n         return callAPI(data, contentType);\n     }); \n}", "author": "anuchandy", "createdAt": "2020-04-21T17:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4MTA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412381043", "bodyText": "We can further simplify the JPEG section as a valid JPEG contains a minimum of 4 bytes: https://en.wikipedia.org/wiki/JPEG#Syntax_and_structure\nfor (int i = 0; i < len; i++) {\n\theader[written[0]] = chunk.get(i);\n\twritten[0]++;\n\tif (written[0] == 4) {\n\t\tif (isJpeg(header)) {\n\t\t\tcontentType[0] = \"IMAGE_JPEG\";\n\t\t} else if (isPdf(header)) {\n\t\t\tcontentType[0] = \"APPLICATION_PDF\";\n\t\t} else if (isPng(header)) {\n\t\t\tcontentType[0] = \"IMAGE_PNG\";\n\t\t} else if (isTiff(header)) {\n\t\t\tcontentType[0] = \"IMAGE_TIFF\";\n\t\t}\n\t\t// Got a four bytes matching or not, either way no need to read more byte return false \n\t   // so that takeWhile can cut the subscription on data\n\t\treturn false;\n\t}\n}", "author": "srnagar", "createdAt": "2020-04-21T18:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4ODIwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412388205", "bodyText": "@srnagar interesting, I just copied from the existing code already in this PR. I wonder the two byte check was agreed across all language sdks, if so we should communicate correct look up (as you suggested) to others.", "author": "anuchandy", "createdAt": "2020-04-21T18:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5MzE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412393149", "bodyText": "To find the content type, the first 2 bytes (Start of image) are sufficient. However, a valid jpeg will also have 2 trailing bytes (End of image). So, reading 4 bytes before determining the content type is okay and doesn't need special logic to stop after reading 2 bytes.", "author": "srnagar", "createdAt": "2020-04-21T18:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM5Mzg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412393865", "bodyText": "synced with @srnagar, @mssfang -  so JPEG has 2 leading bytes that mark the start of image and 2 trailing bytes that mark the end of image, we can read 4 bytes but have to check only the first two bytes, which simplifies the code like Srikanta pointed.", "author": "anuchandy", "createdAt": "2020-04-21T18:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4MDg2NA=="}], "type": "inlineReview"}, {"oid": "21da927a288bcb47cc817bc6cc23ee05fc2ce675", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21da927a288bcb47cc817bc6cc23ee05fc2ce675", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FR-ContentType", "committedDate": "2020-04-21T17:22:05Z", "type": "commit"}, {"oid": "3eb1daa8001ad9a2ef47bf68439ebe458bfcdefc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3eb1daa8001ad9a2ef47bf68439ebe458bfcdefc", "message": "changes method name", "committedDate": "2020-04-21T18:04:20Z", "type": "commit"}, {"oid": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236", "url": "https://github.com/Azure/azure-sdk-for-java/commit/14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236", "message": "final version", "committedDate": "2020-04-21T19:25:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTk5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412509995", "bodyText": "This will throw an error that will cause the public async API to also throw an error. As per reactive guidelines, you should instead catch this exception in the public API method and return an error. See PagedFlux APIs for reference. You will have to do something similar for PollerFlux too.\nFile an issue for this and can be fixed post preview release.", "author": "srnagar", "createdAt": "2020-04-21T21:39:02Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/FormRecognizerAsyncClient.java", "diffHunk": "@@ -382,16 +382,23 @@ public FormRecognizerServiceVersion getServiceVersion() {\n \n     private Function<PollingContext<OperationResult>, Mono<OperationResult>> receiptStreamActivationOperation(\n         Flux<ByteBuffer> data, long length, FormContentType formContentType, boolean includeTextDetails) {\n-        return (pollingContext) -> {\n-            try {\n-                Objects.requireNonNull(data, \"'data' is required and cannot be null.\");\n-                Objects.requireNonNull(formContentType, \"'formContentType' is required and cannot be null.\");\n-                return service.analyzeReceiptAsyncWithResponseAsync(ContentType.fromString(formContentType.toString()),\n-                    data, length, includeTextDetails)\n-                    .map(response -> new OperationResult(\n-                        parseModelId(response.getDeserializedHeaders().getOperationLocation())));\n-            } catch (RuntimeException ex) {\n-                return monoError(logger, ex);\n+        Objects.requireNonNull(data, \"'data' is required and cannot be null.\");", "originalCommit": "14a9a779ce0e22b7ccb5cc1fae52c127ac4c7236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxOTQ2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9953#discussion_r412519462", "bodyText": "Thanks. Srikanta. #10408", "author": "mssfang", "createdAt": "2020-04-21T21:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTk5NQ=="}], "type": "inlineReview"}]}