{"pr_number": 14551, "pr_title": "Fix deserialization of entities", "pr_createdAt": "2020-08-28T03:02:58Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14551", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MzgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479553806", "bodyText": "Is it the URL of the table or is it the service?", "author": "conniey", "createdAt": "2020-08-28T22:05:28Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncClient.java", "diffHunk": "@@ -111,7 +108,7 @@ public String getAccountName() {\n     }\n \n     /**\n-     * returns Url of this service\n+     * returns Url of this table", "originalCommit": "8dab1dac06af4fd88e7dc963adf77f822f64ebfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzkwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479583902", "bodyText": "It's the URL to the table itself, determined by serviceUri.resolve(\"/\" + tableName)", "author": "bsiegel", "createdAt": "2020-08-29T00:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MzgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MzkyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479553928", "bodyText": "nit: Change this to a constant \"\\.\" so that it can be reused in both ctors locations.", "author": "conniey", "createdAt": "2020-08-28T22:05:53Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncClient.java", "diffHunk": "@@ -53,27 +49,32 @@\n     private final ClientLogger logger = new ClientLogger(TableAsyncClient.class);\n     private final String tableName;\n     private final AzureTableImpl implementation;\n-    private final TablesImpl tableImplementation;\n     private final String accountName;\n     private final String tableUrl;\n-    private final TablesServiceVersion apiVersion;\n     private final QueryOptions defaultQueryOptions = new QueryOptions()\n         .setFormat(OdataMetadataFormat.APPLICATION_JSON_ODATA_FULLMETADATA);\n \n     TableAsyncClient(String tableName, AzureTableImpl implementation) {\n+        try {\n+            final URI uri = URI.create(implementation.getUrl());\n+            this.accountName = uri.getHost().split(\"\\\\.\", 2)[0];\n+            this.tableUrl = uri.resolve(\"/\" + tableName).toString();\n+            logger.verbose(\"Table Service URI: {}\", uri);\n+        } catch (IllegalArgumentException ex) {\n+            throw logger.logExceptionAsError(ex);\n+        }\n+\n         this.implementation = implementation;\n-        this.tableImplementation = implementation.getTables();\n         this.tableName = tableName;\n-        this.accountName = null;\n-        this.tableUrl = null;\n-        this.apiVersion = null;\n     }\n \n     TableAsyncClient(String tableName, HttpPipeline pipeline, String url, TablesServiceVersion serviceVersion,\n         SerializerAdapter serializerAdapter) {\n \n         try {\n             final URI uri = URI.create(url);\n+            this.accountName = uri.getHost().split(\"\\\\.\", 2)[0];", "originalCommit": "8dab1dac06af4fd88e7dc963adf77f822f64ebfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NTk4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479585988", "bodyText": "Resolved in PR #14497", "author": "bsiegel", "createdAt": "2020-08-29T00:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1MzkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NTE5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479555191", "bodyText": "The placeholder for these is {} rather than %s", "author": "conniey", "createdAt": "2020-08-28T22:10:40Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/TablesJacksonSerializer.java", "diffHunk": "@@ -27,71 +28,107 @@\n public class TablesJacksonSerializer extends JacksonAdapter {\n     private final ClientLogger logger = new ClientLogger(TablesJacksonSerializer.class);\n \n-    @Override\n-    public String serialize(Object object, SerializerEncoding serializerEncoding) throws IOException {\n-        return super.serialize(object, serializerEncoding);\n-    }\n-\n-    @Override\n-    public String serializeRaw(Object object) {\n-        return super.serializeRaw(object);\n-    }\n-\n-    @Override\n-    public String serializeList(List<?> list, CollectionFormat format) {\n-        return super.serializeList(list, format);\n-    }\n-\n     @Override\n     public <U> U deserialize(String value, Type type, SerializerEncoding serializerEncoding) throws IOException {\n-        return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type, serializerEncoding);\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserialize(new ByteArrayInputStream(value.getBytes(StandardCharsets.UTF_8)), type,\n+                serializerEncoding);\n+        } else {\n+            return super.deserialize(value, type, serializerEncoding);\n+        }\n     }\n \n     @Override\n-    @SuppressWarnings(\"unchecked\")\n     public <U> U deserialize(InputStream inputStream, Type type, SerializerEncoding serializerEncoding)\n         throws IOException {\n-        if (type != TableEntityQueryResponse.class) {\n+        if (type == TableEntityQueryResponse.class) {\n+            return deserializeTableEntityQueryResponse(inputStream);\n+        } else {\n             return super.deserialize(inputStream, type, serializerEncoding);\n         }\n+    }\n \n-        // Force to deserialize as a Map by using Object.class\n+    @SuppressWarnings(\"unchecked\")\n+    private <U> U deserializeTableEntityQueryResponse(InputStream inputStream) throws IOException {\n         String odataMetadata = null;\n         List<Map<String, Object>> values = new ArrayList<>();\n \n+        // Represents the entries in the response. It's possible that it is a single or multiple response.\n         final JsonNode node = super.serializer().readTree(inputStream);\n-        final Map<String, Object> rootObject = new HashMap<>();\n+        Map<String, Object> singleValue = null;\n+\n         for (Iterator<Map.Entry<String, JsonNode>> it = node.fields(); it.hasNext();) {\n             final Map.Entry<String, JsonNode> entry = it.next();\n+            final String fieldName = entry.getKey();\n             final JsonNode childNode = entry.getValue();\n \n-            if (entry.getKey().equals(TableConstants.ODATA_METADATA_KEY)) {\n+            if (fieldName.equals(TablesConstants.ODATA_METADATA_KEY)) {\n                 odataMetadata = childNode.asText();\n-                continue;\n-            }\n-\n-            // Represents the entries in the response. It's possible that it is a single or multiple response.\n-            if (entry.getKey().equals(\"value\")) {\n+            } else if (fieldName.equals(\"value\")) {\n                 if (childNode.isArray()) {\n-                    logger.info(\"Node is an array of items.\");\n+                    // This is a multiple-entity response.\n+                    for (JsonNode childEntry : childNode) {\n+                        values.add(getEntityFieldsAsMap(childEntry));\n+                    }\n+                } else {\n+                    // This is a single-entity response where the user just happened to use the key \"value\".\n+                    if (singleValue == null) {\n+                        singleValue = new HashMap<>();\n+                    }\n+                    singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n                 }\n-\n-                throw logger.logExceptionAsError(\n-                    new UnsupportedOperationException(\"Multiple return values not supported yet.\"));\n+            } else {\n+                // This is a single-entity response.\n+                if (singleValue == null) {\n+                    singleValue = new HashMap<>();\n+                }\n+                singleValue.put(fieldName, getEntityFieldAsObject(node, fieldName));\n             }\n-\n-            rootObject.put(entry.getKey(), entry.getValue().asText());\n         }\n \n-        values.add(0, rootObject);\n+        if (singleValue != null) {\n+            if (values.size() > 0) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Unexpected response format. Response containing a 'value' array must not contain other properties.\"\n+                ));\n+            }\n+            values.add(singleValue);\n+        }\n \n         return (U) new TableEntityQueryResponse()\n             .setOdataMetadata(odataMetadata)\n             .setValue(values);\n     }\n \n-    @Override\n-    public <U> U deserialize(HttpHeaders httpHeaders, Type type) throws IOException {\n-        return super.deserialize(httpHeaders, type);\n+    private Map<String, Object> getEntityFieldsAsMap(JsonNode node) {\n+        Map<String, Object> result = new HashMap<>();\n+        for (Iterator<String> it = node.fieldNames(); it.hasNext(); ) {\n+            String fieldName = it.next();\n+            result.put(fieldName, getEntityFieldAsObject(node, fieldName));\n+        }\n+        return result;\n+    }\n+\n+    private Object getEntityFieldAsObject(JsonNode parentNode, String fieldName) {\n+        JsonNode valueNode = parentNode.get(fieldName);\n+        if (!TablesConstants.METADATA_KEYS.contains(fieldName) && !fieldName.endsWith(\"@odata.type\")) {\n+            JsonNode typeNode = parentNode.get(fieldName + \"@odata.type\");\n+            if (typeNode != null) {\n+                String type = typeNode.asText();\n+                switch (type) {\n+                    case \"Edm.DateTime\":\n+                        try {\n+                            return OffsetDateTime.parse(valueNode.asText());\n+                        } catch (DateTimeParseException e) {\n+                            throw logger.logExceptionAsError(new IllegalArgumentException(String.format(\n+                                \"'%s' value is not a valid OffsetDateTime.\", TablesConstants.TIMESTAMP_KEY), e));\n+                        }\n+                    default:\n+                        logger.warning(\"'%s' value has unknown OData type '%s'\", fieldName, type);", "originalCommit": "8dab1dac06af4fd88e7dc963adf77f822f64ebfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NjU0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479586540", "bodyText": "Fixed.", "author": "bsiegel", "createdAt": "2020-08-29T00:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NTE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NjA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479556077", "bodyText": "You can use the following, this is like Task.whenAll that completes when all three are done.\nMono.when(\n    tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue)),\n    tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue2)),\n    tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue3))).block(TIMEOUT);", "author": "conniey", "createdAt": "2020-08-28T22:13:55Z", "path": "sdk/tables/azure-data-tables/src/test/java/com/azure/data/tables/TablesAsyncClientTest.java", "diffHunk": "@@ -301,60 +303,90 @@ void updateEntityWithResponseAsync(UpdateMode mode) {\n             .verifyComplete();\n     }\n \n-    @Disabled(\"List not working yet.\")\n     @Test\n-    void listEntityWithFilterAsync() {\n+    @Tag(\"ListEntities\")\n+    void listEntitiesAsync() {\n         // Arrange\n         final String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n         final String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n-        final TableEntity entity = new TableEntity(partitionKeyValue, rowKeyValue);\n-        ListEntitiesOptions options = new ListEntitiesOptions().setFilter(\"PartitionKey eq '\" + entity.getPartitionKey() + \"'\");\n-        tableClient.createEntity(entity).block(TIMEOUT);\n+        final String rowKeyValue2 = testResourceNamer.randomName(\"rowKey\", 20);\n+        tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue)).block(TIMEOUT);\n+        tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue2)).block(TIMEOUT);\n+\n+        // Act & Assert\n+        StepVerifier.create(tableClient.listEntities())\n+            .expectNextCount(2)\n+            .thenConsumeWhile(x -> true)\n+            .expectComplete()\n+            .verify();\n+    }\n+\n+    @Test\n+    @Tag(\"ListEntities\")\n+    void listEntitiesWithFilterAsync() {\n+        // Arrange\n+        final String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n+        final String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n+        final String rowKeyValue2 = testResourceNamer.randomName(\"rowKey\", 20);\n+        ListEntitiesOptions options = new ListEntitiesOptions().setFilter(\"RowKey eq '\" + rowKeyValue + \"'\");\n+        tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue)).block(TIMEOUT);\n+        tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue2)).block(TIMEOUT);\n \n         // Act & Assert\n         StepVerifier.create(tableClient.listEntities(options))\n             .assertNext(returnEntity -> {\n                 assertEquals(partitionKeyValue, returnEntity.getPartitionKey());\n-                assertEquals(entity.getRowKey(), returnEntity.getRowKey());\n+                assertEquals(rowKeyValue, returnEntity.getRowKey());\n             })\n+            .expectNextCount(0)\n+            .thenConsumeWhile(x -> true)\n             .expectComplete()\n             .verify();\n     }\n \n-    @Disabled(\"List not working yet.\")\n     @Test\n-    void listEntityWithSelectAsync() {\n+    @Tag(\"ListEntities\")\n+    void listEntitiesWithSelectAsync() {\n         // Arrange\n         final String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n         final String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n         final TableEntity entity = new TableEntity(partitionKeyValue, rowKeyValue)\n             .addProperty(\"propertyC\", \"valueC\")\n             .addProperty(\"propertyD\", \"valueD\");\n         ListEntitiesOptions options = new ListEntitiesOptions()\n-            .setFilter(\"PartitionKey eq '\" + entity.getPartitionKey() + \"'\")\n             .setSelect(\"propertyC\");\n         tableClient.createEntity(entity).block(TIMEOUT);\n \n         // Act & Assert\n         StepVerifier.create(tableClient.listEntities(options))\n             .assertNext(returnEntity -> {\n-                assertEquals(entity.getRowKey(), returnEntity.getRowKey());\n-                assertEquals(entity.getPartitionKey(), returnEntity.getPartitionKey());\n+                assertNull(returnEntity.getRowKey());\n+                assertNull(returnEntity.getPartitionKey());\n                 assertEquals(\"valueC\", returnEntity.getProperties().get(\"propertyC\"));\n-                assertEquals(3, returnEntity.getProperties().size());\n+                assertNull(returnEntity.getProperties().get(\"propertyD\"));\n             })\n             .expectComplete()\n             .verify();\n     }\n \n     @Test\n-    void listEntityWithTopAsync() {\n+    @Tag(\"ListEntities\")\n+    void listEntitiesWithTopAsync() {\n         // Arrange\n-        ListEntitiesOptions options = new ListEntitiesOptions()\n-            .setTop(1);\n+        final String partitionKeyValue = testResourceNamer.randomName(\"partitionKey\", 20);\n+        final String rowKeyValue = testResourceNamer.randomName(\"rowKey\", 20);\n+        final String rowKeyValue2 = testResourceNamer.randomName(\"rowKey\", 20);\n+        final String rowKeyValue3 = testResourceNamer.randomName(\"rowKey\", 20);\n+        ListEntitiesOptions options = new ListEntitiesOptions().setTop(2);\n+        tableClient.createEntity(new TableEntity(partitionKeyValue, rowKeyValue)).block(TIMEOUT);", "originalCommit": "8dab1dac06af4fd88e7dc963adf77f822f64ebfb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NjMyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479556324", "bodyText": "Same with those other instances.", "author": "conniey", "createdAt": "2020-08-28T22:14:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NjA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NzgyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14551#discussion_r479587821", "bodyText": "Fixed", "author": "bsiegel", "createdAt": "2020-08-29T01:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NjA3Nw=="}], "type": "inlineReview"}, {"oid": "7319f7be17c1fefa9c3559139ded36c597e47028", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7319f7be17c1fefa9c3559139ded36c597e47028", "message": "Deserialized TableEntities have no required properties\n\nWhen using a Select clause, the user can cause any properties to be\nomitted, even ones that are service-specific like PartitionKey and\nRowKey.", "committedDate": "2020-08-29T00:11:27Z", "type": "forcePushed"}, {"oid": "85508878da88d35161bff53c1e9806b9722446df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/85508878da88d35161bff53c1e9806b9722446df", "message": "Deserialized TableEntities have no required properties\n\nWhen using a Select clause, the user can cause any properties to be\nomitted, even ones that are service-specific like PartitionKey and\nRowKey.", "committedDate": "2020-08-29T01:01:26Z", "type": "forcePushed"}, {"oid": "51f7e7a3d690bfbfd607fe36c585e933da0ee2f5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51f7e7a3d690bfbfd607fe36c585e933da0ee2f5", "message": "TablesJacksonSerializer uniformly deserializes entities\n\n1. Enable the serializer to handle lists of entities\n2. Centralize the conversion from Map -> TableEntity in its constructor\n3. Begin implementing @odata.type annotation processing", "committedDate": "2020-08-31T17:56:41Z", "type": "commit"}, {"oid": "2fcf6243c6b7e876b070a097eec135008c2942e9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2fcf6243c6b7e876b070a097eec135008c2942e9", "message": "Fix deserialization of single entities for getEntity", "committedDate": "2020-08-31T17:56:41Z", "type": "commit"}, {"oid": "092c96e1365e3a69e874ff77fe2b85dc1d44a0d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/092c96e1365e3a69e874ff77fe2b85dc1d44a0d2", "message": "Deserialized TableEntities have no required properties\n\nWhen using a Select clause, the user can cause any properties to be\nomitted, even ones that are service-specific like PartitionKey and\nRowKey.", "committedDate": "2020-08-31T17:56:41Z", "type": "commit"}, {"oid": "47fa882557b90012a5cc441123a817e2d72050eb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47fa882557b90012a5cc441123a817e2d72050eb", "message": "Clean up ModelHelper", "committedDate": "2020-08-31T19:12:23Z", "type": "commit"}, {"oid": "47fa882557b90012a5cc441123a817e2d72050eb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47fa882557b90012a5cc441123a817e2d72050eb", "message": "Clean up ModelHelper", "committedDate": "2020-08-31T19:12:23Z", "type": "forcePushed"}]}