{"pr_number": 14390, "pr_title": "Improvements to the Storage Performance Tests", "pr_createdAt": "2020-08-25T00:29:05Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14390", "timeline": [{"oid": "d44b19f53c26d3c91faa5f91abc994b95e87c08f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d44b19f53c26d3c91faa5f91abc994b95e87c08f", "message": "Improvements to the Storage performance tests", "committedDate": "2020-08-25T00:27:40Z", "type": "commit"}, {"oid": "9786a3c36fd748548b0a7c3f2572d5b86e553c5b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9786a3c36fd748548b0a7c3f2572d5b86e553c5b", "message": "Replaced flatMap with map and added RepeatingInputStream which allows for marking (required for uploadblockblob tests)", "committedDate": "2020-08-25T17:42:46Z", "type": "commit"}, {"oid": "51efc2efd215685cb85bf0a781768b800328a8f0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51efc2efd215685cb85bf0a781768b800328a8f0", "message": "Merge branch 'master' into AzStorage_PerfTestImprovements", "committedDate": "2020-08-31T17:58:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUyOTMzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486529334", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Random random = new Random();\n          \n          \n            \n                    Random random = new Random(0);\n          \n      \n    \n    \n  \n\nI slightly prefer using a fixed random seed for repeatability.", "author": "mikeharder", "createdAt": "2020-09-10T17:55:44Z", "path": "common/perf-test-core/src/main/java/com/azure/perf/test/core/TestDataCreationHelper.java", "diffHunk": "@@ -3,30 +3,31 @@\n \n package com.azure.perf.test.core;\n \n-import java.io.ByteArrayInputStream;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n import java.io.InputStream;\n-import java.io.SequenceInputStream;\n+import java.io.OutputStream;\n import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.List;\n import java.util.Random;\n-import reactor.core.publisher.Flux;\n \n /**\n  * Utility class to help with data creation for perf testing.\n  */\n public class TestDataCreationHelper {\n+    private static final int RANDOM_BYTES_LENGTH = 1024 * 1024; // 1MB\n     private static final byte[] RANDOM_BYTES;\n     private static final ByteBuffer RANDOM_BYTE_BUFFER;\n     private static final int SIZE = (1024 * 1024 * 1024) + 1;\n-    private static final byte[] RANDOM_STREAM_BYTES;\n \n     static {\n-        RANDOM_BYTES = new byte[1024 * 1024];\n-        (new Random(0)).nextBytes(TestDataCreationHelper.RANDOM_BYTES);\n+        Random random = new Random();", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUyOTY5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486529693", "bodyText": "Remove this commented code?", "author": "mikeharder", "createdAt": "2020-09-10T17:56:16Z", "path": "common/perf-test-core/src/main/java/com/azure/perf/test/core/TestDataCreationHelper.java", "diffHunk": "@@ -3,30 +3,31 @@\n \n package com.azure.perf.test.core;\n \n-import java.io.ByteArrayInputStream;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.IOException;\n import java.io.InputStream;\n-import java.io.SequenceInputStream;\n+import java.io.OutputStream;\n import java.nio.ByteBuffer;\n-import java.util.Collections;\n-import java.util.List;\n import java.util.Random;\n-import reactor.core.publisher.Flux;\n \n /**\n  * Utility class to help with data creation for perf testing.\n  */\n public class TestDataCreationHelper {\n+    private static final int RANDOM_BYTES_LENGTH = 1024 * 1024; // 1MB\n     private static final byte[] RANDOM_BYTES;\n     private static final ByteBuffer RANDOM_BYTE_BUFFER;\n     private static final int SIZE = (1024 * 1024 * 1024) + 1;\n-    private static final byte[] RANDOM_STREAM_BYTES;\n \n     static {\n-        RANDOM_BYTES = new byte[1024 * 1024];\n-        (new Random(0)).nextBytes(TestDataCreationHelper.RANDOM_BYTES);\n+        Random random = new Random();\n+        RANDOM_BYTES = new byte[RANDOM_BYTES_LENGTH];\n+        random.nextBytes(RANDOM_BYTES);\n         RANDOM_BYTE_BUFFER = ByteBuffer.wrap(TestDataCreationHelper.RANDOM_BYTES).asReadOnlyBuffer();\n-        RANDOM_STREAM_BYTES = new byte[SIZE];\n-        (new Random(0)).nextBytes(RANDOM_STREAM_BYTES);\n+\n+//        SIZE_BYTES = new byte[SIZE];", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUyOTc3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486529779", "bodyText": "Remove extra newline?", "author": "mikeharder", "createdAt": "2020-09-10T17:56:28Z", "path": "common/perf-test-core/src/main/java/com/azure/perf/test/core/TestDataCreationHelper.java", "diffHunk": "@@ -43,6 +44,7 @@\n         int quotient = (int) size / remaining;\n         int remainder = (int) size % remaining;\n \n+", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MDA3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486540070", "bodyText": "I think it would be better to make NullOutputStream a singleton, so all consumers can use the same instance instead of creating a new one.", "author": "mikeharder", "createdAt": "2020-09-10T18:14:15Z", "path": "sdk/storage/azure-storage-perf/src/main/java/com/azure/storage/blob/perf/DownloadBlobTest.java", "diffHunk": "@@ -39,18 +42,31 @@ public void run() {\n \n     static class NullOutputStream extends OutputStream {", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MDg1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486540852", "bodyText": "Looking at the docs  for this API, would it be better to use this which is simpler, more closely matches the doc sample, and also more closely matches the sync code?\nNullOutputStream.getInstance().write(b.array())", "author": "mikeharder", "createdAt": "2020-09-10T18:15:12Z", "path": "sdk/storage/azure-storage-perf/src/main/java/com/azure/storage/blob/perf/DownloadBlobTest.java", "diffHunk": "@@ -39,18 +42,31 @@ public void run() {\n \n     static class NullOutputStream extends OutputStream {\n         @Override\n-        public void write(int b) throws IOException {\n+        public void write(int b) {\n \n         }\n+\n+        @Override\n+        public void write(byte[] b) {\n+        }\n+\n+        @Override\n+        public void write(byte[] b, int off, int len) {\n+        }\n     }\n \n     @Override\n     public Mono<Void> runAsync() {\n         return blobAsyncClient.download()\n             .map(b -> {\n-                for (int i = 0; i < b.remaining(); i++) {\n-                    b.get();\n+                int readCount = 0;", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU2MDYxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486560613", "bodyText": "Hmm, that sample should be updated as a ByteBuffer isn't guaranteed to have a backing byte[]. If the ByteBuffer instance is a DirectByteBuffer (aka OS managed memory) that will throw an exception.", "author": "alzimmermsft", "createdAt": "2020-09-10T18:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MjQ4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486542489", "bodyText": "Why add ignoreElements()?  Is this more or less similar to the sync implementation?", "author": "mikeharder", "createdAt": "2020-09-10T18:17:31Z", "path": "sdk/storage/azure-storage-perf/src/main/java/com/azure/storage/blob/perf/ListBlobsTest.java", "diffHunk": "@@ -25,11 +25,14 @@ public ListBlobsTest(PerfStressOptions options) {\n \n     @Override\n     public void run() {\n-        blobContainerClient.listBlobs().forEach(b -> { });\n+        blobContainerClient.listBlobs().forEach(b -> {\n+        });\n     }\n \n     @Override\n     public Mono<Void> runAsync() {\n-        return blobContainerAsyncClient.listBlobs().then();\n+        return blobContainerAsyncClient.listBlobs()\n+            .ignoreElements()", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5MTM3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r488091376", "bodyText": "That's a good question and I'll need to dig a little more into this. ignoreElements actively drops onNext signals upstream propagates while then actively ignores the sequence from upstream. I don't know how this plays out different for the listing operation response.", "author": "alzimmermsft", "createdAt": "2020-09-14T17:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MjQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5Mzg3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r488093876", "bodyText": "Looks like then is a bit of an alias for ignoreElements (not exactly the same but the resulting subscriber is the same). I'll go ahead and remove ignoreElements.", "author": "alzimmermsft", "createdAt": "2020-09-14T17:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MjQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MzkyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r486553922", "bodyText": "Would this be equivalent in both perf and functionality?\ncopyStream(createRandomInputStream(size), blobOutputStream);\nIf so, this would allow us to delete writeBytesToOutputStream() which seems simpler.", "author": "mikeharder", "createdAt": "2020-09-10T18:32:53Z", "path": "sdk/storage/azure-storage-perf/src/main/java/com/azure/storage/blob/perf/UploadOutputStreamTest.java", "diffHunk": "@@ -3,29 +3,25 @@\n \n package com.azure.storage.blob.perf;\n \n-import static com.azure.perf.test.core.TestDataCreationHelper.createRandomInputStream;\n-\n import com.azure.perf.test.core.PerfStressOptions;\n import com.azure.storage.blob.perf.core.BlobTestBase;\n import com.azure.storage.blob.specialized.BlobOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n import reactor.core.publisher.Mono;\n \n-public class UploadOutputStreamTest extends BlobTestBase<PerfStressOptions> {\n+import java.io.IOException;\n \n-    private final InputStream inputStream;\n+import static com.azure.perf.test.core.TestDataCreationHelper.writeBytesToOutputStream;\n \n+public class UploadOutputStreamTest extends BlobTestBase<PerfStressOptions> {\n     public UploadOutputStreamTest(PerfStressOptions options) {\n         super(options);\n-        this.inputStream = createRandomInputStream(options.getSize());\n     }\n \n     @Override\n     public void run() {\n         try {\n             BlobOutputStream blobOutputStream = blockBlobClient.getBlobOutputStream();\n-            copyStream(inputStream, blobOutputStream);\n+            writeBytesToOutputStream(blobOutputStream, options.getSize());", "originalCommit": "51efc2efd215685cb85bf0a781768b800328a8f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA4NTkzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14390#discussion_r488085933", "bodyText": "copyStream is generally less performant, and definitely less performant with the type of streams we are using. ByteArrayInputStream clones the byte[] it returns from read operations and ByteArrayOutputSteam clones the byte[] passed into write operation. writeBytesToOutputStream skips the data copying that occurs during read.", "author": "alzimmermsft", "createdAt": "2020-09-14T16:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MzkyMg=="}], "type": "inlineReview"}, {"oid": "3ea84e65bf1a22e729bcbe7f45c6668f11881011", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ea84e65bf1a22e729bcbe7f45c6668f11881011", "message": "Merge branch 'master' into AzStorage_PerfTestImprovements", "committedDate": "2020-09-14T16:52:03Z", "type": "commit"}, {"oid": "b843426cb1cf4dd1d430ac337015fff8385217bf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b843426cb1cf4dd1d430ac337015fff8385217bf", "message": "Changes based on feedback", "committedDate": "2020-09-14T17:13:09Z", "type": "commit"}]}