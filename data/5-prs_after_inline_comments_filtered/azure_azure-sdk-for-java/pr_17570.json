{"pr_number": 17570, "pr_title": "Adding basic FeedRanges API", "pr_createdAt": "2020-11-13T15:23:42Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/17570", "timeline": [{"oid": "21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "message": "Initial draft of FeedRange artifacts", "committedDate": "2020-11-04T00:58:15Z", "type": "commit"}, {"oid": "6e6930098c1df358ec74f580cb3617df00dff471", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e6930098c1df358ec74f580cb3617df00dff471", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-04T10:30:17Z", "type": "commit"}, {"oid": "40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "message": "Iterating on FeedRange Apis", "committedDate": "2020-11-05T00:29:56Z", "type": "commit"}, {"oid": "54bed2e218c4d42036e4c569c5df311420ac8850", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54bed2e218c4d42036e4c569c5df311420ac8850", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-05T14:05:54Z", "type": "commit"}, {"oid": "58f98e7557075cc4859797a3d4841db3a6d3bd93", "url": "https://github.com/Azure/azure-sdk-for-java/commit/58f98e7557075cc4859797a3d4841db3a6d3bd93", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-11T23:05:03Z", "type": "commit"}, {"oid": "46662e06209505e511f01bd53027c378a375d28f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46662e06209505e511f01bd53027c378a375d28f", "message": "Adding public surface area", "committedDate": "2020-11-12T00:19:01Z", "type": "commit"}, {"oid": "03617a4b6c865db61b15eab54e644d2247028bbe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/03617a4b6c865db61b15eab54e644d2247028bbe", "message": "Adding FeedRange unit tests", "committedDate": "2020-11-12T23:13:26Z", "type": "commit"}, {"oid": "b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Refresh", "committedDate": "2020-11-13T00:03:45Z", "type": "commit"}, {"oid": "4095bc5bc318c7c11178e3b2db19f9cec27d5637", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4095bc5bc318c7c11178e3b2db19f9cec27d5637", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Null", "committedDate": "2020-11-13T00:33:45Z", "type": "commit"}, {"oid": "8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "message": "Adding test feedRangeEPK_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:18:21Z", "type": "commit"}, {"oid": "4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "message": "Adding test feedRangePK_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:27:33Z", "type": "commit"}, {"oid": "2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "message": "Adding test feedRangePKRangeId_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:32:17Z", "type": "commit"}, {"oid": "dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "message": "Adding request visitor unit tests", "committedDate": "2020-11-13T11:22:22Z", "type": "commit"}, {"oid": "0ef3170e6b938b585218cb1274af297221a488a5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ef3170e6b938b585218cb1274af297221a488a5", "message": "Finishing FeedRange tests", "committedDate": "2020-11-13T14:20:56Z", "type": "commit"}, {"oid": "ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "message": "Cleanup and prettifying", "committedDate": "2020-11-13T14:48:00Z", "type": "commit"}, {"oid": "4811e5034bea83f2555f13ab6fb51f9c7defbd68", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4811e5034bea83f2555f13ab6fb51f9c7defbd68", "message": "Prettifying feed range tests", "committedDate": "2020-11-13T14:50:19Z", "type": "commit"}, {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "message": "Fixes and new test for Conatiner.getFeedRanges()", "committedDate": "2020-11-13T15:14:38Z", "type": "commit"}, {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "message": "Addressing some SpotBug violations", "committedDate": "2020-11-13T17:31:29Z", "type": "commit"}, {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b08488a3d52dd394fcd8bbd3de79184c796afe36", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-16T15:31:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r523113207", "bodyText": "nit: license header", "author": "moderakh", "createdAt": "2020-11-13T17:33:02Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ShouldRetryResult.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.azure.cosmos.implementation;", "originalCommit": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMDU2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525530561", "bodyText": "I am afraid to disagree here - this is not a nit :)\nWe need to have the license before this can go in.", "author": "kushagraThapar", "createdAt": "2020-11-17T21:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0MjUzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525542537", "bodyText": "true license header required.\nI meant \"add license header\"  :-)", "author": "moderakh", "createdAt": "2020-11-17T21:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MTA5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525571099", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExMzIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNTQ2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r523115466", "bodyText": "should this be list or Iterable? does indexing feedRange.get(1) a meaningful action?\nIf not probably Iterable is more suitable.\nthought?", "author": "moderakh", "createdAt": "2020-11-13T17:35:43Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -556,4 +557,23 @@ public CosmosScripts getScripts() {\n         return UtilBridgeInternal.createCosmosPagedIterable(cosmosPagedFlux);\n     }\n \n+    /**\n+     * Obtains a list of {@link FeedRange} that can be used to parallelize Feed\n+     * operations.\n+     *\n+     * @return An unmodifiable list of {@link FeedRange}\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public List<FeedRange> getFeedRanges() {", "originalCommit": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNTAzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525525032", "bodyText": "I am fine with List as compared to Iterable - as it gives user more flexibility on not having to cast it to lists or other >Iterables.\nThough I am wondering why are we not using CosmosPagedIterable<FeedRange>\n\n\nfabianm (response): Reason for using List of Iterable was that size will be often used by callers. Not using ComsosPagedIterable because it will always be exactly one page (IO op)", "author": "kushagraThapar", "createdAt": "2020-11-17T21:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNTQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MTUxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525571514", "bodyText": "Reason why I chose List over Iterable is that it allows to get the size efficiently - which I think most callers would need.", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzAwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525333007", "bodyText": "List<FeedRange> feedRanges = new ArrayList<FeedRange>(feedRanges.size());", "author": "moderakh", "createdAt": "2020-11-17T17:06:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -3634,4 +3641,56 @@ private static SqlQuerySpec createLogicalPartitionScanQuerySpec(\n \n         return new SqlQuerySpec(queryStringBuilder.toString(), parameters);\n     }\n+\n+    @Override\n+    public Mono<List<FeedRange>> getFeedRanges(String collectionLink) {\n+\n+        if (StringUtils.isEmpty(collectionLink)) {\n+            throw new IllegalArgumentException(\"collectionLink\");\n+        }\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            this,\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink,\n+            null); // This should not go to backend\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionObs = collectionCache.resolveCollectionAsync(null,\n+            request);\n+\n+        return collectionObs.flatMap(documentCollectionResourceResponse -> {\n+            final DocumentCollection collection = documentCollectionResourceResponse.v;\n+            if (collection == null) {\n+                throw new IllegalStateException(\"Collection cannot be null\");\n+            }\n+\n+            Mono<Utils.ValueHolder<List<PartitionKeyRange>>> valueHolderMono = partitionKeyRangeCache\n+                .tryGetOverlappingRangesAsync(\n+                    BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics),\n+                    collection.getResourceId(), RANGE_INCLUDING_ALL_PARTITION_KEY_RANGES, true, null);\n+\n+            return valueHolderMono.map(partitionKeyRangeListResponse -> {\n+                return toFeedRanges(partitionKeyRangeListResponse);\n+            });\n+        });\n+    }\n+\n+    private static List<FeedRange> toFeedRanges(\n+        Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) {\n+        final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v;\n+        if (partitionKeyRangeList == null) {\n+            throw new IllegalStateException(\"PartitionKeyRange list cannot be null\");\n+        }\n+\n+        List<FeedRange> feedRanges = new ArrayList<FeedRange>();", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyOTg2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525529867", "bodyText": "NIT: Can be final.\nAlso, we can use of java streams as well -\nfinal List<FeedRange> feedRanges = partitionKeyRangeList.stream().map(pkRange -> toFeedRange(pkRange)).collect(Collectors.toList())", "author": "kushagraThapar", "createdAt": "2020-11-17T21:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525572080", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzMzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDMzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525334332", "bodyText": "our implementation is async. the async suffix not needed.\nhere and other places.", "author": "moderakh", "createdAt": "2020-11-17T17:08:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeAsyncVisitor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import reactor.core.publisher.Mono;\n+\n+abstract class FeedRangeAsyncVisitor<TResult> {\n+    public abstract Mono<TResult> visitAsync(FeedRangePartitionKeyImpl feedRange);", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMTg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525531898", "bodyText": "I agree, we should just keep the async word in the class name, and remove it from the APIs.", "author": "kushagraThapar", "createdAt": "2020-11-17T21:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NTQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525575461", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:45:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDU5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525334593", "bodyText": "ditto on Async suffix. as above.", "author": "moderakh", "createdAt": "2020-11-17T17:08:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeAsyncVisitorWithArg.java", "diffHunk": "@@ -0,0 +1,15 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import reactor.core.publisher.Mono;\n+\n+abstract class FeedRangeAsyncVisitorWithArg<TResult, TArg> {\n+    public abstract Mono<TResult> visitAsync(FeedRangePartitionKeyImpl feedRange, TArg argument);", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NTUyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525575524", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525335213", "bodyText": "ranges.isEmpty()", "author": "moderakh", "createdAt": "2020-11-17T17:09:36Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.Integers;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * FeedRangeContinuation using Composite Continuation Tokens and split proof.\n+ * It uses a breath-first approach to transverse Composite Continuation Tokens.\n+ */\n+final class FeedRangeCompositeContinuationImpl extends FeedRangeContinuation {\n+\n+    private final static ShouldRetryResult NO_RETRY = ShouldRetryResult.noRetry();\n+    private final static ShouldRetryResult RETRY = ShouldRetryResult.retryAfter(Duration.ZERO);\n+    private final Queue<CompositeContinuationToken> compositeContinuationTokens;\n+    private CompositeContinuationToken currentToken;\n+    private String initialNoResultsRange;\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges) {\n+\n+        this(containerRid, feedRange, ranges, null);\n+    }\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges,\n+        String continuation) {\n+\n+        this(containerRid, feedRange);\n+\n+        checkNotNull(ranges, \"'ranges' must not be null\");\n+\n+        if (ranges.size() == 0) {", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM1MTQzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525351434", "bodyText": "final List<Range<String>> feedRanges = new ArrayList<>(partitionKeyRangeList.size);", "author": "moderakh", "createdAt": "2020-11-17T17:32:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeExtractorImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ResourceResponse;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.routing.Range;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+final class FeedRangePartitionKeyRangeExtractorImpl extends FeedRangeAsyncVisitor<List<Range<String>>> {\n+\n+    private final RxDocumentClientImpl client;\n+    private final String collectionLink;\n+\n+    public FeedRangePartitionKeyRangeExtractorImpl(\n+        RxDocumentClientImpl client,\n+        String collectionLink) {\n+\n+        checkNotNull(client, \"'client' must not be null\");\n+        checkNotNull(collectionLink, \"'collectionLink' must not be null\");\n+\n+        this.client = client;\n+        this.collectionLink = collectionLink;\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangePartitionKeyImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        return collectionResponseObservable.flatMap(collectionResponse -> {\n+            final DocumentCollection collection = collectionResponse.getResource();\n+            return feedRange.getEffectiveRangesAsync(partitionKeyRangeCache,\n+                collection.getResourceId(),\n+                collection.getPartitionKey());\n+        });\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangePartitionKeyRangeImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        return collectionResponseObservable.flatMap(collectionResponse -> {\n+            final DocumentCollection collection = collectionResponse.getResource();\n+            return feedRange.getEffectiveRangesAsync(partitionKeyRangeCache,\n+                collection.getResourceId(), null);\n+        });\n+    }\n+\n+    @Override\n+    public Mono<List<Range<String>>> visitAsync(FeedRangeEpkImpl feedRange) {\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache =\n+            this.client.getPartitionKeyRangeCache();\n+        final Mono<ResourceResponse<DocumentCollection>> collectionResponseObservable = this.client\n+            .readCollection(this.collectionLink, null);\n+\n+        final Mono<Utils.ValueHolder<List<PartitionKeyRange>>> valueHolderMono =\n+            collectionResponseObservable\n+                .flatMap(collectionResponse -> {\n+                    final DocumentCollection collection = collectionResponse.getResource();\n+                    return partitionKeyRangeCache.tryGetOverlappingRangesAsync(\n+                        BridgeInternal.getMetaDataDiagnosticContext(null),\n+                        collection.getResourceId(),\n+                        feedRange.getRange(), false, null);\n+                });\n+\n+        return valueHolderMono.map(FeedRangePartitionKeyRangeExtractorImpl::toFeedRanges);\n+    }\n+\n+    private static UnmodifiableList<Range<String>> toFeedRanges(\n+        final Utils.ValueHolder<List<PartitionKeyRange>> partitionKeyRangeListValueHolder) {\n+        final List<PartitionKeyRange> partitionKeyRangeList = partitionKeyRangeListValueHolder.v;\n+        if (partitionKeyRangeList == null) {\n+            throw new IllegalStateException(\"PartitionKeyRange list cannot be null\");\n+        }\n+\n+        final List<Range<String>> feedRanges = new ArrayList<>();", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODY4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525368689", "bodyText": "header missing.", "author": "moderakh", "createdAt": "2020-11-17T17:54:51Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/feedranges/FeedRangeTest.java", "diffHunk": "@@ -0,0 +1,503 @@\n+package com.azure.cosmos.implementation.feedranges;", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MTAxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525571011", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2ODY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525370515", "bodyText": "as an optimization; There are two public methods in the parent class (fromJsonString and toJsonString).\nas fromJsonString is the only to instantiate, you could cache the json value and return the same in the toJsonString", "author": "moderakh", "createdAt": "2020-11-17T17:57:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+\n+public abstract class FeedRangeInternal extends JsonSerializable implements FeedRange {\n+\n+    public abstract void accept(FeedRangeVisitor visitor);\n+\n+    public abstract <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input);\n+\n+    public abstract <T> Mono<T> acceptAsync(FeedRangeAsyncVisitor<T> visitor);\n+\n+    public static FeedRangeInternal convert(final FeedRange feedRange) {\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (feedRange instanceof FeedRangeInternal) {\n+            return (FeedRangeInternal)feedRange;\n+        }\n+\n+        String json = feedRange.toJsonString();\n+        return fromJsonString(json);\n+    }\n+\n+    /**\n+     * Creates a range from a previously obtained string representation.\n+     *\n+     * @param json A string representation of a feed range\n+     * @return A feed range\n+     */\n+    public static FeedRangeInternal fromJsonString(String json) {", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3Njg4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525576883", "bodyText": "Not all concrete classes inheriting form this are immutable - so the cached json might not be the current one. Skipping this for now - can be introduced later if perf testing indicates a problem there.", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MDUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525371216", "bodyText": "I would use checkNotNull pattern that you used elsewhere to be consistent and more succinct", "author": "moderakh", "createdAt": "2020-11-17T17:58:34Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -0,0 +1,161 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.PartitionKeyRangeGoneException;\n+import com.azure.cosmos.implementation.Utils.ValueHolder;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+public final class FeedRangePartitionKeyRangeImpl extends FeedRangeInternal {\n+    private final String partitionKeyRangeId;\n+    private final PartitionKeyRangeIdentity partitionKeyRangeIdentity;\n+\n+    public FeedRangePartitionKeyRangeImpl(final String partitionKeyRangeId) {\n+        if (partitionKeyRangeId == null) {\n+            throw new NullPointerException(\"partitionKeyRangeId\");", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjExMTY0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r526111642", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-18T14:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTM5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525371393", "bodyText": "I would use checkNotNull pattern that you used elsewhere to be consistent and more succinct.\nhere and everywhere else in the new code.", "author": "moderakh", "createdAt": "2020-11-17T17:58:49Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -0,0 +1,161 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.PartitionKeyRangeGoneException;\n+import com.azure.cosmos.implementation.Utils.ValueHolder;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+public final class FeedRangePartitionKeyRangeImpl extends FeedRangeInternal {\n+    private final String partitionKeyRangeId;\n+    private final PartitionKeyRangeIdentity partitionKeyRangeIdentity;\n+\n+    public FeedRangePartitionKeyRangeImpl(final String partitionKeyRangeId) {\n+        if (partitionKeyRangeId == null) {\n+            throw new NullPointerException(\"partitionKeyRangeId\");\n+        }\n+\n+        this.partitionKeyRangeId = partitionKeyRangeId;\n+        this.partitionKeyRangeIdentity = new PartitionKeyRangeIdentity(partitionKeyRangeId);\n+    }\n+\n+    public String getPartitionKeyRangeId() {\n+        return this.partitionKeyRangeId;\n+    }\n+\n+    public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n+        return this.partitionKeyRangeIdentity;\n+    }\n+\n+    @Override\n+    public void accept(final FeedRangeVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MTA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525581067", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM3MTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5OTYzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525399636", "bodyText": "why do we need the both version async and sync accept?", "author": "moderakh", "createdAt": "2020-11-17T18:42:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -0,0 +1,152 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n+import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.PartitionKeyDefinition;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+\n+final class FeedRangePartitionKeyImpl extends FeedRangeInternal {\n+    private final PartitionKeyInternal partitionKey;\n+\n+    public FeedRangePartitionKeyImpl(PartitionKeyInternal partitionKey) {\n+        if (partitionKey == null) {\n+            throw new NullPointerException(\"partitionKey\");\n+        }\n+\n+        this.partitionKey = partitionKey;\n+    }\n+\n+    public PartitionKeyInternal getPartitionKeyInternal() {\n+        return this.partitionKey;\n+    }\n+\n+    @Override\n+    public void accept(FeedRangeVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");\n+        }\n+\n+        visitor.visit(this);\n+    }\n+\n+    @Override\n+    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MTYzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525581637", "bodyText": "Discussed offline - usage of the visitors will be added when consuming the FeedRange Api in feedRanges - will double check then which of them are still needed etc. (I only ported those I believe we will need - but I am porting a moving target - so this is work in progress)", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T22:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM5OTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDQ5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525524498", "bodyText": "Shouldn't this be Flux<FeedRange> or CosmosPagedFlux<FeedRange> ? What is the benefit of Mono<List<FeedRange>> - as that will always have just one list of FeedRange ?", "author": "kushagraThapar", "createdAt": "2020-11-17T21:06:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -1124,4 +1125,15 @@ String getLink() {\n     ItemDeserializer getItemDeserializer() {\n         return getDatabase().getDocClientWrapper().getItemDeserializer();\n     }\n+\n+    /**\n+     * Obtains a list of {@link FeedRange} that can be used to parallelize Feed\n+     * operations.\n+     *\n+     * @return An unmodifiable list of {@link FeedRange}\n+     */\n+    @Beta(Beta.SinceVersion.V4_9_0)\n+    public Mono<List<FeedRange>> getFeedRanges() {", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0ODY5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525548692", "bodyText": "Yes - will always be just one returned list - never pages or multiple requests/IO operations", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T21:51:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTAxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525549014", "bodyText": "So intentionally using Mono<List> - Flux would inidcate that there could be multiple asynchronous values", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T21:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNDQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjE2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525526165", "bodyText": "What about 304 (NOT_MODIFIED) - does that not count in maximum success code?", "author": "kushagraThapar", "createdAt": "2020-11-17T21:09:48Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -272,6 +272,9 @@\n     public static class StatusCodes {\n         public static final int OK = 200;\n         public static final int NOT_MODIFIED = 304;\n+        // Success\n+        public static final int MINIMUM_SUCCESS_STATUSCODE = 200;\n+        public static final int MAXIMUM_SUCCESS_STATUSCODE = 299;", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MDYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525550609", "bodyText": "3xx are Redirection status codes.\n2xx - success\n3xx - redirection\n4xx - client failure\n5xx - service failure", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T21:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTIyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525535222", "bodyText": "Should we log the exception here for our own debugging purposes?", "author": "kushagraThapar", "createdAt": "2020-11-17T21:26:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -0,0 +1,366 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.Integers;\n+import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceResponse;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.caches.RxPartitionKeyRangeCache;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+/**\n+ * FeedRangeContinuation using Composite Continuation Tokens and split proof.\n+ * It uses a breath-first approach to transverse Composite Continuation Tokens.\n+ */\n+final class FeedRangeCompositeContinuationImpl extends FeedRangeContinuation {\n+\n+    private final static ShouldRetryResult NO_RETRY = ShouldRetryResult.noRetry();\n+    private final static ShouldRetryResult RETRY = ShouldRetryResult.retryAfter(Duration.ZERO);\n+    private final Queue<CompositeContinuationToken> compositeContinuationTokens;\n+    private CompositeContinuationToken currentToken;\n+    private String initialNoResultsRange;\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges) {\n+\n+        this(containerRid, feedRange, ranges, null);\n+    }\n+\n+    public FeedRangeCompositeContinuationImpl(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<Range<String>> ranges,\n+        String continuation) {\n+\n+        this(containerRid, feedRange);\n+\n+        checkNotNull(ranges, \"'ranges' must not be null\");\n+\n+        if (ranges.size() == 0) {\n+            throw new IllegalArgumentException(\"'ranges' must not be empty\");\n+        }\n+\n+        for (Range<String> range : ranges) {\n+            this.compositeContinuationTokens.add(\n+                FeedRangeCompositeContinuationImpl.createCompositeContinuationTokenForRange(\n+                    range.getMin(),\n+                    range.getMax(),\n+                    continuation)\n+            );\n+        }\n+\n+        this.currentToken = this.getCompositeContinuationTokens().peek();\n+    }\n+\n+    private FeedRangeCompositeContinuationImpl(String containerRid, FeedRangeInternal feedRange) {\n+        super(containerRid, feedRange);\n+\n+        this.compositeContinuationTokens = new LinkedList<>();\n+    }\n+\n+    public Queue<CompositeContinuationToken> getCompositeContinuationTokens() {\n+        return compositeContinuationTokens;\n+    }\n+\n+    public CompositeContinuationToken getCurrentToken() {\n+        return this.currentToken;\n+    }\n+\n+    @Override\n+    public FeedRangeInternal getFeedRange() {\n+        if (!(this.feedRange instanceof FeedRangeEpkImpl)) {\n+            return this.feedRange;\n+        }\n+\n+        if (this.currentToken != null) {\n+            return new FeedRangeEpkImpl(this.currentToken.getRange());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getContinuation() {\n+        CompositeContinuationToken tokenSnapshot = this.currentToken;\n+        if (tokenSnapshot == null) {\n+            return null;\n+        }\n+\n+        return tokenSnapshot.getToken();\n+    }\n+\n+    @Override\n+    public void replaceContinuation(final String continuationToken) {\n+        final CompositeContinuationToken continuationTokenSnapshot = this.currentToken;\n+\n+        if (continuationTokenSnapshot == null) {\n+            return;\n+        }\n+\n+        continuationTokenSnapshot.setToken(continuationToken);\n+        this.moveToNextToken();\n+    }\n+\n+    @Override\n+    public boolean isDone() {\n+        return this.compositeContinuationTokens.size() == 0;\n+    }\n+\n+    @Override\n+    public void validateContainer(final String containerRid) throws IllegalArgumentException {\n+        if (Strings.isNullOrEmpty(containerRid) || !containerRid.equals(this.getContainerRid())) {\n+\n+            final String message = String.format(\n+                \"The continuation was generated for container %s but current container is %s.\",\n+                this.getContainerRid(), containerRid);\n+            throw new IllegalArgumentException(message);\n+        }\n+    }\n+\n+    @Override\n+    public ShouldRetryResult handleChangeFeedNotModified(final RxDocumentServiceResponse response) {\n+        if (response == null) {\n+            throw new NullPointerException(\"response\");\n+        }\n+\n+        final int statusCode = response.getStatusCode();\n+        if (statusCode >= HttpConstants.StatusCodes.MINIMUM_SUCCESS_STATUSCODE\n+            && statusCode <= HttpConstants.StatusCodes.MAXIMUM_SUCCESS_STATUSCODE) {\n+\n+            this.initialNoResultsRange = null;\n+            return NO_RETRY;\n+        }\n+\n+        if (statusCode == HttpConstants.StatusCodes.NOT_MODIFIED && this.compositeContinuationTokens.size() > 1) {\n+\n+            final String eTag = response.getResponseHeaders().get(HttpConstants.HttpHeaders.E_TAG);\n+            if (this.initialNoResultsRange == null) {\n+\n+                this.initialNoResultsRange = this.currentToken.getRange().getMin();\n+                this.replaceContinuation(eTag);\n+                return RETRY;\n+            }\n+\n+            if (!this.initialNoResultsRange.equalsIgnoreCase(this.currentToken.getRange().getMin())) {\n+                this.replaceContinuation(eTag);\n+                return RETRY;\n+            }\n+        }\n+\n+        return NO_RETRY;\n+    }\n+\n+    @Override\n+    public Mono<ShouldRetryResult> handleSplitAsync(final RxDocumentClientImpl client,\n+                                                    final RxDocumentServiceResponse response) {\n+\n+        if (client == null) {\n+            throw new NullPointerException(\"client\");\n+        }\n+\n+        if (response == null) {\n+            throw new NullPointerException(\"response\");\n+        }\n+\n+        Integer nSubStatus = 0;\n+        final String valueSubStatus =\n+            response.getResponseHeaders().get(HttpConstants.HttpHeaders.SUB_STATUS);\n+        if (!Strings.isNullOrEmpty(valueSubStatus)) {\n+            nSubStatus = Integers.tryParse(valueSubStatus);\n+        }\n+\n+        final boolean partitionSplit =\n+            response.getStatusCode() == HttpConstants.StatusCodes.GONE && nSubStatus != null\n+                && (nSubStatus == HttpConstants.SubStatusCodes.PARTITION_KEY_RANGE_GONE\n+                || nSubStatus == HttpConstants.SubStatusCodes.COMPLETING_SPLIT);\n+\n+        if (!partitionSplit) {\n+            return Mono.just(NO_RETRY);\n+        }\n+\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache = client.getPartitionKeyRangeCache();\n+        final Mono<Utils.ValueHolder<List<PartitionKeyRange>>> resolvedRangesTask =\n+            this.tryGetOverlappingRangesAsync(\n+                partitionKeyRangeCache, this.currentToken.getRange().getMin(),\n+                this.currentToken.getRange().getMax(),\n+                true);\n+\n+        return resolvedRangesTask.flatMap(resolvedRanges -> {\n+            if (resolvedRanges.v != null && resolvedRanges.v.size() > 0) {\n+                this.createChildRanges(resolvedRanges.v);\n+            }\n+\n+            return Mono.just(RETRY);\n+        });\n+    }\n+\n+    @Override\n+    public void accept(final FeedRangeContinuationVisitor visitor) {\n+        if (visitor == null) {\n+            throw new NullPointerException(\"visitor\");\n+        }\n+\n+        visitor.visit(this);\n+    }\n+\n+    /**\n+     * Used for deserializtion only\n+     */\n+    public static FeedRangeCompositeContinuationImpl createFromDeserializedTokens(\n+        String containerRid,\n+        FeedRangeInternal feedRange,\n+        List<CompositeContinuationToken> deserializedTokens) {\n+\n+        FeedRangeCompositeContinuationImpl thisPtr =\n+            new FeedRangeCompositeContinuationImpl(containerRid, feedRange);\n+\n+        checkNotNull(deserializedTokens, \"'deserializedTokens' must not be null\");\n+\n+        if (deserializedTokens.size() == 0) {\n+            throw new IllegalArgumentException(\"'deserializedTokens' must not be empty\");\n+        }\n+\n+        thisPtr.compositeContinuationTokens.addAll(deserializedTokens);\n+\n+        thisPtr.currentToken = thisPtr.getCompositeContinuationTokens().peek();\n+\n+        return thisPtr;\n+    }\n+\n+    public static FeedRangeContinuation parse(final String jsonString) throws IOException {\n+        if (jsonString == null) {\n+            throw new NullPointerException(\"jsonString\");\n+        }\n+\n+        final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+        return mapper.readValue(jsonString, FeedRangeCompositeContinuationImpl.class);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try {\n+            return Utils.getSimpleObjectMapper().writeValueAsString(this);\n+        } catch (final IOException e) {\n+            throw new IllegalArgumentException(\n+                \"Unable serialize the composite FeedRange continuation token into a JSON string\",\n+                e);\n+        }\n+    }\n+\n+    private void createChildRanges(final List<PartitionKeyRange> keyRanges) {\n+        final PartitionKeyRange firstRange = keyRanges.get(0);\n+        this.currentToken\n+            .setRange(new Range<>(firstRange.getMinInclusive(),\n+                firstRange.getMaxExclusive(), true, false));\n+\n+        final CompositeContinuationToken continuationAsComposite =\n+            tryParseAsCompositeContinuationToken(\n+                this.currentToken.getToken());\n+\n+        if (continuationAsComposite != null) {\n+            // Update the internal composite continuation\n+            continuationAsComposite.setRange(this.currentToken.getRange());\n+            this.currentToken.setToken(continuationAsComposite.toJson());\n+            // Add children\n+            final int size = keyRanges.size();\n+            for (int i = 1; i < size; i++) {\n+                final PartitionKeyRange keyRange = keyRanges.get(i);\n+                continuationAsComposite.setRange(keyRange.toRange());\n+                this.compositeContinuationTokens.add(createCompositeContinuationTokenForRange(\n+                    keyRange.getMinInclusive(), keyRange.getMaxExclusive(),\n+                    continuationAsComposite.toJson()));\n+            }\n+        } else {\n+            // Add children\n+            final int size = keyRanges.size();\n+            for (int i = 1; i < size; i++) {\n+                final PartitionKeyRange keyRange = keyRanges.get(i);\n+                this.compositeContinuationTokens.add(createCompositeContinuationTokenForRange(\n+                    keyRange.getMinInclusive(), keyRange.getMaxExclusive(),\n+                    this.currentToken.getToken()));\n+            }\n+        }\n+    }\n+\n+    private static CompositeContinuationToken createCompositeContinuationTokenForRange(\n+        String minInclusive,\n+        String maxExclusive,\n+        String token) {\n+        return new CompositeContinuationToken(\n+            token,\n+            new Range<>(minInclusive, maxExclusive, true, false));\n+    }\n+\n+    private void moveToNextToken() {\n+        final CompositeContinuationToken recentToken = this.compositeContinuationTokens.poll();\n+        if (recentToken.getToken() != null) {\n+            // Normal ReadFeed can signal termination by CT null, not NotModified\n+            // Change Feed never lands here, as it always provides a CT\n+            // Consider current range done, if this FeedToken contains multiple ranges due\n+            // to splits,\n+            // all of them need to be considered done\n+            this.compositeContinuationTokens.add(recentToken);\n+        }\n+\n+        if (this.compositeContinuationTokens.size() > 0) {\n+            this.currentToken = this.compositeContinuationTokens.peek();\n+        } else {\n+            this.currentToken = null;\n+        }\n+    }\n+\n+    private Mono<Utils.ValueHolder<List<PartitionKeyRange>>> tryGetOverlappingRangesAsync(\n+        final RxPartitionKeyRangeCache partitionKeyRangeCache, final String min, final String max,\n+        final Boolean forceRefresh) {\n+\n+        return partitionKeyRangeCache.tryGetOverlappingRangesAsync(null, this.getContainerRid(),\n+            new Range<>(min, max, false, true), forceRefresh, null);\n+    }\n+\n+    private static CompositeContinuationToken tryParseAsCompositeContinuationToken(\n+        final String providedContinuation) {\n+\n+        try {\n+            final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n+\n+            if (providedContinuation.trim().startsWith(\"[\")) {\n+                final List<CompositeContinuationToken> compositeContinuationTokens = Arrays\n+                    .asList(mapper.readValue(providedContinuation,\n+                        CompositeContinuationToken[].class));\n+\n+                if (compositeContinuationTokens.size() > 0) {\n+                    return compositeContinuationTokens.get(0);\n+                }\n+\n+                return null;\n+            } else if (providedContinuation.trim().startsWith(\"{\")) {\n+                return mapper.readValue(providedContinuation, CompositeContinuationToken.class);\n+            }\n+\n+            return null;\n+        } catch (final IOException ioError) {\n+            return null;", "originalCommit": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4Mjg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525582843", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-11-17T23:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzNTIyMg=="}], "type": "inlineReview"}, {"oid": "9a4be2758a9872c554b3a73e74cecb6cdb2691c2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a4be2758a9872c554b3a73e74cecb6cdb2691c2", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-17T23:37:46Z", "type": "commit"}, {"oid": "8ac208ae1698576552b9455cf224391866055d91", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ac208ae1698576552b9455cf224391866055d91", "message": "Reacting to code review feedback", "committedDate": "2020-11-17T23:38:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0Mzg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17570#discussion_r525643862", "bodyText": "use slf4j logger placeholder instead of %s\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        LOGGER.debug(\"Failed to parse feed range JSON %s\", jsonString, ioError);\n          \n          \n            \n                        LOGGER.debug(\"Failed to parse feed range JSON {}\", jsonString, ioError);", "author": "moderakh", "createdAt": "2020-11-18T01:54:53Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -88,32 +83,36 @@ public String toJsonString() {\n         return this.toJson();\n     }\n \n-    public static FeedRangeInternal tryParse(final String jsonString) throws IOException {\n-        if (jsonString == null) {\n-            throw new NullPointerException(\"jsonString\");\n-        }\n-\n+    public static FeedRangeInternal tryParse(final String jsonString) {\n+        checkNotNull(jsonString, \"Argument 'jsonString' must not be null\");\n         final ObjectMapper mapper = Utils.getSimpleObjectMapper();\n-        JsonNode rootNode = mapper.readTree(jsonString);\n-\n-        JsonNode rangeNode = rootNode.get(Constants.Properties.RANGE);\n-        if (rangeNode != null && rangeNode.isObject()) {\n-            Range<String> range = new Range<>((ObjectNode)rangeNode);\n-            return new FeedRangeEpkImpl(range);\n-        }\n \n-        JsonNode pkNode = rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY);\n-        if (pkNode != null && pkNode.isArray()) {\n-            PartitionKeyInternal pk = mapper.convertValue(pkNode, PartitionKeyInternal.class);\n-            return new FeedRangePartitionKeyImpl(pk);\n-        }\n-\n-        JsonNode pkRangeIdNode =\n-            rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n-        if (pkRangeIdNode != null && pkRangeIdNode.isTextual()) {\n-            return new FeedRangePartitionKeyRangeImpl(pkRangeIdNode.asText());\n+        try {\n+            JsonNode rootNode = mapper.readTree(jsonString);\n+\n+            JsonNode rangeNode = rootNode.get(Constants.Properties.RANGE);\n+            if (rangeNode != null && rangeNode.isObject()) {\n+                Range<String> range = new Range<>((ObjectNode)rangeNode);\n+                return new FeedRangeEpkImpl(range);\n+            }\n+\n+            JsonNode pkNode = rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY);\n+            if (pkNode != null && pkNode.isArray()) {\n+                PartitionKeyInternal pk = mapper.convertValue(pkNode, PartitionKeyInternal.class);\n+                return new FeedRangePartitionKeyImpl(pk);\n+            }\n+\n+            JsonNode pkRangeIdNode =\n+                rootNode.get(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n+            if (pkRangeIdNode != null && pkRangeIdNode.isTextual()) {\n+                return new FeedRangePartitionKeyRangeImpl(pkRangeIdNode.asText());\n+            }\n+\n+            return null;\n+\n+        } catch (final IOException ioError) {\n+            LOGGER.debug(\"Failed to parse feed range JSON %s\", jsonString, ioError);", "originalCommit": "8ac208ae1698576552b9455cf224391866055d91", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee60826fd826592633307c2758075d424564f406", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee60826fd826592633307c2758075d424564f406", "message": "Update sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java\n\nCo-authored-by: Mohammad Derakhshani <moderakh@users.noreply.github.com>", "committedDate": "2020-11-18T14:06:37Z", "type": "commit"}]}