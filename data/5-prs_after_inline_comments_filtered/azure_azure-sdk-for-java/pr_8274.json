{"pr_number": 8274, "pr_title": "Add Missing Tests and Remove Exists APIs", "pr_createdAt": "2020-02-18T19:50:52Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8274", "timeline": [{"oid": "285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/285c40cd6daa7194ac9ec02f2dbf7eae8214d66d", "message": "Add missing tests", "committedDate": "2020-02-13T18:29:18Z", "type": "commit"}, {"oid": "8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bc12c60d97fa39f309ec7de49489a9e0bdf1bfd", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-13T23:01:42Z", "type": "commit"}, {"oid": "ac7af017686088ba00c6189f13271095583cff37", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ac7af017686088ba00c6189f13271095583cff37", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-14T00:12:57Z", "type": "commit"}, {"oid": "796248e8c1e8f2d871881f11774628e0f62b60ff", "url": "https://github.com/Azure/azure-sdk-for-java/commit/796248e8c1e8f2d871881f11774628e0f62b60ff", "message": "Merged in master", "committedDate": "2020-02-14T00:13:26Z", "type": "commit"}, {"oid": "b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b00bf5f7faed5bf72902df49cb80c7cb3023f4ca", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-14T17:41:00Z", "type": "commit"}, {"oid": "c154b788235d1e9b97042b4ceaceba78103634b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c154b788235d1e9b97042b4ceaceba78103634b4", "message": "General code style refactoring and test cleanup", "committedDate": "2020-02-14T23:54:06Z", "type": "commit"}, {"oid": "868711366e20679c32de29bce9c550758c3fb16e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/868711366e20679c32de29bce9c550758c3fb16e", "message": "Removing more JUnit 4 code and use Java Base64.encodeToString", "committedDate": "2020-02-18T19:48:45Z", "type": "commit"}, {"oid": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "message": "Removed Apache Commons code from tests", "committedDate": "2020-02-18T21:35:51Z", "type": "commit"}, {"oid": "f9e9708e4024e0bd38b96df5e5d4b21761463442", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9e9708e4024e0bd38b96df5e5d4b21761463442", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-19T17:36:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381486500", "bodyText": "If you're planning to delete the async tests and inline the base classes into the sync tests, why not do that first? It would make changes like this much easier to make (and to review \ud83d\ude09).", "author": "brjohnstmsft", "createdAt": "2020-02-19T19:12:58Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/SearchTestBase.java", "diffHunk": "@@ -32,6 +31,10 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4NjU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381586544", "bodyText": "I'll delete all the async tests and the base test classes in the next commit \ud83d\ude04", "author": "alzimmermsft", "createdAt": "2020-02-19T22:35:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNjIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382306218", "bodyText": "Removed most async and base class combinations, I'll hold off on removing the rest for another PR since the few that are left contain more technical details I don't want to handle in this PR.", "author": "alzimmermsft", "createdAt": "2020-02-20T22:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ4NjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381515764", "bodyText": "Does this encode to a URL-safe variant of Base64? Document keys can be used in URL paths, so certain characters used in vanilla Base64 are not allowed.", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:08:05Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);\n+\n+        StepVerifier.create(client.index(batch))\n+            .expectNextCount(1)\n+            .verifyComplete();\n+\n+        // Select only the fields set in the test case so we don't get superfluous data back.\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", new ArrayList<>(indexedDoc.keySet()), null))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void canGetDocumentWithBase64EncodedKey() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        String complexKey = Base64.getEncoder().encodeToString(new byte[]{1, 2, 3, 4, 5});", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU4ODc4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381588787", "bodyText": "Appears that I need to use Base64.getUrlEncoder, that will be URL safe \ud83d\ude04\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Base64.html#getUrlEncoder--", "author": "alzimmermsft", "createdAt": "2020-02-19T22:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MDI1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381590257", "bodyText": "If the URL encoded characters of + and / are expected on the service side this could be wrapped in a called to URLEncode instead.", "author": "alzimmermsft", "createdAt": "2020-02-19T22:44:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NTcxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381595713", "bodyText": "The service doesn't interpret or try to decode the document key (at least not in this API). It's just that the client needs to construct a valid URL that the service will understand.", "author": "brjohnstmsft", "createdAt": "2020-02-19T22:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNTc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381533229", "bodyText": "Changing the casing of these fields/accessors is moving this class further away from its intended purpose (not that it ever properly fulfilled its purpose in the Java tests).\nIn the Track 1 .NET SDK, LoudHotel is used to test scenarios where a customer has implemented their own custom attributes that they use to control how model property names serialize/deserialize to index field names. For LoudHotel specifically, the corresponding index definition has camelCase field names, while LoudHotel has ALLCAPS property names.\nIf I understand correctly, @JsonProperty is part of a JSON library for Java and not something a customer would implement themselves, so this class isn't really fulfilling its intended purpose anyway. Are customer-authored attributes a thing when it comes to Java serialization (@JonathanGiles )? If not, we need to rethink this class.\nIf we keep this class though, the accessor/field names should be ALLCAPS or it isn't really \"loud\" anymore, is it? \ud83d\ude01", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:44:09Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/test/environment/models/LoudHotel.java", "diffHunk": "@@ -12,166 +12,166 @@\n \n public class LoudHotel {\n     @JsonProperty(value = \"HotelId\")\n-    private String HOTELID;\n+    private String hotelId;", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MjU5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381592594", "bodyText": "In tests using LoudHotel the response JSON would be something like the following?\n{\n  \"HOTELID\": \"id\",\n}\nI was changing this to follow Java code style guidelines where camel casing is expected and we have linting rules that fail build if they aren't followed. I will revert these changes and add a suppression on this file.", "author": "alzimmermsft", "createdAt": "2020-02-19T22:49:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5NDIzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381594234", "bodyText": "No, the JSON is expected to have camelCase property names (at least, it is in .NET -- looks like the Java tests were setup for PascalCase instead).", "author": "brjohnstmsft", "createdAt": "2020-02-19T22:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzNTMyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382835328", "bodyText": "Reverting the changes made to this class and will add a linting suppression to this class", "author": "alzimmermsft", "createdAt": "2020-02-21T22:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzMzIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzODIzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381538236", "bodyText": "Thank you very much for doing this. \ud83d\udc4d Good docs are so important!", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:54:38Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381539190", "bodyText": "Missing the Javadoc tags used elsewhere in this file", "author": "brjohnstmsft", "createdAt": "2020-02-19T20:56:21Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,256 +140,196 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example, {@code\n+     * 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property currently\n+     * stored in the index, even if this was not your intent. For this reason, it is strongly recommended that you\n+     * always declare primitive-typed properties with their class equivalents (for example, an integer property should\n+     * be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index. See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Exception IndexBatchException is thrown when some of the indexing actions failed, but other actions succeeded and", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU5MDgxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381590811", "bodyText": "Was planning to fix those, my IntelliJ started acting up and those dropped off my mind. Will be adding in a commit soon", "author": "alzimmermsft", "createdAt": "2020-02-19T22:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305864", "bodyText": "Updated other JavaDocs", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381541244", "bodyText": "I'm assuming that Arrays.asList(null, null) is returning an ArrayList of Object, not String. This is fine (since this SDK has never shipped, there are no backcompat concerns), but the comment and name of the test no longer reflect reality.", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:00:18Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/DocumentConverterTests.java", "diffHunk": "@@ -242,15 +243,55 @@ public void canReadComplexCollection() {\n         Assert.assertEquals(expectedDoc, actualDoc);\n     }\n \n+    @Test\n+    public void canReadArraysOfMixedTypes() {\n+        // Azure Cognitive Search won't return payloads like this; This test is only for pinning purposes.\n+        String json = \"{\\\"field\\\": [\\\"hello\\\", 123, 3.14, { \\\"type\\\": \\\"Point\\\", \\\"coordinates\\\": [-122.131577, 47.678581] }, { \\\"name\\\": \\\"Arthur\\\", \\\"quest\\\": null }] }\";\n+\n+        GeoPoint point = GeoPoint.create(47.678581, -122.131577);\n+        Document innerDoc = new Document();\n+        innerDoc.put(\"name\", \"Arthur\");\n+        innerDoc.put(\"quest\", null);\n+        List<Object> value = Arrays.asList(\"hello\", 123, 3.14, point, innerDoc);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", value);\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n     @Test\n     public void dateTimeStringsAreReadAsDateTime() {\n         String json = \"{\\\"field1\\\":\\\"\".concat(testDateString).concat(\"\\\",\\\"field2\\\" : [\\\"\").concat(testDateString).concat(\"\\\", \\\"\").concat(testDateString).concat(\"\\\"]}\");\n-        Document expectedDoc = new Document() {\n-            {\n-                put(\"field1\", testDate);\n-                put(\"field2\", Arrays.asList(testDate, testDate));\n-            }\n-        };\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field1\", testDate);\n+        expectedDoc.put(\"field2\", Arrays.asList(testDate, testDate));\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void emptyArraysReadAsObjectArrays() {\n+        String json = \"{ \\\"field\\\": [] }\";\n+\n+        // With no elements, we can't tell what type of collection it is, so we default to object.\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"field\", new ArrayList<>());\n+\n+        Document actualDoc = deserialize(json);\n+        Assert.assertEquals(expectedDoc, actualDoc);\n+    }\n+\n+    @Test\n+    public void arraysWithOnlyNullsReadAsStringArrays() {\n+        String json = \"{ \\\"field\\\": [null, null] }\";\n+\n+        // With only null elements, we can't tell what type of collection it is. For backward compatibility, we assume type string.", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjgzNjE1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382836151", "bodyText": "I'll update this to make sure it uses List<String>.", "author": "alzimmermsft", "createdAt": "2020-02-21T22:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MTI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381543476", "bodyText": "Looks like the bug from the Track 1 tests got ported over. This should be uploading indexedDoc, not expectedDoc.", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:04:48Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupAsyncTests.java", "diffHunk": "@@ -281,9 +267,90 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Mono<Document> result = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        StepVerifier.create(result)\n-            .assertNext(actualDoc -> Assert.assertEquals(expectedDoc, actualDoc))\n+        StepVerifier.create(client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions()))\n+            .assertNext(response -> assertEquals(expectedDoc, response.getValue()))\n+            .verifyComplete();\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildAsyncClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        IndexBatch<Document> batch = new IndexBatch<>();\n+        batch.addUploadAction(expectedDoc);", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTY5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305696", "bodyText": "Removed this class", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r381546214", "bodyText": "Should be uploading indexedDoc. I'm getting paranoid now that we've made this mistake in many places and copy-pasted. \ud83d\ude2c", "author": "brjohnstmsft", "createdAt": "2020-02-19T21:10:28Z", "path": "sdk/search/azure-search/src/test/java/com/azure/search/LookupSyncTests.java", "diffHunk": "@@ -266,8 +273,67 @@ public void emptyDynamicObjectsInCollectionExpandedOnGetWhenCollectionFieldSelec\n         uploadDocument(client, originalDoc);\n         List<String> selectedFields = Arrays.asList(\"HotelId\", \"Rooms\");\n \n-        Document actualDoc = client.getDocument(\"1\", selectedFields, generateRequestOptions());\n-        Assert.assertEquals(expectedDoc, actualDoc);\n+        Response<Document> response = client.getDocumentWithResponse(\"1\", selectedFields, generateRequestOptions(), Context.NONE);\n+        assertEquals(expectedDoc, response.getValue());\n+    }\n+\n+    @Override\n+    public void getDynamicDocumentCannotAlwaysDetermineCorrectType() {\n+        createHotelIndex();\n+        client = getSearchIndexClientBuilder(INDEX_NAME).buildClient();\n+\n+        List<Document> rooms = new ArrayList<>();\n+        rooms.add(new Document(Collections.singletonMap(\"baseRate\", NaN)));\n+\n+        Document indexedDoc = new Document();\n+        indexedDoc.put(\"HotelId\", \"1\");\n+        indexedDoc.put(\"HotelName\", \"2015-02-11T12:58:00Z\");\n+        indexedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403)); // Test that we don't confuse Geo-JSON & complex types.\n+        indexedDoc.put(\"Rooms\", rooms);\n+\n+        Document expectedDoc = new Document();\n+        expectedDoc.put(\"HotelId\", \"1\");\n+        expectedDoc.put(\"HotelName\", OffsetDateTime.of(2015, 2, 11, 12, 58, 0, 9, ZoneOffset.UTC));\n+        expectedDoc.put(\"Location\", GeoPoint.create(40.760586, -73.975403));\n+        expectedDoc.put(\"Rooms\", Collections.singleton(new Document(Collections.singletonMap(\"BaseRate\", \"NaN\"))));\n+\n+        client.index(new IndexBatch<>().addUploadAction(expectedDoc));", "originalCommit": "7fef6dc62da4fbea1b179f53cd378dcabb8c8014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwNTc4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382305783", "bodyText": "Using indexDoc now", "author": "alzimmermsft", "createdAt": "2020-02-20T22:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIxNA=="}], "type": "inlineReview"}, {"oid": "72d24da813dae886b61905cd2ad893e6e16472df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/72d24da813dae886b61905cd2ad893e6e16472df", "message": "Update Azure Core version to fix dependency conflicts", "committedDate": "2020-02-19T22:15:58Z", "type": "commit"}, {"oid": "1eecc5809988b825e5869b10b76736bc94c9d5ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1eecc5809988b825e5869b10b76736bc94c9d5ab", "message": "Merge branch 'master' into AzSearch_AddMissingTests", "committedDate": "2020-02-20T17:23:42Z", "type": "commit"}, {"oid": "51541a2f9d18712bffba2d5d452d469d09c1b1c4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51541a2f9d18712bffba2d5d452d469d09c1b1c4", "message": "Finished cleaning up client documentation and removed async test classes", "committedDate": "2020-02-20T21:56:47Z", "type": "commit"}, {"oid": "435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/435b6dc26c3b43f7b792a0e1acaf3b127a57866c", "message": "Fixed Java 8 issues and update to use recording framework tools", "committedDate": "2020-02-20T22:39:27Z", "type": "commit"}, {"oid": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "url": "https://github.com/Azure/azure-sdk-for-java/commit/04e612bfb79a7f2fe687e7eda3c3457707f8d066", "message": "Fix another Java 8 issue", "committedDate": "2020-02-20T23:06:16Z", "type": "commit"}, {"oid": "fe4d5636d5129cd2363e630fa9000b6ee460bd28", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe4d5636d5129cd2363e630fa9000b6ee460bd28", "message": "Fixing unit tests", "committedDate": "2020-02-21T22:17:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTY4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382855689", "bodyText": "Why do we remove the getCoordinates?", "author": "sima-zhu", "createdAt": "2020-02-21T23:41:48Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/models/GeoPoint.java", "diffHunk": "@@ -116,27 +116,19 @@ public String toString() {\n         return \"\";\n     }\n \n-    /**", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTA4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861083", "bodyText": "It was an ask to remove them, #8149", "author": "alzimmermsft", "createdAt": "2020-02-22T00:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzU2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857562", "bodyText": "Not necessary to have the message.\nConsistent with other class\nthis.apiKey = Objects.requireNonNull(apiKey);", "author": "sima-zhu", "createdAt": "2020-02-21T23:50:43Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchApiKeyPipelinePolicy.java", "diffHunk": "@@ -25,14 +26,13 @@\n      * @throws IllegalArgumentException when the api key is an empty string\n      */\n     public SearchApiKeyPipelinePolicy(SearchApiKeyCredential apiKey) {\n-        Objects.requireNonNull(apiKey);\n+        Objects.requireNonNull(apiKey, \"'apiKey' cannot be null.\");", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861218", "bodyText": "It's been a general guideline to include a message on Objects.requireNonNull calls.", "author": "alzimmermsft", "createdAt": "2020-02-22T00:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382857936", "bodyText": "I changed the API and document in my PR", "author": "sima-zhu", "createdAt": "2020-02-21T23:52:18Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchIndexAsyncClient.java", "diffHunk": "@@ -140,265 +140,207 @@ HttpPipeline getHttpPipeline() {\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return document index result.\n+     * @return The result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> uploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.uploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return uploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Uploads a collection of documents to the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * Uploads a collection of documents to the target index.\n      *\n      * @param documents collection of documents to upload to the target Index.\n-     * @return response containing the document index result.\n+     * @return A response containing the result of the document indexing actions.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents) {\n+        return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+    }\n+\n+    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            return withContext(context -> uploadDocumentsWithResponse(documents, context));\n+            return indexWithResponse(buildIndexBatch(documents, IndexActionType.UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n-    Mono<Response<IndexDocumentsResult>> uploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n-        IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.UPLOAD);\n-        return this.indexWithResponse(batch, context);\n-    }\n-\n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n      * Merges a collection of documents with existing documents in the target index.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n      * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> mergeOrUploadDocuments(Iterable<?> documents) {\n-        try {\n-            return this.mergeOrUploadDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return mergeOrUploadDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * This action behaves like merge if a document with the given key already exists in the index.\n-     * If the document does not exist, it behaves like upload with a new document.\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n-     *\n-     * If the type of the document contains non-nullable primitive-typed properties, these properties may not\n-     * merge correctly. If you do not set such a property, it will automatically take its default value\n-     * (for example, 0 for int or false for boolean), which will override the value of the property currently stored\n-     * in the index, even if this was not your intent. For this reason, it is strongly recommended that you always\n-     * declare primitive-typed properties with their class equivalents (for example, an integer property should be\n-     * of type Integer instead of int).\n-     *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n+     * This action behaves like merge if a document with the given key already exists in the index. If the document does\n+     * not exist, it behaves like upload with a new document.\n+     * <p>\n+     * If the type of the document contains non-nullable primitive-typed properties, these properties may not merge\n+     * correctly. If you do not set such a property, it will automatically take its default value (for example,\n+     * {@code 0} for {@code int} or {@code false} for {@code boolean}), which will override the value of the property\n+     * currently stored in the index, even if this was not your intent. For this reason, it is strongly recommended\n+     * that you always declare primitive-typed properties with their class equivalents (for example, an integer\n+     * property should be of type {@code Integer} instead of {@code int}).\n      *\n      * @param documents collection of documents to be merged, if exists, otherwise uploaded\n-     * @return response containing the document index result.\n+     * @return document index result\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> mergeOrUploadDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> mergeOrUploadDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.MERGE_OR_UPLOAD), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<IndexDocumentsResult> deleteDocuments(Iterable<?> documents) {\n-        try {\n-            return this.deleteDocumentsWithResponse(documents)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteDocumentsWithResponse(documents).map(Response::getValue);\n     }\n \n     /**\n-     * Deletes a collection of documents from the target index\n-     * See https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\n+     * Deletes a collection of documents from the target index.\n      *\n-     * Exception IndexBatchException is thrown when some of the indexing actions failed,\n-     * but other actions succeeded and modified the state of the index.\n-     * This can happen when the Search Service is under heavy indexing load.\n-     * It is important to explicitly catch this exception and check the return value of\n-     * its getIndexingResult method. The indexing result reports the status of each indexing\n-     * action in the batch, making it possible to determine the state of the index after a\n-     * partial failure.\n-     *\n-     * @param documents collection of documents to delete from the target Index.\n-     *                  Fields other than the key are ignored.\n+     * @param documents collection of documents to delete from the target Index. Fields other than the key are ignored.\n      * @return response containing the document index result.\n+     * @throws IndexBatchException If some of the indexing actions fail but other actions succeed and modify the state\n+     * of the index. This can happen when the Search Service is under heavy indexing load. It is important to explicitly\n+     * catch this exception and check the return value {@link IndexBatchException#getIndexingResults()}. The indexing\n+     * result reports the status of each indexing action in the batch, making it possible to determine the state of the\n+     * index after a partial failure.\n+     * @see <a href=\"https://docs.microsoft.com/rest/api/searchservice/addupdate-or-delete-documents\">Add, update, or\n+     * delete documents</a>\n      */\n     public Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents) {\n-        try {\n-            return withContext(context -> deleteDocumentsWithResponse(documents, context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return withContext(context -> deleteDocumentsWithResponse(documents, context));\n     }\n \n-    @SuppressWarnings(\"unchecked\")\n     Mono<Response<IndexDocumentsResult>> deleteDocumentsWithResponse(Iterable<?> documents, Context context) {\n         try {\n-            IndexBatch<?> batch = buildIndexBatch(documents, IndexActionType.DELETE);\n-            return this.indexWithResponse(batch, context);\n+            return this.indexWithResponse(buildIndexBatch(documents, IndexActionType.DELETE), context);\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n     /**\n-     * Gets Client Api Version.\n+     * Gets the version of the Search service the client is using.\n      *\n-     * @return the apiVersion value.\n+     * @return The version of the Search service the client is using.\n      */\n     public SearchServiceVersion getApiVersion() {", "originalCommit": "04e612bfb79a7f2fe687e7eda3c3457707f8d066", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg2MTI3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r382861271", "bodyText": "Mind linking the change?", "author": "alzimmermsft", "createdAt": "2020-02-22T00:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg1NzkzNg=="}], "type": "inlineReview"}, {"oid": "38b0626ed58b923f68a206b5857b2318e4a41db0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/38b0626ed58b923f68a206b5857b2318e4a41db0", "message": "Fixing unit tests, making AccessConditionTests a static helper class", "committedDate": "2020-02-22T02:12:13Z", "type": "commit"}, {"oid": "feb0a14240bb75240155f21eda1731ccb72d4eec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/feb0a14240bb75240155f21eda1731ccb72d4eec", "message": "Update session playback records", "committedDate": "2020-02-24T20:47:58Z", "type": "commit"}, {"oid": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "message": "Merged in master", "committedDate": "2020-02-24T20:59:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r383542630", "bodyText": "Why do we remove this API?", "author": "sima-zhu", "createdAt": "2020-02-24T22:05:13Z", "path": "sdk/search/azure-search/src/main/java/com/azure/search/SearchServiceAsyncClient.java", "diffHunk": "@@ -1300,265 +1009,187 @@ public String getEndpoint() {\n      * @return the skillset that was created or updated.\n      */\n     public Mono<Skillset> createOrUpdateSkillset(Skillset skillset) {\n-        try {\n-            return this.createOrUpdateSkillsetWithResponse(skillset, null, null)\n-                .map(Response::getValue);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return createOrUpdateSkillsetWithResponse(skillset, null, null).map(Response::getValue);\n     }\n \n     /**\n      * Creates a new Azure Cognitive Search skillset or updates a skillset if it already exists.\n      *\n      * @param skillset the definition of the skillset to create or update\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response containing the skillset that was created or updated.\n      */\n     public Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                       AccessCondition accessCondition,\n-                                                                       RequestOptions requestOptions) {\n+        AccessCondition accessCondition, RequestOptions requestOptions) {\n+        return withContext(context ->\n+            createOrUpdateSkillsetWithResponse(skillset, accessCondition, requestOptions, context));\n+    }\n+\n+    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset, AccessCondition accessCondition,\n+        RequestOptions requestOptions, Context context) {\n         try {\n-            return withContext(context -> this.createOrUpdateSkillsetWithResponse(skillset,\n-                accessCondition,\n-                requestOptions,\n-                context));\n+            return restClient.skillsets()\n+                .createOrUpdateWithRestResponseAsync(skillset.getName(), skillset, requestOptions, accessCondition,\n+                    context)\n+                .map(Function.identity());\n         } catch (RuntimeException ex) {\n             return monoError(logger, ex);\n         }\n     }\n \n-    Mono<Response<Skillset>> createOrUpdateSkillsetWithResponse(Skillset skillset,\n-                                                                AccessCondition accessCondition,\n-                                                                RequestOptions requestOptions,\n-                                                                Context context) {\n-        return restClient\n-            .skillsets()\n-            .createOrUpdateWithRestResponseAsync(skillset.getName(),\n-                skillset, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @return a response signalling completion.\n      */\n     public Mono<Void> deleteSkillset(String skillsetName) {\n-        try {\n-            return this.deleteSkillsetWithResponse(skillsetName, null, null)\n-                .flatMap(FluxUtil::toMono);\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n+        return deleteSkillsetWithResponse(skillsetName, null, null).flatMap(FluxUtil::toMono);\n     }\n \n     /**\n      * Deletes a cognitive skillset in an Azure Cognitive Search service.\n      *\n      * @param skillsetName the name of the skillset to delete\n      * @param accessCondition the condition where the operation will be performed if the ETag on the server matches or\n-     *                        doesn't match specified values\n-     * @param requestOptions additional parameters for the operation.\n-     *                       Contains the tracking ID sent with the request to help with debugging\n+     * doesn't match specified values\n+     * @param requestOptions additional parameters for the operation. Contains the tracking ID sent with the request to\n+     * help with debugging\n      * @return a response signalling completion.\n      */\n-    public Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                           AccessCondition accessCondition,\n-                                                           RequestOptions requestOptions) {\n-        try {\n-            return withContext(context -> this.deleteSkillsetWithResponse(skillsetName, accessCondition, requestOptions,\n-                context));\n-        } catch (RuntimeException ex) {\n-            return monoError(logger, ex);\n-        }\n-    }\n-\n-    Mono<Response<Void>> deleteSkillsetWithResponse(String skillsetName,\n-                                                    AccessCondition accessCondition,\n-                                                    RequestOptions requestOptions,\n-                                                    Context context) {\n-        return restClient\n-            .skillsets()\n-            .deleteWithRestResponseAsync(skillsetName, requestOptions, accessCondition, context)\n-            .map(Function.identity());\n-    }\n-\n-    /**\n-     * Determines whether or not the given skillset exists.\n-     *\n-     * @param skillsetName the name of the skillset\n-     * @return true if the skillset exists; false otherwise.\n-     */\n-    public Mono<Boolean> skillsetExists(String skillsetName) {", "originalCommit": "b02d5a923ec3c5b04ff9356e1fbbcb3206f375ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU1Mjk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8274#discussion_r383552975", "bodyText": "Per request from Bruce, it will be easier to add this back in the future than removing it from our APIs.", "author": "alzimmermsft", "createdAt": "2020-02-24T22:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0MjYzMA=="}], "type": "inlineReview"}]}