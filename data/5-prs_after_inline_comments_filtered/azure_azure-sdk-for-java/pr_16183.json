{"pr_number": 16183, "pr_title": "Enable Autolock renewal  - Service bus Sync/Async client", "pr_createdAt": "2020-10-12T05:35:08Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16183", "timeline": [{"oid": "2917436e1ccc13c7e1d2b80bd7dc0213d78c2a6f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2917436e1ccc13c7e1d2b80bd7dc0213d78c2a6f", "message": "Draft implementation of Auto lock renewal.", "committedDate": "2020-10-12T05:29:03Z", "type": "commit"}, {"oid": "0686cc558e1a5f806af744722ee477c744625819", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0686cc558e1a5f806af744722ee477c744625819", "message": "Draft implementation of Auto lock renewal.", "committedDate": "2020-10-12T05:32:41Z", "type": "commit"}, {"oid": "ae323dc7022a7aa7178b56cbbc95da00e4aafb9d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae323dc7022a7aa7178b56cbbc95da00e4aafb9d", "message": "Fixing test case and changing processor", "committedDate": "2020-10-13T07:55:03Z", "type": "commit"}, {"oid": "e2e22dbbc170f60540ee284d66e1ad67f9424c85", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e22dbbc170f60540ee284d66e1ad67f9424c85", "message": "unit test fixing", "committedDate": "2020-10-13T08:07:43Z", "type": "commit"}, {"oid": "502c4df17b3d1f94fa847c1fed5f2652314d3235", "url": "https://github.com/Azure/azure-sdk-for-java/commit/502c4df17b3d1f94fa847c1fed5f2652314d3235", "message": "Remove unwanted args from contructor", "committedDate": "2020-10-13T08:15:15Z", "type": "commit"}, {"oid": "d7bfd5a1776d419adf3ae2fdd8583af4055a09c2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7bfd5a1776d419adf3ae2fdd8583af4055a09c2", "message": "Spot bugs fixes", "committedDate": "2020-10-13T16:10:07Z", "type": "commit"}, {"oid": "9f67be389108eb449dc8930f249cd876ddfce963", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f67be389108eb449dc8930f249cd876ddfce963", "message": "Adding custom operstor.", "committedDate": "2020-10-13T23:05:29Z", "type": "commit"}, {"oid": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6af26108806ccdbb45ef9876d3ad98988fd17ca8", "message": "Adding custom operstor.", "committedDate": "2020-10-13T23:27:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4NzE4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504387186", "bodyText": "Is this operator required even if the autoLockRenewal is set to false? Also, this member variable should now be renamed to renewOperator.", "author": "srnagar", "createdAt": "2020-10-14T04:00:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -29,14 +33,19 @@\n     private final Flux<ServiceBusReceivedMessage> processor;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        this.processor = new ServiceBusRenewOperator(linkProcessor", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODMyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388320", "bodyText": "Setter methods on builder should not have set prefix.", "author": "srnagar", "createdAt": "2020-10-14T04:05:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODQxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388411", "bodyText": "Same here. Remove set prefix.", "author": "srnagar", "createdAt": "2020-10-14T04:05:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +851,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder setMaxAutoRenewDuration(Duration maxAutoRenewDuration) {", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504388781", "bodyText": "Not sure why we are passing connectionProcessor and connectionProcessor.getRetryOptions().getTryTimeout(). If the session manager has the connection processor, it should be able to get the retry options from it anyway. Also, it's weird to see retry options in connection processor.", "author": "srnagar", "createdAt": "2020-10-14T04:07:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -763,19 +781,22 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final ReceiverOptions receiverOptions = new ReceiverOptions(receiveMode, prefetchCount,\n                 sessionId, isRollingSessionReceiver(), maxConcurrentSessions);\n \n+            final UnnamedSessionManager sessionManager;\n+\n             if (CoreUtils.isNullOrEmpty(sessionId)) {\n-                final UnnamedSessionManager sessionManager = new UnnamedSessionManager(entityPath, entityType,\n+                sessionManager = new UnnamedSessionManager(entityPath, entityType,\n                     connectionProcessor, connectionProcessor.getRetryOptions().getTryTimeout(), tracerProvider,", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0ODY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508248679", "bodyText": "I removed connectionProcessor.getRetryOptions().getTryTimeout() .\nretry options in connection processor This is being passed on to AMQP Channel Processor in  core-amqp library for retry policy.", "author": "hemanttanwar", "createdAt": "2020-10-20T06:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4ODc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTE4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n          \n          \n            \n                     * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.", "author": "srnagar", "createdAt": "2020-10-14T04:09:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4OTUwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504389504", "bodyText": "I don't see this class being used anywhere outside this file. Do we need this?", "author": "srnagar", "createdAt": "2020-10-14T04:10:34Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageProcessor.java", "diffHunk": "@@ -0,0 +1,350 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.Exceptions;\n+import reactor.core.publisher.FluxProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Deque;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Processor that listens to upstream messages, pushes them downstream then completes it if necessary.\n+ */\n+class ServiceBusMessageProcessor extends FluxProcessor<ServiceBusReceivedMessage, ServiceBusReceivedMessage>", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MjQ4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504392486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n          \n          \n            \n                public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {", "author": "srnagar", "createdAt": "2020-10-14T04:21:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5MzM4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393387", "bodyText": "What is the purpose of hasError? Also, we are swallowing the exception here. If actual.onNext() throws an exception, should we stop the source flux?", "author": "srnagar", "createdAt": "2020-10-14T04:25:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusRenewOperator.java", "diffHunk": "@@ -0,0 +1,114 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+/**\n+ * Operate on messages from to upstream, pushes them downstream  and start lock renewal.\n+ */\n+final class ServiceBusRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage>  {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link org.reactivestreams.Publisher}\n+     * @param source the {@link org.reactivestreams.Publisher} to decorate\n+     */\n+    ServiceBusRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super com.azure.messaging.servicebus.ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription s) {\n+                actual.onSubscribe(s);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+\n+                final long sequenceNumber = message.getSequenceNumber();\n+                final String lockToken = message.getLockToken();\n+                LockRenewalOperation renewLockOperation = null;\n+\n+                if (isAutoRenewLock) {\n+                    if (CoreUtils.isNullOrEmpty(lockToken)) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token on message. Sequence number: \" + sequenceNumber));\n+                    } else if (message.getLockedUntil() ==  null) {\n+                        throw logger.logExceptionAsError(new IllegalStateException(\n+                            \"Cannot auto-renew message without a lock token until on message. Sequence number: \" + sequenceNumber));\n+                    }\n+\n+                    renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal, false,\n+                        onRenewLock, message.getLockedUntil());\n+                    messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                        renewLockOperation);\n+                }\n+\n+                final AtomicBoolean hasError = new AtomicBoolean();\n+                try {\n+                    actual.onNext(message);\n+                } catch (Exception e) {\n+                    hasError.set(true);", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r504393796", "bodyText": "This should be available transitively through com.azure.core.amqp already.", "author": "srnagar", "createdAt": "2020-10-14T04:27:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -3,6 +3,7 @@\n \n module com.azure.messaging.servicebus {\n     requires transitive com.azure.core.amqp;\n+    requires transitive org.reactivestreams;", "originalCommit": "6af26108806ccdbb45ef9876d3ad98988fd17ca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjQ0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508246449", "bodyText": "It is not available , thus I had to add it.", "author": "hemanttanwar", "createdAt": "2020-10-20T06:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NTgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508265806", "bodyText": "com.azure.core module requires this transitively. So, anything depending on core should have it.", "author": "srnagar", "createdAt": "2020-10-20T07:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM5Mzc5Ng=="}], "type": "inlineReview"}, {"oid": "6892dd806377c2518833f851915fe77d7d816305", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6892dd806377c2518833f851915fe77d7d816305", "message": "Added unit test.", "committedDate": "2020-10-14T19:30:21Z", "type": "commit"}, {"oid": "ae0c6eab878397eefa44faa94afaa15ea6388eb9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae0c6eab878397eefa44faa94afaa15ea6388eb9", "message": "cleanup of constructor", "committedDate": "2020-10-14T19:42:24Z", "type": "commit"}, {"oid": "a5444892387a0184eba361884203bb75b0aa2977", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a5444892387a0184eba361884203bb75b0aa2977", "message": "Rename unnamessession manager", "committedDate": "2020-10-14T23:44:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMjg1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505612855", "bodyText": "I notice this file keeps changing, but there are no functional changes here. You can revert them.", "author": "conniey", "createdAt": "2020-10-15T14:58:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -5,6 +5,7 @@\n import com.azure.core.util.logging.ClientLogger;", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMzkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505613911", "bodyText": "This comment isn't needed.", "author": "conniey", "createdAt": "2020-10-15T14:59:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNTA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505615074", "bodyText": "I think we should move the validation of this argument to here, so we don't need to bloat buildAsyncClient. Same with prefetch as well.", "author": "conniey", "createdAt": "2020-10-15T15:01:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,26 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        // .Net have default of  5 minutes\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {\n+            this.maxAutoRenewDuration = maxAutoRenewDuration;", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA4MDgwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506080805", "bodyText": "I did moved it once but later I saw a test which validating illegal value for prefetch thro error at time of buildClient().\nAlso from java convention point of view, I think We throw error when we people call .build() .\nThe flow as I see as user\n\nI configure values  in builder\nI build (This is the place, more appropriate to throw illegal value exception)", "author": "hemanttanwar", "createdAt": "2020-10-16T06:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNTA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxNzY1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505617652", "bodyText": "What about validation of these other parameters?", "author": "conniey", "createdAt": "2020-10-15T15:04:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618185", "bodyText": "Can you split this into another class instead of an anonymous one. This is hard to understand.", "author": "conniey", "createdAt": "2020-10-15T15:04:41Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTA1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625057", "bodyText": "Does this anonymous class need to inherit from CoreSubscriber? BaseSubscriber does most of this for you already.", "author": "conniey", "createdAt": "2020-10-15T15:12:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxODUxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505618511", "bodyText": "Why do you need a lock?", "author": "conniey", "createdAt": "2020-10-15T15:05:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505619765", "bodyText": "Can we have a static \"Is complete\" lock renewal so we can make this variable final.", "author": "conniey", "createdAt": "2020-10-15T15:06:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTM4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621382", "bodyText": "final LockRenewalOperation operation;\nif (renewLock) {\n    operation = ...\n} else {\n    operation = COMPLETED_ONE;\n}", "author": "conniey", "createdAt": "2020-10-15T15:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxOTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMDYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505620619", "bodyText": "nit: change formatting of these if conditionals statements. I notice times you use Objects.isNull rather than comparing. Is there a reason for this?", "author": "conniey", "createdAt": "2020-10-15T15:07:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNDEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505934131", "bodyText": "no specific reason,  I have now changed it to use Objects.isNull  , consistent with other places.", "author": "hemanttanwar", "createdAt": "2020-10-16T00:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMDYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyMTczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505621732", "bodyText": "This can be dumped in the \"ReceiverOptions\"... so we wouldn't have to keep changing the ctor signature.", "author": "conniey", "createdAt": "2020-10-15T15:08:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -121,10 +123,12 @@\n      * @param tracerProvider Tracer for telemetry.\n      * @param messageSerializer Serializes and deserializes Service Bus messages.\n      * @param onClientClose Operation to run when the client completes.\n+     * @param maxAutoRenewLockDuration for which lock should be renewed.\n      */\n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n-        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose) {\n+        TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n+        Duration maxAutoRenewLockDuration) {", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDEzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624130", "bodyText": "Log the error, e?", "author": "conniey", "createdAt": "2020-10-15T15:11:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNDU3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505624574", "bodyText": "If you use the final suggestion above, this null check is not needed.", "author": "conniey", "createdAt": "2020-10-15T15:12:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final Object lock = new Object();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.isAutoRenewLock = autoLockRenewal;\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        source.subscribe(new CoreSubscriber<ServiceBusReceivedMessage>() {\n+\n+           @Override\n+            public void onSubscribe(Subscription subscription) {\n+               Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+               actual.onSubscribe(subscription);\n+            }\n+\n+            @Override\n+            public void onNext(ServiceBusReceivedMessage message) {\n+               synchronized (lock) {\n+                   final String lockToken = message.getLockToken();\n+                   LockRenewalOperation renewLockOperation = null;\n+\n+                   if (isAutoRenewLock\n+                       && message.getLockedUntil() != null\n+                       && message.getLockToken() != null) {\n+                       renewLockOperation = new LockRenewalOperation(message.getLockToken(), maxAutoLockRenewal,\n+                           false, onRenewLock, message.getLockedUntil());\n+\n+                       messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                           renewLockOperation);\n+                   }\n+\n+                   try {\n+                       actual.onNext(message);\n+                   } catch (Exception e) {\n+                       logger.error(\"Exception occurred while handling downstream onNext operation.\");\n+                       onError(e);\n+                   } finally {\n+                       if (renewLockOperation != null) {", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTk2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505625966", "bodyText": "Why the rename?", "author": "conniey", "createdAt": "2020-10-15T15:14:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,58 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {", "originalCommit": "a5444892387a0184eba361884203bb75b0aa2977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMzczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r505713732", "bodyText": "Because now we are using this class for named session also.", "author": "hemanttanwar", "createdAt": "2020-10-15T17:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyNTk2Ng=="}], "type": "inlineReview"}, {"oid": "9bedc59a3a1a70e0b5c424b75ba7e28859d2769e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9bedc59a3a1a70e0b5c424b75ba7e28859d2769e", "message": "Merge branch 'master' into sb-enable-autolock-renewal-16071", "committedDate": "2020-10-15T16:43:48Z", "type": "commit"}, {"oid": "03b2e9747f902e463e0c3e181820aa75da720aab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/03b2e9747f902e463e0c3e181820aa75da720aab", "message": "Incorporated review comments", "committedDate": "2020-10-15T20:22:21Z", "type": "commit"}, {"oid": "761c4f0d19a62fad5d5041f93808f2774a42dc57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/761c4f0d19a62fad5d5041f93808f2774a42dc57", "message": "Review comments", "committedDate": "2020-10-15T20:47:16Z", "type": "commit"}, {"oid": "6314871ae514b3ae9d10ff02193c66895415e788", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6314871ae514b3ae9d10ff02193c66895415e788", "message": "Review comments", "committedDate": "2020-10-16T00:16:57Z", "type": "commit"}, {"oid": "e8849d768abf0a3ee356094a4f8730199bc07ebc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e8849d768abf0a3ee356094a4f8730199bc07ebc", "message": "Review comments", "committedDate": "2020-10-16T00:24:12Z", "type": "commit"}, {"oid": "e3ba139a570ba13ea7f38f769ef2b880f4c32636", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e3ba139a570ba13ea7f38f769ef2b880f4c32636", "message": "Review comments", "committedDate": "2020-10-16T05:34:22Z", "type": "commit"}, {"oid": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "message": "Review comments", "committedDate": "2020-10-16T06:18:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE1OTQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506159448", "bodyText": "When will this happen?", "author": "srnagar", "createdAt": "2020-10-16T08:19:54Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3MjY0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506172641", "bodyText": "Why do we need to use this subscriber if the autoRenewLock is false?", "author": "srnagar", "createdAt": "2020-10-16T08:34:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mzk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506173941", "bodyText": "Log the exception as well.", "author": "srnagar", "createdAt": "2020-10-16T08:35:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181318", "bodyText": "This else block is not required.", "author": "srnagar", "createdAt": "2020-10-16T08:45:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MzAzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507563037", "bodyText": "This should not be called, but this is for debugging  only, I have added a log point to help in production log error.", "author": "hemanttanwar", "createdAt": "2020-10-19T08:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MTczMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506181733", "bodyText": "Remove this printStackTrace.", "author": "srnagar", "createdAt": "2020-10-16T08:46:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MjM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506182379", "bodyText": "Will this also call hookOnError()?", "author": "srnagar", "createdAt": "2020-10-16T08:46:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);\n+        } else {\n+\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MjQzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507562437", "bodyText": "yes", "author": "hemanttanwar", "createdAt": "2020-10-19T08:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4MjM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDA1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506184056", "bodyText": "Will this propagate the subscriber context?", "author": "srnagar", "createdAt": "2020-10-16T08:49:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NDMxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508244312", "bodyText": "yes I wrote test", "author": "hemanttanwar", "createdAt": "2020-10-20T06:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4NDA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506200711", "bodyText": "It's odd that creating an instance of LockRenewalOperation also starts renewing the locks immediately. Also, if the lock renewal fails, how is the user notified of it?", "author": "srnagar", "createdAt": "2020-10-16T09:08:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTU4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508245584", "bodyText": "There is logic logic inside to delay the lock renewal based on given OffsetDateTime tokenLockedUntil", "author": "hemanttanwar", "createdAt": "2020-10-20T06:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508246214", "bodyText": "The lock renewal is running in background and we do not call user in this case, we will log the error.", "author": "hemanttanwar", "createdAt": "2020-10-20T06:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwMDcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTA0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205044", "bodyText": "If the message has null lockedUntil and lockToken values, should that be considered an invalid message?", "author": "srnagar", "createdAt": "2020-10-16T09:12:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1MjA3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506652078", "bodyText": "We should never be in this situation, In RECEIVE_DELETE mode, we will always have these values. But I have put these checks as caution.\nMay be we can log it as warning", "author": "hemanttanwar", "createdAt": "2020-10-16T18:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNTcwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506205702", "bodyText": "When the lock is renewed, will message.getLockedUntil() return the renewed time? If yes, where is the update to lockedUntil property happening for this message?", "author": "srnagar", "createdAt": "2020-10-16T09:12:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNzA4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506207081", "bodyText": "What happens if this operation throws an exception? This can throw if the lockContainer is disposed.", "author": "srnagar", "createdAt": "2020-10-16T09:15:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =\n+        AtomicReferenceFieldUpdater.newUpdater(LockRenewSubscriber.class, Subscription.class,\n+            \"subscription\");\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        if (Operators.setOnce(UPSTREAM, this, subscription)) {\n+            this.subscription = subscription;\n+            actual.onSubscribe(subscription);\n+        } else {\n+            logger.error(\"Already subscribed once.\");\n+        }\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\");\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnCancel() {\n+        logger.error(\"Upstream cancelled.\");\n+        subscription.cancel();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (isAutoRenewLock && !Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil);\n+            messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal), renewOperation);", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU2MzczMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507563731", "bodyText": "the error is thrown in this case.", "author": "hemanttanwar", "createdAt": "2020-10-19T08:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwNzA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIwODQ3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506208478", "bodyText": "Typo in method name max. Also, include Lock after Auto in the name and update the javadocs too.", "author": "srnagar", "createdAt": "2020-10-16T09:16:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -636,10 +638,25 @@ public ServiceBusSenderClient buildClient() {\n         private String sessionId;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusSessionReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the session lock. Setting {@link Duration#ZERO} or\n+         * {@code null} disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the session lock.\n+         * {@link Duration#ZERO} or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusSessionReceiverClientBuilder} object.\n+         */\n+        public ServiceBusSessionReceiverClientBuilder mxAutoRenewDuration(Duration maxAutoRenewDuration) {", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMTAxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506211012", "bodyText": "maxAutoLockRenewDuration.", "author": "srnagar", "createdAt": "2020-10-16T09:20:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +844,25 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO} or\n+         * {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoRenewDuration(Duration maxAutoRenewDuration) {", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxMzEyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506213127", "bodyText": "Since this operator is created only when autoLockRenewal is true, do we need the 2nd param?", "author": "srnagar", "createdAt": "2020-10-16T09:23:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n             .publish(prefetch)\n             .autoConnect(1);\n+\n+        if (autoLockRenewal) {\n+            this.messageSource = new ServiceBusMessageRenewOperator(source,", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjIxNDUxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506214519", "bodyText": "If only one subscription is allowed, this should return from here.", "author": "srnagar", "createdAt": "2020-10-16T09:25:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final boolean isAutoRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, boolean autoLockRenewal, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+            \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.isAutoRenewLock = autoLockRenewal;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, isAutoRenewLock,\n+            maxAutoLockRenewal, messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");", "originalCommit": "92bc5bffbf9e4d1821c28a8ae7cc1812698f8bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc90d6763d1bf8279e2a46403f1baa6499f53b62", "message": "Review comments", "committedDate": "2020-10-16T18:52:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY2NzY4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506667682", "bodyText": "Why are you keeping a reference to this? BaseSubscriber holds most of this logic. I don't see a call to the base class either.", "author": "conniey", "createdAt": "2020-10-16T19:00:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,119 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Operators;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    private volatile Subscription subscription;\n+    private static final AtomicReferenceFieldUpdater<LockRenewSubscriber, Subscription> UPSTREAM =", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MDYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506670619", "bodyText": "nit: unneeded new line.", "author": "conniey", "createdAt": "2020-10-16T19:06:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiver.java", "diffHunk": "@@ -182,6 +183,7 @@ void setSessionLockedUntil(OffsetDateTime lockedUntil) {\n     }\n \n     Mono<Void> updateDisposition(String lockToken, DeliveryState deliveryState) {\n+", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjY3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506672673", "bodyText": "When is this used?", "author": "conniey", "createdAt": "2020-10-16T19:11:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReceiveLinkProcessor.java", "diffHunk": "@@ -129,6 +135,15 @@ public String getLinkName() {\n             }));\n     }\n \n+    /**\n+     * Gets the error context associated with this link.\n+     *\n+     * @return the error context associated with this link.\n+     */\n+    public AmqpErrorContext getErrorContext() {", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjczNzY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506737683", "bodyText": "I was using earlier, but not now. So removing it.", "author": "hemanttanwar", "createdAt": "2020-10-16T21:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3MzIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506673213", "bodyText": "consistent use of final.", "author": "conniey", "createdAt": "2020-10-16T19:12:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});\n+\n+        ServiceBusMessageRenewOperator renewOperator = new ServiceBusMessageRenewOperator(messageSource,", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506674377", "bodyText": "Use TestPublisher because we should test multiple renewals.\nWe should also test that cancellation from downstream.", "author": "conniey", "createdAt": "2020-10-16T19:15:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperatorTest.java", "diffHunk": "@@ -0,0 +1,179 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link ServiceBusMessageRenewOperator}.\n+ */\n+public class ServiceBusMessageRenewOperatorTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(10);\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+    @Mock\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked.\n+     */\n+    @Test\n+    void lockRenewed() {\n+        // Arrange\n+        final int atLeast = 1;\n+        final int processingTimeSeconds = 3;\n+        final OffsetDateTime lockedUntil = OffsetDateTime.now().plusSeconds(3);\n+        final OffsetDateTime renewLockedUntil = lockedUntil.plusSeconds(3);\n+        final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+\n+        when(renewalFunction.apply(LOCK_TOKEN))\n+            .thenReturn(Mono.fromCallable(() -> renewLockedUntil));\n+\n+        final Flux<? extends ServiceBusReceivedMessage> messageSource = Flux.fromArray(new ServiceBusReceivedMessage[]{message});", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4NDczMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506684733", "bodyText": "I think we need more tests about the behaviour of this. has many more cases: https://github.com/reactor/reactor-core/blob/master/reactor-core/src/test/java/reactor/core/publisher/FluxMapTest.java", "author": "conniey", "createdAt": "2020-10-16T19:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU0Njc0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r507546748", "bodyText": "added more test", "author": "hemanttanwar", "createdAt": "2020-10-19T08:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTQ4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675481", "bodyText": "same comment about moving validation not to build method.", "author": "conniey", "createdAt": "2020-10-16T19:17:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -927,20 +956,23 @@ public ServiceBusReceiverClientBuilder topicName(String topicName) {\n          *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n          * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n+         * @throws IllegalArgumentException {#code maxAutoLockRenewDuration} is negative.\n          */\n         public ServiceBusReceiverAsyncClient buildAsyncClient() {\n             final MessagingEntityType entityType = validateEntityPaths(logger, connectionStringEntityName, topicName,\n                 queueName);\n             final String entityPath = getEntityPath(logger, entityType, queueName, topicName, subscriptionName,\n                 subQueue);\n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506675905", "bodyText": "Should move validation to the maxAutoLockRenewDuration setter.", "author": "conniey", "createdAt": "2020-10-16T19:18:29Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);\n+            validateAndThrow(maxAutoLockRenewDuration);", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506678567", "bodyText": "Can we keep this to ReceiveOptions? it seems like we're bloating this constructor", "author": "conniey", "createdAt": "2020-10-16T19:24:39Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,28 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, int prefetch, boolean autoLockRenewal,\n+        Duration maxAutoLockRenewDuration, LockContainer<LockRenewalOperation> messageLockContainer,", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTA3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679074", "bodyText": "I'm also adding another parameter from ReceiveOptions.", "author": "conniey", "createdAt": "2020-10-16T19:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc3MjY5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506772697", "bodyText": "Okay but I think we should not add messageLockContainer since that is not related to ReceiveOptions.", "author": "hemanttanwar", "createdAt": "2020-10-17T00:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3ODU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3OTQxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506679419", "bodyText": "Same with this one. I'm not sure if Yijun fixed this too.", "author": "conniey", "createdAt": "2020-10-16T19:26:41Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -758,24 +777,19 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n                 SubQueue.NONE);\n \n             validateAndThrow(prefetchCount);", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY4MDAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r506680005", "bodyText": "Can we dump this in receive options.", "author": "conniey", "createdAt": "2020-10-16T19:28:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -142,13 +147,13 @@\n             renewal.close();\n         });\n \n-        this.unnamedSessionManager = null;\n+        this.sessionManager = null;\n     }\n \n     ServiceBusReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath, MessagingEntityType entityType,\n         ReceiverOptions receiverOptions, ServiceBusConnectionProcessor connectionProcessor, Duration cleanupInterval,\n         TracerProvider tracerProvider, MessageSerializer messageSerializer, Runnable onClientClose,\n-        UnnamedSessionManager unnamedSessionManager) {\n+        Duration maxAutoRenewLockDuration, ServiceBusSessionManager sessionManager) {", "originalCommit": "fc90d6763d1bf8279e2a46403f1baa6499f53b62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f085df3d56abea3b6c60c3dd7fd89cf5c15e4b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7f085df3d56abea3b6c60c3dd7fd89cf5c15e4b7", "message": "Incorporated  Review comments.", "committedDate": "2020-10-17T19:20:45Z", "type": "commit"}, {"oid": "7b409dd3f5dbfafef1c5b109de1cf6766d13a5d1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7b409dd3f5dbfafef1c5b109de1cf6766d13a5d1", "message": " Added more nuit test", "committedDate": "2020-10-19T09:24:18Z", "type": "commit"}, {"oid": "9172a5a13a1cac6c850bad20360549b788e7aba2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9172a5a13a1cac6c850bad20360549b788e7aba2", "message": "Fix unit test.", "committedDate": "2020-10-19T16:23:37Z", "type": "commit"}, {"oid": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a", "message": "Fixed unit test", "committedDate": "2020-10-19T17:57:39Z", "type": "commit"}, {"oid": "68427390a6f0344b73766e9693c45e8fb2649be2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68427390a6f0344b73766e9693c45e8fb2649be2", "message": "add unit test cae", "committedDate": "2020-10-19T20:33:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODEwMjU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508102581", "bodyText": "receiverOptions also has an sessionId. Can we just use that one?", "author": "YijunXieMS", "createdAt": "2020-10-19T22:37:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -47,43 +47,47 @@\n /**\n  * Package-private class that manages session aware message receiving.\n  */\n-class UnnamedSessionManager implements AutoCloseable {\n+class ServiceBusSessionManager implements AutoCloseable {\n     // Time to delay before trying to accept another session.\n     private static final Duration SLEEP_DURATION_ON_ACCEPT_SESSION_EXCEPTION = Duration.ofMinutes(1);\n \n-    private final ClientLogger logger = new ClientLogger(UnnamedSessionManager.class);\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionManager.class);\n     private final String entityPath;\n     private final MessagingEntityType entityType;\n     private final ReceiverOptions receiverOptions;\n     private final ServiceBusConnectionProcessor connectionProcessor;\n     private final Duration operationTimeout;\n     private final TracerProvider tracerProvider;\n     private final MessageSerializer messageSerializer;\n+    private final String userProvidedSessionId;", "originalCommit": "a757a4f3c20bd8d3ba8d33423cd15bfeebcdd35a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58c909ac64783a747605edaafb4cdee7b7efb8e0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/58c909ac64783a747605edaafb4cdee7b7efb8e0", "message": "Add more unit test.", "committedDate": "2020-10-20T06:23:45Z", "type": "commit"}, {"oid": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "message": "Fix spot bugs error", "committedDate": "2020-10-20T06:37:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTMyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259321", "bodyText": "Wouldn't this call user's onError handler? I thought we were not going to notify the user of any error if auto lock renewal fails.", "author": "srnagar", "createdAt": "2020-10-20T07:10:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5Nzk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508797992", "bodyText": "Okay, for now I will not call onError, log it only.", "author": "hemanttanwar", "createdAt": "2020-10-20T19:53:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508259815", "bodyText": "When will the message have null lock token and lockedUntil?", "author": "srnagar", "createdAt": "2020-10-20T07:11:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2ODM0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508668340", "bodyText": "That's true. We should probably log it and return early.", "author": "conniey", "createdAt": "2020-10-20T16:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI1OTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2NzAzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508267038", "bodyText": "Maybe we should just mark this as info as we don't surface any errors to users. Logging an error could alarm the user.", "author": "srnagar", "createdAt": "2020-10-20T07:24:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI2ODE2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508268166", "bodyText": "When the renewOperation is closed, should we also remove this from messageLockContainer?", "author": "srnagar", "createdAt": "2020-10-20T07:26:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();\n+    private static final LockRenewalOperation COMPLETED_ONE = new LockRenewalOperation(\"lock-no-renew\",\n+        Duration.ZERO, false, (id) -> Mono.empty(), COMPLETED_RENEW_TIME);\n+\n+    private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+    LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer,\n+        Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.actual = actual;\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+    }\n+    /**\n+     * On an initial subscription, will take the first work item, and request that amount of work for it.\n+     * @param subscription Subscription for upstream.\n+     */\n+    @Override\n+    protected void hookOnSubscribe(Subscription subscription) {\n+        Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+        actual.onSubscribe(subscription);\n+    }\n+\n+    /**\n+     * When upstream has completed emitting messages.\n+     */\n+    @Override\n+    public void hookOnComplete() {\n+        logger.info(\"Upstream has completed.\");\n+        actual.onComplete();\n+    }\n+\n+    @Override\n+    protected void hookOnError(Throwable throwable) {\n+        logger.error(\"Errors occurred upstream.\", throwable);\n+        actual.onError(throwable);\n+        dispose();\n+    }\n+\n+    @Override\n+    protected void hookOnNext(ServiceBusReceivedMessage message) {\n+        final String lockToken = message.getLockToken();\n+        final OffsetDateTime lockedUntil = message.getLockedUntil();\n+        final LockRenewalOperation renewOperation;\n+\n+        if (!Objects.isNull(lockedUntil) && !Objects.isNull(lockToken)) {\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false, onRenewLock,\n+                lockedUntil, message::setLockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+                onError(e);\n+            }\n+        } else {\n+            logger.warning(\"Unexpected, LockToken [{}] or lockedUntil [{}] is not present for message [{}].\",\n+                lockToken, lockedUntil, message.getSequenceNumber());\n+            renewOperation = COMPLETED_ONE;\n+        }\n+\n+        try {\n+            actual.onNext(message);\n+        } catch (Exception e) {\n+            logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+            onError(e);\n+        } finally {\n+            renewOperation.close();", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4ODE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508288140", "bodyText": "Why do we restrict this to a single subscriber? Are multiple calls to receive() not allowed?", "author": "srnagar", "createdAt": "2020-10-20T07:58:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwNTQ4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509005480", "bodyText": "changed it to be able to make multiple receive () calls.", "author": "hemanttanwar", "createdAt": "2020-10-21T05:50:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4ODE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjQzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508666431", "bodyText": "Why OffsetDateTime.now()? This variable is only used once.\nI'm not sure why we don't just have a LockRenewalOperation.DONE it just returns empty.\nclass LockRenewalOperation {\n    static final LockRenewalOperation COMPLETED = new LockRenewalOperation(null, null, null, null);\n}", "author": "conniey", "createdAt": "2020-10-20T16:20:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewSubscriber.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Mono;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+ */\n+final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+    private static final OffsetDateTime COMPLETED_RENEW_TIME = OffsetDateTime.now();", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgwNDc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508804762", "bodyText": "Removed it totally based on other comments.", "author": "hemanttanwar", "createdAt": "2020-10-20T20:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY2NjQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3MjY5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508672695", "bodyText": "Do we need all these overloads? I'm not entirely sure why we need this consumer... Can't we map the renewalOperation.map(update -> {});?", "author": "conniey", "createdAt": "2020-10-20T16:29:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/LockRenewalOperation.java", "diffHunk": "@@ -49,6 +53,34 @@\n         this(lockToken, maxLockRenewalDuration, isSession, renewalOperation, OffsetDateTime.now());\n     }\n \n+    /**", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NDcyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508674726", "bodyText": "Can we move that LockRenewSubscriber class into this one? It only exists to be used in this class.", "author": "conniey", "createdAt": "2020-10-20T16:32:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageRenewOperator.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    ServiceBusMessageRenewOperator(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+        if (!lockRenewSubscriber.compareAndSet(null, newLockRenewSubscriber)) {\n+            newLockRenewSubscriber.dispose();\n+            logger.error(\"Already subscribed once.\");\n+            return;\n+        }\n+        source.subscribe(lockRenewSubscriber.get());\n+    }", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NTEzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508675135", "bodyText": "nit: FluxAutoRenew to follow the same vein as the existing ones.", "author": "conniey", "createdAt": "2020-10-20T16:33:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageRenewOperator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class ServiceBusMessageRenewOperator extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3NjI2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508676267", "bodyText": "Can we move this duration logic into a receiver option?\nboolean isAutoRenewEnabled() { return maxAutoLockRenewDuration != null ...; }", "author": "conniey", "createdAt": "2020-10-20T16:35:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +30,32 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor\n             .map(message -> this.messageSerializer.deserialize(message, ServiceBusReceivedMessage.class))\n-            .publish(prefetch)\n+            .publish(receiverOptions.getPrefetchCount())\n             .autoConnect(1);\n+\n+        final Duration maxAutoLockRenewDuration = receiverOptions.getMaxLockRenewDuration();\n+\n+        final boolean isAutoLockRenewal = maxAutoLockRenewDuration != null", "originalCommit": "7e5ee72b3986703d850f2e4e76cad25ce33a1e98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ddf801f590d44aa4f8e42b0eaba8561258633485", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ddf801f590d44aa4f8e42b0eaba8561258633485", "message": "Incorporated review comments", "committedDate": "2020-10-20T20:00:02Z", "type": "commit"}, {"oid": "7fc64e7324197d104ce8bbf92dee64be83670a30", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc64e7324197d104ce8bbf92dee64be83670a30", "message": "Review comments", "committedDate": "2020-10-20T20:45:05Z", "type": "commit"}, {"oid": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "message": "Fix unit test", "committedDate": "2020-10-20T21:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NDkyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508854927", "bodyText": "FluxAutoLockRenew", "author": "srnagar", "createdAt": "2020-10-20T21:36:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjU0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856540", "bodyText": "Don't use error level here as we are not reporting these errors to the user. It will show up in their log and can alert them.", "author": "srnagar", "createdAt": "2020-10-20T21:39:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Njc5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508856796", "bodyText": "onError() shouldn't be called here.", "author": "srnagar", "createdAt": "2020-10-20T21:40:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            } else if (Objects.isNull(lockedUntil)) {\n+                logger.info(\"Unexpected, lockedUntil is not present in message [{}].\", message.getSequenceNumber());\n+                return;\n+            }\n+\n+            final Function<String, Mono<OffsetDateTime>> onRenewLockUpdateMessage = onRenewLock.andThen(updated ->\n+                updated.map(newLockedUntil -> {\n+                    message.setLockedUntil(newLockedUntil);\n+                    return newLockedUntil;\n+                }));\n+\n+            renewOperation = new LockRenewalOperation(lockToken, maxAutoLockRenewal, false,\n+                onRenewLockUpdateMessage, lockedUntil);\n+\n+            try {\n+                messageLockContainer.addOrUpdate(lockToken, OffsetDateTime.now().plus(maxAutoLockRenewal),\n+                    renewOperation);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while updating lockContainer for token [{}].\", lockToken, e);\n+            }\n+\n+            try {\n+                actual.onNext(message);\n+            } catch (Exception e) {\n+                logger.error(\"Exception occurred while handling downstream onNext operation.\", e);\n+                onError(e);", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858361", "bodyText": "We should use AutoLockRenew terminology consistently.", "author": "srnagar", "createdAt": "2020-10-20T21:43:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiverOptions.java", "diffHunk": "@@ -62,6 +75,15 @@ int getPrefetchCount() {\n         return prefetchCount;\n     }\n \n+    /**\n+     * Determine if client have enabled auto renew of message or session lock.\n+     *\n+     * @return true if  autoRenew is enabled; false otherwise.\n+     */\n+    boolean isAutoRenewEnabled() {", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDgwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860808", "bodyText": "Don't think we need to log this as it's not very informative.", "author": "srnagar", "createdAt": "2020-10-20T21:48:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTQ4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508861481", "bodyText": "As discussed, we should categorize these errors into different error sources.\nhttps://github.com/Azure/azure-sdk-for-net/blob/master/sdk/servicebus/Azure.Messaging.ServiceBus/src/Processor/ServiceBusErrorSource.cs", "author": "srnagar", "createdAt": "2020-10-20T21:49:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858445", "bodyText": "can this be static", "author": "conniey", "createdAt": "2020-10-20T21:43:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODU0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858543", "bodyText": "consistent null checks?", "author": "conniey", "createdAt": "2020-10-20T21:43:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODY3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858670", "bodyText": "you can do the assignment on the same line.", "author": "conniey", "createdAt": "2020-10-20T21:44:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1ODc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508858772", "bodyText": "This can be verbose.", "author": "conniey", "createdAt": "2020-10-20T21:44:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTAwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859004", "bodyText": "Informational?\nAlso, the underlying CoreSubscriber should do the dispose already. Do you need to explicitly do it?", "author": "conniey", "createdAt": "2020-10-20T21:44:57Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTM5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508859393", "bodyText": "This should be a warning other than an info?", "author": "conniey", "createdAt": "2020-10-20T21:45:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoRenew.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = actual;\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+            this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+        }\n+        /**\n+         * On an initial subscription, will take the first work item, and request that amount of work for it.\n+         * @param subscription Subscription for upstream.\n+         */\n+        @Override\n+        protected void hookOnSubscribe(Subscription subscription) {\n+            Objects.requireNonNull(subscription, \"'subscription' cannot be null.\");\n+            actual.onSubscribe(subscription);\n+        }\n+\n+        /**\n+         * When upstream has completed emitting messages.\n+         */\n+        @Override\n+        public void hookOnComplete() {\n+            logger.info(\"Upstream has completed.\");\n+            actual.onComplete();\n+        }\n+\n+        @Override\n+        protected void hookOnError(Throwable throwable) {\n+            logger.info(\"Errors occurred upstream.\", throwable);\n+            actual.onError(throwable);\n+            dispose();\n+        }\n+\n+        @Override\n+        protected void hookOnNext(ServiceBusReceivedMessage message) {\n+            final String lockToken = message.getLockToken();\n+            final OffsetDateTime lockedUntil = message.getLockedUntil();\n+            final LockRenewalOperation renewOperation;\n+\n+            if (Objects.isNull(lockToken)) {\n+                logger.info(\"Unexpected, LockToken is not present in message [{}].\", message.getSequenceNumber());", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDE3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860178", "bodyText": "javadocs is incorrect. Same with the one on 654.", "author": "conniey", "createdAt": "2020-10-20T21:47:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -669,8 +688,10 @@ public ServiceBusSessionReceiverClientBuilder maxConcurrentSessions(int maxConcu\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusSessionReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDMzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860332", "bodyText": "Incorrect javadocs", "author": "conniey", "createdAt": "2020-10-20T21:47:37Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDM5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860392", "bodyText": "Incorrect javadocs", "author": "conniey", "createdAt": "2020-10-20T21:47:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -845,8 +874,10 @@ private ServiceBusReceiverClientBuilder() {\n          * @param prefetchCount The prefetch count.\n          *\n          * @return The modified {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code prefetchCount} is negative.", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860630", "bodyText": "This method is only used once. It can be pulled in here.", "author": "conniey", "createdAt": "2020-10-20T21:48:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -830,10 +842,27 @@ private boolean isRollingSessionReceiver() {\n         private ReceiveMode receiveMode = ReceiveMode.PEEK_LOCK;\n         private String subscriptionName;\n         private String topicName;\n+        private Duration maxAutoLockRenewDuration = MAX_LOCK_RENEW_DEFAULT_DURATION;\n \n         private ServiceBusReceiverClientBuilder() {\n         }\n \n+        /**\n+         * Sets the amount of time to continue auto-renewing the lock. Setting {@link Duration#ZERO} or {@code null}\n+         * disables auto-renewal.\n+         *\n+         * @param maxAutoLockRenewDuration the amount of time to continue auto-renewing the lock. {@link Duration#ZERO}\n+         * or {@code null} indicates that auto-renewal is disabled.\n+         *\n+         * @return The updated {@link ServiceBusReceiverClientBuilder} object.\n+         * @throws IllegalArgumentException If {#code maxAutoLockRenewDuration} is negative.\n+         */\n+        public ServiceBusReceiverClientBuilder maxAutoLockRenewDuration(Duration maxAutoLockRenewDuration) {\n+            validateAndThrow(maxAutoLockRenewDuration);", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwNTI2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509005266", "bodyText": "validateAndThrow(maxAutoLockRenewDuration) is used in  ServiceBusSessionReceiverClientBuilder and in ServiceBusReceiverClientBuilder, two places.", "author": "hemanttanwar", "createdAt": "2020-10-21T05:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MDk1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508860951", "bodyText": "final?", "author": "conniey", "createdAt": "2020-10-20T21:48:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -1068,8 +1084,9 @@ private ServiceBusAsyncConsumer getOrCreateConsumer() {\n         final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLink.subscribeWith(\n             new ServiceBusReceiveLinkProcessor(receiverOptions.getPrefetchCount(), retryPolicy,\n                 receiverOptions.getReceiveMode()));\n-        final ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,\n-            messageSerializer, receiverOptions.getPrefetchCount());\n+\n+        ServiceBusAsyncConsumer newConsumer = new ServiceBusAsyncConsumer(linkName, linkMessageProcessor,", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862107", "bodyText": "Should be consistent about adding ( around your lambdas. there are several down there that don't have it.", "author": "conniey", "createdAt": "2020-10-20T21:51:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjE3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862176", "bodyText": "Same with other instances.", "author": "conniey", "createdAt": "2020-10-20T21:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjcwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508862709", "bodyText": "Is there any way to check that your renewal operations are cancelled on these messages?", "author": "conniey", "createdAt": "2020-10-20T21:52:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA2NjkzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509066934", "bodyText": "added it.", "author": "hemanttanwar", "createdAt": "2020-10-21T07:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863023", "bodyText": "The test above tests the same scenario. I'm not sure how Map makes a difference here.", "author": "conniey", "createdAt": "2020-10-20T21:53:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3MTk4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509071981", "bodyText": "I will remove it.", "author": "hemanttanwar", "createdAt": "2020-10-21T08:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863420", "bodyText": "If you  mock this function, you can verify invocations it rather than keeping track.", "author": "conniey", "createdAt": "2020-10-20T21:54:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/FluxAutoRenewTest.java", "diffHunk": "@@ -0,0 +1,431 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+import reactor.test.publisher.TestPublisher;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit test for {@link FluxAutoRenew}.\n+ */\n+public class FluxAutoRenewTest {\n+\n+    private static final UUID LOCK_TOKEN_UUID = UUID.randomUUID();\n+    private static final String LOCK_TOKEN_STRING = LOCK_TOKEN_UUID.toString();\n+    private static final Duration MAX_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(6);\n+    private static final Duration DISABLE_AUTO_LOCK_RENEW_DURATION = Duration.ofSeconds(0);\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoRenewTest.class);\n+\n+    private final ServiceBusReceivedMessage message = new ServiceBusReceivedMessage(\"Some Data\".getBytes());\n+    private final TestPublisher<ServiceBusReceivedMessage> messagesPublisher = TestPublisher.create();\n+    private final Flux<? extends ServiceBusReceivedMessage> messageSource = messagesPublisher.flux();\n+    private Function<String, Mono<OffsetDateTime>> renewalFunction;\n+\n+    private OffsetDateTime lockedUntil;\n+\n+    @Mock\n+    LockContainer<LockRenewalOperation> messageLockContainer;\n+\n+    @BeforeAll\n+    static void beforeAll() {\n+        StepVerifier.setDefaultTimeout(Duration.ofSeconds(30));\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        StepVerifier.resetDefaultTimeout();\n+    }\n+\n+    @BeforeEach\n+    void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        lockedUntil = OffsetDateTime.now().plusSeconds(2);\n+        message.setLockToken(LOCK_TOKEN_UUID);\n+        message.setLockedUntil(lockedUntil);\n+        renewalFunction = (lockToken) -> Mono.just(OffsetDateTime.now().plusSeconds(1));\n+    }\n+\n+    @AfterEach\n+    void teardown() {\n+        Mockito.framework().clearInlineMocks();\n+    }\n+\n+    /**\n+     * Test that the user can cancel the receive function.\n+     */\n+    @Test\n+    void canCancel() {\n+        // Arrange\n+        final ServiceBusReceivedMessage message2 = new ServiceBusReceivedMessage(\"data\".getBytes());\n+        message2.setLockToken(UUID.randomUUID());\n+        message2.setLockedUntil(OffsetDateTime.now().plusSeconds(2));\n+\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator)\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+                messagesPublisher.next(message2);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(LOCK_TOKEN_STRING, actual.getLockToken()))\n+            .thenCancel()\n+            .verify();\n+\n+    }\n+\n+    @Test\n+    public void canMap() {\n+        // Arrange\n+        final String expectedMappedValue = \"New Expected Mapped Value\";\n+        final FluxAutoRenew renewOperator = new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction);\n+\n+        // Act & Assert\n+        StepVerifier.create(renewOperator.map(serviceBusReceivedMessage -> expectedMappedValue))\n+            .then(() -> {\n+                messagesPublisher.next(message);\n+            })\n+            .assertNext(actual -> Assertions.assertEquals(expectedMappedValue, actual))\n+            .thenCancel()\n+            .verify();\n+    }\n+\n+    /**\n+     * Check that illegal values are not allowed in constructor.\n+     */\n+    @Test\n+    void illegalValueConstructor() {\n+        // Arrange, Act & Assert\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(null,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, null, renewalFunction));\n+\n+        assertThrows(NullPointerException.class, () -> new FluxAutoRenew(messageSource,\n+            MAX_AUTO_LOCK_RENEW_DURATION, messageLockContainer, null));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FluxAutoRenew(messageSource,\n+            DISABLE_AUTO_LOCK_RENEW_DURATION, messageLockContainer, renewalFunction));\n+\n+    }\n+\n+    /**\n+     * Test that the function to renew lock is invoked. It will verify\n+     * 1. The renew lock function is invoked multiple times.\n+     * 2. The updated new lockedUntil is reflected on ServiceBusReceivedMessage object.\n+     */\n+    @Test\n+    void lockRenewedMultipleTimes() {\n+        // Arrange\n+        final int renewedForAtLeast = 3;\n+        final int totalProcessingTimeSeconds = 5;\n+        final AtomicInteger actualTokenRenewCalledTimes = new AtomicInteger();\n+        final Function<String, Mono<OffsetDateTime>> lockTokenRenewFunction = (lockToken) -> {", "originalCommit": "1eca58e9cf7b46c92b12d9bc83cfcf4b5fd9f25c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzYyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r508863625", "bodyText": "Also, you could have mocked the function in general instead of providing a concrete implementation.", "author": "conniey", "createdAt": "2020-10-20T21:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3MDgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509070823", "bodyText": "I could not find a way to mock onRenewLock.**andThen**(...), So for now I am using concrete implementation for renewLock.", "author": "hemanttanwar", "createdAt": "2020-10-21T08:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQyMA=="}], "type": "inlineReview"}, {"oid": "f536447cea355dfb7d2f13fd6f6f9c9903192061", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f536447cea355dfb7d2f13fd6f6f9c9903192061", "message": "More review comments", "committedDate": "2020-10-21T08:13:57Z", "type": "commit"}, {"oid": "eb1de592e10971a375acf93a3c60c9608b1f6917", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb1de592e10971a375acf93a3c60c9608b1f6917", "message": "Added check for receive and delete mode.", "committedDate": "2020-10-21T08:37:17Z", "type": "commit"}, {"oid": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/450de935ac61d93fc19bd4c2403a6a462d70fbf9", "message": "Added test for multiple links creation", "committedDate": "2020-10-21T19:50:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTcyNTEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509725101", "bodyText": "Do you need this reference?", "author": "conniey", "createdAt": "2020-10-21T21:43:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();", "originalCommit": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTIxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779219", "bodyText": "the parameter name is 'actual'", "author": "conniey", "createdAt": "2020-10-21T22:52:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");", "originalCommit": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTM1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779358", "bodyText": "nit: add new line.", "author": "conniey", "createdAt": "2020-10-21T22:52:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+\n+    }\n+\n+    /**\n+     * Receives messages from to upstream, pushes them downstream and start lock renewal.\n+     */\n+    static final class LockRenewSubscriber extends BaseSubscriber<ServiceBusReceivedMessage> {\n+        private final ClientLogger logger = new ClientLogger(LockRenewSubscriber.class);\n+\n+        private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+        private final Duration maxAutoLockRenewal;\n+        private final LockContainer<LockRenewalOperation> messageLockContainer;\n+        private final CoreSubscriber<? super ServiceBusReceivedMessage> actual;\n+\n+        LockRenewSubscriber(CoreSubscriber<? super ServiceBusReceivedMessage> actual, Duration maxAutoLockRenewDuration,\n+            LockContainer<LockRenewalOperation> messageLockContainer,\n+            Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+            this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+            this.actual = Objects.requireNonNull(actual, \"'downstream' cannot be null.\");\n+            this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+                \"'messageLockContainer' cannot be null.\");\n+            this.maxAutoLockRenewal = Objects.requireNonNull(maxAutoLockRenewDuration,\n+                \"'maxAutoLockRenewDuration' cannot be null.\");\n+        }\n+        /**", "originalCommit": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3OTQ3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509779477", "bodyText": "nit: remove empty line.", "author": "conniey", "createdAt": "2020-10-21T22:52:45Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/FluxAutoLockRenew.java", "diffHunk": "@@ -0,0 +1,166 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.LockContainer;\n+import org.reactivestreams.Subscription;\n+import reactor.core.CoreSubscriber;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxOperator;\n+import reactor.core.publisher.Mono;\n+import org.reactivestreams.Publisher;\n+import reactor.util.context.Context;\n+\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+/**\n+ * Receives messages from to upstream, subscribe lock renewal subscriber.\n+ */\n+final class FluxAutoLockRenew extends FluxOperator<ServiceBusReceivedMessage, ServiceBusReceivedMessage> {\n+\n+    private final ClientLogger logger = new ClientLogger(FluxAutoLockRenew.class);\n+\n+    private final Function<String, Mono<OffsetDateTime>> onRenewLock;\n+    private final Duration maxAutoLockRenewal;\n+    private final LockContainer<LockRenewalOperation> messageLockContainer;\n+    private final AtomicReference<LockRenewSubscriber> lockRenewSubscriber = new AtomicReference<>();\n+\n+    /**\n+     * Build a {@link FluxOperator} wrapper around the passed parent {@link Publisher}\n+     * @param source the {@link Publisher} to decorate\n+     *\n+     * @throws NullPointerException If {@code onRenewLock}, {@code messageLockContainer},\n+     * {@code maxAutoLockRenewDuration} is null.\n+     *\n+     * @throws IllegalArgumentException If maxLockRenewalDuration is zero or negative.\n+     */\n+    FluxAutoLockRenew(\n+        Flux<? extends ServiceBusReceivedMessage> source, Duration maxAutoLockRenewDuration,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n+        super(source);\n+\n+        this.onRenewLock = Objects.requireNonNull(onRenewLock, \"'onRenewLock' cannot be null.\");\n+        this.messageLockContainer = Objects.requireNonNull(messageLockContainer,\n+            \"'messageLockContainer' cannot be null.\");\n+\n+        Objects.requireNonNull(maxAutoLockRenewDuration, \"'maxAutoLockRenewDuration' cannot be null.\");\n+        if (maxAutoLockRenewDuration.isNegative() || maxAutoLockRenewDuration.isZero()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"'maxLockRenewalDuration' should not be zero or negative.\"));\n+        }\n+        this.maxAutoLockRenewal = maxAutoLockRenewDuration;\n+\n+    }\n+\n+    @Override\n+    public void subscribe(CoreSubscriber<? super ServiceBusReceivedMessage> actual) {\n+        Objects.requireNonNull(actual, \"'coreSubscriber' cannot be null.\");\n+\n+        final LockRenewSubscriber newLockRenewSubscriber = new LockRenewSubscriber(actual, maxAutoLockRenewal,\n+            messageLockContainer, onRenewLock);\n+\n+        source.subscribe(newLockRenewSubscriber);\n+", "originalCommit": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTgzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509781833", "bodyText": "My PR has this one level higher in ReceiverClient. Is there a constraining reason why? If we map this to one level higher, the onRenewLock doesn't have to be passed into the constructor for this.", "author": "conniey", "createdAt": "2020-10-21T22:56:24Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -26,17 +29,27 @@\n     private final String linkName;\n     private final ServiceBusReceiveLinkProcessor linkProcessor;\n     private final MessageSerializer messageSerializer;\n-    private final Flux<ServiceBusReceivedMessage> processor;\n+    private final Flux<ServiceBusReceivedMessage> messageSource;\n \n     ServiceBusAsyncConsumer(String linkName, ServiceBusReceiveLinkProcessor linkProcessor,\n-        MessageSerializer messageSerializer, int prefetch) {\n+        MessageSerializer messageSerializer, ReceiverOptions receiverOptions,\n+        LockContainer<LockRenewalOperation> messageLockContainer, Function<String, Mono<OffsetDateTime>> onRenewLock) {\n         this.linkName = linkName;\n         this.linkProcessor = linkProcessor;\n         this.messageSerializer = messageSerializer;\n-        this.processor = linkProcessor\n+\n+        Flux<ServiceBusReceivedMessage> source = linkProcessor", "originalCommit": "450de935ac61d93fc19bd4c2403a6a462d70fbf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0OTkwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509849908", "bodyText": "Okay moved it higher.", "author": "hemanttanwar", "createdAt": "2020-10-22T02:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc4MTgzMw=="}], "type": "inlineReview"}, {"oid": "faf071a94e5bb976cd8bb2b3e338b8954e226bc3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/faf071a94e5bb976cd8bb2b3e338b8954e226bc3", "message": "review comments", "committedDate": "2020-10-21T23:16:03Z", "type": "commit"}, {"oid": "c39689042daf7ebaaa177004bc700cdc583313dd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c39689042daf7ebaaa177004bc700cdc583313dd", "message": "Review comments", "committedDate": "2020-10-21T23:27:54Z", "type": "commit"}, {"oid": "b3fbfa17393195019a2d46c769a3f159d4b6ab13", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3fbfa17393195019a2d46c769a3f159d4b6ab13", "message": "Moved FluxAutoLockRenew in receiver Client", "committedDate": "2020-10-22T02:55:22Z", "type": "commit"}, {"oid": "e925b762be3e862e818decca7622bc4559a5c5c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e925b762be3e862e818decca7622bc4559a5c5c7", "message": "Moved FluxAutoLockRenew in receiver Client", "committedDate": "2020-10-22T03:06:03Z", "type": "commit"}, {"oid": "939166a7d9c40130ce96596cb3b8f79dbd8e87d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/939166a7d9c40130ce96596cb3b8f79dbd8e87d9", "message": "check style error fix", "committedDate": "2020-10-22T03:55:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg3MDAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509870028", "bodyText": "We should still append a random string to the name of the session to get a unique link name.", "author": "srnagar", "createdAt": "2020-10-22T04:17:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -224,16 +224,21 @@ private AmqpErrorContext getErrorContext() {\n     }\n \n     /**\n-     * Creates an unnamed session receive link.\n+     * Creates an session receive link.\n      *\n-     * @return A Mono that completes with an unnamed session receive link.\n+     * @return A Mono that completes with an session receive link.\n      */\n     private Mono<ServiceBusReceiveLink> createSessionReceiveLink() {\n-        final String linkName = StringUtil.getRandomString(\"session-\");\n+        final String sessionId = receiverOptions.getSessionId();\n \n+        final String linkName = (sessionId != null)\n+            ? sessionId", "originalCommit": "c39689042daf7ebaaa177004bc700cdc583313dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg5OTA2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16183#discussion_r509899060", "bodyText": "If  we make linkName random for same Named SessionId, It will try to create a new Link for same session (Example SessionId= GREEN). And if  a Link already exists for GREEN, we will not be able to get the lock.", "author": "hemanttanwar", "createdAt": "2020-10-22T06:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg3MDAyOA=="}], "type": "inlineReview"}]}