{"pr_number": 15076, "pr_title": "Service Bus naming changes", "pr_createdAt": "2020-09-11T03:17:21Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15076", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5MzMyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486793321", "bodyText": "\"renews the specified message\" is confusing", "author": "YijunXieMS", "createdAt": "2020-09-11T06:06:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified", "originalCommit": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NDAyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486794024", "bodyText": "The above uses monoError. Why is this line different?", "author": "YijunXieMS", "createdAt": "2020-09-11T06:09:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "originalCommit": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgxMTc4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486811784", "bodyText": "Good catch. I've replaced all instances", "author": "conniey", "createdAt": "2020-09-11T06:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NDAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTE1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795152", "bodyText": "Same question. The above uses monoError. This overload uses logger.logExceptionAsError().", "author": "YijunXieMS", "createdAt": "2020-09-11T06:12:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,80 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the specified message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "originalCommit": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njc5NTQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486795484", "bodyText": "same question", "author": "YijunXieMS", "createdAt": "2020-09-11T06:13:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +848,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code sessionId} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a non-session receiver or the receiver is disposed.\n+     */\n+    public Mono<Void> renewSessionLock(String sessionId, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewSessionLock\")));\n+        } else if (!receiverOptions.isSessionReceiver()) {\n+            throw logger.logExceptionAsError(new IllegalStateException(", "originalCommit": "2b4e2b87a821834dcc8d5a27255d9de6c703bb3f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486858552", "bodyText": "Why are we using ServiceBusReceivedMessage for renewing and other settlement methods? Should we use the locktoken instead as per this API view?", "author": "srnagar", "createdAt": "2020-09-11T08:29:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MTIyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487161221", "bodyText": "@srnagar  I should update this APIview with this change.  There was a review with Clemens (Messaging Architect ) and Service team on this . The requirement of  using lockToken was dropped. Here is discussion thread Azure/azure-sdk-for-net#10852 (comment)   Here is an issue for this https://app.zenhub.com/workspaces/azure-sdk-team-5bdca72c4b5806bc2bf0aab2/issues/azure/azure-sdk-for-java/14664", "author": "hemanttanwar", "createdAt": "2020-09-11T16:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5MDg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487290869", "bodyText": "The API view has been updated already: https://apiview.dev/Assemblies/Review/64f40be9988242c9a8facc8a20c5e9e7", "author": "conniey", "createdAt": "2020-09-11T21:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1ODU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg1OTg5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486859893", "bodyText": "There's no lockToken in the input args? I guess this is referring to message. However, as per the API view, the actual argument should be lockToken.", "author": "srnagar", "createdAt": "2020-09-11T08:32:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MDgwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486860800", "bodyText": "Might be worth adding a log when onComplete() is called too.", "author": "srnagar", "createdAt": "2020-09-11T08:34:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";\n+        final Consumer<Throwable> throwableConsumer = onError != null\n+            ? onError\n+            : error -> logger.warning(\"Exception occurred while renewing lock token '{}'.\", lockToken, error);\n+\n+        asyncClient.renewMessageLock(message, maxLockRenewalDuration).subscribe(\n+            v -> logger.verbose(\"Completed renewing lock token: '{}'\", lockToken),\n+            throwableConsumer);", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTg0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r486861847", "bodyText": "Does the auto-lock renewal stop if the user settles the message?", "author": "srnagar", "createdAt": "2020-09-11T08:36:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n+        } else if (receiverOptions.isSessionReceiver()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n+        } else if (maxLockRenewalDuration == null) {\n+            return monoError(logger, new NullPointerException(\"'maxLockRenewalDuration' cannot be null.\"));\n+        } else if (maxLockRenewalDuration.isNegative()) {\n+            return monoError(logger, new IllegalArgumentException(\"'maxLockRenewalDuration' cannot be negative.\"));\n+        }\n+\n+        final LockRenewalOperation operation = new LockRenewalOperation(message.getLockToken(),\n+            maxLockRenewalDuration, false, ignored -> renewMessageLock(message));\n+        renewalContainer.addOrUpdate(message.getLockToken(), Instant.now().plus(maxLockRenewalDuration), operation);\n+\n+        return operation.getCompletionOperation();", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NjY3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487186676", "bodyText": "Yes it does.", "author": "conniey", "createdAt": "2020-09-11T17:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164080", "bodyText": "Although logically lockToken will always be there but we should check for null value also.", "author": "hemanttanwar", "createdAt": "2020-09-11T16:43:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NDkxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487164910", "bodyText": "given lock -> given {@link ServiceBusReceivedMessage}", "author": "hemanttanwar", "createdAt": "2020-09-11T16:45:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NTU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487165575", "bodyText": "null check for message.getLockToken()", "author": "hemanttanwar", "createdAt": "2020-09-11T16:46:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -823,44 +750,79 @@ public String getEntityPath() {\n     }\n \n     /**\n-     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the setting specified\n+     * Asynchronously renews the lock on the message. The lock will be renewed based on the setting specified\n      * on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the\n-     * server for this receiver instance for a duration as specified during the Queue creation (LockDuration). If\n+     * server for this receiver instance for a duration as specified during the entity creation (LockDuration). If\n      * processing of the message requires longer than this duration, the lock needs to be renewed. For each renewal, the\n      * lock is reset to the entity's LockDuration value.\n      *\n-     * @param lockToken Lock token of the message to renew.\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n      *\n      * @return The new expiration time for the message.\n-     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws NullPointerException if {@code message} is null.\n      * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n      *     mode.\n      * @throws IllegalStateException if the receiver is a session receiver.\n-     * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n      */\n-    public Mono<OffsetDateTime> renewMessageLock(String lockToken) {\n+    public Mono<OffsetDateTime> renewMessageLock(ServiceBusReceivedMessage message) {\n         if (isDisposed.get()) {\n             return monoError(logger, new IllegalStateException(\n                 String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"renewMessageLock\")));\n-        } else if (Objects.isNull(lockToken)) {\n-            return monoError(logger, new NullPointerException(\"'lockToken' cannot be null.\"));\n-        } else if (lockToken.isEmpty()) {\n-            return monoError(logger, new IllegalArgumentException(\"'lockToken' cannot be empty.\"));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));\n         } else if (receiverOptions.isSessionReceiver()) {\n             return monoError(logger, new IllegalStateException(\n-                String.format(\"Cannot renew message lock [%s] for a session receiver.\", lockToken)));\n+                String.format(\"Cannot renew message lock [%s] for a session receiver.\", message.getLockToken())));\n         }\n \n         return connectionProcessor\n             .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n             .flatMap(serviceBusManagementNode ->\n-                serviceBusManagementNode.renewMessageLock(lockToken, getLinkName(null)))\n-            .map(instant -> managementNodeLocks.addOrUpdate(lockToken, instant,\n+                serviceBusManagementNode.renewMessageLock(message.getLockToken(), getLinkName(null)))\n+            .map(instant -> managementNodeLocks.addOrUpdate(message.getLockToken(), instant,\n                 instant.atOffset(ZoneOffset.UTC)).atOffset(ZoneOffset.UTC));\n     }\n \n     /**\n-     * Sets the state of a session given its identifier.\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform this operation.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *\n+     * @return A lock renewal operation for the message.\n+     * @throws NullPointerException if {@code message} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     * @throws IllegalArgumentException if {@code message.getLockToken()} is an empty value.\n+     */\n+    public Mono<Void> renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration) {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"getAutoRenewMessageLock\")));\n+        } else if (Objects.isNull(message)) {\n+            return monoError(logger, new NullPointerException(\"'message' cannot be null.\"));\n+        } else if (message.getLockToken().isEmpty()) {\n+            return monoError(logger, new IllegalArgumentException(\"'message.getLockToken()' cannot be empty.\"));", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjU3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487166570", "bodyText": "lock token -> session ?", "author": "hemanttanwar", "createdAt": "2020-09-11T16:48:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -885,6 +847,42 @@ public String getEntityPath() {\n                 .map(instant -> instant.atOffset(ZoneOffset.UTC)));\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     *", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2OTY2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487169662", "bodyText": "the lock on the specified message   This is repeated two times.", "author": "hemanttanwar", "createdAt": "2020-09-11T16:53:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -570,13 +524,13 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n     }\n \n     /**\n-     * Renews the lock on the specified message. The lock will be renewed based on the setting specified on the entity.\n-     * When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is locked on the server for this\n-     * receiver instance for a duration as specified during the Queue creation (LockDuration). If processing of the\n-     * message requires longer than this duration, the lock needs to be renewed. For each renewal, the lock is reset to\n-     * the entity's LockDuration value.\n+     * Renews the lock on the specified message.the lock on the specified message. The lock will be renewed based on the", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzI3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487173279", "bodyText": "What is the reason of assigning \"null\" string to lockToken . Shouldn't  we throw NPE if it is null.", "author": "hemanttanwar", "createdAt": "2020-09-11T17:00:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -585,8 +539,31 @@ public ServiceBusReceivedMessage receiveDeferredMessage(long sequenceNumber, Str\n      * @throws IllegalArgumentException if {@code lockToken} is an empty value.\n      * @throws IllegalStateException if the receiver is a session receiver.\n      */\n-    public OffsetDateTime renewMessageLock(String lockToken) {\n-        return asyncClient.renewMessageLock(lockToken).block(operationTimeout);\n+    public OffsetDateTime renewMessageLock(ServiceBusReceivedMessage message) {\n+        return asyncClient.renewMessageLock(message).block(operationTimeout);\n+    }\n+\n+    /**\n+     * Starts the auto lock renewal for a message with the given lock.\n+     *\n+     * @param message The {@link ServiceBusReceivedMessage} to perform auto-lock renewal.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.\n+     * @param onError A function to call when an error occurs during lock renewal.\n+     *\n+     * @throws NullPointerException if {@code lockToken} or {@code maxLockRenewalDuration} is null.\n+     * @throws IllegalArgumentException if {@code lockToken} is an empty string.\n+     * @throws IllegalStateException if the receiver is a session receiver or the receiver is disposed.\n+     */\n+    public void renewMessageLock(ServiceBusReceivedMessage message, Duration maxLockRenewalDuration,\n+        Consumer<Throwable> onError) {\n+        final String lockToken = message != null ? message.getLockToken() : \"null\";", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4MjkzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487282937", "bodyText": "It'll get thrown later when we call into asyncClient. This is so the function invocation resolves correctly.", "author": "conniey", "createdAt": "2020-09-11T20:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MzI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDE4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174184", "bodyText": "with the given lock : It is a bit confusing since user never gave us any lock in this API.\nSuggestion Starts the auto lock renewal for a session id.", "author": "hemanttanwar", "createdAt": "2020-09-11T17:02:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NDQ1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487174455", "bodyText": "lock token -> session", "author": "hemanttanwar", "createdAt": "2020-09-11T17:02:45Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -601,6 +578,27 @@ public OffsetDateTime renewSessionLock(String sessionId) {\n         return asyncClient.renewSessionLock(sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Starts the auto lock renewal for a session with the given lock.\n+     *\n+     * @param sessionId Id for the session to renew.\n+     * @param maxLockRenewalDuration Maximum duration to keep renewing the lock token.", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3NzAzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15076#discussion_r487177030", "bodyText": "May be adding test is message.getLockToken() returns null.", "author": "hemanttanwar", "createdAt": "2020-09-11T17:07:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientTest.java", "diffHunk": "@@ -164,15 +166,17 @@ void autoRenewMessageLockFails() {\n         final TestPublisher<Void> publisher = TestPublisher.create();\n         final Throwable testError = new IllegalAccessException(\"Some exception\");\n \n-        when(asyncClient.getAutoRenewMessageLock(LOCK_TOKEN, maxDuration)).thenReturn(publisher.mono());\n+        when(message.getLockToken()).thenReturn(LOCK_TOKEN);", "originalCommit": "8643bb112ee7e368851fc81810f3984893551b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ac55299c0c8b4be2bc6aeac667dc1a803597c2c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ac55299c0c8b4be2bc6aeac667dc1a803597c2c", "message": "Rename from getAutoRenewMessageLock and getAutoRenewSessionLock to renewMessageLock and renewSessionLock.", "committedDate": "2020-09-11T19:52:38Z", "type": "commit"}, {"oid": "42817b96fbe85b020370d37df2136dc09c7d9306", "url": "https://github.com/Azure/azure-sdk-for-java/commit/42817b96fbe85b020370d37df2136dc09c7d9306", "message": "Replace renewMessageLock with ServiceBusReceivedMessage instead of string.", "committedDate": "2020-09-11T19:52:39Z", "type": "commit"}, {"oid": "71c5ff6ccf268e8463206c46be7500810a5b9968", "url": "https://github.com/Azure/azure-sdk-for-java/commit/71c5ff6ccf268e8463206c46be7500810a5b9968", "message": "Fix test failure", "committedDate": "2020-09-11T19:52:39Z", "type": "commit"}, {"oid": "b672dd46da0bc7c494451fa11477beab5f3bc9c3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b672dd46da0bc7c494451fa11477beab5f3bc9c3", "message": "Updating to use monoError", "committedDate": "2020-09-11T19:52:39Z", "type": "commit"}, {"oid": "023111ae08c83f3d8388610a30cda386a20fffa6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/023111ae08c83f3d8388610a30cda386a20fffa6", "message": "Adding onComplete(), and updating token documentation.", "committedDate": "2020-09-11T20:58:58Z", "type": "commit"}, {"oid": "7740f8ac30f9a89a49962feb3c0308bdb4a55ccc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7740f8ac30f9a89a49962feb3c0308bdb4a55ccc", "message": "Updating documentation for async client.", "committedDate": "2020-09-11T20:59:34Z", "type": "commit"}, {"oid": "badad4065d173c0806a16af87e1b2549a49ff67e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/badad4065d173c0806a16af87e1b2549a49ff67e", "message": "Adding test cases for lock tokens.", "committedDate": "2020-09-11T20:59:43Z", "type": "commit"}, {"oid": "611f922cb4efedd3a2a5608a21e85febc508291f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/611f922cb4efedd3a2a5608a21e85febc508291f", "message": "Fixing line issues.", "committedDate": "2020-09-11T21:05:18Z", "type": "commit"}, {"oid": "611f922cb4efedd3a2a5608a21e85febc508291f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/611f922cb4efedd3a2a5608a21e85febc508291f", "message": "Fixing line issues.", "committedDate": "2020-09-11T21:05:18Z", "type": "forcePushed"}]}