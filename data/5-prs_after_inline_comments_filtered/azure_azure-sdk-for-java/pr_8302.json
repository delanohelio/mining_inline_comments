{"pr_number": 8302, "pr_title": "Datalake Buffered Upload", "pr_createdAt": "2020-02-19T22:07:19Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8302", "timeline": [{"oid": "c0fb486c9d17aa6b2663430cbdcee3bb8c20adfd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c0fb486c9d17aa6b2663430cbdcee3bb8c20adfd", "message": "Buffered upload fully ported over", "committedDate": "2020-02-04T17:11:29Z", "type": "commit"}, {"oid": "d67b5fb5fc9e7ed25447b635f932df3379caa3f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d67b5fb5fc9e7ed25447b635f932df3379caa3f8", "message": "Updated public signatures of upload methods", "committedDate": "2020-02-06T23:05:49Z", "type": "commit"}, {"oid": "5765e0d548afd5c14f6caf7d83455ae6a5e9fb3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5765e0d548afd5c14f6caf7d83455ae6a5e9fb3c", "message": "Updated upload to create and upload", "committedDate": "2020-02-13T18:22:39Z", "type": "commit"}, {"oid": "163b51e00fe8d4884f98622f0014c1bc32276cef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/163b51e00fe8d4884f98622f0014c1bc32276cef", "message": "Merge branch 'master' into storage/ADLSBufferedUpload", "committedDate": "2020-02-18T20:53:03Z", "type": "commit"}, {"oid": "4941ad8db72c3be2648c75f3f664f6ac73c7f9bc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4941ad8db72c3be2648c75f3f664f6ac73c7f9bc", "message": "Updated all tests", "committedDate": "2020-02-19T19:48:18Z", "type": "commit"}, {"oid": "30a4f41347462d4b1d30fe1238fd190ef19e77f6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30a4f41347462d4b1d30fe1238fd190ef19e77f6", "message": "test recordings", "committedDate": "2020-02-19T22:05:39Z", "type": "commit"}, {"oid": "1bb6e2f7562386b0d9e305db97530444b2eb9e88", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1bb6e2f7562386b0d9e305db97530444b2eb9e88", "message": "Fixed header for UploadUtils", "committedDate": "2020-02-20T17:05:08Z", "type": "commit"}, {"oid": "22b048f2ed7a902c995c5a7a43755e3b1a2f04f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/22b048f2ed7a902c995c5a7a43755e3b1a2f04f2", "message": "marked reporter tests as live only", "committedDate": "2020-02-20T17:17:32Z", "type": "commit"}, {"oid": "d79aab24624dafc272d2f1b041a18f4417b45816", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d79aab24624dafc272d2f1b041a18f4417b45816", "message": "updated javadoc", "committedDate": "2020-02-20T17:33:10Z", "type": "commit"}, {"oid": "49fd94f43b5a267e9f1c6a05dc4f6f5a1be59d82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49fd94f43b5a267e9f1c6a05dc4f6f5a1be59d82", "message": "fixed checkstyle", "committedDate": "2020-02-20T17:55:22Z", "type": "commit"}, {"oid": "78dc86ce6a9471afbddffd30776dba990fc75bfd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/78dc86ce6a9471afbddffd30776dba990fc75bfd", "message": "fixed java doc", "committedDate": "2020-02-20T18:09:06Z", "type": "commit"}, {"oid": "94a87aabf71bf99546069295bc174b76736e2bce", "url": "https://github.com/Azure/azure-sdk-for-java/commit/94a87aabf71bf99546069295bc174b76736e2bce", "message": "modified test coverage for commone", "committedDate": "2020-02-20T18:41:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxODIwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382218209", "bodyText": "Is this also the value we use for chunks in downloadToFile? Perhaps we should update these docs", "author": "rickle-msft", "createdAt": "2020-02-20T19:43:08Z", "path": "sdk/storage/azure-storage-common/src/main/java/com/azure/storage/common/ParallelTransferOptions.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.common;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.storage.common.implementation.StorageImplUtils;\n+\n+/**\n+ * This class contains configuration used to parallelize data transfer operations. Note that not all values are used\n+ * by every method which accepts this type. Please refer to the javadoc on specific methods for these cases.\n+ */\n+@Fluent\n+public final class ParallelTransferOptions {\n+\n+    private final Integer blockSize;\n+    private final Integer numBuffers;\n+    private final ProgressReceiver progressReceiver;\n+    private final Integer maxSingleUploadSize;\n+\n+    /**\n+     * Creates a new {@link ParallelTransferOptions} with default parameters applied.\n+     *\n+     * @param blockSize The block size.\n+     * For upload, The block size is the size of each block that will be staged. This value also determines the number", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3ODExNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382278114", "bodyText": "I added a sentence for downloadToFile", "author": "gapra-msft", "createdAt": "2020-02-20T21:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIxODIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyMzg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382223889", "bodyText": "I wonder if it'd be helpful to have an abstract type we define like Uploader that has abstract methods for validateOptions, initialize, determineUploadFullOrChunked, uploadInChunks, uploadFull, and finalize and then it's like execute/upload/whatever method strings these together and each package has a subtype that overrides each of these methods? Does that make sense and/or do you see any value in that? On the one hand, it seems cleaner to me to have this logic centralized and to deal with well defined overload. On the other hand, I can see why that would feel stiff or overly structured.", "author": "rickle-msft", "createdAt": "2020-02-20T19:54:22Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders headers, Map<String, String> metadata,\n+        DataLakeRequestConditions requestConditions) {\n+        try {\n+            Objects.requireNonNull(data, \"'data' must not be null\");\n+            DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+                ? new DataLakeRequestConditions() : requestConditions;\n+            /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+             after creation, so remove them for the append/flush calls. */\n+            DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+                .setLeaseId(validatedRequestConditions.getLeaseId());\n+            final ParallelTransferOptions validatedParallelTransferOptions =\n+                ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+            long fileOffset = 0;\n+\n+            Function<Flux<ByteBuffer>, Mono<Response<PathInfo>>> uploadInChunksFunction = (stream) ->\n+                uploadInChunks(stream, fileOffset, length, validatedParallelTransferOptions, headers,\n+                    validatedUploadRequestConditions);\n+\n+            BiFunction<Flux<ByteBuffer>, Long, Mono<Response<PathInfo>>> uploadFullMethod =\n+                (stream, lengthUploaded) -> uploadWithResponse(ProgressReporter\n+                        .addProgressReporting(stream, validatedParallelTransferOptions.getProgressReceiver()),\n+                    fileOffset, length, headers, validatedUploadRequestConditions);\n+\n+            return createWithResponse(null, null, headers, metadata, requestConditions)\n+                .then(UploadUtils.determineUploadFullOrChunked(data, validatedParallelTransferOptions,\n+                uploadInChunksFunction, uploadFullMethod));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDkyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382714923", "bodyText": "#8383", "author": "gapra-msft", "createdAt": "2020-02-21T17:39:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyMzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNTU0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382225548", "bodyText": "Can you give a more thorough description of what this scan method is doing/how it works? Yes, there's the reactor docs, but perhaps walking through a few iterations in our own example will help improve clarity. In particular, some of the arithmetic is not exactly self evident as to its effect.", "author": "rickle-msft", "createdAt": "2020-02-20T19:57:52Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders headers, Map<String, String> metadata,\n+        DataLakeRequestConditions requestConditions) {\n+        try {\n+            Objects.requireNonNull(data, \"'data' must not be null\");\n+            DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+                ? new DataLakeRequestConditions() : requestConditions;\n+            /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+             after creation, so remove them for the append/flush calls. */\n+            DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+                .setLeaseId(validatedRequestConditions.getLeaseId());\n+            final ParallelTransferOptions validatedParallelTransferOptions =\n+                ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+            long fileOffset = 0;\n+\n+            Function<Flux<ByteBuffer>, Mono<Response<PathInfo>>> uploadInChunksFunction = (stream) ->\n+                uploadInChunks(stream, fileOffset, length, validatedParallelTransferOptions, headers,\n+                    validatedUploadRequestConditions);\n+\n+            BiFunction<Flux<ByteBuffer>, Long, Mono<Response<PathInfo>>> uploadFullMethod =\n+                (stream, lengthUploaded) -> uploadWithResponse(ProgressReporter\n+                        .addProgressReporting(stream, validatedParallelTransferOptions.getProgressReceiver()),\n+                    fileOffset, length, headers, validatedUploadRequestConditions);\n+\n+            return createWithResponse(null, null, headers, metadata, requestConditions)\n+                .then(UploadUtils.determineUploadFullOrChunked(data, validatedParallelTransferOptions,\n+                uploadInChunksFunction, uploadFullMethod));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadInChunks(Flux<ByteBuffer> data, long fileOffset, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders httpHeaders,\n+        DataLakeRequestConditions requestConditions) {\n+        // See ProgressReporter for an explanation on why this lock is necessary and why we use AtomicLong.\n+        AtomicLong totalProgress = new AtomicLong();\n+        Lock progressLock = new ReentrantLock();\n+\n+        // Validation done in the constructor.\n+        UploadBufferPool pool = new UploadBufferPool(parallelTransferOptions.getNumBuffers(),\n+            parallelTransferOptions.getBlockSize(), MAX_APPEND_FILE_BYTES);\n+\n+        Flux<ByteBuffer> chunkedSource = UploadUtils.chunkSource(data, parallelTransferOptions);\n+\n+        /*\n+         Write to the pool and upload the output.\n+         */\n+        return chunkedSource.concatMap(pool::write)\n+            .concatWith(Flux.defer(pool::flush))\n+            /* Map the data to a tuple, writing in the buffer.remaining temporarily */\n+            .map(buffer -> Tuples.of(buffer, (long) buffer.remaining()))\n+            /* The tuple keeps track of the next buffer to write and the fileOffset for the next buffer */\n+            .scan((result, source) -> {", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1NDI3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382254273", "bodyText": "made a Tuple 3, and added a block comment.", "author": "gapra-msft", "createdAt": "2020-02-20T20:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNzk2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382227962", "bodyText": "I think then() is a bit of a cleaner way of doing this", "author": "rickle-msft", "createdAt": "2020-02-20T20:02:38Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders headers, Map<String, String> metadata,\n+        DataLakeRequestConditions requestConditions) {\n+        try {\n+            Objects.requireNonNull(data, \"'data' must not be null\");\n+            DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+                ? new DataLakeRequestConditions() : requestConditions;\n+            /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+             after creation, so remove them for the append/flush calls. */\n+            DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+                .setLeaseId(validatedRequestConditions.getLeaseId());\n+            final ParallelTransferOptions validatedParallelTransferOptions =\n+                ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+            long fileOffset = 0;\n+\n+            Function<Flux<ByteBuffer>, Mono<Response<PathInfo>>> uploadInChunksFunction = (stream) ->\n+                uploadInChunks(stream, fileOffset, length, validatedParallelTransferOptions, headers,\n+                    validatedUploadRequestConditions);\n+\n+            BiFunction<Flux<ByteBuffer>, Long, Mono<Response<PathInfo>>> uploadFullMethod =\n+                (stream, lengthUploaded) -> uploadWithResponse(ProgressReporter\n+                        .addProgressReporting(stream, validatedParallelTransferOptions.getProgressReceiver()),\n+                    fileOffset, length, headers, validatedUploadRequestConditions);\n+\n+            return createWithResponse(null, null, headers, metadata, requestConditions)\n+                .then(UploadUtils.determineUploadFullOrChunked(data, validatedParallelTransferOptions,\n+                uploadInChunksFunction, uploadFullMethod));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadInChunks(Flux<ByteBuffer> data, long fileOffset, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders httpHeaders,\n+        DataLakeRequestConditions requestConditions) {\n+        // See ProgressReporter for an explanation on why this lock is necessary and why we use AtomicLong.\n+        AtomicLong totalProgress = new AtomicLong();\n+        Lock progressLock = new ReentrantLock();\n+\n+        // Validation done in the constructor.\n+        UploadBufferPool pool = new UploadBufferPool(parallelTransferOptions.getNumBuffers(),\n+            parallelTransferOptions.getBlockSize(), MAX_APPEND_FILE_BYTES);\n+\n+        Flux<ByteBuffer> chunkedSource = UploadUtils.chunkSource(data, parallelTransferOptions);\n+\n+        /*\n+         Write to the pool and upload the output.\n+         */\n+        return chunkedSource.concatMap(pool::write)\n+            .concatWith(Flux.defer(pool::flush))\n+            /* Map the data to a tuple, writing in the buffer.remaining temporarily */\n+            .map(buffer -> Tuples.of(buffer, (long) buffer.remaining()))\n+            /* The tuple keeps track of the next buffer to write and the fileOffset for the next buffer */\n+            .scan((result, source) -> {\n+                ByteBuffer buffer = source.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long lastBytesWritten = result.getT2();\n+\n+                return Tuples.of(buffer, currentBufferLength + lastBytesWritten);\n+            })\n+            .flatMapSequential(tuple2 -> {\n+                ByteBuffer buffer = tuple2.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long currentOffset = tuple2.getT2() - currentBufferLength + fileOffset;\n+                // Report progress as necessary.\n+                Flux<ByteBuffer> progressData = ProgressReporter.addParallelProgressReporting(\n+                    Flux.just(buffer), parallelTransferOptions.getProgressReceiver(), progressLock, totalProgress);\n+                return appendWithResponse(progressData, currentOffset, currentBufferLength, null,\n+                    requestConditions.getLeaseId())\n+                    .doFinally(x -> pool.returnBuffer(buffer))\n+                    .flux();\n+            })\n+            .last()\n+            .flatMap(resp -> flushWithResponse(length, false, false, httpHeaders, requestConditions));", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3Njk1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382276951", "bodyText": "need to use flatmap now to pass length", "author": "gapra-msft", "createdAt": "2020-02-20T21:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNzk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNzM4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382237386", "bodyText": "Same comment about possibly abstracting uploadFromFile stuff", "author": "rickle-msft", "createdAt": "2020-02-20T20:23:08Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders headers, Map<String, String> metadata,\n+        DataLakeRequestConditions requestConditions) {\n+        try {\n+            Objects.requireNonNull(data, \"'data' must not be null\");\n+            DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+                ? new DataLakeRequestConditions() : requestConditions;\n+            /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+             after creation, so remove them for the append/flush calls. */\n+            DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+                .setLeaseId(validatedRequestConditions.getLeaseId());\n+            final ParallelTransferOptions validatedParallelTransferOptions =\n+                ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+            long fileOffset = 0;\n+\n+            Function<Flux<ByteBuffer>, Mono<Response<PathInfo>>> uploadInChunksFunction = (stream) ->\n+                uploadInChunks(stream, fileOffset, length, validatedParallelTransferOptions, headers,\n+                    validatedUploadRequestConditions);\n+\n+            BiFunction<Flux<ByteBuffer>, Long, Mono<Response<PathInfo>>> uploadFullMethod =\n+                (stream, lengthUploaded) -> uploadWithResponse(ProgressReporter\n+                        .addProgressReporting(stream, validatedParallelTransferOptions.getProgressReceiver()),\n+                    fileOffset, length, headers, validatedUploadRequestConditions);\n+\n+            return createWithResponse(null, null, headers, metadata, requestConditions)\n+                .then(UploadUtils.determineUploadFullOrChunked(data, validatedParallelTransferOptions,\n+                uploadInChunksFunction, uploadFullMethod));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadInChunks(Flux<ByteBuffer> data, long fileOffset, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders httpHeaders,\n+        DataLakeRequestConditions requestConditions) {\n+        // See ProgressReporter for an explanation on why this lock is necessary and why we use AtomicLong.\n+        AtomicLong totalProgress = new AtomicLong();\n+        Lock progressLock = new ReentrantLock();\n+\n+        // Validation done in the constructor.\n+        UploadBufferPool pool = new UploadBufferPool(parallelTransferOptions.getNumBuffers(),\n+            parallelTransferOptions.getBlockSize(), MAX_APPEND_FILE_BYTES);\n+\n+        Flux<ByteBuffer> chunkedSource = UploadUtils.chunkSource(data, parallelTransferOptions);\n+\n+        /*\n+         Write to the pool and upload the output.\n+         */\n+        return chunkedSource.concatMap(pool::write)\n+            .concatWith(Flux.defer(pool::flush))\n+            /* Map the data to a tuple, writing in the buffer.remaining temporarily */\n+            .map(buffer -> Tuples.of(buffer, (long) buffer.remaining()))\n+            /* The tuple keeps track of the next buffer to write and the fileOffset for the next buffer */\n+            .scan((result, source) -> {\n+                ByteBuffer buffer = source.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long lastBytesWritten = result.getT2();\n+\n+                return Tuples.of(buffer, currentBufferLength + lastBytesWritten);\n+            })\n+            .flatMapSequential(tuple2 -> {\n+                ByteBuffer buffer = tuple2.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long currentOffset = tuple2.getT2() - currentBufferLength + fileOffset;\n+                // Report progress as necessary.\n+                Flux<ByteBuffer> progressData = ProgressReporter.addParallelProgressReporting(\n+                    Flux.just(buffer), parallelTransferOptions.getProgressReceiver(), progressLock, totalProgress);\n+                return appendWithResponse(progressData, currentOffset, currentBufferLength, null,\n+                    requestConditions.getLeaseId())\n+                    .doFinally(x -> pool.returnBuffer(buffer))\n+                    .flux();\n+            })\n+            .last()\n+            .flatMap(resp -> flushWithResponse(length, false, false, httpHeaders, requestConditions));\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long fileOffset, long length,\n+        PathHttpHeaders httpHeaders, DataLakeRequestConditions requestConditions) {\n+        return appendWithResponse(data, fileOffset, length, null, requestConditions.getLeaseId())\n+            .flatMap(resp -> flushWithResponse(fileOffset + length, false, false, httpHeaders,\n+                requestConditions));\n+    }\n+\n+    /**\n+     * Creates a new file, with the content of the specified file. By default this method will not overwrite an\n+     * existing file.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadFromFile#String}\n+     *\n+     * @param filePath Path to the upload file\n+     * @return An empty response\n+     * @throws UncheckedIOException If an I/O error occurs\n+     */\n+    public Mono<Void> uploadFromFile(String filePath) {\n+        try {\n+            return uploadFromFile(filePath, false);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new file, with the content of the specified file.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadFromFile#String-boolean}\n+     *\n+     * @param filePath Path to the upload file\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return An empty response\n+     * @throws UncheckedIOException If an I/O error occurs\n+     */\n+    public Mono<Void> uploadFromFile(String filePath, boolean overwrite) {\n+        try {", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzOTQ4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382239480", "bodyText": "These I think can also move into the common utility, right?", "author": "rickle-msft", "createdAt": "2020-02-20T20:27:18Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders headers, Map<String, String> metadata,\n+        DataLakeRequestConditions requestConditions) {\n+        try {\n+            Objects.requireNonNull(data, \"'data' must not be null\");\n+            DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+                ? new DataLakeRequestConditions() : requestConditions;\n+            /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+             after creation, so remove them for the append/flush calls. */\n+            DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+                .setLeaseId(validatedRequestConditions.getLeaseId());\n+            final ParallelTransferOptions validatedParallelTransferOptions =\n+                ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+            long fileOffset = 0;\n+\n+            Function<Flux<ByteBuffer>, Mono<Response<PathInfo>>> uploadInChunksFunction = (stream) ->\n+                uploadInChunks(stream, fileOffset, length, validatedParallelTransferOptions, headers,\n+                    validatedUploadRequestConditions);\n+\n+            BiFunction<Flux<ByteBuffer>, Long, Mono<Response<PathInfo>>> uploadFullMethod =\n+                (stream, lengthUploaded) -> uploadWithResponse(ProgressReporter\n+                        .addProgressReporting(stream, validatedParallelTransferOptions.getProgressReceiver()),\n+                    fileOffset, length, headers, validatedUploadRequestConditions);\n+\n+            return createWithResponse(null, null, headers, metadata, requestConditions)\n+                .then(UploadUtils.determineUploadFullOrChunked(data, validatedParallelTransferOptions,\n+                uploadInChunksFunction, uploadFullMethod));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadInChunks(Flux<ByteBuffer> data, long fileOffset, long length,\n+        ParallelTransferOptions parallelTransferOptions, PathHttpHeaders httpHeaders,\n+        DataLakeRequestConditions requestConditions) {\n+        // See ProgressReporter for an explanation on why this lock is necessary and why we use AtomicLong.\n+        AtomicLong totalProgress = new AtomicLong();\n+        Lock progressLock = new ReentrantLock();\n+\n+        // Validation done in the constructor.\n+        UploadBufferPool pool = new UploadBufferPool(parallelTransferOptions.getNumBuffers(),\n+            parallelTransferOptions.getBlockSize(), MAX_APPEND_FILE_BYTES);\n+\n+        Flux<ByteBuffer> chunkedSource = UploadUtils.chunkSource(data, parallelTransferOptions);\n+\n+        /*\n+         Write to the pool and upload the output.\n+         */\n+        return chunkedSource.concatMap(pool::write)\n+            .concatWith(Flux.defer(pool::flush))\n+            /* Map the data to a tuple, writing in the buffer.remaining temporarily */\n+            .map(buffer -> Tuples.of(buffer, (long) buffer.remaining()))\n+            /* The tuple keeps track of the next buffer to write and the fileOffset for the next buffer */\n+            .scan((result, source) -> {\n+                ByteBuffer buffer = source.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long lastBytesWritten = result.getT2();\n+\n+                return Tuples.of(buffer, currentBufferLength + lastBytesWritten);\n+            })\n+            .flatMapSequential(tuple2 -> {\n+                ByteBuffer buffer = tuple2.getT1();\n+                long currentBufferLength = buffer.remaining();\n+                long currentOffset = tuple2.getT2() - currentBufferLength + fileOffset;\n+                // Report progress as necessary.\n+                Flux<ByteBuffer> progressData = ProgressReporter.addParallelProgressReporting(\n+                    Flux.just(buffer), parallelTransferOptions.getProgressReceiver(), progressLock, totalProgress);\n+                return appendWithResponse(progressData, currentOffset, currentBufferLength, null,\n+                    requestConditions.getLeaseId())\n+                    .doFinally(x -> pool.returnBuffer(buffer))\n+                    .flux();\n+            })\n+            .last()\n+            .flatMap(resp -> flushWithResponse(length, false, false, httpHeaders, requestConditions));\n+    }\n+\n+    private Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long fileOffset, long length,\n+        PathHttpHeaders httpHeaders, DataLakeRequestConditions requestConditions) {\n+        return appendWithResponse(data, fileOffset, length, null, requestConditions.getLeaseId())\n+            .flatMap(resp -> flushWithResponse(fileOffset + length, false, false, httpHeaders,\n+                requestConditions));\n+    }\n+\n+    /**\n+     * Creates a new file, with the content of the specified file. By default this method will not overwrite an\n+     * existing file.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadFromFile#String}\n+     *\n+     * @param filePath Path to the upload file\n+     * @return An empty response\n+     * @throws UncheckedIOException If an I/O error occurs\n+     */\n+    public Mono<Void> uploadFromFile(String filePath) {\n+        try {\n+            return uploadFromFile(filePath, false);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new file, with the content of the specified file.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadFromFile#String-boolean}\n+     *\n+     * @param filePath Path to the upload file\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return An empty response\n+     * @throws UncheckedIOException If an I/O error occurs\n+     */\n+    public Mono<Void> uploadFromFile(String filePath, boolean overwrite) {\n+        try {\n+            Mono<Void> overwriteCheck = Mono.empty();\n+            DataLakeRequestConditions requestConditions = null;\n+\n+            // Note that if the file will be uploaded using a putBlob, we also can skip the exists check.\n+            if (!overwrite) {\n+                if (uploadInBlocks(filePath, DataLakeFileAsyncClient.MAX_APPEND_FILE_BYTES)) {\n+                    overwriteCheck = exists().flatMap(exists -> exists\n+                        ? monoError(logger, new IllegalArgumentException(Constants.FILE_ALREADY_EXISTS))\n+                        : Mono.empty());\n+                }\n+\n+                requestConditions = new DataLakeRequestConditions()\n+                    .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+            }\n+\n+            return overwriteCheck.then(uploadFromFile(filePath, null, null, null, requestConditions));\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    /**\n+     * Creates a new file, with the content of the specified file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadFromFile#String-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * @param filePath Path to the upload file\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} to use to upload from file. Number of parallel\n+     * transfers parameter is ignored.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return An empty response\n+     * @throws UncheckedIOException If an I/O error occurs\n+     */\n+    public Mono<Void> uploadFromFile(String filePath, ParallelTransferOptions parallelTransferOptions,\n+        PathHttpHeaders headers, Map<String, String> metadata, DataLakeRequestConditions requestConditions) {\n+        Integer originalBlockSize = (parallelTransferOptions == null)\n+            ? null\n+            : parallelTransferOptions.getBlockSize();\n+\n+        DataLakeRequestConditions validatedRequestConditions = requestConditions == null\n+            ? new DataLakeRequestConditions() : requestConditions;\n+        /* Since we are creating a file with the request conditions, everything but lease id becomes invalid\n+           after creation, so e remove them for the append/flush calls. */\n+        DataLakeRequestConditions validatedUploadRequestConditions = new DataLakeRequestConditions()\n+            .setLeaseId(validatedRequestConditions.getLeaseId());\n+\n+        final ParallelTransferOptions finalParallelTransferOptions =\n+            ModelHelper.populateAndApplyDefaults(parallelTransferOptions);\n+        long fileOffset = 0;\n+\n+        try {\n+            return Mono.using(() -> uploadFileResourceSupplier(filePath),\n+                channel -> {\n+                    try {\n+                        long fileSize = channel.size();\n+\n+                        if (fileSize == 0) {\n+                            throw logger.logExceptionAsError(new IllegalArgumentException(\"Size of the file must be \"\n+                                + \"greater than 0.\"));\n+                        }\n+                        if (uploadInBlocks(filePath, finalParallelTransferOptions.getMaxSingleUploadSize())) {\n+                            return createWithResponse(null, null, headers, metadata, validatedRequestConditions)\n+                                .then(uploadBlocks(fileOffset, fileSize, finalParallelTransferOptions,\n+                                originalBlockSize, headers, validatedUploadRequestConditions, channel));\n+                        } else {\n+                            // Otherwise we know it can be sent in a single request reducing network overhead.\n+                            return createWithResponse(null, null, headers, metadata, validatedRequestConditions)\n+                                .then(uploadWithResponse(FluxUtil.readFile(channel), fileOffset, fileSize, headers,\n+                                validatedUploadRequestConditions))\n+                                .then();\n+                        }\n+\n+                    } catch (IOException ex) {\n+                        return Mono.error(ex);\n+                    }\n+                }, this::uploadFileCleanup);\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    boolean uploadInBlocks(String filePath, Integer maxSingleUploadSize) {\n+        AsynchronousFileChannel channel = uploadFileResourceSupplier(filePath);\n+        boolean retVal;\n+        try {\n+            retVal = channel.size() > maxSingleUploadSize;\n+        } catch (IOException e) {\n+            throw logger.logExceptionAsError(new UncheckedIOException(e));\n+        } finally {\n+            uploadFileCleanup(channel);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    private Mono<Void> uploadBlocks(long fileOffset, long fileSize, ParallelTransferOptions parallelTransferOptions,\n+        Integer originalBlockSize, PathHttpHeaders headers, DataLakeRequestConditions requestConditions,\n+        AsynchronousFileChannel channel) {\n+        // parallelTransferOptions are finalized in the calling method.\n+\n+        // See ProgressReporter for an explanation on why this lock is necessary and why we use AtomicLong.\n+        AtomicLong totalProgress = new AtomicLong();\n+        Lock progressLock = new ReentrantLock();\n+\n+        return Flux.fromIterable(sliceFile(fileSize, originalBlockSize, parallelTransferOptions.getBlockSize()))\n+            .flatMap(chunk -> {\n+                Flux<ByteBuffer> progressData = ProgressReporter.addParallelProgressReporting(\n+                    FluxUtil.readFile(channel, chunk.getOffset(), chunk.getCount()),\n+                    parallelTransferOptions.getProgressReceiver(), progressLock, totalProgress);\n+\n+                return appendWithResponse(progressData, fileOffset + chunk.getOffset(), chunk.getCount(), null,\n+                    requestConditions.getLeaseId());\n+            })\n+            .then(Mono.defer(() ->\n+                flushWithResponse(fileSize, false, false, headers, requestConditions)))\n+            .then();\n+    }\n+\n+    /**\n+     * RESERVED FOR INTERNAL USE.\n+     *\n+     * Resource Supplier for UploadFile.\n+     *\n+     * @param filePath The path for the file\n+     * @return {@code AsynchronousFileChannel}\n+     * @throws UncheckedIOException an input output exception.\n+     */\n+    protected AsynchronousFileChannel uploadFileResourceSupplier(String filePath) {\n+        try {\n+            return AsynchronousFileChannel.open(Paths.get(filePath), StandardOpenOption.READ);\n+        } catch (IOException e) {\n+            throw logger.logExceptionAsError(new UncheckedIOException(e));\n+        }\n+    }\n+\n+    private void uploadFileCleanup(AsynchronousFileChannel channel) {\n+        try {\n+            channel.close();\n+        } catch (IOException e) {\n+            throw logger.logExceptionAsError(new UncheckedIOException(e));\n+        }\n+    }\n+\n+    private List<FileRange> sliceFile(long fileSize, Integer originalBlockSize, int blockSize) {\n+        List<FileRange> ranges = new ArrayList<>();\n+        if (fileSize > 100 * Constants.MB && originalBlockSize == null) {\n+            blockSize = BlobAsyncClient.BLOB_DEFAULT_HTBB_UPLOAD_BLOCK_SIZE;\n+        }\n+        for (long pos = 0; pos < fileSize; pos += blockSize) {\n+            long count = blockSize;\n+            if (pos + count > fileSize) {\n+                count = fileSize - pos;\n+            }\n+            ranges.add(new FileRange(pos, count));\n+        }\n+        return ranges;", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI1NjQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382256461", "bodyText": "yep, there was some difficulty with some of the logging stuff but it should go in common - I'll work on that", "author": "gapra-msft", "createdAt": "2020-02-20T21:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzOTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NzU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382247575", "bodyText": "Remove the length parameter as buffered upload should be able to calculate it.", "author": "rickle-msft", "createdAt": "2020-02-20T20:45:28Z", "path": "sdk/storage/azure-storage-file-datalake/src/main/java/com/azure/storage/file/datalake/DataLakeFileAsyncClient.java", "diffHunk": "@@ -148,6 +183,368 @@ public String getFileName() {\n \n     }\n \n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions) {\n+        return upload(data, length, parallelTransferOptions, false);\n+    }\n+\n+    /**\n+     * Creates a new file and uploads content.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.upload#Flux-long-ParallelTransferOptions-boolean}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param overwrite Whether or not to overwrite, should the file already exist.\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<PathInfo> upload(Flux<ByteBuffer> data, long length, ParallelTransferOptions parallelTransferOptions,\n+        boolean overwrite) {\n+\n+        Mono<Void> overwriteCheck;\n+        DataLakeRequestConditions requestConditions;\n+\n+        if (overwrite) {\n+            overwriteCheck = Mono.empty();\n+            requestConditions = null;\n+        } else {\n+            overwriteCheck = exists().flatMap(exists -> exists\n+                ? monoError(logger, new IllegalArgumentException(Constants.BLOB_ALREADY_EXISTS))\n+                : Mono.empty());\n+            requestConditions = new DataLakeRequestConditions()\n+                .setIfNoneMatch(Constants.HeaderConstants.ETAG_WILDCARD);\n+        }\n+\n+        return overwriteCheck\n+            .then(uploadWithResponse(data, length, parallelTransferOptions, null, null, requestConditions))\n+            .flatMap(FluxUtil::toMono);\n+    }\n+\n+    /**\n+     * Creates a new file.\n+     * <p>\n+     * To avoid overwriting, pass \"*\" to {@link DataLakeRequestConditions#setIfNoneMatch(String)}.\n+     *\n+     * <p><strong>Code Samples</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions}\n+     *\n+     * <p><strong>Using Progress Reporting</strong></p>\n+     *\n+     * {@codesnippet com.azure.storage.file.datalake.DataLakeFileAsyncClient.uploadWithResponse#Flux-long-ParallelTransferOptions-PathHttpHeaders-Map-DataLakeRequestConditions.ProgressReporter}\n+     *\n+     * @param data The data to write to the file. Unlike other upload methods, this method does not require that the\n+     * {@code Flux} be replayable. In other words, it does not have to support multiple subscribers and is not expected\n+     * to produce the same values across subscriptions.\n+     * @param length The exact length of the data. It is important that this value match precisely the length of the\n+     * data emitted by the {@code Flux}.\n+     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n+     * @param headers {@link PathHttpHeaders}\n+     * @param metadata Metadata to associate with the resource.\n+     * @param requestConditions {@link DataLakeRequestConditions}\n+     * @return A reactive response containing the information of the uploaded file.\n+     */\n+    public Mono<Response<PathInfo>> uploadWithResponse(Flux<ByteBuffer> data, long length,", "originalCommit": "94a87aabf71bf99546069295bc174b76736e2bce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI3Njc2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382276769", "bodyText": "done", "author": "gapra-msft", "createdAt": "2020-02-20T21:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0NzU3NQ=="}], "type": "inlineReview"}, {"oid": "cf824a499e199ae1995327111a9de363b33362ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf824a499e199ae1995327111a9de363b33362ab", "message": "addressed a few PR comments", "committedDate": "2020-02-20T21:56:17Z", "type": "commit"}, {"oid": "ad33c8978eb7d98ad0887d1888dc5f387e646f0f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ad33c8978eb7d98ad0887d1888dc5f387e646f0f", "message": "refactored upload from file methods", "committedDate": "2020-02-20T22:38:24Z", "type": "commit"}, {"oid": "124f5b8eca552c2871cc4a16672bc782b8ecd489", "url": "https://github.com/Azure/azure-sdk-for-java/commit/124f5b8eca552c2871cc4a16672bc782b8ecd489", "message": "fixed analyze step", "committedDate": "2020-02-20T22:48:38Z", "type": "commit"}, {"oid": "b85393d3f586342249bf58744020163971ed0b19", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b85393d3f586342249bf58744020163971ed0b19", "message": "Added back protected method", "committedDate": "2020-02-20T22:56:34Z", "type": "commit"}, {"oid": "5d1f4c1aa4fd79ae6e31bde277ab2bbeb8b9e777", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5d1f4c1aa4fd79ae6e31bde277ab2bbeb8b9e777", "message": "removed unused import", "committedDate": "2020-02-20T23:34:01Z", "type": "commit"}, {"oid": "40e3b37e29b446f1f4132bc3177d06fa6bef518d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/40e3b37e29b446f1f4132bc3177d06fa6bef518d", "message": "changed request conditions to validated conditions", "committedDate": "2020-02-20T23:44:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzYzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382347634", "bodyText": "Because this class is blocking, and because it will block for significant amounts of time given we're handling buffers with it, we should wrap it in a reactive data structure using the tips described here for wrapping synchronous, blocking calls.", "author": "jaschrep-msft", "createdAt": "2020-02-21T01:11:17Z", "path": "sdk/storage/azure-storage-common/src/main/java/com/azure/storage/common/implementation/UploadBufferPool.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.storage.common.implementation;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import reactor.core.publisher.Flux;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * This type is to support the implementation of buffered upload only. It is mandatory that the caller has broken the\n+ * source into ByteBuffers that are no greater than the size of a chunk and therefore a buffer in the pool. This is\n+ * necessary because it upper bounds the number of buffers we need for a given call to write() to 2. If the size of\n+ * ByteBuffer passed into write() were unbounded, the pool could stall as it would run out of buffers before it is able\n+ * to return a result, and if it is unable to return, no data can be uploaded and therefore no pools returned.\n+ *\n+ * It is incumbent upon the caller to return the buffers after an upload is completed. It is also the caller's\n+ * responsibility to signal to the pool when the stream is empty and call flush to return any data still sitting in the\n+ * pool.\n+ *\n+ * Broadly, the workflow of this operation is to chunk the source into reasonable sized pieces. On each piece, one\n+ * thread will call write on the pool. The pool will grab a buffer from the queue to write to, possibly waiting for one\n+ * to be available, and either store the incomplete buffer to be filled on the next write or return the filled buffer to\n+ * be sent. Filled buffers can be uploaded in parallel and should return buffers to the pool after the upload completes.\n+ * Once the source terminates, it should call flush.\n+ *\n+ * RESERVED FOR INTERNAL USE ONLY\n+ */\n+public final class UploadBufferPool {\n+    private final ClientLogger logger = new ClientLogger(UploadBufferPool.class);\n+\n+    /*\n+    Note that a blocking on a synchronized object is not the same as blocking on a reactive operation; blocking on this\n+    queue will not compromise the async nature of this workflow. Fluxes themselves are internally synchronized to ensure\n+    only one call to onNext happens at a time.\n+     */\n+    private final BlockingQueue<ByteBuffer> buffers;", "originalCommit": "40e3b37e29b446f1f4132bc3177d06fa6bef518d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcwMDM4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382700387", "bodyText": "Just cause this class was a straight up copy paste from what exists in blobs, and it shouldnt affect any public APIs, I'll create an issue for this", "author": "gapra-msft", "createdAt": "2020-02-21T17:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcxNDE3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8302#discussion_r382714170", "bodyText": "#8382", "author": "gapra-msft", "createdAt": "2020-02-21T17:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzYzNA=="}], "type": "inlineReview"}, {"oid": "392203656238aa364da8089c59da66fda52dd245", "url": "https://github.com/Azure/azure-sdk-for-java/commit/392203656238aa364da8089c59da66fda52dd245", "message": "Added changes according to PR comments", "committedDate": "2020-02-21T17:06:59Z", "type": "commit"}]}