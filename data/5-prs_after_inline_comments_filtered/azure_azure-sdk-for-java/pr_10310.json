{"pr_number": 10310, "pr_title": "Serialization and deserialization handling of types with discriminator", "pr_createdAt": "2020-04-16T21:13:07Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10310", "timeline": [{"oid": "1f89457e2daeebcff82e4451435a6578b87c22ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f89457e2daeebcff82e4451435a6578b87c22ee", "message": "Updating Flattening serializer and deserializer to fully support discriminator, nested types with flattening properties", "committedDate": "2020-04-16T20:48:47Z", "type": "commit"}, {"oid": "aeaf8195de479f04954d789a55740b2c0fddd9a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aeaf8195de479f04954d789a55740b2c0fddd9a4", "message": "moving model types from test entities to test serializer package.", "committedDate": "2020-04-16T20:54:04Z", "type": "commit"}, {"oid": "aa3baef3cd3882de7d805ce60f3262c39b1b9dfc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aa3baef3cd3882de7d805ce60f3262c39b1b9dfc", "message": "Minor addition to AdditionalPropertiesSerializerTests to validate extra cases", "committedDate": "2020-04-16T20:55:23Z", "type": "commit"}, {"oid": "14715214f0bf97316d3bf536047be8202200fb57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/14715214f0bf97316d3bf536047be8202200fb57", "message": "Adding more code coverage to flattening and typeId scenarios.", "committedDate": "2020-04-16T20:57:40Z", "type": "commit"}, {"oid": "9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "message": "opening test models in azure-core-test entities pkg to azure-core", "committedDate": "2020-04-16T21:58:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NTk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409885986", "bodyText": "Given this is in a for loop could the failing if checks be inverted and continue? It'll flatten the indentation level and should me this easier to read.", "author": "alzimmermsft", "createdAt": "2020-04-16T22:30:50Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/FlatteningDeserializer.java", "diffHunk": "@@ -65,58 +68,185 @@ public static SimpleModule getModule(final ObjectMapper mapper) {\n         SimpleModule module = new SimpleModule();\n         module.setDeserializerModifier(new BeanDeserializerModifier() {\n             @Override\n-            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc,\n+            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n+                                                          BeanDescription beanDesc,\n                                                           JsonDeserializer<?> deserializer) {\n-                if (beanDesc.getBeanClass().getAnnotation(JsonFlatten.class) != null) {\n+                if (BeanDeserializer.class.isAssignableFrom(deserializer.getClass())) {\n+                    // Register 'FlatteningDeserializer' for complex type so that 'deserializeWithType'\n+                    // will get called for complex types and it can analyze typeId discriminator.\n                     return new FlatteningDeserializer(beanDesc.getBeanClass(), deserializer, mapper);\n+                } else {\n+                    return deserializer;\n                 }\n-                return deserializer;\n             }\n         });\n         return module;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        JsonNode root = mapper.readTree(jp);\n+    public Object deserializeWithType(JsonParser jp,\n+                                      DeserializationContext cxt,\n+                                      TypeDeserializer tDeserializer) throws IOException {\n+        // This method will be called from Jackson for each \"Json object with TypeId\" as it\n+        // process the input data. This enable us to pre-process then give it to the next\n+        // deserializer in the Jackson pipeline.\n+        //\n+        // The parameter 'jp' is the reader to read \"Json object with TypeId\"\n+        //\n+        JsonNode currentJsonNode = mapper.readTree(jp);\n         final Class<?> tClass = this.defaultDeserializer.handledType();\n         for (Class<?> c : TypeUtil.getAllClasses(tClass)) {\n-            // Ignore checks for Object type.\n             if (c.isAssignableFrom(Object.class)) {\n                 continue;\n-            }\n-            for (Field field : c.getDeclaredFields()) {\n-                JsonNode node = root;\n-                JsonProperty property = field.getAnnotation(JsonProperty.class);\n-                if (property != null) {\n-                    String value = property.value();\n-                    if (value.matches(\".+[^\\\\\\\\]\\\\..+\")) {\n-                        String[] values = value.split(\"((?<!\\\\\\\\))\\\\.\");\n-                        for (String val : values) {\n-                            val = val.replace(\"\\\\.\", \".\");\n-                            node = node.get(val);\n-                            if (node == null) {\n-                                break;\n-                            }\n-                        }\n-                        // If additional properties have a conflicting key, escape the additional property's key\n-                        if (root.has(value)) {\n-                            String escapedValue = value.replace(\".\", \"\\\\.\");\n-                            ((ObjectNode) root).set(escapedValue, root.get(value));\n+            } else {\n+                final JsonTypeInfo typeInfo = c.getAnnotation(com.fasterxml.jackson.annotation.JsonTypeInfo.class);\n+                if (typeInfo != null) {", "originalCommit": "9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1Mjc4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410352789", "bodyText": "cool, yes we can invert this and make more readable.", "author": "anuchandy", "createdAt": "2020-04-17T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4NTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwODkxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409908916", "bodyText": "Should we just cast this to ObjectNode ahead of time so we don't need to cast all the time later in the method?", "author": "alzimmermsft", "createdAt": "2020-04-16T23:36:52Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/FlatteningDeserializer.java", "diffHunk": "@@ -65,58 +68,185 @@ public static SimpleModule getModule(final ObjectMapper mapper) {\n         SimpleModule module = new SimpleModule();\n         module.setDeserializerModifier(new BeanDeserializerModifier() {\n             @Override\n-            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc,\n+            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n+                                                          BeanDescription beanDesc,\n                                                           JsonDeserializer<?> deserializer) {\n-                if (beanDesc.getBeanClass().getAnnotation(JsonFlatten.class) != null) {\n+                if (BeanDeserializer.class.isAssignableFrom(deserializer.getClass())) {\n+                    // Register 'FlatteningDeserializer' for complex type so that 'deserializeWithType'\n+                    // will get called for complex types and it can analyze typeId discriminator.\n                     return new FlatteningDeserializer(beanDesc.getBeanClass(), deserializer, mapper);\n+                } else {\n+                    return deserializer;\n                 }\n-                return deserializer;\n             }\n         });\n         return module;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        JsonNode root = mapper.readTree(jp);\n+    public Object deserializeWithType(JsonParser jp,\n+                                      DeserializationContext cxt,\n+                                      TypeDeserializer tDeserializer) throws IOException {\n+        // This method will be called from Jackson for each \"Json object with TypeId\" as it\n+        // process the input data. This enable us to pre-process then give it to the next\n+        // deserializer in the Jackson pipeline.\n+        //\n+        // The parameter 'jp' is the reader to read \"Json object with TypeId\"\n+        //\n+        JsonNode currentJsonNode = mapper.readTree(jp);", "originalCommit": "9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410351023", "bodyText": "Please see the below comment on upcasting based on the presence of jsonProperty, similar constraint applied here but based on the presence of JsonTypeInfo.", "author": "anuchandy", "createdAt": "2020-04-17T16:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwODkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwOTk5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409909993", "bodyText": "Should we just use ObjectNode?", "author": "alzimmermsft", "createdAt": "2020-04-16T23:40:14Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/FlatteningDeserializer.java", "diffHunk": "@@ -65,58 +68,185 @@ public static SimpleModule getModule(final ObjectMapper mapper) {\n         SimpleModule module = new SimpleModule();\n         module.setDeserializerModifier(new BeanDeserializerModifier() {\n             @Override\n-            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc,\n+            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n+                                                          BeanDescription beanDesc,\n                                                           JsonDeserializer<?> deserializer) {\n-                if (beanDesc.getBeanClass().getAnnotation(JsonFlatten.class) != null) {\n+                if (BeanDeserializer.class.isAssignableFrom(deserializer.getClass())) {\n+                    // Register 'FlatteningDeserializer' for complex type so that 'deserializeWithType'\n+                    // will get called for complex types and it can analyze typeId discriminator.\n                     return new FlatteningDeserializer(beanDesc.getBeanClass(), deserializer, mapper);\n+                } else {\n+                    return deserializer;\n                 }\n-                return deserializer;\n             }\n         });\n         return module;\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        JsonNode root = mapper.readTree(jp);\n+    public Object deserializeWithType(JsonParser jp,\n+                                      DeserializationContext cxt,\n+                                      TypeDeserializer tDeserializer) throws IOException {\n+        // This method will be called from Jackson for each \"Json object with TypeId\" as it\n+        // process the input data. This enable us to pre-process then give it to the next\n+        // deserializer in the Jackson pipeline.\n+        //\n+        // The parameter 'jp' is the reader to read \"Json object with TypeId\"\n+        //\n+        JsonNode currentJsonNode = mapper.readTree(jp);\n         final Class<?> tClass = this.defaultDeserializer.handledType();\n         for (Class<?> c : TypeUtil.getAllClasses(tClass)) {\n-            // Ignore checks for Object type.\n             if (c.isAssignableFrom(Object.class)) {\n                 continue;\n-            }\n-            for (Field field : c.getDeclaredFields()) {\n-                JsonNode node = root;\n-                JsonProperty property = field.getAnnotation(JsonProperty.class);\n-                if (property != null) {\n-                    String value = property.value();\n-                    if (value.matches(\".+[^\\\\\\\\]\\\\..+\")) {\n-                        String[] values = value.split(\"((?<!\\\\\\\\))\\\\.\");\n-                        for (String val : values) {\n-                            val = val.replace(\"\\\\.\", \".\");\n-                            node = node.get(val);\n-                            if (node == null) {\n-                                break;\n-                            }\n-                        }\n-                        // If additional properties have a conflicting key, escape the additional property's key\n-                        if (root.has(value)) {\n-                            String escapedValue = value.replace(\".\", \"\\\\.\");\n-                            ((ObjectNode) root).set(escapedValue, root.get(value));\n+            } else {\n+                final JsonTypeInfo typeInfo = c.getAnnotation(com.fasterxml.jackson.annotation.JsonTypeInfo.class);\n+                if (typeInfo != null) {\n+                    String typeId = typeInfo.property();\n+                    if (containsDot(typeId)) {\n+                        final String typeIdOnWire = unescapeEscapedDots(typeId);\n+                        JsonNode typeIdValue = ((ObjectNode) currentJsonNode).remove(typeIdOnWire);\n+                        if (typeIdValue != null) {\n+                            ((ObjectNode) currentJsonNode).put(typeId, typeIdValue);\n                         }\n-                        ((ObjectNode) root).set(value, node);\n                     }\n                 }\n             }\n         }\n-        JsonParser parser = new JsonFactory().createParser(root.toString());\n-        parser.nextToken();\n-        return defaultDeserializer.deserialize(parser, ctxt);\n+        return tDeserializer.deserializeTypedFromAny(newJsonParserForNode(currentJsonNode), cxt);\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext cxt) throws IOException {\n+        // This method will be called by Jackson for each \"Json object\" in the input wire stream\n+        // it is trying to deserialize.\n+        //\n+        // The parameter 'jp' is the reader to read \"Json object with TypeId\"\n+        //\n+        JsonNode currentJsonNode = mapper.readTree(jp);\n+        if (currentJsonNode.isNull()) {\n+            currentJsonNode = mapper.getNodeFactory().objectNode();\n+        }\n+        final Class<?> tClass = this.defaultDeserializer.handledType();\n+        for (Class<?> c : TypeUtil.getAllClasses(tClass)) {\n+            if (c.isAssignableFrom(Object.class)) {\n+                continue;\n+            } else {\n+                for (Field classField : c.getDeclaredFields()) {\n+                    handleFlatteningForField(classField, currentJsonNode);\n+                }\n+            }\n+        }\n+        return this.defaultDeserializer.deserialize(newJsonParserForNode(currentJsonNode), cxt);\n     }\n \n     @Override\n-    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n-        ((ResolvableDeserializer) defaultDeserializer).resolve(ctxt);\n+    public void resolve(DeserializationContext cxt) throws JsonMappingException {\n+        ((ResolvableDeserializer) this.defaultDeserializer).resolve(cxt);\n+    }\n+\n+    /**\n+     * Given a field of a POJO class and JsonNode corresponds to the same POJO class,\n+     * check field's {@link JsonProperty} has flattening dots in it if so\n+     * flatten the nested child JsonNode corresponds to the field in the given JsonNode.\n+     *\n+     * @param classField the field in a POJO class\n+     * @param jsonNode the json node corresponds to POJO class that field belongs to\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private static void handleFlatteningForField(Field classField, JsonNode jsonNode) {", "originalCommit": "9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM0OTQ3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410349470", "bodyText": "I'm not sure we should do the upcasting ahead - w.r.t jsonProperty lookup and modification in this method, we're trying not to move away from the current logic (in released versions) to mutate ObjectNode. The ObjectNode is type extending from JsonNode and today we do the upcasting only if we find it has jsonProperty, but if we have to take ObjectNode here then we have to do the upcasting for all nodes from the caller.\nAn example is - In calling side, when we attempted to assign the value of readTree to ObjectNode, there happened a runtime cast exception where readTree returned NullNode which is not an ObjectNode but JsonNode, and auto-casting based on receiving variable type failed.", "author": "anuchandy", "createdAt": "2020-04-17T16:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwOTk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1NDM4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410354388", "bodyText": "For reference: upcasting in released versions here, see line-91  where we do check for annotation presence before the upcast, the same pattern followed in this PR.", "author": "anuchandy", "createdAt": "2020-04-17T17:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkwOTk5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409949679", "bodyText": "I am not sure if opening it up is good or bad at this point.\nHere is a bug in track1 that kind of caused by open-up (not really, but previous class not under \"@JsonFlatten\" will not be affected, but now it will, and hence the bug)\nAzure/autorest-clientruntime-for-java#663\nAnd we got this one there\n#8372\nJust saying it could be risky if there is unfixed or even unknown bug.", "author": "weidongxu-microsoft", "createdAt": "2020-04-17T02:03:00Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/FlatteningDeserializer.java", "diffHunk": "@@ -65,58 +68,185 @@ public static SimpleModule getModule(final ObjectMapper mapper) {\n         SimpleModule module = new SimpleModule();\n         module.setDeserializerModifier(new BeanDeserializerModifier() {\n             @Override\n-            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BeanDescription beanDesc,\n+            public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n+                                                          BeanDescription beanDesc,\n                                                           JsonDeserializer<?> deserializer) {\n-                if (beanDesc.getBeanClass().getAnnotation(JsonFlatten.class) != null) {\n+                if (BeanDeserializer.class.isAssignableFrom(deserializer.getClass())) {", "originalCommit": "9f08fd5315cbe2fb1f8b7c14a3c30a01b64a36b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk3MDIzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409970231", "bodyText": "I think we're safe to do this in \"deserializer\" because in deserialization path we always check for JsonProperty value and if it has un-escaped dots then it means \"do flatten\", right?\n\\cc @jianghaolu - please chime if this interpretation in \"deserialization\" context is wrong", "author": "anuchandy", "createdAt": "2020-04-17T03:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MjUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r409982512", "bodyText": "Sorry, I think I mean the same place in FlatteningSerializer (it is opened-up as well). Both bug referred is happening in serialization stage.", "author": "weidongxu-microsoft", "createdAt": "2020-04-17T04:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5ODY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410398643", "bodyText": "Right, this PR is to address the discriminated type \"deserialization\" issue, #10217.\nThanks for the heads-up on the \"serialization\" path. Reverted the  FlatteningSerializer, so there won't be any change in the FlatteningSerializer and \"serialization\" logic stay as it is. This means the track1 issue with template \"serialization\" \"663\" will not happen when using azure-core. The \"8372\" is a different issue, and this PR does not address it.", "author": "anuchandy", "createdAt": "2020-04-17T18:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410455418", "bodyText": "@weidongxu-microsoft  - reg -  I had a chat with Jinaghao on AutoRest logic associated with escaping dots in JsonProperty. Such escaping will be done only if the properties in the parent type have to include non-escaped dots, this means we should limit the application of Deserializer only to JsonFlatten annotated types.", "author": "anuchandy", "createdAt": "2020-04-17T20:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU0MjM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10310#discussion_r410542359", "bodyText": "@anuchandy Got it, as well as the required \"@JsonFlatten\" on there classes as well.\nOne question, at least for the ARM template (which should not have any flatten in there), should we always use readValue to convert json to an Object (as LinkedHashMap), instead of using readTree to ObjectNode, so that if FlattenSerializer got involved, it could still escape the \".\" as it is now a Map with nested Maps?", "author": "weidongxu-microsoft", "createdAt": "2020-04-18T01:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk0OTY3OQ=="}], "type": "inlineReview"}, {"oid": "27c8b79cd197360afc120ad27520893c59642837", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27c8b79cd197360afc120ad27520893c59642837", "message": "Reverting FlatteningSerializer: same as current FlatteningSerlizer ou there, updating newly added tests to include JsonFlatten", "committedDate": "2020-04-17T18:26:50Z", "type": "commit"}, {"oid": "092dbd1f81962178e8a4cc0a7b97033d7d5f04c5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/092dbd1f81962178e8a4cc0a7b97033d7d5f04c5", "message": "FlattteningDeserializer: improve code readbility", "committedDate": "2020-04-17T18:27:31Z", "type": "commit"}, {"oid": "ef473fea365ccc109482f2c9a07d45abe7f22e18", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ef473fea365ccc109482f2c9a07d45abe7f22e18", "message": "removing jacoco.exec that was added by mistake", "committedDate": "2020-04-17T20:34:23Z", "type": "commit"}, {"oid": "3183d6fca5e04883ff11e5a5a3b7e8f7da44abb2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3183d6fca5e04883ff11e5a5a3b7e8f7da44abb2", "message": "Limit FlatteningDeserializer to JsonFlatten annotated type", "committedDate": "2020-04-17T23:58:40Z", "type": "commit"}]}