{"pr_number": 10660, "pr_title": "Add Schema Registry Client SDK", "pr_createdAt": "2020-05-01T05:58:32Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10660", "timeline": [{"oid": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "url": "https://github.com/Azure/azure-sdk-for-java/commit/29f7f6c0130463e16bb643a6b3f0e27375ebed50", "message": "init", "committedDate": "2020-05-01T05:51:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjI5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522297", "bodyText": "ClientLogger defined in azure-core should be used for logging.", "author": "srnagar", "createdAt": "2020-05-01T12:32:09Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.schemaregistry.client.rest.RestService;\n+import com.azure.schemaregistry.client.rest.entities.responses.SchemaObjectResponse;\n+import com.azure.schemaregistry.client.rest.exceptions.RestClientException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ *\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ *\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SRObject cache by GUID - accessed when consuming, store GUIDs previously seen in payloads\n+ * - SRObject cache by schema string - accessed when sending, minimizes HTTP calls when payloads of same schema\n+ *\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClient.Builder Follows static builder pattern for object instantiation\n+ */\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private static final Logger log = LoggerFactory.getLogger(CachedSchemaRegistryClient.class);", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjUzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522530", "bodyText": "License text should be:\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.", "author": "srnagar", "createdAt": "2020-05-01T12:32:54Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMjk1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418522955", "bodyText": "Each package should also include a package-info.java. See an example here", "author": "srnagar", "createdAt": "2020-05-01T12:34:11Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMzMyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418523327", "bodyText": "Mocks should be in src/test/java", "author": "srnagar", "createdAt": "2020-05-01T12:35:23Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class MockSchemaRegistryClient implements SchemaRegistryClient {", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwMjcxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r428202713", "bodyText": "Moved MockSchemaRegistryClient to test directory of serde-common, where it's actually used.", "author": "arerlend", "createdAt": "2020-05-20T17:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyMzMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNDMyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418524327", "bodyText": "Consider naming this as SchemaRegistryObject instead. See naming patterns", "author": "srnagar", "createdAt": "2020-05-01T12:38:51Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/SRObject.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.schemaregistry.client.rest.RestService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ *\n+ * @param <T> is derived from the parser function that is passed in the constructor.\n+ */\n+public class SRObject<T> {", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwMjkxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r428202916", "bodyText": "Renamed.  Also took out generic parameter since it is unnecessary.", "author": "arerlend", "createdAt": "2020-05-20T17:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyNDMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyODIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418528203", "bodyText": "Add module-info.java for all new modules.", "author": "srnagar", "createdAt": "2020-05-01T12:51:54Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyOTk1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418529957", "bodyText": "azure-core has an HTTP client interface that should be used for making REST calls. We have 3 pluggable HTTP client implementations - Netty, OkHttp and JDK 11 HTTP client.", "author": "srnagar", "createdAt": "2020-05-01T12:57:44Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -0,0 +1,376 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client.rest;\n+\n+import com.azure.schemaregistry.client.rest.entities.ErrorMessage;\n+import com.azure.schemaregistry.client.rest.entities.responses.RegisterSchemaResponse;\n+import com.azure.schemaregistry.client.rest.entities.responses.SchemaObjectResponse;\n+import com.azure.schemaregistry.client.rest.exceptions.RestClientException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSocketFactory;", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg3NDQyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r421874421", "bodyText": "will be resolved by autorest generated HTTP client", "author": "arerlend", "createdAt": "2020-05-08T00:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUyOTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMTA1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418531053", "bodyText": "Clients have to be concrete classes instantiated from ClientBuilders. See guidelines on creating service clients. Also, add the necessary annotations.", "author": "srnagar", "createdAt": "2020-05-01T13:01:01Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ *  Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ *  schema registry store.\n+ */\n+public interface SchemaRegistryClient {", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMjQ2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418532469", "bodyText": "Do you have a service swagger that can be used to generate clients using autorest?", "author": "srnagar", "createdAt": "2020-05-01T13:05:27Z", "path": "sdk/schemaregistry/client/src/main/java/com/azure/schemaregistry/client/rest/entities/responses/RegisterSchemaResponse.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ */\n+\n+package com.azure.schemaregistry.client.rest.entities.responses;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+\n+public class RegisterSchemaResponse {", "originalCommit": "29f7f6c0130463e16bb643a6b3f0e27375ebed50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NTA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r418685086", "bodyText": "@hmlam", "author": "arerlend", "createdAt": "2020-05-01T18:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUzMjQ2OQ=="}], "type": "inlineReview"}, {"oid": "ba86f027a0a2e124aae3fcdc417bedc75393db98", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ba86f027a0a2e124aae3fcdc417bedc75393db98", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-05-22T00:23:03Z", "type": "commit"}, {"oid": "4e94edfd3863ce656887c0af5b5bb37eb8e14d19", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e94edfd3863ce656887c0af5b5bb37eb8e14d19", "message": "remove kafka", "committedDate": "2020-05-22T00:24:06Z", "type": "commit"}, {"oid": "54d5ad837bedb3b753f770a300ad1c1a218c9848", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54d5ad837bedb3b753f770a300ad1c1a218c9848", "message": "azure- artifact ids", "committedDate": "2020-05-22T00:24:07Z", "type": "commit"}, {"oid": "98ce87d6e289725830d190e2b71c71e0ec7bc4f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/98ce87d6e289725830d190e2b71c71e0ec7bc4f1", "message": "azure-core + version change", "committedDate": "2020-05-22T00:24:07Z", "type": "commit"}, {"oid": "21b663dd43d0355c9411d56a0bc62e4e3609b52a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21b663dd43d0355c9411d56a0bc62e4e3609b52a", "message": "progress snapshot before swapping autorest client", "committedDate": "2020-05-22T00:24:07Z", "type": "commit"}, {"oid": "be646ab8560d73d83dc7eaff8944c4217d7b58bb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/be646ab8560d73d83dc7eaff8944c4217d7b58bb", "message": "swagger generated http client", "committedDate": "2020-05-22T00:24:07Z", "type": "commit"}, {"oid": "8fa8f89c9752d6c47f747a78e7daac35fa372fd2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fa8f89c9752d6c47f747a78e7daac35fa372fd2", "message": "update common package", "committedDate": "2020-05-22T00:24:07Z", "type": "commit"}, {"oid": "305ffa56f78e370864f606629efbc6d56c34b127", "url": "https://github.com/Azure/azure-sdk-for-java/commit/305ffa56f78e370864f606629efbc6d56c34b127", "message": "junit engine", "committedDate": "2020-05-22T00:24:08Z", "type": "commit"}, {"oid": "7eb5a2f353cf28486485ed3119b86e69c96a2fa8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7eb5a2f353cf28486485ed3119b86e69c96a2fa8", "message": "fix versioning", "committedDate": "2020-05-22T00:26:11Z", "type": "commit"}, {"oid": "e13f670dd838a875fe52555fc5609c01bd896ae5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e13f670dd838a875fe52555fc5609c01bd896ae5", "message": "javadoc checkstyle", "committedDate": "2020-05-22T00:26:12Z", "type": "commit"}, {"oid": "59c1c07d195d29336b245b125d1525f244457685", "url": "https://github.com/Azure/azure-sdk-for-java/commit/59c1c07d195d29336b245b125d1525f244457685", "message": "javadoc checkstyle", "committedDate": "2020-05-22T00:26:12Z", "type": "commit"}, {"oid": "492a77ed646237e05b9872a9477a3e521e80c4d6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/492a77ed646237e05b9872a9477a3e521e80c4d6", "message": "checkstyle javadoc", "committedDate": "2020-05-22T00:26:12Z", "type": "commit"}, {"oid": "07fcff11aa494af2aaad61c7d67e4d701eb69acc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/07fcff11aa494af2aaad61c7d67e4d701eb69acc", "message": "spotbugs override for serializing null value", "committedDate": "2020-05-22T00:26:13Z", "type": "commit"}, {"oid": "16ec23e54235c372cba9295cb98394f30da15d2a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/16ec23e54235c372cba9295cb98394f30da15d2a", "message": "add service client annotation", "committedDate": "2020-05-22T00:33:48Z", "type": "commit"}, {"oid": "a6b56a8ea6815d7797f6e4f7719aa8308a6b0f9b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6b56a8ea6815d7797f6e4f7719aa8308a6b0f9b", "message": "service client style", "committedDate": "2020-05-22T00:41:53Z", "type": "commit"}, {"oid": "309b0bb4ef849caa33c85527eb138e4a9487517e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/309b0bb4ef849caa33c85527eb138e4a9487517e", "message": "fix dep management tags", "committedDate": "2020-05-22T02:06:29Z", "type": "commit"}, {"oid": "51db740b3fdc1a7be446361a547ed187b2fcdc0e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51db740b3fdc1a7be446361a547ed187b2fcdc0e", "message": "add module-info and initial readme", "committedDate": "2020-05-22T05:00:19Z", "type": "commit"}, {"oid": "7492f737a61d0151097267692e9e7aeee62b4ab9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7492f737a61d0151097267692e9e7aeee62b4ab9", "message": "add readme sections", "committedDate": "2020-05-22T05:36:45Z", "type": "commit"}, {"oid": "c1ac6c6a8cebe93b9ceca251c19d925b3c1fdd5d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1ac6c6a8cebe93b9ceca251c19d925b3c1fdd5d", "message": "fix readme section case", "committedDate": "2020-05-22T05:44:34Z", "type": "commit"}, {"oid": "47dba954784ff3b90784ed5e7aee231ca36c26c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47dba954784ff3b90784ed5e7aee231ca36c26c9", "message": "add src clients to jacoco", "committedDate": "2020-05-22T19:15:27Z", "type": "commit"}, {"oid": "198a0304094ecdabffc951af5763ee30c6539d11", "url": "https://github.com/Azure/azure-sdk-for-java/commit/198a0304094ecdabffc951af5763ee30c6539d11", "message": "add latest swagger", "committedDate": "2020-05-22T19:33:01Z", "type": "commit"}, {"oid": "24381c0ddcfa41338502bf12181deb5c33688d42", "url": "https://github.com/Azure/azure-sdk-for-java/commit/24381c0ddcfa41338502bf12181deb5c33688d42", "message": "add basic readme intros", "committedDate": "2020-05-22T22:59:15Z", "type": "commit"}, {"oid": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "message": "Merge branch 'master' into arerlend.src", "committedDate": "2020-05-26T16:01:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NDU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430564581", "bodyText": "Don't need to add implementation details about which Map type we are using since this may change over time. Added in some explanation on how to set the maximum map size along with the default value that will be used.\nChanges some HTML formatting for the maps that are maintained explanation.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Utilizes in-memory HashMap caching to minimize network I/O.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Max HashMap size can be configured when instantiating.\n          \n          \n            \n             * Two maps are maintained -\n          \n          \n            \n             * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n          \n          \n            \n             * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n          \n          \n            \n             * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Two maps are maintained.\n          \n          \n            \n             * <ul>\n          \n          \n            \n             * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n          \n          \n            \n             * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n          \n          \n            \n             * </ul>", "author": "alzimmermsft", "createdAt": "2020-05-26T16:54:51Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NzIxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430567210", "bodyText": "Should place TODO comments outside of Javadocs, I would move this above the Javadoc as the following:\n// TODO (<your alias>): implement max age for schema mapls? or will schemas always be immutable?\nThe reason to move this outside of the Javadocs is two-fold, we won't accidentally ship Javadocs with TODO comments generated into them and some IDEs will add in highlighting for TODO comments that will make them more noticeable.", "author": "alzimmermsft", "createdAt": "2020-05-26T16:58:52Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTE4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430571181", "bodyText": "Generally, client builders use empty parameter constructors. Another benefit of setting scheamRegistryUrl with a method would allow for more general configurations like HttpPipeline, log options, etc, to be set once and different registries could be passed to build multiple clients.", "author": "alzimmermsft", "createdAt": "2020-05-26T17:05:40Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MzQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430783457", "bodyText": "+1", "author": "srnagar", "createdAt": "2020-05-27T00:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMzE4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431503185", "bodyText": "Moved URL to .host()", "author": "arerlend", "createdAt": "2020-05-27T23:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTU4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430571580", "bodyText": "Should these checks be moved into the building instead of the client constructor?", "author": "alzimmermsft", "createdAt": "2020-05-26T17:06:22Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MjkwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430762903", "bodyText": "Yeah this is a redundant check, already in the builder.", "author": "arerlend", "createdAt": "2020-05-26T23:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430572317", "bodyText": "Given that this is a default value does this need to be public? Should this be used in place when no value is passed for max map size?", "author": "alzimmermsft", "createdAt": "2020-05-26T17:07:37Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MjU4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430762584", "bodyText": "Changed to default", "author": "arerlend", "createdAt": "2020-05-26T23:30:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwNjE4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431506184", "bodyText": "Correction - has to be public.  'serde-avro' module requires that defaults be set in serializer and deserializer builder class.", "author": "arerlend", "createdAt": "2020-05-27T23:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwNjM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431506361", "bodyText": "*only default needs to be public.", "author": "arerlend", "createdAt": "2020-05-27T23:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MzEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430573136", "bodyText": "Does this need to be public? Would a user of the library leverage this constant or is it for internal usage in the SDK?", "author": "alzimmermsft", "createdAt": "2020-05-26T17:09:02Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430574065", "bodyText": "Azure Core has a CoreUtils.isNullOrEmpty which covers these checks. Doesn't need to be used but centralizes the logic.", "author": "alzimmermsft", "createdAt": "2020-05-26T17:10:46Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDcyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430574729", "bodyText": "Is Locale.ENGLISH safe to use when this library goes public.", "author": "alzimmermsft", "createdAt": "2020-05-26T17:11:56Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDk5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774994", "bodyText": "Use Locale.ROOT instead.", "author": "srnagar", "createdAt": "2020-05-27T00:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NDcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3NzI0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430577240", "bodyText": "Should typeParserDictionary use a ConcurrentHashMap? I'm seeing that it gets used in a synchronized manner and ConcurrentHashMap could handle that internally. In one place I see checking if the map contains the key already and throwing if it does, this could be replaced with putIfAbsent and checking if the return is not null.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html#putIfAbsent-K-V-", "author": "alzimmermsft", "createdAt": "2020-05-26T17:16:14Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzNDY4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430634688", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n          \n          \n            \n                                String.format(\"Max schema map size must be greater than %d.\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));", "author": "alzimmermsft", "createdAt": "2020-05-26T18:53:14Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzNTY1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430635651", "bodyText": "The logger APIs will use SLF4J's string formatting which is lazy compared to String.format, it uses a general {} instead of type specific formatting like %s or %d. Where possible look to update to using this instead as it will reduce CPU time on formatting strings that may not get used due to log level configuration.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.verbose(\n          \n          \n            \n                        String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));\n          \n          \n            \n                    logger.verbose(\n          \n          \n            \n                        \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));", "author": "alzimmermsft", "createdAt": "2020-05-26T18:54:51Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTI2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430639265", "bodyText": "Has a least recently used cache been thought about? Instead of clearing everything when we hit the limit just begin prune stale entries. Current logic will work but for hot path schemas they'll need to go make a network call when this case happens.\nOverall, this doesn't need to be prioritized now as 1000 entries, by default, seems to be a lot of head space.", "author": "alzimmermsft", "createdAt": "2020-05-26T19:01:00Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        if (maxSchemaMapSize < MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                    String.format(\"Max schema map size must be greater than %d schemas\", MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            String.format(\"Loaded parser for '%s' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH)));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(\n+            schemaString,\n+            new SchemaRegistryObject(\n+                schemaId.getId(),\n+                schemaType,\n+                schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+                getParseFunc(schemaType)));\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return schemaId.getId();\n+    }\n+\n+    @Override\n+    public String deleteSchemaVersion(String schemaGroup, String schemaName, int version)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, version);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public String deleteLatestSchemaVersion(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, null);\n+        // remove from cache\n+        return null;\n+    }\n+\n+    @Override\n+    public List<String> deleteSchema(String schemaGroup, String schemaName)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchema();\n+        // remove from cache\n+        return null;\n+    }\n+\n+    /**\n+     * Explicit call to clear all caches.\n+     */\n+    public synchronized void reset() {\n+        guidCache.clear();\n+        schemaStringCache.clear();\n+        typeParserDictionary.clear();\n+    }\n+\n+    /**\n+     * Checks if caches should be reinitialized to satisfy initial configuration\n+     */\n+    private synchronized void resetIfNeeded() {", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MDE4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430780186", "bodyText": "Yeah, don't need to clear all - we can use the LRU approach later.", "author": "srnagar", "createdAt": "2020-05-27T00:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNDkyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430834929", "bodyText": "Yeah I thought about this but figured it wasn't worth adding (*for now).  If an app has more than 1k entries, the app is going to have a lot more problems than just the cache getting fully cleared.", "author": "arerlend", "createdAt": "2020-05-27T03:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYzOTI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MzY2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430643660", "bodyText": "I see that typeParserDictionary generally has it's key lower cased to allow for case insensitive matching, I believe using a TreeMap should cover that case without needing to manually manage key casing on accesses. Using new TreeMap(String::equalsIgnoreCase) should produce the same effect.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html#TreeMap-java.util.Comparator-", "author": "alzimmermsft", "createdAt": "2020-05-26T19:09:06Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,281 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory HashMap caching to minimize network I/O.\n+ * <p>\n+ * Max HashMap size can be configured when instantiating.\n+ * Two maps are maintained -\n+ * - SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads\n+ * - SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema\n+ * <p>\n+ * TODO: implement max age for schema maps? or will schemas always be immutable?\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMzA3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431503079", "bodyText": "Using ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER)", "author": "arerlend", "createdAt": "2020-05-27T23:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0MzY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0Njg4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430646887", "bodyText": "Need to null check the retryPolicy here and use the default. Another option is null checking when setting the retry policy.", "author": "alzimmermsft", "createdAt": "2020-05-26T19:15:01Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {\n+        HttpPipeline pipeline = this.httpPipeline;\n+        // Create a default Pipeline if it is not given\n+        if (pipeline == null) {\n+            // Closest to API goes first, closest to wire goes last.\n+            final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+            policies.add(new UserAgentPolicy(httpLogOptions.getApplicationId(), clientName, clientVersion,\n+                Configuration.getGlobalConfiguration().clone()));\n+            policies.add(new RequestIdPolicy());\n+            policies.add(new AddHeadersPolicy(this.headers));\n+\n+            HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+\n+            policies.add(retryPolicy);", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0Nzc1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430647750", "bodyText": "Is this ever mutated? If there are plans to add static headers let's leave it, but otherwise we can just remove it.", "author": "alzimmermsft", "createdAt": "2020-05-26T19:16:36Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MjA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430772085", "bodyText": "Ok let's take it out for now.  We had some ideas on adding headers for internal testing, but we don't have any real use cases for clients adding their own headers to HTTP calls.", "author": "arerlend", "createdAt": "2020-05-27T00:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0Nzc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY0ODQ3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430648478", "bodyText": "Let's check for this when starting the construction of the HttpPipeline, no need to waste time to just throw.", "author": "alzimmermsft", "createdAt": "2020-05-26T19:17:56Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+    private final HttpHeaders headers;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+\n+        this.headers = new HttpHeaders();\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {\n+        HttpPipeline pipeline = this.httpPipeline;\n+        // Create a default Pipeline if it is not given\n+        if (pipeline == null) {\n+            // Closest to API goes first, closest to wire goes last.\n+            final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+            policies.add(new UserAgentPolicy(httpLogOptions.getApplicationId(), clientName, clientVersion,\n+                Configuration.getGlobalConfiguration().clone()));\n+            policies.add(new RequestIdPolicy());\n+            policies.add(new AddHeadersPolicy(this.headers));\n+\n+            HttpPolicyProviders.addBeforeRetryPolicies(policies);\n+\n+            policies.add(retryPolicy);\n+\n+            policies.add(new AddDatePolicy());\n+            // Authentications\n+            if (credential != null) {\n+                // User token based policy\n+                policies.add(new BearerTokenAuthenticationPolicy(credential, DEFAULT_SCOPE));\n+            } else {\n+                // Throw exception that credential and tokenCredential cannot be null", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3MDc1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430670755", "bodyText": "Let's initialize this String once before any potential logging.", "author": "alzimmermsft", "createdAt": "2020-05-26T19:54:04Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }\n+\n+        if (this.deserialized == null) {\n+            logger.verbose(\n+                String.format(\"Deserializing schema, id: %s, schema string %s\",\n+                    this.schemaId,\n+                    new String(this.schemaByteArray, CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING)));\n+            this.deserialized = parseMethod.apply(\n+                new String(this.schemaByteArray, CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING));", "originalCommit": "f2a69b41e797e9d8d29e2a0c4d1b317edd0b22aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09d2745466c27375d3d238f4b19fad94a14b2257", "url": "https://github.com/Azure/azure-sdk-for-java/commit/09d2745466c27375d3d238f4b19fad94a14b2257", "message": "Update sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>", "committedDate": "2020-05-26T23:34:29Z", "type": "commit"}, {"oid": "866fe7f70ef19f0ab65169cbdcb411c44f1068c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/866fe7f70ef19f0ab65169cbdcb411c44f1068c9", "message": "fix comments", "committedDate": "2020-05-26T23:36:24Z", "type": "commit"}, {"oid": "abc131d4cf4a6aaf83337eb3e1c4c620b1475f3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abc131d4cf4a6aaf83337eb3e1c4c620b1475f3c", "message": "Merge branch 'arerlend.src' of https://github.com/arerlend/azure-sdk-for-java into arerlend.src", "committedDate": "2020-05-26T23:36:26Z", "type": "commit"}, {"oid": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "message": "Update sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>", "committedDate": "2020-05-26T23:40:23Z", "type": "commit"}, {"oid": "f0a35a9e1e27970d02c194bfb243fcddf312fd15", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0a35a9e1e27970d02c194bfb243fcddf312fd15", "message": "default retry policy on null", "committedDate": "2020-05-26T23:57:41Z", "type": "commit"}, {"oid": "6199719b77530eaeb38b267733b693ad2afee002", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6199719b77530eaeb38b267733b693ad2afee002", "message": "Merge branch 'arerlend.src' of https://github.com/arerlend/azure-sdk-for-java into arerlend.src", "committedDate": "2020-05-27T00:03:42Z", "type": "commit"}, {"oid": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "message": "remove unused headers policy", "committedDate": "2020-05-27T00:04:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MjgyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430772822", "bodyText": "Use the interface instead Map<String, Function<String, Object>>.", "author": "srnagar", "createdAt": "2020-05-27T00:05:44Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "originalCommit": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MzE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430773172", "bodyText": "Use Map instead.", "author": "srnagar", "createdAt": "2020-05-27T00:06:58Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {", "originalCommit": "d4e534007a19fe5f9198e31acc5c152b8b05b4f1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3MzkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430773905", "bodyText": "This should be configured in the builder itself and the restService instance should be passed in to this constructor.", "author": "srnagar", "createdAt": "2020-05-27T00:09:27Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDEyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774129", "bodyText": "both these should use ConcurrentHashMap.", "author": "srnagar", "createdAt": "2020-05-27T00:10:08Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDQ0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430774440", "bodyText": "Is this ctor required just to enable testing? Can mocks be used instead?", "author": "srnagar", "createdAt": "2020-05-27T00:11:07Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUwMzQxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431503416", "bodyText": "As per discussion, will be fixed after private preview.  Will convert to use mockito", "author": "arerlend", "createdAt": "2020-05-27T23:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NDQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTI3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430775276", "bodyText": "You can instead use putIfAbsent() to add to map only when it doesn't exist. You can then also remove synchronized keyword if you make the typeParserDicitionary a ConcurrentHashMap.", "author": "srnagar", "createdAt": "2020-05-27T00:14:03Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MDI0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430840243", "bodyText": "Yeah I think I am going to make all three ConcurrentHashMaps so I can remove synchronized\nIn this case I prefer to throw if multiple parsers are added for the same serialization type, just because upserting could potentially result in a functioning app with unexpected behaviors.", "author": "arerlend", "createdAt": "2020-05-27T03:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTgwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430775802", "bodyText": "nit: Consider naming it as typeParserMap to be java-like and agree with Alan on using a ConcurrentHashMap.", "author": "srnagar", "createdAt": "2020-05-27T00:15:55Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNzY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430837661", "bodyText": "Changed to typeParserMap.  I will use ConcurrentHashMap here.", "author": "arerlend", "createdAt": "2020-05-27T03:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjM4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430776385", "bodyText": "Don't need to have throws SchemaRegistryClientException in the method signature as it's a RuntimeException.", "author": "srnagar", "createdAt": "2020-05-27T00:18:02Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDgzNzc2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430837760", "bodyText": "Yeah this is an artifact from when it was a checked exception.  Will remove these", "author": "arerlend", "createdAt": "2020-05-27T03:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjkxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430776912", "bodyText": "Making this method synchronized will have a performance impact especially when register is called every single time an event is serialized. Consider using ConcurrentHashMap and remove synchronized.", "author": "srnagar", "createdAt": "2020-05-27T00:19:59Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg0MTEwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430841100", "bodyText": "Removed.", "author": "arerlend", "createdAt": "2020-05-27T03:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzQzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430777436", "bodyText": "Consider using HttpResponseException instead of creating a custom exception.", "author": "srnagar", "createdAt": "2020-05-27T00:21:45Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClientException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+/**\n+ * Runtime exception to be returned from SchemaRegistryClient implementations.\n+ */\n+public class SchemaRegistryClientException extends RuntimeException {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NDc2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431344768", "bodyText": "Changed to use AzureException", "author": "arerlend", "createdAt": "2020-05-27T18:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3NzQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3ODIwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430778205", "bodyText": "Same here - avoid using synchronized if ConcurrentHashMap for guidCache can serve the purpose and especially since the cache hit is expected to be the majority scenario here and we don't want to penalize every request by synchronizing the method.", "author": "srnagar", "createdAt": "2020-05-27T00:24:41Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3ODM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430778399", "bodyText": "You might want to have a null check for schemaId.", "author": "srnagar", "createdAt": "2020-05-27T00:25:17Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTM2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430779366", "bodyText": "putIfAbsent()", "author": "srnagar", "createdAt": "2020-05-27T00:28:57Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTcxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430779718", "bodyText": "Are these yet to be implemented?", "author": "srnagar", "createdAt": "2020-05-27T00:30:09Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClient.class);\n+\n+    public static final Charset SCHEMA_REGISTRY_SERVICE_ENCODING = StandardCharsets.UTF_8;\n+\n+    static final int MAX_SCHEMA_MAP_SIZE_DEFAULT = 1000;\n+    static final int MAX_SCHEMA_MAP_SIZE_MINIMUM = 10;\n+\n+    private final AzureSchemaRegistryRestService restService;\n+    private final int maxSchemaMapSize;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final HashMap<String, SchemaRegistryObject> guidCache;\n+    private final HashMap<String, SchemaRegistryObject> schemaStringCache;\n+\n+    CachedSchemaRegistryClient(\n+        String registryUrl,\n+        HttpPipeline pipeline,\n+        int maxSchemaMapSize,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        if (registryUrl == null || registryUrl.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Schema Registry URL cannot be null or empty.\"));\n+        }\n+\n+        this.restService = new AzureSchemaRegistryRestServiceClientBuilder()\n+            .host(registryUrl)\n+            .pipeline(pipeline)\n+            .buildClient();\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.guidCache = new HashMap<>();\n+        this.schemaStringCache = new HashMap<>();\n+    }\n+\n+    // testing\n+    CachedSchemaRegistryClient(\n+        AzureSchemaRegistryRestService restService,\n+        HashMap<String, SchemaRegistryObject> guidCache,\n+        HashMap<String, SchemaRegistryObject> schemaStringCache,\n+        HashMap<String, Function<String, Object>> typeParserDictionary) {\n+        this.restService = restService; // mockable\n+        this.guidCache = guidCache;\n+        this.schemaStringCache = schemaStringCache;\n+        this.typeParserDictionary = typeParserDictionary;\n+        this.maxSchemaMapSize = MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+    }\n+\n+    /**\n+     * @return Azure Schema Registry service string encoding\n+     */\n+    @Override\n+    public Charset getEncoding() {\n+        return CachedSchemaRegistryClient.SCHEMA_REGISTRY_SERVICE_ENCODING;\n+    }\n+\n+    /**\n+     * @param schemaType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     * @throws IllegalArgumentException on bad schema type or if parser for schema type has already been registered\n+     */\n+    public synchronized void loadSchemaParser(String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        logger.verbose(\n+            \"Loaded parser for '{}' serialization format.\", schemaType.toLowerCase(Locale.ENGLISH));\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject register(\n+        String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(\n+                String.format(\n+                    \"Cache hit schema string. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                    schemaGroup, schemaName, serializationType, schemaString));\n+            return schemaStringCache.get(schemaString);\n+        }\n+\n+        logger.verbose(\n+            String.format(\"Registering schema. Group: '%s', name: '%s', serialization type: '%s', payload: '%s'\",\n+                schemaGroup, schemaName, serializationType, schemaString));\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.createSchema(schemaGroup, schemaName, schemaString, serializationType);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Register operation failed.\", e));\n+        }\n+\n+        SchemaRegistryObject registered = new SchemaRegistryObject(schemaId.getId(),\n+            serializationType,\n+            schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(serializationType));\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(schemaString, registered);\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return registered;\n+    }\n+\n+    @Override\n+    public synchronized SchemaRegistryObject getSchemaByGuid(String schemaId)\n+        throws SchemaRegistryClientException {\n+        if (guidCache.containsKey(schemaId)) {\n+            logger.verbose(String.format(\"Cache hit for schema id '%s'\", schemaId));\n+            return guidCache.get(schemaId);\n+        }\n+\n+        GetSchemaByIdResponse response;\n+        try {\n+            response = this.restService.getSchemaByIdWithResponseAsync(UUID.fromString(schemaId)).block();\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\"Fetching schema failed.\", e));\n+        }\n+\n+        if (response == null) {\n+            throw logger.logExceptionAsError(\n+                new SchemaRegistryClientException(\"HTTP client returned null schema response\"));\n+        }\n+\n+        String schemaType = response.getDeserializedHeaders().getXSchemaType();\n+\n+        SchemaRegistryObject schemaObject = new SchemaRegistryObject(schemaId,\n+            schemaType,\n+            response.getValue().getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+            getParseFunc(schemaType));\n+\n+        resetIfNeeded();\n+        guidCache.put(schemaId, schemaObject);\n+        logger.verbose(String.format(\"Cached schema object. Path: '%s'\", schemaId));\n+        return schemaObject;\n+    }\n+\n+    @Override\n+    public synchronized String getSchemaId(\n+        String schemaGroup, String schemaName, String schemaString, String schemaType)\n+        throws SchemaRegistryClientException {\n+        if (schemaStringCache.containsKey(schemaString)) {\n+            logger.verbose(String.format(\"Cache hit schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+            return schemaStringCache.get(schemaString).getSchemaId();\n+        }\n+\n+        SchemaId schemaId;\n+        try {\n+            schemaId = this.restService.getIdBySchemaContent(schemaGroup, schemaName, schemaType, schemaString);\n+        } catch (HttpResponseException e) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"Failed to fetch schema guid for schema. Group: '%s', name: '%s'\",\n+                    schemaGroup, schemaName),\n+                e));\n+        }\n+\n+        resetIfNeeded();\n+        schemaStringCache.put(\n+            schemaString,\n+            new SchemaRegistryObject(\n+                schemaId.getId(),\n+                schemaType,\n+                schemaString.getBytes(SCHEMA_REGISTRY_SERVICE_ENCODING),\n+                getParseFunc(schemaType)));\n+        logger.verbose(String.format(\"Cached schema string. Group: '%s', name: '%s'\", schemaGroup, schemaName));\n+        return schemaId.getId();\n+    }\n+\n+    @Override\n+    public String deleteSchemaVersion(String schemaGroup, String schemaName, int version)\n+        throws SchemaRegistryClientException {\n+        // return this.restService.deleteSchemaVersion(schemaName, version);\n+        // remove from cache\n+        return null;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0NTIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431345211", "bodyText": "Throwing unsupported operation", "author": "arerlend", "createdAt": "2020-05-27T18:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc3OTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4MTYyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430781625", "bodyText": "Make this client final.", "author": "srnagar", "createdAt": "2020-05-27T00:37:23Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.exception.HttpResponseException;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestService;\n+import com.azure.schemaregistry.client.rest.AzureSchemaRegistryRestServiceClientBuilder;\n+import com.azure.schemaregistry.client.rest.models.GetSchemaByIdResponse;\n+import com.azure.schemaregistry.client.rest.models.SchemaId;\n+\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+/**\n+ * HTTP-based client that interacts with Azure Schema Registry service to store and retrieve schemas on demand.\n+ * <p>\n+ * Utilizes in-memory {@link Map} caching to minimize network I/O. Max size can be configured when instantiating by using {@link CachedSchemaRegistryClientBuilder#maxSchemaMapSize}, otherwise {@code 1000} will be used as the default.\n+ * <p>\n+ * Two maps are maintained.\n+ * <ul>\n+ * <li>SchemaRegistryObject cache by GUID - stores GUIDs previously seen in payloads.</li>\n+ * <li>SchemaRegistryObject cache by schema string - minimizes HTTP calls when sending payloads of same schema.</li>\n+ * </ul>\n+ * <p>\n+ *\n+ * @see SchemaRegistryClient Implements SchemaRegistryClient interface to allow for testing with mock\n+ * @see CachedSchemaRegistryClientBuilder Follows builder pattern for object instantiation\n+ */\n+@ServiceClient(\n+    builder = CachedSchemaRegistryClientBuilder.class,\n+    serviceInterfaces = AzureSchemaRegistryRestService.class)\n+public class CachedSchemaRegistryClient implements SchemaRegistryClient {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NDA1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430784057", "bodyText": "Shouldn't this be allowed if the user wants to overwrite an existing entry for schemaType?", "author": "srnagar", "createdAt": "2020-05-27T00:45:29Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MDY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431470691", "bodyText": "We should avoid this use case - user intent when calling this method is to load (add) schema parser, not to upsert.  Overwriting previous writes may result in unpredictable behavior.", "author": "arerlend", "createdAt": "2020-05-27T22:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NDE2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430784167", "bodyText": "Are we not going to have an async client?", "author": "srnagar", "createdAt": "2020-05-27T00:45:53Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,284 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpHeaders;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.AddHeadersPolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final String schemaRegistryUrl;\n+    private final HashMap<String, Function<String, Object>> typeParserDictionary;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private HttpClient httpClient;\n+    private int maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     * Supplies client defaults.\n+     *\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL.\n+     */\n+    public CachedSchemaRegistryClientBuilder(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_DEFAULT;\n+        this.typeParserDictionary = new HashMap<>();\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) throws IllegalArgumentException {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.schemaregistry.ByteEncoder or com.azure.schemaregistry.ByteDecoder class will implement\n+     * - serializationFormat(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     * This method can be used by passing in a method reference, e.g. ByteEncoder::parseSchemaString.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param schemaType schema type for which the parse method should be applied.\n+     * @param parseMethod function for deserializing registry-stored schema strings to Java Objects\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder loadSchemaParser(\n+        String schemaType, Function<String, Object> parseMethod) {\n+        if (schemaType == null || schemaType.isEmpty()) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Serialization type cannot be null or empty.\"));\n+        }\n+        if (this.typeParserDictionary.containsKey(schemaType.toLowerCase(Locale.ENGLISH))) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Multiple parse methods for single serialization type may not be added.\"));\n+        }\n+        this.typeParserDictionary.put(schemaType.toLowerCase(Locale.ENGLISH), parseMethod);\n+        return this;\n+    }\n+\n+    /**\n+     * Creates a {@link CachedSchemaRegistryClient} based on options set in the builder.\n+     * Every time {@code buildClient()} is called a new instance of {@link CachedSchemaRegistryClient} is created.\n+     *\n+     * If {@link #pipeline(HttpPipeline) pipeline} is set, then all HTTP pipeline related settings are ignored\n+     * endpoint} are when creating the {@link CachedSchemaRegistryClient client}.\n+     *\n+     * @return A {@link CachedSchemaRegistryClient} with the options set from the builder.\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public CachedSchemaRegistryClient buildClient() {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NTA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430785086", "bodyText": "Consider naming this as createSchema as per guidelines here", "author": "srnagar", "createdAt": "2020-05-27T00:49:39Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ * schema registry store.\n+ */\n+public interface SchemaRegistryClient {\n+\n+    /**\n+     * Encoding used by registry client implementation.\n+     * @return encoding for registry client implementation\n+     */\n+    Charset getEncoding();\n+\n+    /**\n+     * Loads function for a given serialization format that can parse the registry-stored schema string into\n+     * usable schema object.\n+     *\n+     * @param serializationType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     */\n+    void loadSchemaParser(String serializationType, Function<String, Object> parseMethod);\n+\n+    /**\n+     * Registers a schema against backing schema registry store.\n+     *\n+     * @param schemaGroup schema group name\n+     * @param schemaName schema name\n+     * @param schemaString string representation of schema\n+     * @param serializationType string representation of serialization format type\n+     * @return SchemaRegistryObject containing information regarding registered schema.\n+     * @throws SchemaRegistryClientException if registration operation fails\n+     */\n+    SchemaRegistryObject register(String schemaGroup, String schemaName, String schemaString, String serializationType)", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3MDE3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431470174", "bodyText": "Schema registration is a bit of a special case - if schema exists, it returns the existing GUID.  Doesn't fit very cleanly into the categories in the guidelines", "author": "arerlend", "createdAt": "2020-05-27T22:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4NzA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430787080", "bodyText": "This interface won't work if we have to support both sync and async APIs as the return types will be different. In track 2, we don't have an interface like this for the client. We directly have 2 client classes - sync and async.", "author": "srnagar", "createdAt": "2020-05-27T00:57:24Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+/**\n+ * Interface that defines operation for registering and fetching schemas and schema information to and from a\n+ * schema registry store.\n+ */\n+public interface SchemaRegistryClient {\n+\n+    /**\n+     * Encoding used by registry client implementation.\n+     * @return encoding for registry client implementation\n+     */\n+    Charset getEncoding();\n+\n+    /**\n+     * Loads function for a given serialization format that can parse the registry-stored schema string into\n+     * usable schema object.\n+     *\n+     * @param serializationType tag used by schema registry store to identify schema serialization type, e.g. \"avro\"\n+     * @param parseMethod function to parse string into usable schema object\n+     */\n+    void loadSchemaParser(String serializationType, Function<String, Object> parseMethod);\n+\n+    /**\n+     * Registers a schema against backing schema registry store.\n+     *\n+     * @param schemaGroup schema group name\n+     * @param schemaName schema name\n+     * @param schemaString string representation of schema\n+     * @param serializationType string representation of serialization format type\n+     * @return SchemaRegistryObject containing information regarding registered schema.\n+     * @throws SchemaRegistryClientException if registration operation fails\n+     */\n+    SchemaRegistryObject register(String schemaGroup, String schemaName, String schemaString, String serializationType)\n+        throws SchemaRegistryClientException;\n+\n+    /**\n+     * Fetches schema specified by the GUID.\n+     * <p>\n+     * GUID can be assumed to be unique within a schema registry store.\n+     *\n+     * @param schemaGuid GUID reference to specific schema within configured schema registry store.\n+     * @return SchemaRegistryObject containing information regarding matching schema.\n+     * @throws SchemaRegistryClientException if fetch operation fails\n+     */\n+    SchemaRegistryObject getSchemaByGuid(String schemaGuid) throws SchemaRegistryClientException;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODQxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430788413", "bodyText": "Shouldn't this check happen in the constructor itself?", "author": "srnagar", "createdAt": "2020-05-27T01:02:50Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2ODM4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431468382", "bodyText": "Null check was removed, parseMethod can never be passed in as null since CachedSchemaRegistryClient throws if no parser is stored for the given schema type", "author": "arerlend", "createdAt": "2020-05-27T22:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430788819", "bodyText": "You might want to synchronize access to this.", "author": "srnagar", "createdAt": "2020-05-27T01:04:31Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/SchemaRegistryObject.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import java.util.function.Function;\n+\n+/**\n+ * Stores all relevant information returned from SchemaRegistryClient layer.\n+ */\n+public class SchemaRegistryObject {\n+    private final ClientLogger logger = new ClientLogger(SchemaRegistryObject.class);\n+\n+    private final String schemaId;\n+    private final String schemaType;\n+    private final Function<String, Object> parseMethod;\n+    private final byte[] schemaByteArray;\n+\n+    private Object deserialized;\n+\n+    /**\n+     * Initializes SchemaRegistryObject instance.\n+     *\n+     * @param schemaId schema ID\n+     * @param schemaType type of schema, e.g. avro, json\n+     * @param schemaByteArray byte payload representing schema, returned from Azure Schema Registry\n+     * @param parseMethod method to deserialize schema payload into Object\n+     */\n+    public SchemaRegistryObject(\n+        String schemaId,\n+        String schemaType,\n+        byte[] schemaByteArray,\n+        Function<String, Object> parseMethod) {\n+        this.schemaId = schemaId;\n+        this.schemaType = schemaType;\n+        this.schemaByteArray = schemaByteArray.clone();\n+        this.deserialized = null;\n+        this.parseMethod = parseMethod;\n+    }\n+\n+    /**\n+     * @return schema ID\n+     */\n+    public String getSchemaId() {\n+        return schemaId;\n+    }\n+\n+    /**\n+     * @return schema type associated with the schema payload\n+     */\n+    public String getSchemaType() {\n+        return schemaType;\n+    }\n+\n+    /**\n+     *  Deserialize schema bytes returned from Schema Registry.  If deserialization has happened once, the deserialized\n+     *  object is stored and returned.\n+     *\n+     *  @return schema object, deserialized using stored schema parser method.\n+     */\n+    public Object deserialize() {\n+        if (parseMethod == null) {\n+            throw logger.logExceptionAsError(new SchemaRegistryClientException(\n+                String.format(\"No loaded parser for %s format. Schema guid: %s\",\n+                    this.schemaType, this.schemaId)));\n+        }\n+\n+        if (this.deserialized == null) {", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MjU1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431442551", "bodyText": "Parsing is idempotent so multiple writes won't cause any problems", "author": "arerlend", "createdAt": "2020-05-27T21:07:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc4ODgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430790619", "bodyText": "This should be in implementation package as it's the convention we follow to denote packages that users shouldn't use.\nhttps://azure.github.io/azure-sdk/java_design.html#example-namespaces", "author": "srnagar", "createdAt": "2020-05-27T01:11:35Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/rest/AzureSchemaRegistryRestServiceClientBuilder.java", "diffHunk": "@@ -0,0 +1,67 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client.rest;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2ODQ3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431468477", "bodyText": "Moved to implementation", "author": "arerlend", "createdAt": "2020-05-27T22:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MDYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MTA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430791047", "bodyText": "This should not be used directly by the user. So, move this to implementation package. Same for any other classes that shouldn't in public API view.", "author": "srnagar", "createdAt": "2020-05-27T01:13:16Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/java/com/azure/schemaregistry/client/rest/AzureSchemaRegistryRestService.java", "diffHunk": "@@ -0,0 +1,1411 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.schemaregistry.client.rest;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MzAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r430793023", "bodyText": "Does this package have to be exported? It contains codgen rest service client and builder which shouldn't be used anywhere outside this module.", "author": "srnagar", "createdAt": "2020-05-27T01:15:43Z", "path": "sdk/schemaregistry/azure-schemaregistry-client/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,14 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.schemaregistry.client {\n+    requires transitive com.azure.core;\n+\n+    exports com.azure.schemaregistry.client;\n+    exports com.azure.schemaregistry.client.rest;", "originalCommit": "2a216c3617d1b1c31c749c7db1556ec0ef6bec07", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ2ODk3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r431468970", "bodyText": "Removed rest and rest.models from module-info.", "author": "arerlend", "createdAt": "2020-05-27T22:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc5MzAyMw=="}], "type": "inlineReview"}, {"oid": "d25047fd1cfd114aec2b106aae454e1237d841ed", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d25047fd1cfd114aec2b106aae454e1237d841ed", "message": "netty dep", "committedDate": "2020-05-27T15:36:49Z", "type": "commit"}, {"oid": "9cd191ebe22a464348914279d96db3cf321871ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9cd191ebe22a464348914279d96db3cf321871ea", "message": "hashmap to concurrent hashmap, slf4j format pattern", "committedDate": "2020-05-27T15:38:52Z", "type": "commit"}, {"oid": "59d8f9d2fd1c4ea421a774ed95c98a9a85d73a06", "url": "https://github.com/Azure/azure-sdk-for-java/commit/59d8f9d2fd1c4ea421a774ed95c98a9a85d73a06", "message": "builder cleanup", "committedDate": "2020-05-27T15:39:37Z", "type": "commit"}, {"oid": "a04c3835260f66214ce8618ec632e7e8774e03eb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a04c3835260f66214ce8618ec632e7e8774e03eb", "message": "remove runtime error from method signature", "committedDate": "2020-05-27T15:40:01Z", "type": "commit"}, {"oid": "1656da90030e3ca9f610132ba3b4537dfa049910", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1656da90030e3ca9f610132ba3b4537dfa049910", "message": "comments", "committedDate": "2020-05-27T20:56:46Z", "type": "commit"}, {"oid": "81682bcf0e27294f75d434f047e63ed5eda9e110", "url": "https://github.com/Azure/azure-sdk-for-java/commit/81682bcf0e27294f75d434f047e63ed5eda9e110", "message": "change group name", "committedDate": "2020-05-28T00:33:25Z", "type": "commit"}, {"oid": "b855cd00761662d2d845a68ea753ef0a5e96d29e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b855cd00761662d2d845a68ea753ef0a5e96d29e", "message": "move rest service builder", "committedDate": "2020-05-28T00:42:18Z", "type": "commit"}, {"oid": "850201a2c0e6907248dd8ff0ff2b9d5234c87150", "url": "https://github.com/Azure/azure-sdk-for-java/commit/850201a2c0e6907248dd8ff0ff2b9d5234c87150", "message": "update dirs and repo files", "committedDate": "2020-05-28T00:47:26Z", "type": "commit"}, {"oid": "6b1ee4e13efcd0ec118bdafc4d273b01874131ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b1ee4e13efcd0ec118bdafc4d273b01874131ab", "message": "update package structure", "committedDate": "2020-05-28T19:46:17Z", "type": "commit"}, {"oid": "d6e0941bd0ecbd4918935608d447047be7fe7795", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6e0941bd0ecbd4918935608d447047be7fe7795", "message": "update versioning", "committedDate": "2020-05-28T19:46:42Z", "type": "commit"}, {"oid": "c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1f71999dfc723f4022f3ce221f2e82aeaf1f1ec", "message": "fix jacoco test pom", "committedDate": "2020-05-28T20:05:03Z", "type": "commit"}, {"oid": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "url": "https://github.com/Azure/azure-sdk-for-java/commit/93defa9bdfacb71789c231eb2cb9980f80c0ea01", "message": "fix eng system comments", "committedDate": "2020-05-29T16:15:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYwODYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432608623", "bodyText": "Do you know if it would be better to phrase the exception in the \"why this happened\" instead of \"what happened\"?\nAttempted to decode with non-Avro schema object in AvroByteDecoder.\nvs\nobject must be an Avro Schema.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:46:44Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432610034", "bodyText": "I'm not sure this is completely correct, based on the Avro spec bytes will contain a leading long indicating the number of bytes in the byte[]. Based on my testing having Apache's implementation parse this is safe, though it may return ByteBuffer which could be unwrapped to byte[].", "author": "alzimmermsft", "createdAt": "2020-05-29T16:49:16Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));\n+        }\n+        Schema schema = (Schema) object;\n+\n+        if (schema.getType().equals(Schema.Type.BYTES)) {\n+            return b;\n+        }", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MDg1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432680852", "bodyText": "I think that is the expectation on how to handle byte-only payloads coming back from a message body.  Avro cares about the length of a byte array when working within a struct because it needs to know how long byte arrays are within the data structure so it doesn't read past the end of a byte array.  This specific case is for payloads that consist of nothing but a single byte array.  Avro can just read the entire payload into a buffer and return it to the user to manage.\nI am adding a //todo to revisit this.", "author": "arerlend", "createdAt": "2020-05-29T19:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMDc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432610793", "bodyText": "From what I remember DecoderFactory should be thread safe, this could be made static.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:50:37Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMjI3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432612278", "bodyText": "I would also conditionally check !(result instanceof String). It is possible to configure your schema with \"avro.java.stringType\":\"String\" to tell the parser to read the string type as java.lang.String instead of Apache's Utf8 CharSequence implementation.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:53:28Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(\"Attempted to decode with non-Avro schema object in AvroByteDecoder\"));\n+        }\n+        Schema schema = (Schema) object;\n+\n+        if (schema.getType().equals(Schema.Type.BYTES)) {\n+            return b;\n+        }\n+\n+        DatumReader<?> reader = getDatumReader(schema);\n+\n+        try {\n+            Object result = reader.read(null, decoderFactory.binaryDecoder(b, null));\n+\n+            if (schema.getType().equals(Schema.Type.STRING)) {", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMzIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432613202", "bodyText": "Same comment about byte deserialization, this will need a leading long to indicate the number of bytes in the byte[].", "author": "alzimmermsft", "createdAt": "2020-05-29T16:55:13Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            if (object instanceof byte[]) {\n+                out.write((byte[]) object);", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjI2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432686264", "bodyText": "Yup, see comments there.", "author": "arerlend", "createdAt": "2020-05-29T19:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxMzIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjI1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432616257", "bodyText": "Should we be checking both the object and primitive representations here? boolean and Boolean, int and Integer, etc.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:58:22Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NjgxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432676810", "bodyText": "This is for top level Object parameter, so they cannot be passed in as primitives.  Avro will handle if there are primitives as fields on the object.", "author": "arerlend", "createdAt": "2020-05-29T18:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432617091", "bodyText": "This exception doesn't match the conditionals, unless IndexedRecord is a subclass of GenericContainer.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:59:15Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {\n+            return PRIMITIVE_SCHEMAS.get(\"Boolean\");\n+        } else if (object instanceof Integer) {\n+            return PRIMITIVE_SCHEMAS.get(\"Integer\");\n+        } else if (object instanceof Long) {\n+            return PRIMITIVE_SCHEMAS.get(\"Long\");\n+        } else if (object instanceof Float) {\n+            return PRIMITIVE_SCHEMAS.get(\"Float\");\n+        } else if (object instanceof Double) {\n+            return PRIMITIVE_SCHEMAS.get(\"Double\");\n+        } else if (object instanceof CharSequence) {\n+            return PRIMITIVE_SCHEMAS.get(\"String\");\n+        } else if (object instanceof byte[]) {\n+            return PRIMITIVE_SCHEMAS.get(\"Bytes\");\n+        } else if (object instanceof GenericContainer) {\n+            return ((GenericContainer) object).getSchema();\n+        } else {\n+            ClientLogger logger = new ClientLogger(AvroSchemaUtils.class);\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\n+                \"Unsupported Avro type. Supported types are null, Boolean, Integer, Long, \"\n+                    + \"Float, Double, String, byte[] and IndexedRecord\"));", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1NTExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432655111", "bodyText": "https://avro.apache.org/docs/1.9.2/api/java/org/apache/avro/generic/IndexedRecord.html", "author": "arerlend", "createdAt": "2020-05-29T18:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzI3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432617278", "bodyText": "Should ByteBuffer fall into this category.", "author": "alzimmermsft", "createdAt": "2020-05-29T16:59:36Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroSchemaUtils.java", "diffHunk": "@@ -0,0 +1,87 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericContainer;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Utility class for Avro schema functionality.\n+ */\n+class AvroSchemaUtils {\n+    private static final Map<String, Schema> PRIMITIVE_SCHEMAS;\n+\n+    static {\n+        Schema.Parser parser = new Schema.Parser();\n+        PRIMITIVE_SCHEMAS = new HashMap<>();\n+        PRIMITIVE_SCHEMAS.put(\"Null\", createPrimitiveSchema(parser, \"null\"));\n+        PRIMITIVE_SCHEMAS.put(\"Boolean\", createPrimitiveSchema(parser, \"boolean\"));\n+        PRIMITIVE_SCHEMAS.put(\"Integer\", createPrimitiveSchema(parser, \"int\"));\n+        PRIMITIVE_SCHEMAS.put(\"Long\", createPrimitiveSchema(parser, \"long\"));\n+        PRIMITIVE_SCHEMAS.put(\"Float\", createPrimitiveSchema(parser, \"float\"));\n+        PRIMITIVE_SCHEMAS.put(\"Double\", createPrimitiveSchema(parser, \"double\"));\n+        PRIMITIVE_SCHEMAS.put(\"String\", createPrimitiveSchema(parser, \"string\"));\n+        PRIMITIVE_SCHEMAS.put(\"Bytes\", createPrimitiveSchema(parser, \"bytes\"));\n+    }\n+\n+    /**\n+     * Generates Avro Schema object for the specified primitive type.\n+     * @param parser Avro schema parser\n+     * @param type primitive schema type\n+     * @return Avro Schema object for corresponding primitive type\n+     */\n+    private static Schema createPrimitiveSchema(Schema.Parser parser, String type) {\n+        String schemaString = String.format(\"{\\\"type\\\" : \\\"%s\\\"}\", type);\n+        return parser.parse(schemaString);\n+    }\n+\n+    /**\n+     * Maintains map of primitive schemas.\n+     * @return Map containing string representation of primitive type to corresponding Avro primitive schema\n+     */\n+    public static Map<String, Schema> getPrimitiveSchemas() {\n+        return Collections.unmodifiableMap(PRIMITIVE_SCHEMAS);\n+    }\n+\n+    /**\n+     * Returns Avro schema for specified object, including null values\n+     *\n+     * @param object object for which Avro schema is being returned\n+     * @return Avro schema for object's data structure\n+     *\n+     * @throws IllegalArgumentException if object type is unsupported\n+     */\n+    public static Schema getSchema(Object object) throws IllegalArgumentException {\n+        if (object == null) {\n+            return PRIMITIVE_SCHEMAS.get(\"Null\");\n+        } else if (object instanceof Boolean) {\n+            return PRIMITIVE_SCHEMAS.get(\"Boolean\");\n+        } else if (object instanceof Integer) {\n+            return PRIMITIVE_SCHEMAS.get(\"Integer\");\n+        } else if (object instanceof Long) {\n+            return PRIMITIVE_SCHEMAS.get(\"Long\");\n+        } else if (object instanceof Float) {\n+            return PRIMITIVE_SCHEMAS.get(\"Float\");\n+        } else if (object instanceof Double) {\n+            return PRIMITIVE_SCHEMAS.get(\"Double\");\n+        } else if (object instanceof CharSequence) {\n+            return PRIMITIVE_SCHEMAS.get(\"String\");\n+        } else if (object instanceof byte[]) {", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2ODE0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432668146", "bodyText": "Yes it should.  added", "author": "arerlend", "createdAt": "2020-05-29T18:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDE0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432620146", "bodyText": "This package doesn't exist, this should be com.azure.data.schemaregistry.avro right?", "author": "alzimmermsft", "createdAt": "2020-05-29T17:05:14Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.avro {\n+    requires transitive com.azure.core;\n+\n+    exports com.azure.data.schemaregistry.serde.avro;", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0NjMyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432646327", "bodyText": "Yeah I missed this, there have been a lot of package changes.", "author": "arerlend", "createdAt": "2020-05-29T17:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMDE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMjEzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432622138", "bodyText": "Is there a specific reason we are creating a custom scheduler for deserialization?", "author": "alzimmermsft", "createdAt": "2020-05-29T17:07:53Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncDeserializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based deserializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncDeserializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroDeserializer deserializer;\n+    private final Scheduler scheduler;", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1Mzg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432653898", "bodyText": "Async implementation is using a threadpool to do sync work, hence the scheduler with the dedicated threadpool", "author": "arerlend", "createdAt": "2020-05-29T18:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMjEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY1Mzk0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432653949", "bodyText": "This will be changed for GA.", "author": "arerlend", "createdAt": "2020-05-29T18:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzM2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432623362", "bodyText": "Should we use Mono.empty() or Mono.just(new byte[0])? These will have two very different things happen when dealing with Reactor streams. The former will complete the stream without an onNext operation, the latter will trigger an onNext (triggering downstream map and flatMap operators) and will contain an empty byte[] as expected when Avro serializes a null.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:09:51Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncSerializer.java", "diffHunk": "@@ -0,0 +1,48 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.AbstractDataSerializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based serializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncSerializer extends AbstractDataSerializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroSerializer serializer;\n+    private final Scheduler scheduler;\n+\n+    /**\n+     * @param serializer synchronous Avro serializer implementation\n+     */\n+    SchemaRegistryAvroAsyncSerializer(SchemaRegistryAvroSerializer serializer) {\n+        this.serializer = serializer;\n+        this.scheduler = Schedulers.fromExecutor(Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n+    }\n+\n+    /**\n+     * Async wrapper around sync serialization operation\n+     *\n+     * @param object object to be serialized to bytes\n+     * @return Avro byte representation of object\n+     * @throws SerializationException upon serialization operation failure\n+     */\n+    public Mono<byte[]> serializeAsync(Object object) throws SerializationException {\n+        if (object == null) {\n+            return Mono.empty();", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTUwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432669502", "bodyText": "Leaving this as is after discussion with Alan.\nThinking about this in terms of a user scenario makes it clear that returning empty byte array has a different meaning from returning null.  batch.tryAdd(null) throws.  batch.tryAdd(byte[0]) would not.  If there was an intermediate serialization step when doing batch.tryAdd(null), then the non-null contract breaks.", "author": "arerlend", "createdAt": "2020-05-29T18:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NzQxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432687416", "bodyText": "Agree. This should return Mono.just(new byte[0])", "author": "srnagar", "createdAt": "2020-05-29T19:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyMzM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432624644", "bodyText": "For these Javadocs is the but about instanceof meant to go into the overview of the method or specific to the return portion? Also, Javadocs are HTML so any newlines are scrubbed, if you need line separators you'll need to add <p> where newlines are (except when transitioning Javadoc sections such as param to param, return to throws, etc.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:12:30Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataDeserializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import com.azure.data.schemaregistry.client.CachedSchemaRegistryClientBuilder;\n+\n+/**\n+ * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n+ * fetching payload-specified schemas from the Azure Schema Registry store.\n+ *\n+ * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n+ *\n+ * Pluggable with the core Azure SDK Deserializer interface.\n+ *\n+ * @see AbstractDataDeserializer See AbstractDataDeserializer for internal deserialization implementation\n+ */\n+public class SchemaRegistryAvroDeserializer extends AbstractDataDeserializer {\n+    SchemaRegistryAvroDeserializer(String registryUrl,\n+                                   TokenCredential credential,\n+                                   boolean avroSpecificReader,\n+                                   Integer maxSchemaMapSize) {\n+        super(new CachedSchemaRegistryClientBuilder()\n+            .endpoint(registryUrl)\n+            .credential(credential)\n+            .maxSchemaMapSize(maxSchemaMapSize)\n+            .buildClient());\n+\n+        loadByteDecoder(new AvroByteDecoder(avroSpecificReader));\n+    }\n+\n+    /**\n+     * Deserializes byte array into Java object using payload-specified schema.\n+     *\n+     * @param data Byte array containing serialized bytes\n+     * @return Java object.\n+     *\n+     * Object type is testable with instanceof operator.  Return value can be casted in the caller layer.\n+     *\n+     * @throws SerializationException Throws on deserialization failure.\n+     * Exception may contain inner exceptions detailing failure condition.", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNTcxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432725712", "bodyText": "I just removed the extra comment line.. it's was extraneous anyway.", "author": "arerlend", "createdAt": "2020-05-29T20:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYyNDk3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432624979", "bodyText": "Need to add <p> tags to have Javadocs generate with line separators.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n          \n          \n            \n             * fetching payload-specified schemas from the Azure Schema Registry store.\n          \n          \n            \n             *\n          \n          \n            \n             * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n          \n          \n            \n             *\n          \n          \n            \n             * Pluggable with the core Azure SDK Deserializer interface.\n          \n          \n            \n             * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n          \n          \n            \n             * fetching payload-specified schemas from the Azure Schema Registry store.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * Pluggable with the core Azure SDK Deserializer interface.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:13:10Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataDeserializer;\n+import com.azure.data.schemaregistry.SerializationException;\n+import com.azure.data.schemaregistry.client.CachedSchemaRegistryClientBuilder;\n+\n+/**\n+ * A deserializer implementation capable of automatedly deserializing encoded byte array payloads into Java objects by\n+ * fetching payload-specified schemas from the Azure Schema Registry store.\n+ *\n+ * SchemaRegistryAvroDeserializer instances should be built using the static Builder class.\n+ *\n+ * Pluggable with the core Azure SDK Deserializer interface.", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTA3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432631079", "bodyText": "Was this made protected to sub-classes could interact with it? Generally we stay away from protected as it is part of the public API.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:25:01Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/AbstractDataDeserializer.java", "diffHunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.client.SchemaRegistryObject;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClient;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClientException;\n+\n+import java.nio.BufferUnderflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Common implementation for all registry-based deserializers.\n+ */\n+public abstract class AbstractDataDeserializer extends AbstractDataSerDe {\n+    private final ClientLogger logger = new ClientLogger(AbstractDataDeserializer.class);\n+\n+    protected final Map<String, ByteDecoder> byteDecoderMap = new ConcurrentHashMap<>();", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432670418", "bodyText": "Updated to be private.  All access to this map is controlled via loadByteDecoder()", "author": "arerlend", "createdAt": "2020-05-29T18:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432632255", "bodyText": "I think throwing is the correct choice here, if we can't determine the schema there isn't much we can do.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:27:08Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/AbstractDataDeserializer.java", "diffHunk": "@@ -0,0 +1,127 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.client.SchemaRegistryObject;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClient;\n+import com.azure.data.schemaregistry.client.SchemaRegistryClientException;\n+\n+import java.nio.BufferUnderflowException;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Common implementation for all registry-based deserializers.\n+ */\n+public abstract class AbstractDataDeserializer extends AbstractDataSerDe {\n+    private final ClientLogger logger = new ClientLogger(AbstractDataDeserializer.class);\n+\n+    protected final Map<String, ByteDecoder> byteDecoderMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Constructor called by all concrete implementation constructors.\n+     * Should only call parent constructor.\n+     * @param schemaRegistryClient client to be used for fetching schemas by ID\n+     */\n+    protected AbstractDataDeserializer(SchemaRegistryClient schemaRegistryClient) {\n+        super(schemaRegistryClient);\n+    }\n+\n+    /**\n+     * Special case constructor for Kafka deserializer's empty constructors.\n+     */\n+    protected AbstractDataDeserializer() { }\n+\n+    /**\n+     * Fetches schema referenced by prefixed ID and deserializes the subsequent payload into Java object.\n+     *\n+     * @param payload byte payload, produced by an Azure Schema Registry client producer\n+     * @return object, deserialized with the prefixed schema\n+     * @throws SerializationException if deserialization of registry schema or message payload fails.\n+     */\n+    protected Object deserialize(byte[] payload) throws SerializationException {\n+        if (payload == null) {\n+            return null;\n+        }\n+\n+        ByteBuffer buffer = ByteBuffer.wrap(payload);\n+        String schemaGuid = getSchemaGuidFromPayload(buffer);\n+        SchemaRegistryObject registryObject;\n+        Object payloadSchema;\n+\n+        try {\n+            registryObject = this.schemaRegistryClient.getSchemaByGuid(schemaGuid);\n+            payloadSchema = registryObject.deserialize();\n+        } catch (SchemaRegistryClientException e) {\n+            throw logger.logExceptionAsError(\n+                new SerializationException(String.format(\"Failed to retrieve schema for id %s\", schemaGuid), e));\n+        }\n+\n+        // TODO: how to handle unknown formats", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0ODQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432648438", "bodyText": "Yeah the question here is whether or not we should offer a config to skip the messages where schema was not recognized.  Right now it will throw at the registry client level since there no schema parser will have been loaded.  I think we decided to punt the final decision after preview but I am leaning heavily towards throwing.", "author": "arerlend", "createdAt": "2020-05-29T17:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0ODUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432648512", "bodyText": "Going to just take the comment out.", "author": "arerlend", "createdAt": "2020-05-29T17:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMjI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzkyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432637920", "bodyText": "Should this be switched to OutputStream in case we want to change the internal return type in the future.", "author": "alzimmermsft", "createdAt": "2020-05-29T17:37:53Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/ByteEncoder.java", "diffHunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+/**\n+ * An interface defining operations required for registry serializer to convert object to bytes.\n+ */\n+public interface ByteEncoder extends Codec {\n+    /**\n+     * Return schema name for storing in registry store\n+     * @param object Schema object\n+     * Refer to Schema Registry documentation for information on schema grouping and naming.\n+     *\n+     * @return schema name\n+     * @throws SerializationException runtime exception in error cases\n+     */\n+    String getSchemaName(Object object) throws SerializationException;\n+\n+    /**\n+     * Returns string representation of schema object to be stored in the service.\n+     *\n+     * @param object Schema object used to generate schema string\n+     * @return String representation of schema object parameter\n+     * @throws SerializationException if generating string representation of schema fails\n+     */\n+    String getSchemaString(Object object) throws SerializationException;\n+\n+    // TODO: Method does not currently require schema object to be passed since schemas can be derived from\n+    // Avro objects. JSON implementation would be the same.\n+    /**\n+     * Converts object into stream containing the encoded representation of the object.\n+     * @param object Object to be encoded into byte stream\n+     * @return output stream containing byte representation of object\n+     * @throws SerializationException if generating byte representation of object fails\n+     */\n+    ByteArrayOutputStream encode(Object object) throws SerializationException;", "originalCommit": "93defa9bdfacb71789c231eb2cb9980f80c0ea01", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cea60ee4b0f1327bbcd6ed5231f8a23ac3faef83", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cea60ee4b0f1327bbcd6ed5231f8a23ac3faef83", "message": "Update sdk/schemaregistry/azure-data-schemaregistry-avro/pom.xml\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>", "committedDate": "2020-05-29T17:47:34Z", "type": "commit"}, {"oid": "6ffe75968536564b10be6f66ec76e925c9679c6c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ffe75968536564b10be6f66ec76e925c9679c6c", "message": "Update sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializer.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>", "committedDate": "2020-05-29T18:30:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTYwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432669603", "bodyText": "nit: specify that this is Apache Avro specific implementation.", "author": "srnagar", "createdAt": "2020-05-29T18:41:52Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2OTkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432669911", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public AvroByteDecoder(Boolean avroSpecificReader) {\n          \n          \n            \n                public AvroByteDecoder(boolean avroSpecificReader) {", "author": "srnagar", "createdAt": "2020-05-29T18:42:34Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MDc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432670785", "bodyText": "Extend from AzureException instead.", "author": "srnagar", "createdAt": "2020-05-29T18:44:16Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/SerializationException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry;\n+\n+/**\n+ * Exception thrown by Schema Registry serializer/deserializer implementations for runtime error cases.\n+ */\n+public class SerializationException extends RuntimeException {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3MTU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432671595", "bodyText": "Don't need to include throws SerializationException as it's a RuntimeException. Having @throws in JavaDoc is sufficient.", "author": "srnagar", "createdAt": "2020-05-29T18:45:54Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3Mjg5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432672895", "bodyText": "If the object is null, throw NPE instead of SerializationException.", "author": "srnagar", "createdAt": "2020-05-29T18:48:38Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec\n+        implements ByteDecoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteDecoder.class);\n+    private final DecoderFactory decoderFactory = DecoderFactory.get();\n+    private final boolean avroSpecificReader;\n+\n+    /**\n+     * Instantiates AvroByteDecoder instance\n+     * @param avroSpecificReader flag indicating if attempting to decode as Avro SpecificRecord\n+     */\n+    public AvroByteDecoder(Boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+    }\n+\n+    /**\n+     * @param b byte array containing encoded bytes\n+     * @param object schema for Avro reader read - fetched from Azure Schema Registry\n+     * @return deserialized object\n+     * @throws SerializationException upon deserialization failure\n+     */\n+    public Object decodeBytes(byte[] b, Object object) throws SerializationException {\n+        if (!(object instanceof Schema)) {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwNjQwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432706408", "bodyText": "Added Objects.requireNotNull() check", "author": "arerlend", "createdAt": "2020-05-29T19:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3Mjg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3NjI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432676244", "bodyText": "This ctor is available by default. It can be removed.", "author": "srnagar", "createdAt": "2020-05-29T18:55:36Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODg4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432678882", "bodyText": "Both these methods can be moved to AvroSchemaUtils and can be made static.", "author": "srnagar", "createdAt": "2020-05-29T19:01:28Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMDM4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432710385", "bodyText": "These have to be available on the byte encoder interface in order to be used by the Serializer to properly store schemas in the registry, so it needs to stay.", "author": "arerlend", "createdAt": "2020-05-29T20:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3ODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY3OTI0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432679248", "bodyText": "Same here - throws SerializationException is not required.", "author": "srnagar", "createdAt": "2020-05-29T19:02:17Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4MTQ4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432681488", "bodyText": "Don't need to close ByteArrayOutputStream.\nFrom javadoc:\n\nClosing a ByteArrayOutputStream has no effect. The methods in this class can be called after the stream has been closed without generating an IOException.", "author": "srnagar", "createdAt": "2020-05-29T19:07:11Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteEncoder.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteEncoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumWriter;\n+import org.apache.avro.io.BinaryEncoder;\n+import org.apache.avro.io.DatumWriter;\n+import org.apache.avro.io.EncoderFactory;\n+import org.apache.avro.specific.SpecificDatumWriter;\n+import org.apache.avro.specific.SpecificRecord;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * ByteEncoder implementation with all Avro-specific functionality required to serialize Java objects into byte arrays.\n+ */\n+public class AvroByteEncoder extends AvroCodec\n+        implements ByteEncoder {\n+    private final ClientLogger logger = new ClientLogger(AvroByteEncoder.class);\n+    private final EncoderFactory encoderFactory = EncoderFactory.get();\n+\n+    /**\n+     * Instantiates AvroByteEncoder instance.\n+     */\n+    public AvroByteEncoder() { }\n+\n+    /**\n+     * @param object Schema object used to generate schema string\n+     * @see AvroSchemaUtils for distinction between primitive and Avro schema generation\n+     * @return string representation of schema\n+     */\n+    public String getSchemaString(Object object) {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+        return schema.toString();\n+    }\n+\n+    /**\n+     * Returns schema name for storing schemas in schema registry store.\n+     *\n+     * @param object Schema object used to generate schema path\n+     * @return schema name as string\n+     */\n+    public String getSchemaName(Object object) {\n+        return AvroSchemaUtils.getSchema(object).getFullName();\n+    }\n+\n+    /**\n+     * Returns ByteArrayOutputStream containing Avro encoding of object parameter\n+     * @param object Object to be encoded into byte stream\n+     * @return closed ByteArrayOutputStream\n+     * @throws SerializationException wraps runtime exceptions\n+     */\n+    public ByteArrayOutputStream encode(Object object) throws SerializationException {\n+        Schema schema = AvroSchemaUtils.getSchema(object);\n+\n+        try {\n+            ByteArrayOutputStream out = new ByteArrayOutputStream();\n+            if (object instanceof byte[]) {\n+                out.write((byte[]) object);\n+            } else {\n+                BinaryEncoder encoder = encoderFactory.directBinaryEncoder(out, null);\n+                DatumWriter<Object> writer;\n+                if (object instanceof SpecificRecord) {\n+                    writer = new SpecificDatumWriter<>(schema);\n+                } else {\n+                    writer = new GenericDatumWriter<>(schema);\n+                }\n+                writer.write(object, encoder);\n+                encoder.flush();\n+            }\n+            out.close();", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4Mjc2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432682761", "bodyText": "Add @OverRide annotation for both these methods.", "author": "srnagar", "createdAt": "2020-05-29T19:10:14Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroCodec.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.Codec;\n+import org.apache.avro.Schema;\n+\n+/**\n+ * Base Codec class for Avro encoder and decoder implementations\n+ */\n+abstract class AvroCodec implements Codec {\n+    public String schemaType() {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NDQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432684420", "bodyText": "Name this class ApacheAvroByteDecoder so that  we can support Jackson avro later if required. (If this is going away after switching to azure-core implementation, then you can leave it as-is).", "author": "srnagar", "createdAt": "2020-05-29T19:14:08Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/AvroByteDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.ByteDecoder;\n+import com.azure.data.schemaregistry.SerializationException;\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericDatumReader;\n+import org.apache.avro.io.DatumReader;\n+import org.apache.avro.io.DecoderFactory;\n+import org.apache.avro.specific.SpecificDatumReader;\n+\n+import java.io.IOException;\n+\n+/**\n+ * ByteDecoder implementation with all Avro-specific functionality required to deserialize byte arrays\n+ * given an Avro schema.\n+ */\n+public class AvroByteDecoder extends AvroCodec", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxODc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432718781", "bodyText": "Leaving as is for now.  I think the plan will be to allow passing in the Jackson serializer, but will default to an Apache implementation.  Dependency story is okay because Jackson has a dep on Apache anyway.", "author": "arerlend", "createdAt": "2020-05-29T20:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NDQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjM4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432686385", "bodyText": "Don't need async suffix since the class is called SchemaRegistryAvroAsyncDeserializer", "author": "srnagar", "createdAt": "2020-05-29T19:18:50Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroAsyncDeserializer.java", "diffHunk": "@@ -0,0 +1,43 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.data.schemaregistry.SerializationException;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * Asynchronous registry-based deserializer implementation.\n+ */\n+public class SchemaRegistryAvroAsyncDeserializer {\n+    private static final int DEFAULT_THREAD_POOL_SIZE = 8;\n+\n+    private final SchemaRegistryAvroDeserializer deserializer;\n+    private final Scheduler scheduler;\n+\n+    /**\n+     * Instantiates instance of async deserializer.\n+     *\n+     * @param deserializer synchronous internal deserializer implementation\n+     */\n+    SchemaRegistryAvroAsyncDeserializer(SchemaRegistryAvroDeserializer deserializer) {\n+        this.deserializer = deserializer;\n+        this.scheduler = Schedulers.fromExecutor(Executors.newFixedThreadPool(DEFAULT_THREAD_POOL_SIZE));\n+    }\n+\n+    /**\n+     * Async wrapper around synchronous deserialization method\n+     * @param data bytes containing schema ID and encoded byte representation of object\n+     * @return Mono wrapper around deserialized object\n+     * @throws SerializationException if deserialization operation fails\n+     */\n+    public Mono<Object> deserializeAsync(byte[] data) throws SerializationException {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMTcyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432711720", "bodyText": "Ok.  I have removed sync and async suffixes for Serializer and Deserializer", "author": "arerlend", "createdAt": "2020-05-29T20:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432689034", "bodyText": "Consider using no-args ctor for builder and have a setter method for registryUrl", "author": "srnagar", "createdAt": "2020-05-29T19:25:05Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializerBuilder.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+\n+/**\n+ * Builder class for constructing {@link SchemaRegistryAvroDeserializer} and {@link SchemaRegistryAvroAsyncDeserializer}\n+ */\n+public class SchemaRegistryAvroDeserializerBuilder {\n+\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean avroSpecificReader;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder(String registryUrl) {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyMzg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432723843", "bodyText": "Updated both serializer and deserializer builders to have separate schemaRegistryUrl() methods.", "author": "arerlend", "createdAt": "2020-05-29T20:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MDE4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432690185", "bodyText": "Check if credential and registryUrl are null before creating the Deserializer.", "author": "srnagar", "createdAt": "2020-05-29T19:27:46Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroDeserializerBuilder.java", "diffHunk": "@@ -0,0 +1,90 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+\n+/**\n+ * Builder class for constructing {@link SchemaRegistryAvroDeserializer} and {@link SchemaRegistryAvroAsyncDeserializer}\n+ */\n+public class SchemaRegistryAvroDeserializerBuilder {\n+\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean avroSpecificReader;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder(String registryUrl) {\n+        this.registryUrl = registryUrl;\n+        this.credential = null;\n+        this.avroSpecificReader = false;\n+        this.maxSchemaMapSize = null;\n+    }\n+\n+    /**\n+     *\n+     * @param credential TokenCredential to be used for authenticating with Azure Schema Registry Service\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder credential(TokenCredential credential) {\n+        this.credential = credential;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies if objects should be deserialized into Avro SpecificRecords via Avro SpecificDatumReader\n+     * @param avroSpecificReader specific reader flag\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder avroSpecificReader(boolean avroSpecificReader) {\n+        this.avroSpecificReader = avroSpecificReader;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies maximum schema object cache size for underlying CachedSchemaRegistryClient.  If specified cache\n+     * size is exceeded, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize maximum number of schemas per cache\n+     * @return updated {@link SchemaRegistryAvroDeserializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroDeserializerBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Construct instance of {@link SchemaRegistryAvroAsyncDeserializer}\n+     *\n+     * @return {@link SchemaRegistryAvroAsyncDeserializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroAsyncDeserializer buildAsyncClient() {\n+        return new SchemaRegistryAvroAsyncDeserializer(this.buildSyncClient());\n+    }\n+\n+    /**\n+     * Construct instance of {@link SchemaRegistryAvroDeserializer}\n+     *\n+     * @return {@link SchemaRegistryAvroDeserializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroDeserializer buildSyncClient() {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcxMjU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432712544", "bodyText": "I am going update this such that the CachedSchemaRegistryClient is created in the builder and is passed into the constructor of the serializer/deserializer.\nTakes advantage of all the checks in CachedSchemaRegistryClientBuilder.", "author": "arerlend", "createdAt": "2020-05-29T20:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MDE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjY5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432692696", "bodyText": "Validate inputs to check if all required fields like registryUrl and credential are set.", "author": "srnagar", "createdAt": "2020-05-29T19:33:35Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/java/com/azure/data/schemaregistry/avro/SchemaRegistryAvroSerializerBuilder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.avro;\n+\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.data.schemaregistry.AbstractDataSerializer;\n+\n+/**\n+ * Builder implemenation for building {@link SchemaRegistryAvroSerializer} and {@link SchemaRegistryAvroAsyncSerializer}\n+ */\n+public final class SchemaRegistryAvroSerializerBuilder {\n+    private final String registryUrl;\n+    private TokenCredential credential;\n+    private boolean autoRegisterSchemas;\n+    private String schemaGroup;\n+    private Integer maxSchemaMapSize;\n+\n+    /**\n+     * Instantiates instance of Builder class.\n+     * Supplies client defaults.\n+     *\n+     * @param registryUrl base schema registry URL for storing and fetching schemas\n+     */\n+    private SchemaRegistryAvroSerializerBuilder(String registryUrl) {\n+        this.registryUrl = registryUrl;\n+        this.credential = null;\n+        this.autoRegisterSchemas = AbstractDataSerializer.AUTO_REGISTER_SCHEMAS_DEFAULT;\n+        this.schemaGroup = AbstractDataSerializer.SCHEMA_GROUP_DEFAULT;\n+        this.maxSchemaMapSize = null;\n+    }\n+\n+    /**\n+     * Specifies schema group for interacting with Azure Schema Registry service.\n+     *\n+     * If auto-registering schemas, schema will be stored under this group.\n+     * If not auto-registering, serializer will request schema ID for matching data schema under specified group.\n+     *\n+     * @param schemaGroup Azure Schema Registry schema group\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder schemaGroup(String schemaGroup) {\n+        this.schemaGroup = schemaGroup;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies authentication behavior with Azure Schema Registry\n+     * @param credential TokenCredential to be used to authenticate with Azure Schema Registry service\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder credential(TokenCredential credential) {\n+        this.credential = credential;\n+        return this;\n+    }\n+\n+    /**\n+     * If specified true, serializer will register schemas against Azure Schema Registry service under the specified\n+     * group.  See Azure Schema Registry documentation for a description of schema registration behavior.\n+     *\n+     * If specified false, serializer will simply query the service for an existing ID given schema content.\n+     * Serialization will fail if the schema has not been pre-created.\n+     *\n+     * Auto-registration is **NOT RECOMMENDED** for production scenarios.\n+     *\n+     * @param autoRegisterSchemas flag for schema auto-registration\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder autoRegisterSchema(boolean autoRegisterSchemas) {\n+        this.autoRegisterSchemas = autoRegisterSchemas;\n+        return this;\n+    }\n+\n+    /**\n+     * Specifies maximum schema object cache size for underlying CachedSchemaRegistryClient.  If specified cache\n+     * size is exceeded, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize maximum number of schemas per cache\n+     * @return updated {@link SchemaRegistryAvroSerializerBuilder} instance\n+     */\n+    public SchemaRegistryAvroSerializerBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Instantiates SchemaRegistry\n+     * @return {@link SchemaRegistryAvroAsyncSerializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroAsyncSerializer buildAsyncClient() {\n+        return new SchemaRegistryAvroAsyncSerializer(this.buildSyncClient());\n+    }\n+\n+    /**\n+     * Instantiates {@link SchemaRegistryAvroSerializer}\n+     * @return {@link SchemaRegistryAvroSerializer} instance\n+     *\n+     * @throws NullPointerException if parameters are incorrectly set.\n+     * @throws IllegalArgumentException if credential is not set.\n+     */\n+    public SchemaRegistryAvroSerializer buildSyncClient() {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyMjE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432722162", "bodyText": "Moved CachedSchemaRegistryClient build call to this builder so it can take advantage of the validation already in the client builder.", "author": "arerlend", "createdAt": "2020-05-29T20:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzA3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432693070", "bodyText": "This should be named as com.azure.data.schemaregistry.avro", "author": "srnagar", "createdAt": "2020-05-29T19:34:33Z", "path": "sdk/schemaregistry/azure-data-schemaregistry-avro/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.avro {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5ODQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432698484", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n          \n          \n            \n                    Objects.requireNonNull(schemaRegistryUrl, \"'schemaRegistryUrl' cannot be null.\");", "author": "srnagar", "createdAt": "2020-05-29T19:43:01Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5ODg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432698869", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));\n          \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'schemaRegistryUrl' must be a valid URL.\", ex));", "author": "srnagar", "createdAt": "2020-05-29T19:43:30Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5OTcyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432699723", "bodyText": "Check if codec is null before checking codec.schemaType.", "author": "srnagar", "createdAt": "2020-05-29T19:44:40Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/java/com/azure/data/schemaregistry/client/CachedSchemaRegistryClientBuilder.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.data.schemaregistry.client;\n+\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.HttpPipelineBuilder;\n+import com.azure.core.http.policy.AddDatePolicy;\n+import com.azure.core.http.policy.BearerTokenAuthenticationPolicy;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpLoggingPolicy;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.HttpPolicyProviders;\n+import com.azure.core.http.policy.RequestIdPolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.http.policy.UserAgentPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.schemaregistry.Codec;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestService;\n+import com.azure.data.schemaregistry.client.implementation.AzureSchemaRegistryRestServiceClientBuilder;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.function.Function;\n+\n+/**\n+ * Builder implementation for {@link CachedSchemaRegistryClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = CachedSchemaRegistryClient.class)\n+public class CachedSchemaRegistryClientBuilder {\n+    private final ClientLogger logger = new ClientLogger(CachedSchemaRegistryClientBuilder.class);\n+\n+    private static final String DEFAULT_SCOPE = \"https://eventhubs.azure.com/.default\";\n+    private static final String CLIENT_PROPERTIES = \"azure-data-schemaregistry-client.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+    private static final RetryPolicy DEFAULT_RETRY_POLICY =\n+        new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+    private final ConcurrentSkipListMap<String, Function<String, Object>> typeParserMap;\n+    private final List<HttpPipelinePolicy> policies;\n+    private final String clientName;\n+    private final String clientVersion;\n+\n+    private String schemaRegistryUrl;\n+    private HttpClient httpClient;\n+    private Integer maxSchemaMapSize;\n+    private TokenCredential credential;\n+    private HttpLogOptions httpLogOptions;\n+    private HttpPipeline httpPipeline;\n+    private RetryPolicy retryPolicy;\n+\n+    /**\n+     * Constructor for CachedSchemaRegistryClientBuilder.  Supplies client defaults.\n+     */\n+    public CachedSchemaRegistryClientBuilder() {\n+        this.policies = new ArrayList<>();\n+        this.httpLogOptions = new HttpLogOptions();\n+        this.maxSchemaMapSize = null;\n+        this.typeParserMap = new ConcurrentSkipListMap<>(String.CASE_INSENSITIVE_ORDER);\n+        this.httpClient = null;\n+        this.credential = null;\n+        this.retryPolicy = new RetryPolicy(\"retry-after-ms\", ChronoUnit.MILLIS);\n+\n+        Map<String, String> properties = CoreUtils.getProperties(CLIENT_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Schema Registry instance.\n+     *\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @param schemaRegistryUrl The URL of the Azure Schema Registry instance\n+     * @throws NullPointerException if {@code schemaRegistryUrl} is null\n+     * @throws IllegalArgumentException if {@code schemaRegistryUrl} cannot be parsed into a valid URL\n+     */\n+    public CachedSchemaRegistryClientBuilder endpoint(String schemaRegistryUrl) {\n+        Objects.requireNonNull(schemaRegistryUrl, \"'endpoint' cannot be null.\");\n+\n+        try {\n+            new URL(schemaRegistryUrl);\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));\n+        }\n+\n+        if (schemaRegistryUrl.endsWith(\"/\")) {\n+            this.schemaRegistryUrl = schemaRegistryUrl.substring(0, schemaRegistryUrl.length() - 1);\n+        } else {\n+            this.schemaRegistryUrl = schemaRegistryUrl;\n+        }\n+\n+        return this;\n+    }\n+\n+    /**\n+     * Sets schema cache size limit.  If limit is exceeded on any cache, all caches are recycled.\n+     *\n+     * @param maxSchemaMapSize max size for internal schema caches in {@link CachedSchemaRegistryClient}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws IllegalArgumentException on invalid maxSchemaMapSize value\n+     */\n+    public CachedSchemaRegistryClientBuilder maxSchemaMapSize(int maxSchemaMapSize) {\n+        if (maxSchemaMapSize < CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                String.format(\"Schema map size must be greater than %s entries\",\n+                    CachedSchemaRegistryClient.MAX_SCHEMA_MAP_SIZE_MINIMUM)));\n+        }\n+\n+        this.maxSchemaMapSize = maxSchemaMapSize;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param httpClient The HTTP client to use for requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpClient(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client.\n+     * <p>\n+     * If {@code pipeline} is set, all other HTTP settings are ignored to build {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder pipeline(HttpPipeline httpPipeline) {\n+        if (this.httpPipeline != null && httpPipeline == null) {\n+            logger.info(\"HttpPipeline is being set to 'null' when it was previously configured.\");\n+        }\n+\n+        this.httpPipeline = httpPipeline;\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Sets the {@link TokenCredential} to use when authenticating HTTP requests for this\n+     * {@link CachedSchemaRegistryClient}.\n+     *\n+     * @param credential {@link TokenCredential}\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code credential} is {@code null}\n+     */\n+    public CachedSchemaRegistryClientBuilder credential(TokenCredential credential) {\n+        this.credential = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     *\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        this.httpLogOptions = logOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link CachedSchemaRegistryClient} .\n+     *\n+     * @param retryPolicy user's retry policy applied to each request.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     *\n+     * @param policy The retry policy for service requests.\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public CachedSchemaRegistryClientBuilder addPolicy(HttpPipelinePolicy policy) {\n+        policies.add(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Loads a parser method Function object used to convert schema strings returned from the Schema Registry\n+     * service into useable schema objects.\n+     *\n+     * Any com.azure.data.schemaregistry.ByteEncoder or com.azure.data.schemaregistry.ByteDecoder class will implement\n+     * - schemaType(), which specifies schema type, and\n+     * - parseSchemaString(), which parses schemas of the specified schema type from String to Object.\n+     *\n+     * The parseMethod argument should be a stateless, idempotent function.\n+     *\n+     * @param codec Codec class implementation\n+     * @return The updated {@link CachedSchemaRegistryClientBuilder} object.\n+     */\n+    public CachedSchemaRegistryClientBuilder addSchemaParser(Codec codec) {\n+        if (CoreUtils.isNullOrEmpty(codec.schemaType())) {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMTgxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432701818", "bodyText": "This should be named as com.azure.data.schemaregistry", "author": "srnagar", "createdAt": "2020-05-29T19:47:34Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.common {", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwMjgyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10660#discussion_r432702824", "bodyText": "This should transitively require core.", "author": "srnagar", "createdAt": "2020-05-29T19:49:43Z", "path": "sdk/schemaregistry/azure-data-schemaregistry/src/main/module-info.java", "diffHunk": "@@ -0,0 +1,11 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.data.schemaregistry.serde.common {\n+    requires com.azure.core;", "originalCommit": "6ffe75968536564b10be6f66ec76e925c9679c6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5c40b1d74f2ba4462e9ec347998c876458c017a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5c40b1d74f2ba4462e9ec347998c876458c017a", "message": "fix comments", "committedDate": "2020-05-29T20:49:46Z", "type": "commit"}, {"oid": "101aeebbd0ab2198e58b83c5deeddcd80660ef4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/101aeebbd0ab2198e58b83c5deeddcd80660ef4b", "message": "spotbugs update", "committedDate": "2020-05-29T20:49:58Z", "type": "commit"}]}