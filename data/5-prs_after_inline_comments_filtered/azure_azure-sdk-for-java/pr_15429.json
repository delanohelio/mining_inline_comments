{"pr_number": 15429, "pr_title": "Initial commit for monitor exporter client library", "pr_createdAt": "2020-09-21T19:12:04Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15429", "timeline": [{"oid": "1abbcdce8ab3eb0a665c28ddaecda9a18b4eb97d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1abbcdce8ab3eb0a665c28ddaecda9a18b4eb97d", "message": "Initial commit for monitor exporter client library", "committedDate": "2020-09-21T07:53:11Z", "type": "commit"}, {"oid": "e10d8a59e61809eab8773bea595c670e93d977fc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e10d8a59e61809eab8773bea595c670e93d977fc", "message": "Add netty dependency", "committedDate": "2020-09-21T19:10:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4ODAwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r492388001", "bodyText": "asynchronous operations", "author": "samvaity", "createdAt": "2020-09-21T22:45:54Z", "path": "sdk/monitorexporter/azure-analytics-monitorexporter/src/main/java/com/azure/analytics/monitorexporter/MonitorExporterAsyncClient.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.analytics.monitorexporter;\n+\n+import com.azure.analytics.monitorexporter.implementation.ApplicationInsightsClientImpl;\n+import com.azure.analytics.monitorexporter.models.TelemetryItem;\n+import com.azure.analytics.monitorexporter.models.TrackResponse;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+/**\n+ * This class contains synchronous operations to interact with the Azure Monitor Exporter service.", "originalCommit": "e10d8a59e61809eab8773bea595c670e93d977fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4OTA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r492389041", "bodyText": "Should we consider renaming TrackResponse  to not have the suffix Response. The return type currently might be confusing to the users to have Response<TrackResponse>.\nHow about TrackMeta, TrackStatistics or TrackProperties?", "author": "samvaity", "createdAt": "2020-09-21T22:48:48Z", "path": "sdk/monitorexporter/azure-analytics-monitorexporter/src/main/java/com/azure/analytics/monitorexporter/MonitorExporterAsyncClient.java", "diffHunk": "@@ -0,0 +1,60 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.analytics.monitorexporter;\n+\n+import com.azure.analytics.monitorexporter.implementation.ApplicationInsightsClientImpl;\n+import com.azure.analytics.monitorexporter.models.TelemetryItem;\n+import com.azure.analytics.monitorexporter.models.TrackResponse;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.List;\n+\n+/**\n+ * This class contains synchronous operations to interact with the Azure Monitor Exporter service.\n+ */\n+@ServiceClient(builder = MonitorExporterClientBuilder.class, isAsync = true)\n+public class MonitorExporterAsyncClient {\n+    private final ApplicationInsightsClientImpl restServiceClient;\n+\n+    MonitorExporterAsyncClient(ApplicationInsightsClientImpl restServiceClient) {\n+        this.restServiceClient = restServiceClient;\n+    }\n+\n+    /**\n+     * The list of telemetry items that will be sent to the Azure Monitor Exporter service. The response contains the\n+     * status of number of telemetry items successfully accepted and the number of items that failed along with the\n+     * error code for all the failed items.\n+     *\n+     * @param telemetryItems The list of telemetry items to send.\n+     * @return The response containing the number of successfully accepted items and error details of items that were\n+     * rejected.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<TrackResponse> track(List<TelemetryItem> telemetryItems) {\n+        return restServiceClient.trackAsync(telemetryItems);\n+    }\n+\n+    /**\n+     * The list of telemetry items that will be sent to the Azure Monitor Exporter service. The response contains the\n+     * status of number of telemetry items successfully accepted and the number of items that failed along with the\n+     * error code for all the failed items.\n+     *\n+     * @param telemetryItems The list of telemetry items to send.\n+     * @return The response containing the number of successfully accepted items and error details of items that were\n+     * rejected.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Response<TrackResponse>> trackWithResponse(List<TelemetryItem> telemetryItems) {", "originalCommit": "e10d8a59e61809eab8773bea595c670e93d977fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE5MTEzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r493191138", "bodyText": "TrackResult?", "author": "trask", "createdAt": "2020-09-23T04:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM4OTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM5MDg3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r492390874", "bodyText": "Is this a generated model?\nIf so, we should add this to custom-types on the swagger readme.\nSame for other models.", "author": "samvaity", "createdAt": "2020-09-21T22:54:27Z", "path": "sdk/monitorexporter/azure-analytics-monitorexporter/src/main/java/com/azure/analytics/monitorexporter/models/TrackResponse.java", "diffHunk": "@@ -0,0 +1,91 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+// Code generated by Microsoft (R) AutoRest Code Generator.", "originalCommit": "e10d8a59e61809eab8773bea595c670e93d977fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3adcd8ec652f99a80e1fd2fa4206f1b335b497b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3adcd8ec652f99a80e1fd2fa4206f1b335b497b7", "message": "Update artifact name and move to monitor directory", "committedDate": "2020-10-01T17:54:19Z", "type": "commit"}, {"oid": "3ed6045c47105fc3d27f8bdeb5281babfa5f6f05", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ed6045c47105fc3d27f8bdeb5281babfa5f6f05", "message": "Readme, samples and package name update", "committedDate": "2020-10-02T21:40:47Z", "type": "commit"}, {"oid": "e997c37b5468b17acb535deb1c7bfbd2cf041b91", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e997c37b5468b17acb535deb1c7bfbd2cf041b91", "message": "Merge branch 'master' into monitor-exporter", "committedDate": "2020-10-02T21:45:45Z", "type": "commit"}, {"oid": "bbcaf06337330e12ff66392abd11ca84b6748b09", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bbcaf06337330e12ff66392abd11ca84b6748b09", "message": "Checkstyles, tests and module-info update", "committedDate": "2020-10-06T17:01:44Z", "type": "commit"}, {"oid": "6b148c4e815117e2c72bffc9567d3a5dfe224c16", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b148c4e815117e2c72bffc9567d3a5dfe224c16", "message": "Move exporter code to mono repo", "committedDate": "2020-10-06T17:01:48Z", "type": "commit"}, {"oid": "71f7c5230a0ef88d4bc8aa8cdc7aacce6ded39e5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/71f7c5230a0ef88d4bc8aa8cdc7aacce6ded39e5", "message": "maven enforcer plugin update for opentelemetry", "committedDate": "2020-10-06T17:46:02Z", "type": "commit"}, {"oid": "e9832903296a87883b94e6980ef8248c7cca9c75", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9832903296a87883b94e6980ef8248c7cca9c75", "message": "Fix compile error", "committedDate": "2020-10-06T18:44:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMjczOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500522738", "bodyText": "Consider Collections.unmodifiableSet()? unless we plan on updating this set.", "author": "conniey", "createdAt": "2020-10-06T18:49:41Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,783 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = dbSystems;", "originalCommit": "e9832903296a87883b94e6980ef8248c7cca9c75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzk3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500523974", "bodyText": "Do you have a constant's class somewhere? I see some of these are used multiple times and could be fragile if a replacement happens in one place and not another.", "author": "conniey", "createdAt": "2020-10-06T18:51:48Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,783 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = dbSystems;\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode shutdown() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    private void export(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Span.Kind kind = span.getKind();\n+        String instrumentationName = span.getInstrumentationLibraryInfo().getName();\n+        Matcher matcher = COMPONENT_PATTERN.matcher(instrumentationName);\n+        String stdComponent = matcher.matches() ? matcher.group(1) : null;\n+        if (\"jms\".equals(stdComponent) && !span.getParentSpanId().isValid() && kind == Span.Kind.CLIENT) {\n+            // no need to capture these, at least is consistent with prior behavior\n+            // these tend to be frameworks pulling messages which are then pushed to consumers\n+            // where we capture them\n+            return;\n+        }\n+        if (kind == Span.Kind.INTERNAL) {\n+            if (span.getName().equals(\"log.message\")) {\n+                exportLogSpan(span, telemetryItems);\n+            } else if (!span.getParentSpanId().isValid()) {\n+                // TODO revisit this decision\n+                // maybe user-generated telemetry?\n+                // otherwise this top-level span won't show up in Performance blade\n+                exportRequest(stdComponent, span, telemetryItems);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should use PRODUCER instead of INTERNAL\n+                exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+            } else {\n+                exportRemoteDependency(stdComponent, span, true, telemetryItems);\n+            }\n+        } else if (kind == Span.Kind.CLIENT || kind == Span.Kind.PRODUCER) {\n+            exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+        } else if (kind == Span.Kind.SERVER || kind == Span.Kind.CONSUMER) {\n+            exportRequest(stdComponent, span, telemetryItems);\n+        } else {\n+            throw new UnsupportedOperationException(kind.name());\n+        }\n+    }\n+\n+    private void exportLogSpan(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+        String message = removeAttributeString(attributes, \"message\");\n+        String level = removeAttributeString(attributes, \"level\");\n+        String loggerName = removeAttributeString(attributes, \"loggerName\");\n+        String errorStack = removeAttributeString(attributes, \"error.stack\");\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);\n+        if (errorStack == null) {\n+            trackTrace(message, span.getStartEpochNanos(), level, loggerName, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        } else {\n+            trackTraceAsException(message, span.getStartEpochNanos(), level, loggerName, errorStack, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        }\n+    }\n+\n+    private void trackTrace(String message, long timeEpochNanos, String level, String loggerName, TraceId traceId,\n+                            SpanId parentSpanId, Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                            List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        MessageData messageData = new MessageData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Message\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        messageData.setProperties(new HashMap<>());\n+        messageData.setVersion(2);\n+        monitorBase.setBaseType(\"MessageData\");\n+        monitorBase.setBaseData(messageData);\n+        messageData.setSeverityLevel(toSeverityLevel(level));\n+        messageData.setMessage(message);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        setProperties(messageData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static void setProperties(Map<String, String> properties, long timeEpochNanos, String level,\n+                                      String loggerName, Map<String, AttributeValue> attributes) {\n+        if (level != null) {\n+            properties.put(\"SourceType\", \"Logger\");\n+            properties.put(\"LoggingLevel\", level);\n+        }\n+        if (loggerName != null) {\n+            properties.put(\"LoggerName\", loggerName);\n+        }\n+\n+        if (attributes != null) {\n+            for (Map.Entry<String, AttributeValue> entry : attributes.entrySet()) {\n+                AttributeValue av = entry.getValue();\n+                String stringValue = null;\n+                switch (av.getType()) {\n+                    case STRING:\n+                        stringValue = av.getStringValue();\n+                        break;\n+                    case BOOLEAN:\n+                        stringValue = String.valueOf(av.getBooleanValue());\n+                        break;\n+                    case LONG:\n+                        stringValue = String.valueOf(av.getLongValue());\n+                        break;\n+                    case DOUBLE:\n+                        stringValue = String.valueOf(av.getDoubleValue());\n+                        break;\n+                    case STRING_ARRAY:\n+                        stringValue = String.valueOf(av.getStringArrayValue());\n+                        break;\n+                    case BOOLEAN_ARRAY:\n+                        stringValue = String.valueOf(av.getBooleanArrayValue());\n+                        break;\n+                    case LONG_ARRAY:\n+                        stringValue = String.valueOf(av.getLongArrayValue());\n+                        break;\n+                    case DOUBLE_ARRAY:\n+                        stringValue = String.valueOf(av.getDoubleArrayValue());\n+                        break;\n+                }\n+                if (stringValue != null) {\n+                    properties.put(entry.getKey(), stringValue);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trackTraceAsException(String message, long timeEpochNanos, String level, String loggerName,\n+                                       String errorStack, TraceId traceId, SpanId parentSpanId,\n+                                       Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                                       List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        TelemetryExceptionData exceptionData = new TelemetryExceptionData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Exception\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        exceptionData.setProperties(new HashMap<>());\n+        exceptionData.setVersion(2);\n+        monitorBase.setBaseType(\"ExceptionData\");\n+        monitorBase.setBaseData(exceptionData);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        exceptionData.setExceptions(minimalParse(errorStack));\n+        exceptionData.setSeverityLevel(toSeverityLevel(level));\n+        exceptionData.getProperties().put(\"Logger Message\", message);\n+        setProperties(exceptionData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static List<TelemetryExceptionDetails> minimalParse(String errorStack) {\n+        TelemetryExceptionDetails details = new TelemetryExceptionDetails();\n+        String line = errorStack.split(\"\\n\")[0];\n+        int index = line.indexOf(\": \");\n+\n+        if (index != -1) {\n+            details.setTypeName(line.substring(0, index));\n+            details.setMessage(line.substring(index + 2));\n+        } else {\n+            details.setTypeName(line);\n+        }\n+        details.setStack(errorStack);\n+        return Arrays.asList(details);\n+    }\n+\n+    private void exportRemoteDependency(String stdComponent, SpanData span, boolean inProc, List<TelemetryItem> telemetryItems) {\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        RemoteDependencyData remoteDependencyData = new RemoteDependencyData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"RemoteDependency\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        remoteDependencyData.setProperties(new HashMap<>());\n+        remoteDependencyData.setVersion(2);\n+        monitorBase.setBaseType(\"RemoteDependencyData\");\n+        monitorBase.setBaseData(remoteDependencyData);\n+\n+        addLinks(remoteDependencyData.getProperties(), span.getLinks());\n+        remoteDependencyData.setName(span.getName());\n+\n+        span.getInstrumentationLibraryInfo().getName();\n+\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+\n+        if (inProc) {\n+            remoteDependencyData.setType(\"InProc\");\n+        } else {\n+            if (attributes.containsKey(\"http.method\")) {\n+                applyHttpRequestSpan(attributes, remoteDependencyData);\n+            } else if (attributes.containsKey(SemanticAttributes.DB_SYSTEM.key())) {\n+                applyDatabaseQuerySpan(attributes, remoteDependencyData, stdComponent);\n+            } else if (span.getName().equals(\"EventHubs.send\")) {\n+                // TODO eventhubs should use CLIENT instead of PRODUCER\n+                // TODO eventhubs should add links to messages?\n+                remoteDependencyData.setType(\"Microsoft.EventHub\");\n+                String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+                String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+                remoteDependencyData.setTarget(peerAddress + \"/\" + destination);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {", "originalCommit": "e9832903296a87883b94e6980ef8248c7cca9c75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU0NDYwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500544604", "bodyText": "Yes, we'll have a constants class in a follow-up PR.", "author": "srnagar", "createdAt": "2020-10-06T19:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyMzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNDE2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500524166", "bodyText": "ServiceClient Annotations?", "author": "conniey", "createdAt": "2020-10-06T18:52:08Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporterBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.ApplicationInsightsClientImpl;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.ApplicationInsightsClientImplBuilder;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.NdJsonSerializer;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+/**\n+ * This class provides a fluent builder API to instantiate {@link AzureMonitorExporter} that implements\n+ * {@link SpanExporter} interface defined by OpenTelemetry API specification.\n+ */\n+public final class AzureMonitorExporterBuilder {", "originalCommit": "e9832903296a87883b94e6980ef8248c7cca9c75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU0NTEzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500545130", "bodyText": "This doesn't build conventional track 2 clients. It builds an open telemetry exporter. So, I don't think the annotations are appropriate here.", "author": "srnagar", "createdAt": "2020-10-06T19:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUyNDE2Ng=="}], "type": "inlineReview"}, {"oid": "33a2c2053a0f4b2bd99abe725bff1930ffa81ce4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/33a2c2053a0f4b2bd99abe725bff1930ffa81ce4", "message": "Merge remote-tracking branch 'upstream/master' into monitor-exporter", "committedDate": "2020-10-06T18:53:07Z", "type": "commit"}, {"oid": "cc60fb8af7716627f688c96acbda2eb630635fe5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cc60fb8af7716627f688c96acbda2eb630635fe5", "message": "Fix dependency version", "committedDate": "2020-10-06T19:22:27Z", "type": "commit"}, {"oid": "99bc32818959ea3b9342f99225e2c6d802b630ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99bc32818959ea3b9342f99225e2c6d802b630ca", "message": "Address PR comments", "committedDate": "2020-10-06T19:47:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMzk1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500603950", "bodyText": "before GA let's switch from instrumentation key to connection string", "author": "trask", "createdAt": "2020-10-06T21:23:01Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporterBuilder.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.ApplicationInsightsClientImpl;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.ApplicationInsightsClientImplBuilder;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.NdJsonSerializer;\n+import com.azure.core.http.HttpClient;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.policy.HttpLogDetailLevel;\n+import com.azure.core.http.policy.HttpLogOptions;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.http.policy.RetryPolicy;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.Objects;\n+\n+/**\n+ * This class provides a fluent builder API to instantiate {@link AzureMonitorExporter} that implements\n+ * {@link SpanExporter} interface defined by OpenTelemetry API specification.\n+ */\n+public final class AzureMonitorExporterBuilder {\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporterBuilder.class);\n+    private final ApplicationInsightsClientImplBuilder restServiceClientBuilder;\n+    private String instrumentationKey;\n+\n+    /**\n+     * Creates an instance of {@link AzureMonitorExporterBuilder}.\n+     */\n+    public AzureMonitorExporterBuilder() {\n+        restServiceClientBuilder = new ApplicationInsightsClientImplBuilder();\n+    }\n+\n+    /**\n+     * Sets the service endpoint for the Azure Monitor Exporter.\n+     * @param endpoint The URL of the Azure Monitor Exporter endpoint.\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     * @throws NullPointerException if {@code endpoint} is null.\n+     * @throws IllegalArgumentException if {@code endpoint} cannot be parsed into a valid URL.\n+     */\n+    public AzureMonitorExporterBuilder endpoint(String endpoint) {\n+        Objects.requireNonNull(endpoint, \"'endpoint' cannot be null.\");\n+\n+        try {\n+            URL url = new URL(endpoint);\n+            restServiceClientBuilder.host(url.getHost());\n+        } catch (MalformedURLException ex) {\n+            throw logger.logExceptionAsWarning(\n+                new IllegalArgumentException(\"'endpoint' must be a valid URL.\", ex));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP pipeline to use for the service client. If {@code pipeline} is set, all other settings are\n+     * ignored, apart from {@link #endpoint(String) endpoint}.\n+     *\n+     * @param httpPipeline The HTTP pipeline to use for sending service requests and receiving responses.\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder pipeline(HttpPipeline httpPipeline) {\n+        restServiceClientBuilder.pipeline(httpPipeline);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the HTTP client to use for sending and receiving requests to and from the service.\n+     *\n+     * @param client The HTTP client to use for requests.\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder httpClient(HttpClient client) {\n+        restServiceClientBuilder.httpClient(client);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the logging configuration for HTTP requests and responses.\n+     *\n+     * <p> If logLevel is not provided, default value of {@link HttpLogDetailLevel#NONE} is set. </p>\n+     * @param logOptions The logging configuration to use when sending and receiving HTTP requests/responses.\n+     *\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder httpLogOptions(HttpLogOptions logOptions) {\n+        restServiceClientBuilder.httpLogOptions(logOptions);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the {@link RetryPolicy} that is used when each request is sent.\n+     * <p>\n+     * The default retry policy will be used if not provided to build {@link AzureMonitorExporterBuilder} .\n+     * @param retryPolicy user's retry policy applied to each request.\n+     *\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        restServiceClientBuilder.retryPolicy(retryPolicy);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds a policy to the set of existing policies that are executed after required policies.\n+     * @param policy The retry policy for service requests.\n+     *\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     * @throws NullPointerException If {@code policy} is {@code null}.\n+     */\n+    public AzureMonitorExporterBuilder addPolicy(HttpPipelinePolicy policy) {\n+        restServiceClientBuilder.addPolicy(Objects.requireNonNull(policy, \"'policy' cannot be null.\"));\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the configuration store that is used during construction of the service client.\n+     * <p>\n+     * The default configuration store is a clone of the {@link Configuration#getGlobalConfiguration() global\n+     * configuration store}, use {@link Configuration#NONE} to bypass using configuration settings during construction.\n+     *\n+     * @param configuration The configuration store used to\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder configuration(Configuration configuration) {\n+        restServiceClientBuilder.configuration(configuration);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the instrumentation key to use for exporting telemetry events to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of the Azure Monitor resource.\n+     * @return The updated {@link AzureMonitorExporterBuilder} object.\n+     */\n+    public AzureMonitorExporterBuilder instrumentationKey(String instrumentationKey) {", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNTM1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500605356", "bodyText": "i think dashes need to be removed from ikey here", "author": "trask", "createdAt": "2020-10-06T21:25:59Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNTYxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500605610", "bodyText": "TODO implement before GA", "author": "trask", "createdAt": "2020-10-06T21:26:29Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNjE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500606154", "bodyText": "(not required for beta.1) we don't need log handling, this is all hack to transport logs over spans, and not official OpenTelemetry (which will support Logs separately in the future)", "author": "trask", "createdAt": "2020-10-06T21:27:38Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode shutdown() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    private void export(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Span.Kind kind = span.getKind();\n+        String instrumentationName = span.getInstrumentationLibraryInfo().getName();\n+        Matcher matcher = COMPONENT_PATTERN.matcher(instrumentationName);\n+        String stdComponent = matcher.matches() ? matcher.group(1) : null;\n+        if (\"jms\".equals(stdComponent) && !span.getParentSpanId().isValid() && kind == Span.Kind.CLIENT) {\n+            // no need to capture these, at least is consistent with prior behavior\n+            // these tend to be frameworks pulling messages which are then pushed to consumers\n+            // where we capture them\n+            return;\n+        }\n+        if (kind == Span.Kind.INTERNAL) {\n+            if (span.getName().equals(\"log.message\")) {\n+                exportLogSpan(span, telemetryItems);", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNzAyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500607020", "bodyText": "not needed (part of logging hack)", "author": "trask", "createdAt": "2020-10-06T21:29:13Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode shutdown() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    private void export(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Span.Kind kind = span.getKind();\n+        String instrumentationName = span.getInstrumentationLibraryInfo().getName();\n+        Matcher matcher = COMPONENT_PATTERN.matcher(instrumentationName);\n+        String stdComponent = matcher.matches() ? matcher.group(1) : null;\n+        if (\"jms\".equals(stdComponent) && !span.getParentSpanId().isValid() && kind == Span.Kind.CLIENT) {\n+            // no need to capture these, at least is consistent with prior behavior\n+            // these tend to be frameworks pulling messages which are then pushed to consumers\n+            // where we capture them\n+            return;\n+        }\n+        if (kind == Span.Kind.INTERNAL) {\n+            if (span.getName().equals(\"log.message\")) {\n+                exportLogSpan(span, telemetryItems);\n+            } else if (!span.getParentSpanId().isValid()) {\n+                // TODO revisit this decision\n+                // maybe user-generated telemetry?\n+                // otherwise this top-level span won't show up in Performance blade\n+                exportRequest(stdComponent, span, telemetryItems);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should use PRODUCER instead of INTERNAL\n+                exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+            } else {\n+                exportRemoteDependency(stdComponent, span, true, telemetryItems);\n+            }\n+        } else if (kind == Span.Kind.CLIENT || kind == Span.Kind.PRODUCER) {\n+            exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+        } else if (kind == Span.Kind.SERVER || kind == Span.Kind.CONSUMER) {\n+            exportRequest(stdComponent, span, telemetryItems);\n+        } else {\n+            throw new UnsupportedOperationException(kind.name());\n+        }\n+    }\n+\n+    private void exportLogSpan(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+        String message = removeAttributeString(attributes, \"message\");\n+        String level = removeAttributeString(attributes, \"level\");\n+        String loggerName = removeAttributeString(attributes, \"loggerName\");\n+        String errorStack = removeAttributeString(attributes, \"error.stack\");\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);\n+        if (errorStack == null) {\n+            trackTrace(message, span.getStartEpochNanos(), level, loggerName, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        } else {\n+            trackTraceAsException(message, span.getStartEpochNanos(), level, loggerName, errorStack, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        }\n+    }\n+\n+    private void trackTrace(String message, long timeEpochNanos, String level, String loggerName, TraceId traceId,\n+                            SpanId parentSpanId, Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                            List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        MessageData messageData = new MessageData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Message\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        messageData.setProperties(new HashMap<>());\n+        messageData.setVersion(2);\n+        monitorBase.setBaseType(\"MessageData\");\n+        monitorBase.setBaseData(messageData);\n+        messageData.setSeverityLevel(toSeverityLevel(level));\n+        messageData.setMessage(message);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        setProperties(messageData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static void setProperties(Map<String, String> properties, long timeEpochNanos, String level,\n+                                      String loggerName, Map<String, AttributeValue> attributes) {\n+        if (level != null) {\n+            properties.put(\"SourceType\", \"Logger\");\n+            properties.put(\"LoggingLevel\", level);\n+        }\n+        if (loggerName != null) {\n+            properties.put(\"LoggerName\", loggerName);\n+        }", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYxMTc0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500611748", "bodyText": "TODO for GA, probably need to publish an OpenTelemetry Sampler as part of this package that implements ApplicationInsights's sampling algorithm", "author": "trask", "createdAt": "2020-10-06T21:39:34Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode shutdown() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    private void export(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Span.Kind kind = span.getKind();\n+        String instrumentationName = span.getInstrumentationLibraryInfo().getName();\n+        Matcher matcher = COMPONENT_PATTERN.matcher(instrumentationName);\n+        String stdComponent = matcher.matches() ? matcher.group(1) : null;\n+        if (\"jms\".equals(stdComponent) && !span.getParentSpanId().isValid() && kind == Span.Kind.CLIENT) {\n+            // no need to capture these, at least is consistent with prior behavior\n+            // these tend to be frameworks pulling messages which are then pushed to consumers\n+            // where we capture them\n+            return;\n+        }\n+        if (kind == Span.Kind.INTERNAL) {\n+            if (span.getName().equals(\"log.message\")) {\n+                exportLogSpan(span, telemetryItems);\n+            } else if (!span.getParentSpanId().isValid()) {\n+                // TODO revisit this decision\n+                // maybe user-generated telemetry?\n+                // otherwise this top-level span won't show up in Performance blade\n+                exportRequest(stdComponent, span, telemetryItems);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should use PRODUCER instead of INTERNAL\n+                exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+            } else {\n+                exportRemoteDependency(stdComponent, span, true, telemetryItems);\n+            }\n+        } else if (kind == Span.Kind.CLIENT || kind == Span.Kind.PRODUCER) {\n+            exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+        } else if (kind == Span.Kind.SERVER || kind == Span.Kind.CONSUMER) {\n+            exportRequest(stdComponent, span, telemetryItems);\n+        } else {\n+            throw new UnsupportedOperationException(kind.name());\n+        }\n+    }\n+\n+    private void exportLogSpan(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+        String message = removeAttributeString(attributes, \"message\");\n+        String level = removeAttributeString(attributes, \"level\");\n+        String loggerName = removeAttributeString(attributes, \"loggerName\");\n+        String errorStack = removeAttributeString(attributes, \"error.stack\");\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);\n+        if (errorStack == null) {\n+            trackTrace(message, span.getStartEpochNanos(), level, loggerName, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        } else {\n+            trackTraceAsException(message, span.getStartEpochNanos(), level, loggerName, errorStack, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        }\n+    }\n+\n+    private void trackTrace(String message, long timeEpochNanos, String level, String loggerName, TraceId traceId,\n+                            SpanId parentSpanId, Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                            List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        MessageData messageData = new MessageData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Message\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        messageData.setProperties(new HashMap<>());\n+        messageData.setVersion(2);\n+        monitorBase.setBaseType(\"MessageData\");\n+        monitorBase.setBaseData(messageData);\n+        messageData.setSeverityLevel(toSeverityLevel(level));\n+        messageData.setMessage(message);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        setProperties(messageData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static void setProperties(Map<String, String> properties, long timeEpochNanos, String level,\n+                                      String loggerName, Map<String, AttributeValue> attributes) {\n+        if (level != null) {\n+            properties.put(\"SourceType\", \"Logger\");\n+            properties.put(\"LoggingLevel\", level);\n+        }\n+        if (loggerName != null) {\n+            properties.put(\"LoggerName\", loggerName);\n+        }\n+\n+        if (attributes != null) {\n+            for (Map.Entry<String, AttributeValue> entry : attributes.entrySet()) {\n+                AttributeValue av = entry.getValue();\n+                String stringValue = null;\n+                switch (av.getType()) {\n+                    case STRING:\n+                        stringValue = av.getStringValue();\n+                        break;\n+                    case BOOLEAN:\n+                        stringValue = String.valueOf(av.getBooleanValue());\n+                        break;\n+                    case LONG:\n+                        stringValue = String.valueOf(av.getLongValue());\n+                        break;\n+                    case DOUBLE:\n+                        stringValue = String.valueOf(av.getDoubleValue());\n+                        break;\n+                    case STRING_ARRAY:\n+                        stringValue = String.valueOf(av.getStringArrayValue());\n+                        break;\n+                    case BOOLEAN_ARRAY:\n+                        stringValue = String.valueOf(av.getBooleanArrayValue());\n+                        break;\n+                    case LONG_ARRAY:\n+                        stringValue = String.valueOf(av.getLongArrayValue());\n+                        break;\n+                    case DOUBLE_ARRAY:\n+                        stringValue = String.valueOf(av.getDoubleArrayValue());\n+                        break;\n+                }\n+                if (stringValue != null) {\n+                    properties.put(entry.getKey(), stringValue);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trackTraceAsException(String message, long timeEpochNanos, String level, String loggerName,\n+                                       String errorStack, TraceId traceId, SpanId parentSpanId,\n+                                       Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                                       List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        TelemetryExceptionData exceptionData = new TelemetryExceptionData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Exception\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        exceptionData.setProperties(new HashMap<>());\n+        exceptionData.setVersion(2);\n+        monitorBase.setBaseType(\"ExceptionData\");\n+        monitorBase.setBaseData(exceptionData);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        exceptionData.setExceptions(minimalParse(errorStack));\n+        exceptionData.setSeverityLevel(toSeverityLevel(level));\n+        exceptionData.getProperties().put(\"Logger Message\", message);\n+        setProperties(exceptionData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static List<TelemetryExceptionDetails> minimalParse(String errorStack) {\n+        TelemetryExceptionDetails details = new TelemetryExceptionDetails();\n+        String line = errorStack.split(\"\\n\")[0];\n+        int index = line.indexOf(\": \");\n+\n+        if (index != -1) {\n+            details.setTypeName(line.substring(0, index));\n+            details.setMessage(line.substring(index + 2));\n+        } else {\n+            details.setTypeName(line);\n+        }\n+        details.setStack(errorStack);\n+        return Arrays.asList(details);\n+    }\n+\n+    private void exportRemoteDependency(String stdComponent, SpanData span, boolean inProc, List<TelemetryItem> telemetryItems) {\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        RemoteDependencyData remoteDependencyData = new RemoteDependencyData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"RemoteDependency\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        remoteDependencyData.setProperties(new HashMap<>());\n+        remoteDependencyData.setVersion(2);\n+        monitorBase.setBaseType(\"RemoteDependencyData\");\n+        monitorBase.setBaseData(remoteDependencyData);\n+\n+        addLinks(remoteDependencyData.getProperties(), span.getLinks());\n+        remoteDependencyData.setName(span.getName());\n+\n+        span.getInstrumentationLibraryInfo().getName();\n+\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+\n+        if (inProc) {\n+            remoteDependencyData.setType(\"InProc\");\n+        } else {\n+            if (attributes.containsKey(\"http.method\")) {\n+                applyHttpRequestSpan(attributes, remoteDependencyData);\n+            } else if (attributes.containsKey(SemanticAttributes.DB_SYSTEM.key())) {\n+                applyDatabaseQuerySpan(attributes, remoteDependencyData, stdComponent);\n+            } else if (span.getName().equals(\"EventHubs.send\")) {\n+                // TODO eventhubs should use CLIENT instead of PRODUCER\n+                // TODO eventhubs should add links to messages?\n+                remoteDependencyData.setType(\"Microsoft.EventHub\");\n+                String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+                String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+                remoteDependencyData.setTarget(peerAddress + \"/\" + destination);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should populate peer.address and message_bus.destination\n+                String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+                String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+                if (peerAddress != null) {\n+                    remoteDependencyData.setTarget(peerAddress + \"/\" + destination);\n+                }\n+                remoteDependencyData.setType(\"Microsoft.EventHub\");\n+            } else if (\"kafka-clients\".equals(stdComponent)) {\n+                remoteDependencyData.setType(\"Kafka\");\n+                remoteDependencyData.setTarget(span.getName()); // destination queue name\n+            } else if (\"jms\".equals(stdComponent)) {\n+                remoteDependencyData.setType(\"JMS\");\n+                remoteDependencyData.setTarget(span.getName()); // destination queue name\n+            }\n+        }\n+\n+        remoteDependencyData.setId(span.getSpanId().toLowerBase16());\n+        telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), span.getTraceId().toLowerBase16());\n+\n+        SpanId parentSpanId = span.getParentSpanId();\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        telemetryItem.setTime(getFormattedTime(span.getStartEpochNanos()));\n+        remoteDependencyData.setDuration(getFormattedDuration(Duration.ofNanos(span.getEndEpochNanos() - span.getStartEpochNanos())));\n+\n+        remoteDependencyData.setSuccess(span.getStatus().isOk());\n+        String description = span.getStatus().getDescription();\n+        if (description != null) {\n+            remoteDependencyData.getProperties().put(\"statusDescription\", description);\n+        }\n+\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYxNDI4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15429#discussion_r500614289", "bodyText": "TODO do we want to provide a legacy Application Insights propagator?", "author": "trask", "createdAt": "2020-10-06T21:45:27Z", "path": "sdk/monitor/opentelemetry-exporter-azuremonitor/src/main/java/com/azure/opentelemetry/exporter/azuremonitor/AzureMonitorExporter.java", "diffHunk": "@@ -0,0 +1,784 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.opentelemetry.exporter.azuremonitor;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.ContextTagKeys;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MessageData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.MonitorBase;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RemoteDependencyData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.RequestData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.SeverityLevel;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryEventData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionData;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryExceptionDetails;\n+import com.azure.opentelemetry.exporter.azuremonitor.implementation.models.TelemetryItem;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.common.Attributes;\n+import io.opentelemetry.common.ReadableAttributes;\n+import io.opentelemetry.common.ReadableKeyValuePairs;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.attributes.SemanticAttributes;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n+\n+/**\n+ * This class is an implementation of OpenTelemetry {@link SpanExporter} that allows different tracing services to\n+ * export recorded data for sampled spans in their own format.\n+ */\n+public class AzureMonitorExporter implements SpanExporter {\n+    private static final Pattern COMPONENT_PATTERN = Pattern\n+        .compile(\"io\\\\.opentelemetry\\\\.auto\\\\.([^0-9]*)(-[0-9.]*)?\");\n+\n+    private static final Set<String> SQL_DB_SYSTEMS;\n+\n+    static {\n+        Set<String> dbSystems = new HashSet<>();\n+        dbSystems.add(\"db2\");\n+        dbSystems.add(\"derby\");\n+        dbSystems.add(\"mariadb\");\n+        dbSystems.add(\"mssql\");\n+        dbSystems.add(\"mysql\");\n+        dbSystems.add(\"oracle\");\n+        dbSystems.add(\"postgresql\");\n+        dbSystems.add(\"sqlite\");\n+        dbSystems.add(\"other_sql\");\n+        dbSystems.add(\"hsqldb\");\n+        dbSystems.add(\"h2\");\n+\n+        SQL_DB_SYSTEMS = Collections.unmodifiableSet(dbSystems);\n+    }\n+\n+    private final MonitorExporterClient client;\n+    private final ClientLogger logger = new ClientLogger(AzureMonitorExporter.class);\n+    private final String instrumentationKey;\n+    private final String telemetryItemNamePrefix;\n+\n+    /**\n+     * Creates an instance of exporter that is configured with given exporter client that sends telemetry events to\n+     * Application Insights resource identified by the instrumentation key.\n+     *\n+     * @param client The client used to send data to Azure Monitor.\n+     * @param instrumentationKey The instrumentation key of Application Insights resource.\n+     */\n+    AzureMonitorExporter(MonitorExporterClient client, String instrumentationKey) {\n+        this.client = client;\n+        this.instrumentationKey = instrumentationKey;\n+        this.telemetryItemNamePrefix = \"Microsoft.ApplicationInsights.\" + instrumentationKey + \".\";\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode export(Collection<SpanData> spans) {\n+\n+        try {\n+            List<TelemetryItem> telemetryItems = new ArrayList<>();\n+            for (SpanData span : spans) {\n+                logger.verbose(\"exporting span: {}\", span);\n+                export(span, telemetryItems);\n+            }\n+            client.export(telemetryItems);\n+            return CompletableResultCode.ofSuccess();\n+        } catch (Throwable t) {\n+            logger.error(t.getMessage(), t);\n+            return CompletableResultCode.ofFailure();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode flush() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public CompletableResultCode shutdown() {\n+        return CompletableResultCode.ofSuccess();\n+    }\n+\n+    private void export(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Span.Kind kind = span.getKind();\n+        String instrumentationName = span.getInstrumentationLibraryInfo().getName();\n+        Matcher matcher = COMPONENT_PATTERN.matcher(instrumentationName);\n+        String stdComponent = matcher.matches() ? matcher.group(1) : null;\n+        if (\"jms\".equals(stdComponent) && !span.getParentSpanId().isValid() && kind == Span.Kind.CLIENT) {\n+            // no need to capture these, at least is consistent with prior behavior\n+            // these tend to be frameworks pulling messages which are then pushed to consumers\n+            // where we capture them\n+            return;\n+        }\n+        if (kind == Span.Kind.INTERNAL) {\n+            if (span.getName().equals(\"log.message\")) {\n+                exportLogSpan(span, telemetryItems);\n+            } else if (!span.getParentSpanId().isValid()) {\n+                // TODO revisit this decision\n+                // maybe user-generated telemetry?\n+                // otherwise this top-level span won't show up in Performance blade\n+                exportRequest(stdComponent, span, telemetryItems);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should use PRODUCER instead of INTERNAL\n+                exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+            } else {\n+                exportRemoteDependency(stdComponent, span, true, telemetryItems);\n+            }\n+        } else if (kind == Span.Kind.CLIENT || kind == Span.Kind.PRODUCER) {\n+            exportRemoteDependency(stdComponent, span, false, telemetryItems);\n+        } else if (kind == Span.Kind.SERVER || kind == Span.Kind.CONSUMER) {\n+            exportRequest(stdComponent, span, telemetryItems);\n+        } else {\n+            throw new UnsupportedOperationException(kind.name());\n+        }\n+    }\n+\n+    private void exportLogSpan(SpanData span, List<TelemetryItem> telemetryItems) {\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+        String message = removeAttributeString(attributes, \"message\");\n+        String level = removeAttributeString(attributes, \"level\");\n+        String loggerName = removeAttributeString(attributes, \"loggerName\");\n+        String errorStack = removeAttributeString(attributes, \"error.stack\");\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);\n+        if (errorStack == null) {\n+            trackTrace(message, span.getStartEpochNanos(), level, loggerName, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        } else {\n+            trackTraceAsException(message, span.getStartEpochNanos(), level, loggerName, errorStack, span.getTraceId(),\n+                span.getParentSpanId(), samplingPercentage, attributes, telemetryItems);\n+        }\n+    }\n+\n+    private void trackTrace(String message, long timeEpochNanos, String level, String loggerName, TraceId traceId,\n+                            SpanId parentSpanId, Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                            List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        MessageData messageData = new MessageData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Message\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        messageData.setProperties(new HashMap<>());\n+        messageData.setVersion(2);\n+        monitorBase.setBaseType(\"MessageData\");\n+        monitorBase.setBaseData(messageData);\n+        messageData.setSeverityLevel(toSeverityLevel(level));\n+        messageData.setMessage(message);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        setProperties(messageData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static void setProperties(Map<String, String> properties, long timeEpochNanos, String level,\n+                                      String loggerName, Map<String, AttributeValue> attributes) {\n+        if (level != null) {\n+            properties.put(\"SourceType\", \"Logger\");\n+            properties.put(\"LoggingLevel\", level);\n+        }\n+        if (loggerName != null) {\n+            properties.put(\"LoggerName\", loggerName);\n+        }\n+\n+        if (attributes != null) {\n+            for (Map.Entry<String, AttributeValue> entry : attributes.entrySet()) {\n+                AttributeValue av = entry.getValue();\n+                String stringValue = null;\n+                switch (av.getType()) {\n+                    case STRING:\n+                        stringValue = av.getStringValue();\n+                        break;\n+                    case BOOLEAN:\n+                        stringValue = String.valueOf(av.getBooleanValue());\n+                        break;\n+                    case LONG:\n+                        stringValue = String.valueOf(av.getLongValue());\n+                        break;\n+                    case DOUBLE:\n+                        stringValue = String.valueOf(av.getDoubleValue());\n+                        break;\n+                    case STRING_ARRAY:\n+                        stringValue = String.valueOf(av.getStringArrayValue());\n+                        break;\n+                    case BOOLEAN_ARRAY:\n+                        stringValue = String.valueOf(av.getBooleanArrayValue());\n+                        break;\n+                    case LONG_ARRAY:\n+                        stringValue = String.valueOf(av.getLongArrayValue());\n+                        break;\n+                    case DOUBLE_ARRAY:\n+                        stringValue = String.valueOf(av.getDoubleArrayValue());\n+                        break;\n+                }\n+                if (stringValue != null) {\n+                    properties.put(entry.getKey(), stringValue);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void trackTraceAsException(String message, long timeEpochNanos, String level, String loggerName,\n+                                       String errorStack, TraceId traceId, SpanId parentSpanId,\n+                                       Double samplingPercentage, Map<String, AttributeValue> attributes,\n+                                       List<TelemetryItem> telemetryItems) {\n+\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        TelemetryExceptionData exceptionData = new TelemetryExceptionData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Exception\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        exceptionData.setProperties(new HashMap<>());\n+        exceptionData.setVersion(2);\n+        monitorBase.setBaseType(\"ExceptionData\");\n+        monitorBase.setBaseData(exceptionData);\n+\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), traceId.toLowerBase16());\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        exceptionData.setExceptions(minimalParse(errorStack));\n+        exceptionData.setSeverityLevel(toSeverityLevel(level));\n+        exceptionData.getProperties().put(\"Logger Message\", message);\n+        setProperties(exceptionData.getProperties(), timeEpochNanos, level, loggerName, attributes);\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+    }\n+\n+    private static List<TelemetryExceptionDetails> minimalParse(String errorStack) {\n+        TelemetryExceptionDetails details = new TelemetryExceptionDetails();\n+        String line = errorStack.split(\"\\n\")[0];\n+        int index = line.indexOf(\": \");\n+\n+        if (index != -1) {\n+            details.setTypeName(line.substring(0, index));\n+            details.setMessage(line.substring(index + 2));\n+        } else {\n+            details.setTypeName(line);\n+        }\n+        details.setStack(errorStack);\n+        return Arrays.asList(details);\n+    }\n+\n+    private void exportRemoteDependency(String stdComponent, SpanData span, boolean inProc, List<TelemetryItem> telemetryItems) {\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        RemoteDependencyData remoteDependencyData = new RemoteDependencyData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"RemoteDependency\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        remoteDependencyData.setProperties(new HashMap<>());\n+        remoteDependencyData.setVersion(2);\n+        monitorBase.setBaseType(\"RemoteDependencyData\");\n+        monitorBase.setBaseData(remoteDependencyData);\n+\n+        addLinks(remoteDependencyData.getProperties(), span.getLinks());\n+        remoteDependencyData.setName(span.getName());\n+\n+        span.getInstrumentationLibraryInfo().getName();\n+\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+\n+        if (inProc) {\n+            remoteDependencyData.setType(\"InProc\");\n+        } else {\n+            if (attributes.containsKey(\"http.method\")) {\n+                applyHttpRequestSpan(attributes, remoteDependencyData);\n+            } else if (attributes.containsKey(SemanticAttributes.DB_SYSTEM.key())) {\n+                applyDatabaseQuerySpan(attributes, remoteDependencyData, stdComponent);\n+            } else if (span.getName().equals(\"EventHubs.send\")) {\n+                // TODO eventhubs should use CLIENT instead of PRODUCER\n+                // TODO eventhubs should add links to messages?\n+                remoteDependencyData.setType(\"Microsoft.EventHub\");\n+                String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+                String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+                remoteDependencyData.setTarget(peerAddress + \"/\" + destination);\n+            } else if (span.getName().equals(\"EventHubs.message\")) {\n+                // TODO eventhubs should populate peer.address and message_bus.destination\n+                String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+                String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+                if (peerAddress != null) {\n+                    remoteDependencyData.setTarget(peerAddress + \"/\" + destination);\n+                }\n+                remoteDependencyData.setType(\"Microsoft.EventHub\");\n+            } else if (\"kafka-clients\".equals(stdComponent)) {\n+                remoteDependencyData.setType(\"Kafka\");\n+                remoteDependencyData.setTarget(span.getName()); // destination queue name\n+            } else if (\"jms\".equals(stdComponent)) {\n+                remoteDependencyData.setType(\"JMS\");\n+                remoteDependencyData.setTarget(span.getName()); // destination queue name\n+            }\n+        }\n+\n+        remoteDependencyData.setId(span.getSpanId().toLowerBase16());\n+        telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), span.getTraceId().toLowerBase16());\n+\n+        SpanId parentSpanId = span.getParentSpanId();\n+        if (parentSpanId.isValid()) {\n+            telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_PARENT_ID.toString(), parentSpanId.toLowerBase16());\n+        }\n+\n+        telemetryItem.setTime(getFormattedTime(span.getStartEpochNanos()));\n+        remoteDependencyData.setDuration(getFormattedDuration(Duration.ofNanos(span.getEndEpochNanos() - span.getStartEpochNanos())));\n+\n+        remoteDependencyData.setSuccess(span.getStatus().isOk());\n+        String description = span.getStatus().getDescription();\n+        if (description != null) {\n+            remoteDependencyData.getProperties().put(\"statusDescription\", description);\n+        }\n+\n+        Double samplingPercentage = removeAiSamplingPercentage(attributes);\n+\n+        // for now, only add extra attributes for custom telemetry\n+        if (stdComponent == null) {\n+            addExtraAttributes(remoteDependencyData.getProperties(), attributes);\n+        }\n+        telemetryItem.setSampleRate(samplingPercentage.floatValue());\n+        telemetryItems.add(telemetryItem);\n+        exportEvents(span, samplingPercentage, telemetryItems);\n+    }\n+\n+    private void applyDatabaseQuerySpan(Map<String, AttributeValue> attributes, RemoteDependencyData rd,\n+                                        String component) {\n+        String type = removeAttributeString(attributes, SemanticAttributes.DB_SYSTEM.key());\n+\n+        if (SQL_DB_SYSTEMS.contains(type)) {\n+            type = \"SQL\";\n+        }\n+        rd.setType(type);\n+        rd.setData(removeAttributeString(attributes, SemanticAttributes.DB_STATEMENT.key()));\n+\n+        String dbUrl = removeAttributeString(attributes, SemanticAttributes.DB_CONNECTION_STRING.key());\n+        if (dbUrl == null) {\n+            // this is needed until all database instrumentation captures the required db.url\n+            rd.setTarget(type);\n+        } else {\n+            String dbInstance = removeAttributeString(attributes, SemanticAttributes.DB_NAME.key());\n+            if (dbInstance != null) {\n+                dbUrl += \" | \" + dbInstance;\n+            }\n+            if (\"jdbc\".equals(component)) {\n+                // TODO this is special case to match 2.x behavior\n+                //      because U/X strips off the beginning in E2E tx view\n+                rd.setTarget(\"jdbc:\" + dbUrl);\n+            } else {\n+                rd.setTarget(dbUrl);\n+            }\n+        }\n+        // TODO put db.instance somewhere\n+    }\n+\n+    private void applyHttpRequestSpan(Map<String, AttributeValue> attributes,\n+                                      RemoteDependencyData remoteDependencyData) {\n+\n+        remoteDependencyData.setType(\"Http (tracked component)\");\n+\n+        String method = removeAttributeString(attributes, SemanticAttributes.HTTP_METHOD.key());\n+        String url = removeAttributeString(attributes, SemanticAttributes.HTTP_URL.key());\n+\n+        AttributeValue httpStatusCode = attributes.remove(SemanticAttributes.HTTP_STATUS_CODE.key());\n+        if (httpStatusCode != null && httpStatusCode.getType() == AttributeValue.Type.LONG) {\n+            long statusCode = httpStatusCode.getLongValue();\n+            remoteDependencyData.setResultCode(Long.toString(statusCode));\n+        }\n+\n+        if (url != null) {\n+            try {\n+                URI uriObject = new URI(url);\n+                String target = createTarget(uriObject);\n+                remoteDependencyData.setTarget(target);\n+                // TODO is this right, overwriting name to include the full path?\n+                String path = uriObject.getPath();\n+                if (CoreUtils.isNullOrEmpty(path)) {\n+                    remoteDependencyData.setName(method + \" /\");\n+                } else {\n+                    remoteDependencyData.setName(method + \" \" + path);\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.error(e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void exportRequest(String stdComponent, SpanData span, List<TelemetryItem> telemetryItems) {\n+        TelemetryItem telemetryItem = new TelemetryItem();\n+        RequestData requestData = new RequestData();\n+        MonitorBase monitorBase = new MonitorBase();\n+\n+        telemetryItem.setTags(new HashMap<>());\n+        telemetryItem.setName(telemetryItemNamePrefix + \"Request\");\n+        telemetryItem.setVersion(1);\n+        telemetryItem.setInstrumentationKey(instrumentationKey);\n+        telemetryItem.setData(monitorBase);\n+\n+        requestData.setProperties(new HashMap<>());\n+        requestData.setVersion(2);\n+        monitorBase.setBaseType(\"RequestData\");\n+        monitorBase.setBaseData(requestData);\n+\n+        Map<String, AttributeValue> attributes = getAttributesCopy(span.getAttributes());\n+\n+        if (\"kafka-clients\".equals(stdComponent)) {\n+            requestData.setSource(span.getName()); // destination queue name\n+        } else if (\"jms\".equals(stdComponent)) {\n+            requestData.setSource(span.getName()); // destination queue name\n+        }\n+        addLinks(requestData.getProperties(), span.getLinks());\n+        AttributeValue httpStatusCode = attributes.remove(SemanticAttributes.HTTP_STATUS_CODE.key());\n+\n+        if (isNonNullLong(httpStatusCode)) {\n+            requestData.setResponseCode(Long.toString(httpStatusCode.getLongValue()));\n+        }\n+\n+        String httpUrl = removeAttributeString(attributes, SemanticAttributes.HTTP_URL.key());\n+        if (httpUrl != null) {\n+            requestData.setUrl(httpUrl);\n+        }\n+\n+        String httpMethod = removeAttributeString(attributes, SemanticAttributes.HTTP_METHOD.key());\n+        String name = span.getName();\n+        if (httpMethod != null && name.startsWith(\"/\")) {\n+            name = httpMethod + \" \" + name;\n+        }\n+        requestData.setName(name);\n+        telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_NAME.toString(), name);\n+\n+        if (span.getName().equals(\"EventHubs.process\")) {\n+            // TODO eventhubs should use CONSUMER instead of SERVER\n+            // (https://gist.github.com/lmolkova/e4215c0f44a49ef824983382762e6b92#opentelemetry-example-1)\n+            String peerAddress = removeAttributeString(attributes, \"peer.address\");\n+            String destination = removeAttributeString(attributes, \"message_bus.destination\");\n+            requestData.setSource(peerAddress + \"/\" + destination);\n+        }\n+        requestData.setId(span.getSpanId().toLowerBase16());\n+        telemetryItem.getTags().put(ContextTagKeys.AI_OPERATION_ID.toString(), span.getTraceId().toLowerBase16());\n+\n+        String aiLegacyParentId = span.getTraceState().get(\"ai-legacy-parent-id\");", "originalCommit": "99bc32818959ea3b9342f99225e2c6d802b630ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f50d4e47a508718e2d25935d431177dd17ea3bdd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f50d4e47a508718e2d25935d431177dd17ea3bdd", "message": "Remove log data", "committedDate": "2020-10-06T23:56:03Z", "type": "commit"}, {"oid": "c6ffbe17df149c226b341085b3b1993c2bb71ce8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c6ffbe17df149c226b341085b3b1993c2bb71ce8", "message": "Update changelog", "committedDate": "2020-10-07T00:58:16Z", "type": "commit"}, {"oid": "6ce5238c4df26d0b990cdbcf84ae343d10221f7b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ce5238c4df26d0b990cdbcf84ae343d10221f7b", "message": "Remove unused imports", "committedDate": "2020-10-07T01:00:23Z", "type": "commit"}]}