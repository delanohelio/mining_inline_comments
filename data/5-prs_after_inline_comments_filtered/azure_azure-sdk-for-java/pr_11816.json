{"pr_number": 11816, "pr_title": "Remove serializer from search rest client", "pr_createdAt": "2020-06-05T07:38:57Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/11816", "timeline": [{"oid": "d69c320da67db3d06a232ff7acba107e2853a49e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d69c320da67db3d06a232ff7acba107e2853a49e", "message": "Remove serializer from rest client", "committedDate": "2020-06-12T18:44:55Z", "type": "forcePushed"}, {"oid": "bf36868d56e4a4f7d64e8571de7156ae8dc163d5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf36868d56e4a4f7d64e8571de7156ae8dc163d5", "message": "Remove serializer from rest client", "committedDate": "2020-06-12T21:36:31Z", "type": "forcePushed"}, {"oid": "df3071892d7985d32e9029f051b3129546889907", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df3071892d7985d32e9029f051b3129546889907", "message": "Remove serializer from rest client.", "committedDate": "2020-06-13T00:10:35Z", "type": "forcePushed"}, {"oid": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2184ac094cd724d63a3c824cb601491dcc04a8a3", "message": "Remove serializer from rest client.", "committedDate": "2020-06-15T15:48:53Z", "type": "commit"}, {"oid": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2184ac094cd724d63a3c824cb601491dcc04a8a3", "message": "Remove serializer from rest client.", "committedDate": "2020-06-15T15:48:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MDMzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440290332", "bodyText": "Let's make ObjectMapper a class level constant. Jackson documentation mentions constructing an ObjectMapper has non-trivial overhead and is able to create lightweight, thread-safe reader and writers from itself.\nprivate static final ObjectMapper MAPPER;\n\nstatic {\n  MAPPER = new ObjectMapper();\n  SerializationUtil.configureMapper(MAPPER);\n}", "author": "alzimmermsft", "createdAt": "2020-06-15T16:13:52Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchAsyncClient.java", "diffHunk": "@@ -471,8 +463,10 @@ SearchPagedFlux search(String searchText, SearchOptions searchOptions, RequestOp\n                 .getWithRestResponseAsync(key, selectedFields, RequestOptionsConverter.map(requestOptions), context)\n                 .onErrorMap(DocumentResponseConversions::exceptionMapper)\n                 .map(res -> {\n-                    SearchDocument doc = new SearchDocument(res.getValue());\n-                    return new SimpleResponse<>(res, doc);\n+                    ObjectMapper mapper = new ObjectMapper();", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTUwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440291508", "bodyText": "What is res.getValue() here? convertValue isn't an efficient operation as it will convert the passed object back into JSON and deserialize it again targeting the new Class type.\nWe should validate what type is being returned here.", "author": "alzimmermsft", "createdAt": "2020-06-15T16:15:35Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchAsyncClient.java", "diffHunk": "@@ -471,8 +463,10 @@ SearchPagedFlux search(String searchText, SearchOptions searchOptions, RequestOp\n                 .getWithRestResponseAsync(key, selectedFields, RequestOptionsConverter.map(requestOptions), context)\n                 .onErrorMap(DocumentResponseConversions::exceptionMapper)\n                 .map(res -> {\n-                    SearchDocument doc = new SearchDocument(res.getValue());\n-                    return new SimpleResponse<>(res, doc);\n+                    ObjectMapper mapper = new ObjectMapper();\n+                    SerializationUtil.configureMapper(mapper);\n+                    SearchDocument document = mapper.convertValue(res.getValue(), SearchDocument.class);", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NzEwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440347100", "bodyText": "What we returned is Object, we convert Object to SearchDocument", "author": "sima-zhu", "createdAt": "2020-06-15T17:53:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0OTk0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440349942", "bodyText": "What we do here is to serialize Object to json, and desrialize to map. I did not find any API which can shortcut the process.", "author": "sima-zhu", "createdAt": "2020-06-15T17:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjcyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440292723", "bodyText": "I'm okay with this as it follows what the service will be doing. It is a little concerning though as we are implicitly mutating passed customer value, so we need to make sure this is documented strongly somewhere.", "author": "alzimmermsft", "createdAt": "2020-06-15T16:17:32Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateSerializer.java", "diffHunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.implementation;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+import java.io.IOException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+/**\n+ * Custom serializer to serialize {@link java.util.Date} to Iso8601 standard date format \"yyyy-MM-dd'T'hh:mm:ss.SSS'Z'\".\n+ */\n+final class Iso8601DateSerializer extends JsonSerializer<Date> {\n+\n+    /**\n+     * Gets a module wrapping this serializer as an adapter for the Jackson\n+     * ObjectMapper.\n+     *\n+     * @return a simple module to be plugged onto Jackson ObjectMapper.\n+     */\n+    public static SimpleModule getModule() {\n+        SimpleModule module = new SimpleModule();\n+        module.addSerializer(Date.class, new Iso8601DateSerializer());\n+        return module;\n+    }\n+\n+    @Override\n+    public void serialize(Date dateValue, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0NDEzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440344131", "bodyText": "Sure. Will add JavaDoc.", "author": "sima-zhu", "createdAt": "2020-06-15T17:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NzgwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440367809", "bodyText": "Since Date is in UTC, the mutation is not resulting in data-loss. So, it's okay to set the timezone to UTC and format the string.", "author": "srnagar", "createdAt": "2020-06-15T18:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2ODY1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440468655", "bodyText": "SimpleDateFormat has some shortage of converting am/pm. I convert the date value to offsetDateTime to guarantee the accuracy.", "author": "sima-zhu", "createdAt": "2020-06-15T21:54:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxODUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r441018521", "bodyText": "Date is assumed UTC but is that a contractual agreement in the model? Either way this is the best option we have in supporting it so I'm good with it.", "author": "alzimmermsft", "createdAt": "2020-06-16T17:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwNjg4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440306888", "bodyText": "Can we make format a static property on the class, it is the same during every call. Check if it is thread safe before making the change though.", "author": "alzimmermsft", "createdAt": "2020-06-15T16:41:21Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateSerializer.java", "diffHunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.implementation;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+import java.io.IOException;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+/**\n+ * Custom serializer to serialize {@link java.util.Date} to Iso8601 standard date format \"yyyy-MM-dd'T'hh:mm:ss.SSS'Z'\".\n+ */\n+final class Iso8601DateSerializer extends JsonSerializer<Date> {\n+\n+    /**\n+     * Gets a module wrapping this serializer as an adapter for the Jackson\n+     * ObjectMapper.\n+     *\n+     * @return a simple module to be plugged onto Jackson ObjectMapper.\n+     */\n+    public static SimpleModule getModule() {\n+        SimpleModule module = new SimpleModule();\n+        module.addSerializer(Date.class, new Iso8601DateSerializer());\n+        return module;\n+    }\n+\n+    @Override\n+    public void serialize(Date dateValue, JsonGenerator gen, SerializerProvider serializers) throws IOException {\n+        SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MTI2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440351267", "bodyText": "SimpleDateFormat is not thread safe. It will trigger the spotbugs\nhttps://stackoverflow.com/questions/6840803/why-is-javas-simpledateformat-not-thread-safe", "author": "sima-zhu", "createdAt": "2020-06-15T18:01:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwNjg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwODUyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440308529", "bodyText": "Why was the logic here changed to eagerly call the deserializer?", "author": "alzimmermsft", "createdAt": "2020-06-15T16:44:13Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateDeserializer.java", "diffHunk": "@@ -9,58 +9,42 @@\n import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n \n import java.io.IOException;\n-import java.time.OffsetDateTime;\n-import java.time.format.DateTimeFormatter;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.List;\n import java.util.stream.Collectors;\n \n-/**\n- * Custom deserializer to deserialize strings as instances of {@link OffsetDateTime}\n- */\n-final class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n+public class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n     private static final long serialVersionUID = 1L;\n     private final UntypedObjectDeserializer defaultDeserializer;\n \n-    /**\n-     * Constructor\n-     *\n-     * @param defaultDeserializer the deserializer to use when an OffsetDateTime match is not found\n-     */\n-    Iso8601DateDeserializer(UntypedObjectDeserializer defaultDeserializer) {\n+    protected Iso8601DateDeserializer(final UntypedObjectDeserializer defaultDeserializer) {\n         super(null, null);\n         this.defaultDeserializer = defaultDeserializer;\n     }\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        if (jp.getCurrentTokenId() == JsonTokenId.ID_STRING) {\n-            String value = jp.getText();\n-            return parseOffsetDateTime(value);\n-        } else if (jp.getCurrentTokenId() == JsonTokenId.ID_START_ARRAY) {\n-            List<?> list = (List) defaultDeserializer.deserialize(jp, ctxt);\n+        Object obj = defaultDeserializer.deserialize(jp, ctxt);", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1Mzc3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440453774", "bodyText": "This is needed for every block. Just tried to minimize the code with local var.", "author": "sima-zhu", "createdAt": "2020-06-15T21:20:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwODUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwOTQ5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440309497", "bodyText": "Why was this logic flipped?", "author": "alzimmermsft", "createdAt": "2020-06-15T16:45:50Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/SerializationUtil.java", "diffHunk": "@@ -21,18 +18,15 @@\n      * @param mapper the mapper to be configured\n      */\n     public static void configureMapper(ObjectMapper mapper) {\n-        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-        df.setTimeZone(TimeZone.getDefault());\n-        mapper.setDateFormat(df);\n-\n-        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        mapper.registerModule(new JavaTimeModule());\n         mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);\n \n         UntypedObjectDeserializer defaultDeserializer = new UntypedObjectDeserializer(null, null);\n-        Iso8601DateDeserializer dateDeserializer = new Iso8601DateDeserializer(defaultDeserializer);\n-        GeoPointDeserializer geoPointDeserializer = new GeoPointDeserializer(dateDeserializer);\n+        GeoPointDeserializer geoPointDeserializer = new GeoPointDeserializer(defaultDeserializer);\n+        Iso8601DateDeserializer iso8601DateDeserializer = new Iso8601DateDeserializer(geoPointDeserializer);", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1NjgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440356823", "bodyText": "The order does not make any differences.", "author": "sima-zhu", "createdAt": "2020-06-15T18:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwOTQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxMDkyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440310921", "bodyText": "Are we good for using the generic Map.class or do we need to use a JavaType which explicitly determines to use Map<String, Object>.", "author": "alzimmermsft", "createdAt": "2020-06-15T16:48:14Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/converters/IndexActionConverter.java", "diffHunk": "@@ -54,18 +54,21 @@\n             indexAction.setActionType(actionType);\n         }\n \n-        T document = obj.getDocument();\n+\n \n         ObjectMapper mapper = new JacksonAdapter().serializer();\n         SerializationUtil.configureMapper(mapper);\n-        Map<String, Object> additionalProperties = mapper.convertValue(document, Map.class);\n-\n-        indexAction.setAdditionalProperties(additionalProperties);\n \n+        Map<String, Object> additionalProperties;\n         if (obj.getParamMap() != null) {\n             Map<String, Object> properties = obj.getParamMap();\n-            PrivateFieldAccessHelper.set(indexAction, \"additionalProperties\", properties);\n+            additionalProperties = mapper.convertValue(properties, Map.class);", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNTA5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440315099", "bodyText": "I'm a little confused on the decimal to String conversion, is there any reason we can't use %+02f anymore in the String.format call? Are we looking to get additional units of precision in the decimal part?", "author": "alzimmermsft", "createdAt": "2020-06-15T16:55:26Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java", "diffHunk": "@@ -108,10 +116,14 @@ public int hashCode() {\n     @Override\n     public String toString() {\n         if (isValid()) {\n+            String longitude = (\"\" + coordinates.get(0)).contains(\".\")", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM5MjI3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440392278", "bodyText": "I am trying to replicate the format service return.", "author": "sima-zhu", "createdAt": "2020-06-15T19:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNTQ5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440315496", "bodyText": "Don't need to call toString here as the formatting function should implicitly do that.", "author": "alzimmermsft", "createdAt": "2020-06-15T16:56:05Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java", "diffHunk": "@@ -108,10 +116,14 @@ public int hashCode() {\n     @Override\n     public String toString() {\n         if (isValid()) {\n+            String longitude = (\"\" + coordinates.get(0)).contains(\".\")\n+                ? \"\" + coordinates.get(0) : \"\" + coordinates.get(0) + \".0\";\n+            String latitude = (\"\" + coordinates.get(1)).contains(\".\")\n+                ? \"\" + coordinates.get(1) : \"\" + coordinates.get(1) + \".0\";\n             return String.format(\n                 Locale.US,\n-                \"%+02f%+02f%s/\",\n-                coordinates.get(1), coordinates.get(0), coordinateSystem.toString());\n+                \"{type=Point, coordinates=[%s, %s], crs={%s}}\", \"\" + longitude, latitude,\n+                coordinateSystem.toString());", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNzk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440317941", "bodyText": "I don't think these tests are testing different concepts as Date has no concept of time zone.", "author": "alzimmermsft", "createdAt": "2020-06-15T17:00:13Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/implementation/Iso8601SerializerTests.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.implementation;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.SimpleDateFormat;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.TimeZone;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class Iso8601SerializerTests {\n+    private static final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    @BeforeAll\n+    public static void setupClass() {\n+        MAPPER.registerModule(Iso8601DateSerializer.getModule());\n+    }\n+\n+    @Test\n+    public void dateWithTimeZone() throws JsonProcessingException {\n+        SimpleDateFormat format = new SimpleDateFormat(\"\\\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\\\"\");\n+        format.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+        Date currentDate = new Date();\n+        String expectedDate = format.format(currentDate);\n+        String actualDate = MAPPER.writeValueAsString(currentDate);\n+        assertEquals(expectedDate, actualDate);\n+    }\n+\n+    @Test\n+    public void dateWithoutTimeZone() throws JsonProcessingException {", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTE0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440371147", "bodyText": "I will rename this. I am trying to test two different ways of providing date, one is intended to use UTC date, one did not specify anything.", "author": "sima-zhu", "createdAt": "2020-06-15T18:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440364282", "bodyText": "This date format is used in multiple places. Consider making this a string constant.", "author": "srnagar", "createdAt": "2020-06-15T18:25:45Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateDeserializer.java", "diffHunk": "@@ -9,58 +9,42 @@\n import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n \n import java.io.IOException;\n-import java.time.OffsetDateTime;\n-import java.time.format.DateTimeFormatter;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.List;\n import java.util.stream.Collectors;\n \n-/**\n- * Custom deserializer to deserialize strings as instances of {@link OffsetDateTime}\n- */\n-final class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n+public class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n     private static final long serialVersionUID = 1L;\n     private final UntypedObjectDeserializer defaultDeserializer;\n \n-    /**\n-     * Constructor\n-     *\n-     * @param defaultDeserializer the deserializer to use when an OffsetDateTime match is not found\n-     */\n-    Iso8601DateDeserializer(UntypedObjectDeserializer defaultDeserializer) {\n+    protected Iso8601DateDeserializer(final UntypedObjectDeserializer defaultDeserializer) {\n         super(null, null);\n         this.defaultDeserializer = defaultDeserializer;\n     }\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        if (jp.getCurrentTokenId() == JsonTokenId.ID_STRING) {\n-            String value = jp.getText();\n-            return parseOffsetDateTime(value);\n-        } else if (jp.getCurrentTokenId() == JsonTokenId.ID_START_ARRAY) {\n-            List<?> list = (List) defaultDeserializer.deserialize(jp, ctxt);\n+        Object obj = defaultDeserializer.deserialize(jp, ctxt);\n+        if (jp.currentTokenId() == JsonTokenId.ID_START_OBJECT) {\n+            return parseDateType(obj);\n+        } else if (jp.currentTokenId() == JsonTokenId.ID_START_ARRAY) {\n+            List<?> list = (List) obj;\n             return list.stream()\n-                .map(this::parseOffsetDateTime)\n+                .map(this::parseDateType)\n                 .collect(Collectors.toList());\n         } else {\n-            return defaultDeserializer.deserialize(jp, ctxt);\n+            return obj;\n         }\n+\n     }\n \n-    /**\n-     * Converts an object to an OffsetDateTime if it matches the ISO8601 format.\n-     *\n-     * @param obj the object to parse\n-     * @return an instance of {@link OffsetDateTime} if valid ISO8601, otherwise obj.\n-     */\n-    private Object parseOffsetDateTime(Object obj) {\n-        if (obj != null && obj.getClass() == String.class) {\n-            try {\n-                return OffsetDateTime.parse((String) obj, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n-            } catch (Exception e) {\n-                return obj;\n-            }\n-        } else {\n-            return obj;\n+    private Object parseDateType(Object obj) {\n+        try {\n+            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").parse((String) obj);", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDg4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440364884", "bodyText": "Return the obj here instead of having empty catch block.", "author": "srnagar", "createdAt": "2020-06-15T18:26:44Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateDeserializer.java", "diffHunk": "@@ -9,58 +9,42 @@\n import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n \n import java.io.IOException;\n-import java.time.OffsetDateTime;\n-import java.time.format.DateTimeFormatter;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.List;\n import java.util.stream.Collectors;\n \n-/**\n- * Custom deserializer to deserialize strings as instances of {@link OffsetDateTime}\n- */\n-final class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n+public class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n     private static final long serialVersionUID = 1L;\n     private final UntypedObjectDeserializer defaultDeserializer;\n \n-    /**\n-     * Constructor\n-     *\n-     * @param defaultDeserializer the deserializer to use when an OffsetDateTime match is not found\n-     */\n-    Iso8601DateDeserializer(UntypedObjectDeserializer defaultDeserializer) {\n+    protected Iso8601DateDeserializer(final UntypedObjectDeserializer defaultDeserializer) {\n         super(null, null);\n         this.defaultDeserializer = defaultDeserializer;\n     }\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        if (jp.getCurrentTokenId() == JsonTokenId.ID_STRING) {\n-            String value = jp.getText();\n-            return parseOffsetDateTime(value);\n-        } else if (jp.getCurrentTokenId() == JsonTokenId.ID_START_ARRAY) {\n-            List<?> list = (List) defaultDeserializer.deserialize(jp, ctxt);\n+        Object obj = defaultDeserializer.deserialize(jp, ctxt);\n+        if (jp.currentTokenId() == JsonTokenId.ID_START_OBJECT) {\n+            return parseDateType(obj);\n+        } else if (jp.currentTokenId() == JsonTokenId.ID_START_ARRAY) {\n+            List<?> list = (List) obj;\n             return list.stream()\n-                .map(this::parseOffsetDateTime)\n+                .map(this::parseDateType)\n                 .collect(Collectors.toList());\n         } else {\n-            return defaultDeserializer.deserialize(jp, ctxt);\n+            return obj;\n         }\n+\n     }\n \n-    /**\n-     * Converts an object to an OffsetDateTime if it matches the ISO8601 format.\n-     *\n-     * @param obj the object to parse\n-     * @return an instance of {@link OffsetDateTime} if valid ISO8601, otherwise obj.\n-     */\n-    private Object parseOffsetDateTime(Object obj) {\n-        if (obj != null && obj.getClass() == String.class) {\n-            try {\n-                return OffsetDateTime.parse((String) obj, DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n-            } catch (Exception e) {\n-                return obj;\n-            }\n-        } else {\n-            return obj;\n+    private Object parseDateType(Object obj) {\n+        try {\n+            return new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\").parse((String) obj);\n+        } catch (ParseException e) {\n+            // Do nothing", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTUwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440371508", "bodyText": "Is this required? module, which has the date deserializer, is registered to the mapper in the next line.", "author": "srnagar", "createdAt": "2020-06-15T18:38:56Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/SerializationUtil.java", "diffHunk": "@@ -21,18 +18,15 @@\n      * @param mapper the mapper to be configured\n      */\n     public static void configureMapper(ObjectMapper mapper) {\n-        SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss'Z'\");\n-        df.setTimeZone(TimeZone.getDefault());\n-        mapper.setDateFormat(df);\n-\n-        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        mapper.registerModule(new JavaTimeModule());\n         mapper.disable(DeserializationFeature.ADJUST_DATES_TO_CONTEXT_TIME_ZONE);\n \n         UntypedObjectDeserializer defaultDeserializer = new UntypedObjectDeserializer(null, null);\n-        Iso8601DateDeserializer dateDeserializer = new Iso8601DateDeserializer(defaultDeserializer);\n-        GeoPointDeserializer geoPointDeserializer = new GeoPointDeserializer(dateDeserializer);\n+        GeoPointDeserializer geoPointDeserializer = new GeoPointDeserializer(defaultDeserializer);\n+        Iso8601DateDeserializer iso8601DateDeserializer = new Iso8601DateDeserializer(geoPointDeserializer);\n         SimpleModule module = new SimpleModule();\n-        module.addDeserializer(Object.class, geoPointDeserializer);\n+        module.addDeserializer(Object.class, iso8601DateDeserializer);\n+        mapper.registerModule(Iso8601DateSerializer.getModule());", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM4MTc0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440381746", "bodyText": "Here we register both serializer and deserializer for java.utl.Date type", "author": "sima-zhu", "createdAt": "2020-06-15T18:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjMwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440372305", "bodyText": "Set the locale to Locale.ROOT.", "author": "srnagar", "createdAt": "2020-06-15T18:40:26Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java", "diffHunk": "@@ -108,10 +116,14 @@ public int hashCode() {\n     @Override\n     public String toString() {\n         if (isValid()) {\n+            String longitude = (\"\" + coordinates.get(0)).contains(\".\")\n+                ? \"\" + coordinates.get(0) : \"\" + coordinates.get(0) + \".0\";\n+            String latitude = (\"\" + coordinates.get(1)).contains(\".\")\n+                ? \"\" + coordinates.get(1) : \"\" + coordinates.get(1) + \".0\";\n             return String.format(\n                 Locale.US,", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3NTU2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440375565", "bodyText": "isValid should also check that coordinates.get(0) and coordinates.get(1) are not null?", "author": "srnagar", "createdAt": "2020-06-15T18:46:29Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java", "diffHunk": "@@ -63,6 +70,7 @@ public static GeoPoint create(double latitude, double longitude, CoordinateSyste\n      *\n      * @return true if valid, false if invalid\n      */\n+    @JsonIgnore\n     public boolean isValid() {\n         return coordinates != null && coordinates.size() == 2\n             && coordinates.get(0) >= -180.0 && coordinates.get(0) <= 180.0", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3OTIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440379218", "bodyText": "Double.toString(value) will append .0. Don't have to do this explicitly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String latitude = (\"\" + coordinates.get(1)).contains(\".\")\n          \n          \n            \n                            ? \"\" + coordinates.get(1) : \"\" + coordinates.get(1) + \".0\";\n          \n          \n            \n                        String latitude = Double.toString(coordinates.get(1));", "author": "srnagar", "createdAt": "2020-06-15T18:53:28Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java", "diffHunk": "@@ -108,10 +116,14 @@ public int hashCode() {\n     @Override\n     public String toString() {\n         if (isValid()) {\n+            String longitude = (\"\" + coordinates.get(0)).contains(\".\")\n+                ? \"\" + coordinates.get(0) : \"\" + coordinates.get(0) + \".0\";\n+            String latitude = (\"\" + coordinates.get(1)).contains(\".\")\n+                ? \"\" + coordinates.get(1) : \"\" + coordinates.get(1) + \".0\";", "originalCommit": "2184ac094cd724d63a3c824cb601491dcc04a8a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18194cb03d1f8bbf33ce0e5f4246e9266b4f6684", "url": "https://github.com/Azure/azure-sdk-for-java/commit/18194cb03d1f8bbf33ce0e5f4246e9266b4f6684", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/GeoPoint.java\n\nCo-authored-by: Srikanta <51379715+srnagar@users.noreply.github.com>", "committedDate": "2020-06-15T18:59:47Z", "type": "commit"}, {"oid": "d19e741e7fc1f7d38ec09ff6d29666dde437da4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d19e741e7fc1f7d38ec09ff6d29666dde437da4b", "message": "Allow to use more generic format.", "committedDate": "2020-06-15T20:22:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MDQ4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440440486", "bodyText": "Should this be a common class in azure-core? Iso8601 seems like a common format to deserialize?", "author": "conniey", "createdAt": "2020-06-15T20:53:28Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateDeserializer.java", "diffHunk": "@@ -9,58 +9,42 @@\n import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n \n import java.io.IOException;\n-import java.time.OffsetDateTime;\n-import java.time.format.DateTimeFormatter;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n import java.util.List;\n import java.util.stream.Collectors;\n \n-/**\n- * Custom deserializer to deserialize strings as instances of {@link OffsetDateTime}\n- */\n-final class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n+public class Iso8601DateDeserializer extends UntypedObjectDeserializer {\n     private static final long serialVersionUID = 1L;\n     private final UntypedObjectDeserializer defaultDeserializer;\n \n-    /**\n-     * Constructor\n-     *\n-     * @param defaultDeserializer the deserializer to use when an OffsetDateTime match is not found\n-     */\n-    Iso8601DateDeserializer(UntypedObjectDeserializer defaultDeserializer) {\n+    protected Iso8601DateDeserializer(final UntypedObjectDeserializer defaultDeserializer) {\n         super(null, null);\n         this.defaultDeserializer = defaultDeserializer;\n     }\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n-        if (jp.getCurrentTokenId() == JsonTokenId.ID_STRING) {\n-            String value = jp.getText();\n-            return parseOffsetDateTime(value);\n-        } else if (jp.getCurrentTokenId() == JsonTokenId.ID_START_ARRAY) {\n-            List<?> list = (List) defaultDeserializer.deserialize(jp, ctxt);\n+        Object obj = defaultDeserializer.deserialize(jp, ctxt);", "originalCommit": "18194cb03d1f8bbf33ce0e5f4246e9266b4f6684", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MjQyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440442427", "bodyText": "DateTimeSerializer is supposed to deserialize and deserialize this format.. should the fix be in there?\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/core/azure-core/src/main/java/com/azure/core/util/serializer/DateTimeSerializer.java#L18", "author": "conniey", "createdAt": "2020-06-15T20:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MDQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0OTk2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r440449960", "bodyText": "Search allows to upload user-defined documents with any date classes.\nThe link you have is to support Joda time (OffsetDateTime, LocalDateTime etc).\nWhat we are trying to do here is to support old date lib (java.util.Date)\nWe agreed to put serializer to search only, since Search has specific format and time zone requirement.", "author": "sima-zhu", "createdAt": "2020-06-15T21:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ0MDQ4Ng=="}], "type": "inlineReview"}, {"oid": "1ecaeebadcefc3d2a40937eefc49696140dfc3ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1ecaeebadcefc3d2a40937eefc49696140dfc3ae", "message": "Addressed most of comments.", "committedDate": "2020-06-15T21:19:02Z", "type": "commit"}, {"oid": "2254012d4f4423e89ddb8881bb705f38023bd800", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2254012d4f4423e89ddb8881bb705f38023bd800", "message": "Use Offset date format to avoid am pm inaccurancy", "committedDate": "2020-06-15T21:52:55Z", "type": "commit"}, {"oid": "2254012d4f4423e89ddb8881bb705f38023bd800", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2254012d4f4423e89ddb8881bb705f38023bd800", "message": "Use Offset date format to avoid am pm inaccurancy", "committedDate": "2020-06-15T21:52:55Z", "type": "forcePushed"}, {"oid": "e4e892855c2d0f39acecd514abc78cc9c2f3029e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e4e892855c2d0f39acecd514abc78cc9c2f3029e", "message": "Fixed live tests", "committedDate": "2020-06-15T22:15:06Z", "type": "commit"}, {"oid": "0f37c7a134517e6a443cc2b854bfd42d049cdcbe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f37c7a134517e6a443cc2b854bfd42d049cdcbe", "message": "Update SerializationUtil.java", "committedDate": "2020-06-15T22:38:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA0MzMwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11816#discussion_r441043306", "bodyText": "As discussed, these serializers are Jackson specific and may have to go into a separate pluggable module in a follow-up PR. This will allow us to support Gson serializers too.", "author": "srnagar", "createdAt": "2020-06-16T18:05:51Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/Iso8601DateSerializer.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.implementation;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+import java.io.IOException;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Date;\n+\n+/**\n+ * Custom serializer to serialize {@link java.util.Date} to Iso8601 standard date format \"yyyy-MM-dd'T'hh:mm:ss.SSS'Z'\".\n+ */\n+final class Iso8601DateSerializer extends JsonSerializer<Date> {", "originalCommit": "0f37c7a134517e6a443cc2b854bfd42d049cdcbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}