{"pr_number": 17044, "pr_title": "[Tables] Add transactional batch support", "pr_createdAt": "2020-10-31T02:32:41Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/17044", "timeline": [{"oid": "12f7cd15c1a375b1698d95de3f1d169954097c5e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/12f7cd15c1a375b1698d95de3f1d169954097c5e", "message": "Add changelog", "committedDate": "2020-11-02T21:53:17Z", "type": "forcePushed"}, {"oid": "8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8d8f62830a0ef8fd9833b089d6dcb6db7377eaac", "message": "Add changelog", "committedDate": "2020-11-02T22:21:13Z", "type": "forcePushed"}, {"oid": "05afd40e73cde9d1b87c4cb497210b3df18bceab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/05afd40e73cde9d1b87c4cb497210b3df18bceab", "message": "Add changelog", "committedDate": "2020-11-02T22:36:35Z", "type": "forcePushed"}, {"oid": "87401a34fdfc9dab30c7ab9eed6d9016d3c90472", "url": "https://github.com/Azure/azure-sdk-for-java/commit/87401a34fdfc9dab30c7ab9eed6d9016d3c90472", "message": "Initial public API for batching", "committedDate": "2020-11-02T23:22:01Z", "type": "commit"}, {"oid": "e91eb4ab2f296ffb4b47dd4f7cc3c0698e5634d8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e91eb4ab2f296ffb4b47dd4f7cc3c0698e5634d8", "message": "Record operations in a txn", "committedDate": "2020-11-02T23:22:02Z", "type": "commit"}, {"oid": "b5831e7506689447b37291f87a1eaeb25b48702f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5831e7506689447b37291f87a1eaeb25b48702f", "message": "Make the batch APIs fluent", "committedDate": "2020-11-02T23:22:02Z", "type": "commit"}, {"oid": "90a7b27dbb67c8ace1fb4336276e4e1c56684264", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90a7b27dbb67c8ace1fb4336276e4e1c56684264", "message": "Make batch interactions thread-safe", "committedDate": "2020-11-02T23:22:02Z", "type": "commit"}, {"oid": "21ac1034eb381dc6ef8866c1f237c0d77ba106f0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21ac1034eb381dc6ef8866c1f237c0d77ba106f0", "message": "Fix return types for batch operations\n\nThey return a multipart response body containing either all the\nindividual responses or one error response, but for now just make\nthese Response<Void>", "committedDate": "2020-11-02T23:22:03Z", "type": "commit"}, {"oid": "ed2fdcd04c6bc27f01ee92202afd6d65e3a4ae56", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed2fdcd04c6bc27f01ee92202afd6d65e3a4ae56", "message": "Model the body of a Multipart request", "committedDate": "2020-11-02T23:22:03Z", "type": "commit"}, {"oid": "9150be5735247b56186574bdb6666930d2f2fc1a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9150be5735247b56186574bdb6666930d2f2fc1a", "message": "Add service client for table batch operation", "committedDate": "2020-11-02T23:22:03Z", "type": "commit"}, {"oid": "7ca313ced2308c1f4be6dda5c4ca1458d43d7260", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ca313ced2308c1f4be6dda5c4ca1458d43d7260", "message": "Refactor Batch into client-like objects", "committedDate": "2020-11-02T23:22:03Z", "type": "commit"}, {"oid": "2cc4b43ab77568b97ac2f4f30b649c98e28a2fca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2cc4b43ab77568b97ac2f4f30b649c98e28a2fca", "message": "Checkpoint", "committedDate": "2020-11-02T23:22:04Z", "type": "commit"}, {"oid": "3dbb9c0aff1c7b1927ae7f58da2eb1ea572591b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3dbb9c0aff1c7b1927ae7f58da2eb1ea572591b9", "message": "Batch now propagates errors", "committedDate": "2020-11-02T23:22:04Z", "type": "commit"}, {"oid": "10a65318612a0eb86311712c7a107a20cff395e3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10a65318612a0eb86311712c7a107a20cff395e3", "message": "Fix including failed operation in batch error message", "committedDate": "2020-11-02T23:22:04Z", "type": "commit"}, {"oid": "c443c99a62d4043ffd8e5fe12cd832ecc98f1049", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c443c99a62d4043ffd8e5fe12cd832ecc98f1049", "message": "Add recordings", "committedDate": "2020-11-02T23:22:04Z", "type": "commit"}, {"oid": "a6095a9005a7fa59c20a8372970ecade3190acb6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6095a9005a7fa59c20a8372970ecade3190acb6", "message": "Add changelog", "committedDate": "2020-11-02T23:22:05Z", "type": "commit"}, {"oid": "cae7c89a09f9c8a5508941c400be2ba22f02b67b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cae7c89a09f9c8a5508941c400be2ba22f02b67b", "message": "Fix checkstyle issues", "committedDate": "2020-11-02T23:39:06Z", "type": "commit"}, {"oid": "76486a368b1b7bf4acdd490cbec81207dc5d979b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/76486a368b1b7bf4acdd490cbec81207dc5d979b", "message": "Add Javadoc", "committedDate": "2020-11-03T00:45:17Z", "type": "commit"}, {"oid": "108b27f67bbfc703fe0fe31722e052b240c5db87", "url": "https://github.com/Azure/azure-sdk-for-java/commit/108b27f67bbfc703fe0fe31722e052b240c5db87", "message": "Fix spotbugs issues", "committedDate": "2020-11-03T01:01:58Z", "type": "commit"}, {"oid": "108b27f67bbfc703fe0fe31722e052b240c5db87", "url": "https://github.com/Azure/azure-sdk-for-java/commit/108b27f67bbfc703fe0fe31722e052b240c5db87", "message": "Fix spotbugs issues", "committedDate": "2020-11-03T01:01:58Z", "type": "forcePushed"}, {"oid": "3fcab1aa5e8fc7ee61951a9380dc5b944f4b42af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3fcab1aa5e8fc7ee61951a9380dc5b944f4b42af", "message": "Move BatchOperationResponse to the public API", "committedDate": "2020-11-04T23:05:45Z", "type": "commit"}, {"oid": "cdd146ba058944494847278d7c07f7dc1346a1e6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cdd146ba058944494847278d7c07f7dc1346a1e6", "message": "Disallow submitting the batch with no operations", "committedDate": "2020-11-04T23:06:45Z", "type": "commit"}, {"oid": "656ddb1f6bf0005e8fc25f959f3c1f7567d013fe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/656ddb1f6bf0005e8fc25f959f3c1f7567d013fe", "message": "Don't try to serialize a null sub-request body", "committedDate": "2020-11-04T23:07:23Z", "type": "commit"}, {"oid": "f09aa2ae34ca3bdb3a857fb66d3510dfbc9849dc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f09aa2ae34ca3bdb3a857fb66d3510dfbc9849dc", "message": "Handle more error cases in sub-responses", "committedDate": "2020-11-04T23:07:41Z", "type": "commit"}, {"oid": "9238dffa3b263ab2391cd61a563170c589c8102b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9238dffa3b263ab2391cd61a563170c589c8102b", "message": "The HTTP verb for merge sub-requests must be MERGE", "committedDate": "2020-11-04T23:08:10Z", "type": "commit"}, {"oid": "d0c6571b68f395ba39b4919b6f121d08dd092638", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d0c6571b68f395ba39b4919b6f121d08dd092638", "message": "Fix upsert - it was actually doing an update!\n\nAlso simplify the implementation of update, the getEntity result is not\nused, nor does it appear to be needed in order to fail correctly when\nthe entity does not exist, as #13680 seems to imply.", "committedDate": "2020-11-04T23:30:07Z", "type": "commit"}, {"oid": "f24814e6f4457098d5b291efc86f785f75ea3c8a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f24814e6f4457098d5b291efc86f785f75ea3c8a", "message": "Send the whole URL in each sub-request.", "committedDate": "2020-11-04T23:30:21Z", "type": "commit"}, {"oid": "0a2c23890662eaeb77d345b835e8136af7e5a613", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a2c23890662eaeb77d345b835e8136af7e5a613", "message": "Add more tests", "committedDate": "2020-11-04T23:40:37Z", "type": "commit"}, {"oid": "2bdd5eb88d111088a63febb9afd03734774ab3ad", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2bdd5eb88d111088a63febb9afd03734774ab3ad", "message": "Make BatchOperationResponse public read-only", "committedDate": "2020-11-05T00:59:14Z", "type": "commit"}, {"oid": "95fb875ccf6a5a0a66222645afea6c5381d37c8a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/95fb875ccf6a5a0a66222645afea6c5381d37c8a", "message": "Re-record tests and commit recordings", "committedDate": "2020-11-05T00:59:15Z", "type": "commit"}, {"oid": "95fb875ccf6a5a0a66222645afea6c5381d37c8a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/95fb875ccf6a5a0a66222645afea6c5381d37c8a", "message": "Re-record tests and commit recordings", "committedDate": "2020-11-05T00:59:15Z", "type": "forcePushed"}, {"oid": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9fb9131e7f167be7c63cefc4c1296aeb52003d76", "message": "Add changelog", "committedDate": "2020-11-05T01:09:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNDUyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517814523", "bodyText": "Since there is only one element, you probably don't have to allocate a list for it:\nHttpPipelinePolicy[] policies = {\n    new AddHeadersPolicy(new HttpHeaders().put(\"Accept\", \"application/json;odata=minimalmetadata\"))\n};", "author": "conniey", "createdAt": "2020-11-05T06:17:51Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/BuilderHelper.java", "diffHunk": "@@ -99,6 +100,16 @@ static HttpPipeline buildPipeline(TablesSharedKeyCredential tablesSharedKeyCrede\n             .build();\n     }\n \n+    static HttpPipeline buildNullClientPipeline() {\n+        List<HttpPipelinePolicy> policies = new ArrayList<>();", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNjAxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517816016", "bodyText": "Do we need a new instance of this serializer for each batch? Can it be passed in as a dependency?", "author": "conniey", "createdAt": "2020-11-05T06:22:41Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzQxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518293411", "bodyText": "Hmm, you're probably right. I think I was following the pattern from our TableClientBuilder - each builder instance has its own instance of TablesJacksonSerializer and configures the client with that serializer when build() is called. Would a lazy static be a better / more efficient way to handle this?", "author": "bsiegel", "createdAt": "2020-11-05T19:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzM3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517817378", "bodyText": "We don't align parameters or throws.", "author": "conniey", "createdAt": "2020-11-05T06:26:51Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzUwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517817503", "bodyText": "Same with the other javadocs", "author": "conniey", "createdAt": "2020-11-05T06:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxNzM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODgyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517818821", "bodyText": "doOnNext should be for side effects like logging. There are better operators to use if you want it to be part of your main scenario.\nIn this case, would you be better using operations.stream()....? There aren't any async operations going on.", "author": "conniey", "createdAt": "2020-11-05T06:31:14Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4Njg3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518286871", "bodyText": "The call to op.prepareRequest is async, it returns a Mono<HttpRequest>. Because of that, I'm not clear if I can replace .doOnNext(...) with .toStream().forEach(...), but I'm far from an expert at Reactor. Maybe I will borrow a couple minutes of you or Alan's time to see how to write this better - I definitely felt a little unconfident about this part.", "author": "bsiegel", "createdAt": "2020-11-05T18:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM3NjgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518376819", "bodyText": "I would lean towards using collect operations on Flux.\nFlux.fromIterable(operations)\n    .flatMapSequential(op -> op.prepareRequest(operationClient).zipWith(Mono.just(op)))\n    .collect(BatchRequestBody::new, (body, pair) -> body.addChangeOperation(new BatchSubRquest(pair.getT2(), pair.getT1())));\nThis will remove the need to blockLast on the Flux which will prevent exceptions from being thrown if this is called in a non-blocking reactive thread.", "author": "alzimmermsft", "createdAt": "2020-11-05T21:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MTQ5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518381495", "bodyText": "It can also then be chained with the code below:\n/* collect reactive call */\n   .map(body -> /* code below */);", "author": "alzimmermsft", "createdAt": "2020-11-05T21:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxOTcxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517819715", "bodyText": "The .handle operator is better for this.", "author": "conniey", "createdAt": "2020-11-05T06:34:05Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518289865", "bodyText": "Hmm, another thing with Reactor I'm not really knowledgable about - the TableAsyncClient uses this pattern everywhere - call the method on the impl and then apply map() to the result. Additionally the docs for handle() indicate it's useful as a combination of map + filter, if your mapper method doesn't always return a value. Here, we always either return a value or throw an exception which gets transformed into a Mono.error.", "author": "bsiegel", "createdAt": "2020-11-05T19:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgxOTcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMDkwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517820902", "bodyText": "Is it possible to make this an AtomicBoolean and use that as a guard instead of having every method synchronized?", "author": "conniey", "createdAt": "2020-11-05T06:37:46Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDY5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518290694", "bodyText": "I don't think so, because the order of operations in the batch theoretically matters - we need to preserve the ordering of operations added to the batch even if they are being added by multiple threads. I'm not sure if there is a better way other than by using synchronized. What do you think?", "author": "bsiegel", "createdAt": "2020-11-05T19:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMDk4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517820984", "bodyText": "We have CoreUtils.isNullorEmpty", "author": "conniey", "createdAt": "2020-11-05T06:38:03Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {\n+                    TableServiceError error = null;\n+                    String errorMessage = null;\n+                    BatchChangeSet changes = null;\n+                    BatchOperation failedOperation = null;\n+\n+                    if (body.getContents().get(0) instanceof BatchChangeSet) {\n+                        changes = (BatchChangeSet) body.getContents().get(0);\n+                    }\n+\n+                    for (int i = 0; i < response.getValue().length; i++) {\n+                        BatchOperationResponse subResponse = response.getValue()[i];\n+\n+                        // Attempt to attach a sub-request to each batch sub-response\n+                        if (changes != null && changes.getContents().get(i) != null) {\n+                            ModelHelper.updateBatchOperationResponse(subResponse,\n+                                changes.getContents().get(i).getHttpRequest());\n+                        }\n+\n+                        // If one sub-response was an error, we need to throw even though the service responded with 202\n+                        if (subResponse.getStatusCode() >= 400 && error == null && errorMessage == null) {\n+                            if (subResponse.getValue() instanceof TableServiceError) {\n+                                error = (TableServiceError) subResponse.getValue();\n+\n+                                // Make a best effort to locate the failed operation and include it in the message\n+                                if (changes != null && error.getOdataError() != null\n+                                    && error.getOdataError().getMessage() != null\n+                                    && error.getOdataError().getMessage().getValue() != null) {\n+\n+                                    String message = error.getOdataError().getMessage().getValue();\n+                                    try {\n+                                        int failedIndex = Integer.parseInt(message.substring(0, message.indexOf(\":\")));\n+                                        failedOperation = changes.getContents().get(failedIndex).getOperation();\n+                                    } catch (NumberFormatException e) {\n+                                        // Unable to parse failed operation from batch error message - this just means\n+                                        // the service did not indicate which request was the one that failed. Since\n+                                        // this is optional, just swallow the exception.\n+                                    }\n+                                }\n+                            } else if (subResponse.getValue() instanceof String) {\n+                                errorMessage = \"The service returned the following data for the failed operation: \"\n+                                    + subResponse.getValue();\n+                            } else {\n+                                errorMessage =\n+                                    \"The service returned the following status code for the failed operation: \"\n+                                        + subResponse.getStatusCode();\n+                            }\n+                        }\n+                    }\n+\n+                    if (error != null || errorMessage != null) {\n+                        String message = \"An operation within the batch failed, the transaction has been rolled back.\";\n+                        if (failedOperation != null) {\n+                            message += \" The failed operation was: \" + failedOperation.toString();\n+                        } else if (errorMessage != null) {\n+                            message += \" \" + errorMessage;\n+                        }\n+                        throw logger.logExceptionAsError(new TableServiceErrorException(message, null, error));\n+                    } else {\n+                        return new SimpleResponse<>(response, Arrays.asList(response.getValue()));\n+                    }\n+                });\n+        } catch (RuntimeException ex) {\n+            return monoError(logger, ex);\n+        }\n+    }\n+\n+    private synchronized void addOperation(BatchOperation operation) {\n+        operations.add(operation);\n+    }\n+\n+    private synchronized void validate(TableEntity entity) {\n+        validate(entity.getPartitionKey(), entity.getRowKey());\n+    }\n+\n+    private synchronized void validate(String partitionKey, String rowKey) {\n+        if (this.frozen) {\n+            throw logger.logExceptionAsError(\n+                new IllegalStateException(\"Operations can't be modified once a batch is submitted.\"));\n+        }\n+\n+        if (!this.partitionKey.equals(partitionKey)) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"All operations in a batch must share the same partition key.\"));\n+        }\n+\n+        if (rowKey == null || rowKey.isEmpty()) {", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMTExNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517821114", "bodyText": "CoreUtils.isnullorEmpty", "author": "conniey", "createdAt": "2020-11-05T06:38:27Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncClient.java", "diffHunk": "@@ -124,6 +127,31 @@ public TablesServiceVersion getApiVersion() {\n         return TablesServiceVersion.fromString(implementation.getVersion());\n     }\n \n+    /**\n+     * Creates a new {@link TableAsyncBatch} object. Batch objects allow you to enqueue multiple create, update, upsert,\n+     * and/or delete operations on entities that share the same partition key. When the batch is executed, all of the\n+     * operations will be performed as part of a single transaction. As a result, either all operations in the batch\n+     * will succeed, or if a failure occurs, all operations in the batch will be rolled back. Each operation in a batch\n+     * must operate on a distinct row key. Attempting to add multiple operations to a batch that share the same row key\n+     * will cause an exception to be thrown.\n+     *\n+     * @param partitionKey The partition key shared by all operations in the batch.\n+     *\n+     * @return An object representing the batch, to which operations can be added.\n+     * @throws IllegalArgumentException if the provided partition key is {@code null} or empty.\n+     */\n+    public TableAsyncBatch createBatch(String partitionKey) {\n+        if (partitionKey == null || partitionKey.isEmpty()) {", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzgyMTI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r517821293", "bodyText": "parameter alignments aren't necessary. it results in a lot of empty whitespace.", "author": "conniey", "createdAt": "2020-11-05T06:39:02Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableBatch.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import static com.azure.storage.common.implementation.StorageImplUtils.blockWithOptionalTimeout;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableClient#createBatch(String)} method on a {@link\n+ * TableClient} object.\n+ */\n+@Fluent\n+public final class TableBatch {\n+    private final TableAsyncBatch batch;\n+\n+    TableBatch(TableAsyncBatch batch) {\n+        this.batch = batch;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableBatch} object, if the entity's row key is {@code null}", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM2Mzk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518363940", "bodyText": "Shouldn't block here", "author": "alzimmermsft", "createdAt": "2020-11-05T21:05:25Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM2NzE4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518367187", "bodyText": "Indeed, I would love to find a non-blocking way to do this. The only async operation is the op.prepareRequest step, which \"executes\" the request using the new NullHttpClient which doesn't actually send the request on the wire, it just captures the request so we can read out its method / headers / body and stuff them into the multipart body later on. So the blocking call here isn't as bad as it looks, but it still would be ideal to find a way to remove it.", "author": "bsiegel", "createdAt": "2020-11-05T21:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM2Mzk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM3OTMyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518379324", "bodyText": "Given this is in the scope of a reactive operation use Mono.error to return the exception.\nFluxUtil.monoError(logger, /* exception */)\nThis will prevent needing to wrap this statement in a try/catch.", "author": "alzimmermsft", "createdAt": "2020-11-05T21:28:40Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/TableAsyncBatch.java", "diffHunk": "@@ -0,0 +1,385 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.data.tables;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.http.rest.SimpleResponse;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.data.tables.implementation.BatchImpl;\n+import com.azure.data.tables.implementation.ModelHelper;\n+import com.azure.data.tables.implementation.TablesMultipartSerializer;\n+import com.azure.data.tables.implementation.models.BatchChangeSet;\n+import com.azure.data.tables.implementation.models.BatchOperation;\n+import com.azure.data.tables.models.BatchOperationResponse;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubRequest;\n+import com.azure.data.tables.implementation.models.TableServiceError;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import com.azure.data.tables.models.TableEntity;\n+import com.azure.data.tables.models.UpdateMode;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * Provides a batch object for asynchronously executing a transaction containing one or more operations on entities\n+ * within a table in the Azure Tables service.\n+ *\n+ * The batch object represents a collection of one or more create, update, upsert, and/or delete operations on entities\n+ * that share the same partition key within the table. When the batch is executed, all of the operations will be\n+ * performed as part of a single transaction. As a result, either all operations in the batch will succeed, or if a\n+ * failure occurs, all operations in the batch will be rolled back. Each operation in a batch must operate on a distinct\n+ * row key. Attempting to add multiple operations to a batch that share the same row key will cause an exception to be\n+ * thrown.\n+ *\n+ * Instances of this object are obtained by calling the {@link TableAsyncClient#createBatch(String)} method on a {@link\n+ * TableAsyncClient} object.\n+ */\n+@Fluent\n+public final class TableAsyncBatch {\n+    private final ClientLogger logger = new ClientLogger(TableAsyncBatch.class);\n+    private final String partitionKey;\n+    private final TableAsyncClient operationClient;\n+    private final BatchImpl batchImpl;\n+    private final HashSet<String> rowKeys = new HashSet<>();\n+    private final List<BatchOperation> operations = new ArrayList<>();\n+    private boolean frozen = false;\n+\n+    TableAsyncBatch(String partitionKey, TableAsyncClient client) {\n+        this.partitionKey = partitionKey;\n+        this.batchImpl = new BatchImpl(client.getImplementation(), new TablesMultipartSerializer());\n+        this.operationClient = new TableClientBuilder()\n+            .tableName(client.getTableName())\n+            .endpoint(client.getImplementation().getUrl())\n+            .serviceVersion(client.getApiVersion())\n+            .pipeline(BuilderHelper.buildNullClientPipeline())\n+            .buildAsyncClient();\n+    }\n+\n+    /**\n+     * Inserts an entity into the table.\n+     *\n+     * @param entity The entity to insert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch createEntity(TableEntity entity) {\n+        validate(entity);\n+        addOperation(new BatchOperation.CreateEntity(entity));\n+        return this;\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or merges the entity with the existing entity otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the provided entity's properties will be merged into the existing entity.\n+     *\n+     * @param entity The entity to upsert.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity) {\n+        return upsertEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Inserts an entity into the table if it does not exist, or updates the existing entity using the specified update\n+     * mode otherwise.\n+     *\n+     * If no entity exists within the table having the same partition key and row key as the provided entity, it will\n+     * be inserted. Otherwise, the existing entity will be updated according to the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to upsert.\n+     * @param updateMode The type of update to perform if the entity already exits.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch upsertEntity(TableEntity entity, UpdateMode updateMode) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpsertEntity(entity, updateMode));\n+        return this;\n+    }\n+\n+    /**\n+     * Updates an existing entity by merging the provided entity with the existing entity.\n+     *\n+     * @param entity The entity to update.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity) {\n+        return updateEntity(entity, UpdateMode.MERGE);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode) {\n+        return updateEntity(entity, updateMode, false);\n+    }\n+\n+    /**\n+     * Updates an existing entity using the specified update mode.\n+     *\n+     * When the update mode is 'MERGE', the provided entity's properties will be merged into the existing entity. When\n+     * the update mode is 'REPLACE', the provided entity's properties will completely replace those in the existing\n+     * entity.\n+     *\n+     * @param entity The entity to update.\n+     * @param updateMode The type of update to perform.\n+     * @param ifUnchanged When true, the eTag of the provided entity must match the eTag of the entity in the Table\n+     *                    service. If the values do not match, the update will not occur and an exception will be\n+     *                    thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the entity's partition key does not match the partition key provided when\n+     *                                  creating this {@link TableAsyncBatch} object, if the entity's row key is {@code\n+     *                                  null} or empty, or if another operation with the same row key has already been\n+     *                                  added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch updateEntity(TableEntity entity, UpdateMode updateMode, boolean ifUnchanged) {\n+        validate(entity);\n+        addOperation(new BatchOperation.UpdateEntity(entity, updateMode, ifUnchanged));\n+        return this;\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey) {\n+        return deleteEntity(rowKey, \"*\");\n+    }\n+\n+    /**\n+     * Deletes an entity from the table.\n+     *\n+     * @param rowKey The row key of the entity.\n+     * @param eTag The value to compare with the eTag of the entity in the Tables service. If the values do not match,\n+     *             the delete will not occur and an exception will be thrown.\n+     *\n+     * @return The updated {@link TableAsyncBatch}.\n+     * @throws IllegalArgumentException if the provided row key is {@code null} or empty, or if another operation with\n+     *                                  the same row key has already been added to the batch.\n+     * @throws IllegalStateException if this method is called after the batch has been submitted.\n+     */\n+    public TableAsyncBatch deleteEntity(String rowKey, String eTag) {\n+        validate(partitionKey, rowKey);\n+        addOperation(new BatchOperation.DeleteEntity(partitionKey, rowKey, eTag));\n+        return this;\n+    }\n+\n+    /**\n+     * Gets an immutable list containing all operations added to this batch.\n+     *\n+     * @return An immutable list containing all operations added to this batch.\n+     */\n+    public synchronized List<BatchOperation> getOperations() {\n+        return Collections.unmodifiableList(this.operations);\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<List<BatchOperationResponse>> submitTransaction() {\n+        return submitTransactionWithResponse().flatMap(response -> Mono.justOrEmpty(response.getValue()));\n+    }\n+\n+    /**\n+     * Executes all operations within The batch inside a transaction. When the call completes, either all operations in\n+     * the batch will succeed, or if a failure occurs, all operations in the batch will be rolled back.\n+     *\n+     * @return A reactive result containing the HTTP response produced for the batch itself. The response's value will\n+     * contain a list of sub-responses for each operation in the batch.\n+     * @throws TableServiceErrorException if any operation within the batch fails. See the documentation for the client\n+     *                                    methods in {@link TableAsyncClient} to understand the conditions that may\n+     *                                    cause a given operation to fail.\n+     * @throws IllegalStateException if no operations have been added to the batch.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse() {\n+        return withContext(this::submitTransactionWithResponse);\n+    }\n+\n+    synchronized Mono<Response<List<BatchOperationResponse>>> submitTransactionWithResponse(Context context) {\n+        this.frozen = true;\n+        context = context == null ? Context.NONE : context;\n+\n+        if (operations.size() == 0) {\n+            throw logger.logExceptionAsError(new IllegalStateException(\"A batch must contain at least one operation.\"));\n+        }\n+\n+        final BatchRequestBody body = new BatchRequestBody();\n+        Flux.fromIterable(operations)\n+            .flatMapSequential(op -> op.prepareRequest(operationClient))\n+            .zipWith(Flux.fromIterable(operations))\n+            .doOnNext(pair -> body.addChangeOperation(new BatchSubRequest(pair.getT2(), pair.getT1())))\n+            .blockLast();\n+\n+        try {\n+            return batchImpl.submitBatchWithRestResponseAsync(body, null, context)\n+                .map(response -> {\n+                    TableServiceError error = null;\n+                    String errorMessage = null;\n+                    BatchChangeSet changes = null;\n+                    BatchOperation failedOperation = null;\n+\n+                    if (body.getContents().get(0) instanceof BatchChangeSet) {\n+                        changes = (BatchChangeSet) body.getContents().get(0);\n+                    }\n+\n+                    for (int i = 0; i < response.getValue().length; i++) {\n+                        BatchOperationResponse subResponse = response.getValue()[i];\n+\n+                        // Attempt to attach a sub-request to each batch sub-response\n+                        if (changes != null && changes.getContents().get(i) != null) {\n+                            ModelHelper.updateBatchOperationResponse(subResponse,\n+                                changes.getContents().get(i).getHttpRequest());\n+                        }\n+\n+                        // If one sub-response was an error, we need to throw even though the service responded with 202\n+                        if (subResponse.getStatusCode() >= 400 && error == null && errorMessage == null) {\n+                            if (subResponse.getValue() instanceof TableServiceError) {\n+                                error = (TableServiceError) subResponse.getValue();\n+\n+                                // Make a best effort to locate the failed operation and include it in the message\n+                                if (changes != null && error.getOdataError() != null\n+                                    && error.getOdataError().getMessage() != null\n+                                    && error.getOdataError().getMessage().getValue() != null) {\n+\n+                                    String message = error.getOdataError().getMessage().getValue();\n+                                    try {\n+                                        int failedIndex = Integer.parseInt(message.substring(0, message.indexOf(\":\")));\n+                                        failedOperation = changes.getContents().get(failedIndex).getOperation();\n+                                    } catch (NumberFormatException e) {\n+                                        // Unable to parse failed operation from batch error message - this just means\n+                                        // the service did not indicate which request was the one that failed. Since\n+                                        // this is optional, just swallow the exception.\n+                                    }\n+                                }\n+                            } else if (subResponse.getValue() instanceof String) {\n+                                errorMessage = \"The service returned the following data for the failed operation: \"\n+                                    + subResponse.getValue();\n+                            } else {\n+                                errorMessage =\n+                                    \"The service returned the following status code for the failed operation: \"\n+                                        + subResponse.getStatusCode();\n+                            }\n+                        }\n+                    }\n+\n+                    if (error != null || errorMessage != null) {\n+                        String message = \"An operation within the batch failed, the transaction has been rolled back.\";\n+                        if (failedOperation != null) {\n+                            message += \" The failed operation was: \" + failedOperation.toString();\n+                        } else if (errorMessage != null) {\n+                            message += \" \" + errorMessage;\n+                        }\n+                        throw logger.logExceptionAsError(new TableServiceErrorException(message, null, error));", "originalCommit": "9fb9131e7f167be7c63cefc4c1296aeb52003d76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "message": "Code review changes", "committedDate": "2020-11-05T23:07:18Z", "type": "commit"}, {"oid": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "message": "Code review changes", "committedDate": "2020-11-05T23:07:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NTAxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518985017", "bodyText": "Is this the only data service version this is supported in? I thought there was some expandable enum for these.", "author": "conniey", "createdAt": "2020-11-06T20:19:15Z", "path": "sdk/tables/azure-data-tables/src/main/java/com/azure/data/tables/implementation/BatchImpl.java", "diffHunk": "@@ -0,0 +1,83 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.data.tables.implementation;\n+\n+import com.azure.core.annotation.BodyParam;\n+import com.azure.core.annotation.ExpectedResponses;\n+import com.azure.core.annotation.HeaderParam;\n+import com.azure.core.annotation.Host;\n+import com.azure.core.annotation.HostParam;\n+import com.azure.core.annotation.Post;\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceInterface;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.annotation.UnexpectedResponseExceptionType;\n+import com.azure.core.http.rest.RestProxy;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.data.tables.implementation.models.BatchRequestBody;\n+import com.azure.data.tables.implementation.models.BatchSubmitBatchResponse;\n+import com.azure.data.tables.implementation.models.TableServiceErrorException;\n+import reactor.core.publisher.Mono;\n+\n+/** An instance of this class provides access to all the operations defined in Batch. */\n+public final class BatchImpl {\n+    /** The proxy service used to perform REST calls. */\n+    private final BatchService service;\n+\n+    /** The service client containing this operation class. */\n+    private final AzureTableImpl client;\n+\n+    /**\n+     * Initializes an instance of BatchImpl.\n+     *\n+     * @param client the instance of the service client containing this operation class.\n+     */\n+    public BatchImpl(AzureTableImpl client, SerializerAdapter serializerAdapter) {\n+        this.service = RestProxy.create(BatchService.class, client.getHttpPipeline(), serializerAdapter);\n+        this.client = client;\n+    }\n+\n+    /**\n+     * The interface defining all the services for AzureTableBatch to be used by the proxy service to perform REST\n+     * calls.\n+     */\n+    @Host(\"{url}\")\n+    @ServiceInterface(name = \"AzureTableServices\")\n+    private interface BatchService {\n+        @Post(\"/$batch\")\n+        @ExpectedResponses({202})\n+        @UnexpectedResponseExceptionType(TableServiceErrorException.class)\n+        Mono<BatchSubmitBatchResponse> submitBatch(\n+            @HostParam(\"url\") String url,\n+            @HeaderParam(\"Content-Type\") String multipartContentType,\n+            @HeaderParam(\"x-ms-version\") String version,\n+            @HeaderParam(\"x-ms-client-request-id\") String requestId,\n+            @HeaderParam(\"DataServiceVersion\") String dataServiceVersion,\n+            @BodyParam(\"multipart/mixed\") BatchRequestBody body,\n+            Context context);\n+    }\n+\n+    /**\n+     * The Batch operation allows multiple API calls to be embedded into a single HTTP request.\n+     *\n+     * @param body Initial data.\n+     * @param requestId Provides a client-generated, opaque value with a 1 KB character limit that is recorded in the\n+     *                  analytics logs when storage analytics logging is enabled.\n+     * @param context The context to associate with this operation.\n+     * @throws IllegalArgumentException thrown if parameters fail the validation.\n+     * @return a Mono which performs the network request upon subscription.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<BatchSubmitBatchResponse> submitBatchWithRestResponseAsync(\n+        BatchRequestBody body,\n+        String requestId,\n+        Context context\n+    ) {\n+        final String dataServiceVersion = \"3.0\";", "originalCommit": "a72f65b460e7aa860f8a9ff9673446a3e4495cc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NzE3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17044#discussion_r518987178", "bodyText": "It's the only supported version. The Impl types are typically generated by Autorest - if you compare with TablesImpl.java you can see that Autorest generates code with a hard-coded version of \"3.0\" there as well. In the future we want to replace a lot of the code I wrote here with code that's generated from Autorest, but at present there is some complexity I don't recall that prevents us from being able to describe the batch endpoint correctly in the swagger.", "author": "bsiegel", "createdAt": "2020-11-06T20:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk4NTAxNw=="}], "type": "inlineReview"}]}