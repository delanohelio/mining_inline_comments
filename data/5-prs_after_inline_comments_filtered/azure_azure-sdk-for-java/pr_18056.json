{"pr_number": 18056, "pr_title": "ChangeFeed pull model and switching CF processor to FeedRange", "pr_createdAt": "2020-12-09T22:21:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/18056", "timeline": [{"oid": "6392f9aaa30fe96f1867b35958c5af62d5c1c17b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6392f9aaa30fe96f1867b35958c5af62d5c1c17b", "message": "Update FeedRange.java", "committedDate": "2021-01-19T16:01:40Z", "type": "commit"}, {"oid": "29c0719aa828a6b2ac81f717eff81f12f03adfbf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/29c0719aa828a6b2ac81f717eff81f12f03adfbf", "message": "Cleanup", "committedDate": "2021-01-19T17:57:45Z", "type": "commit"}, {"oid": "0804d1617b2c39f0ac7c8a84c578657e6cfe8437", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0804d1617b2c39f0ac7c8a84c578657e6cfe8437", "message": "Fixing typos in comments", "committedDate": "2021-01-19T19:34:36Z", "type": "commit"}, {"oid": "c1d565ee192c924299c3053b7cdc1c47aed4fef3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1d565ee192c924299c3053b7cdc1c47aed4fef3", "message": "Fixing Duration in ChangeFeedPolicy", "committedDate": "2021-01-19T23:30:31Z", "type": "commit"}, {"oid": "7148a3a58d5334f9aee023968db55ef1def39747", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7148a3a58d5334f9aee023968db55ef1def39747", "message": "Changing the encoding of FeedRange and ChangeFeedState to be base64-encoded Json vs. Json", "committedDate": "2021-01-20T00:43:04Z", "type": "commit"}, {"oid": "b8ed9937dd19a74448cb2884155ee06f208dc00e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b8ed9937dd19a74448cb2884155ee06f208dc00e", "message": "Cleanup", "committedDate": "2021-01-20T01:24:57Z", "type": "commit"}, {"oid": "268e467ada8b7ad5846fc30cedfa4e12bc5a0129", "url": "https://github.com/Azure/azure-sdk-for-java/commit/268e467ada8b7ad5846fc30cedfa4e12bc5a0129", "message": "Fixing spotbug issue", "committedDate": "2021-01-20T02:06:30Z", "type": "commit"}, {"oid": "7718b241b6c5f7c91afc9fd5696cba0f48dda0de", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7718b241b6c5f7c91afc9fd5696cba0f48dda0de", "message": "Fixing test issue", "committedDate": "2021-01-20T09:25:44Z", "type": "commit"}, {"oid": "4db657eebb17287f4b572ea92d3355e856c314cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4db657eebb17287f4b572ea92d3355e856c314cb", "message": "Switching deserializer registration to annotation based approach", "committedDate": "2021-01-20T18:30:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzOTU5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561339596", "bodyText": "useEtagAsContinuation... why etag?", "author": "milismsft", "createdAt": "2021-01-20T22:08:55Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -565,8 +597,11 @@ ItemDeserializer getItemDeserializer() {\n         );\n     }\n \n-    private <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryDecryptionTransformer(Class<T> classType,\n-                                                                                                   Function<CosmosPagedFluxOptions, Flux<FeedResponse<JsonNode>>> func) {\n+    private <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryDecryptionTransformer(\n+        Class<T> classType,\n+        Function<CosmosPagedFluxOptions, Flux<FeedResponse<JsonNode>>> func,\n+        boolean useEtagAsContinuation) {", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3MjM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561772389", "bodyText": "Flag is used in FeedResponse - for Changefeed responses from the backend the continuation isn't passed as header but instead the etag is used. This flag needed to be passed through to be able to recreate a new FeedResponse in the PagedFlized etc. from a list of results of", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTMzOTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MjgxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561342812", "bodyText": "we will change these to real versions, right? :-)", "author": "milismsft", "createdAt": "2021-01-20T22:15:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -471,14 +476,94 @@ public String getId() {\n \n                 return getDatabase().getDocClientWrapper()\n                              .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions)\n-                             .map(response -> prepareFeedResponse(response, classType));\n+                             .map(response -> prepareFeedResponse(response, false, classType));\n         });\n \n         return pagedFluxOptionsFluxFunction;\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * After subscription the operation will be performed. The {@link Flux} will\n+     * contain one or several feed response of the obtained items. In case of\n+     * failure the {@link CosmosPagedFlux} will error.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one or several feed response pages of the obtained\n+     * items or an error.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3MjY5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561772693", "bodyText": "Correct - tracking it in an active comment in the Beta annotation class.", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MjgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzY2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561343669", "bodyText": "same here", "author": "milismsft", "createdAt": "2021-01-20T22:17:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -338,6 +359,33 @@ private TransactionalBatchResponse blockBatchResponse(Mono<TransactionalBatchRes\n         return getCosmosPagedIterable(this.asyncContainer.queryItems(querySpec, options, classType));\n     }\n \n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * The next page can be retrieved by calling queryChangeFeed again with a new instance of\n+     * {@link CosmosChangeFeedRequestOptions} created from the continuation token of the previously returned\n+     * {@link FeedResponse} instance.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one feed response page\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3MjgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561772819", "bodyText": "Dito", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM0MzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1NzcxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561357713", "bodyText": "curious, what's the point of this and why we could not extract the self link directly from the CosmosAsyncContainer param?", "author": "milismsft", "createdAt": "2021-01-20T22:46:34Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedContextClientImpl.java", "diffHunk": "@@ -83,20 +79,40 @@ public ChangeFeedContextClientImpl(CosmosAsyncContainer cosmosContainer, Schedul\n     }\n \n     @Override\n-    public Flux<FeedResponse<JsonNode>> createDocumentChangeFeedQuery(CosmosAsyncContainer collectionLink,\n-                                                                      ChangeFeedOptions feedOptions) {\n+    public Flux<FeedResponse<JsonNode>> createDocumentChangeFeedQuery(\n+        CosmosAsyncContainer collectionLink,\n+        CosmosChangeFeedRequestOptions requestOptions) {\n+\n         AsyncDocumentClient clientWrapper =\n             CosmosBridgeInternal.getAsyncDocumentClient(collectionLink.getDatabase());\n         Flux<FeedResponse<JsonNode>> feedResponseFlux =\n-            clientWrapper.queryDocumentChangeFeed(BridgeInternal.extractContainerSelfLink(collectionLink), feedOptions)\n-                                                                    .map(response -> {\n-                                                                        List<JsonNode> results = response.getResults()\n-                                                                                                                     .stream()\n-                                                                                                                     .map(document ->\n-                                                                                                                         ModelBridgeInternal.toObjectFromJsonSerializable(document, JsonNode.class))\n-                                                                                                                     .collect(Collectors.toList());\n-                                                                        return BridgeInternal.toFeedResponsePage(results, response.getResponseHeaders(), false);\n-                                                                    });\n+            clientWrapper\n+                .getCollectionCache()", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3NzM3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561777372", "bodyText": "CosmosAsyncContainer isn't a resource (doesn't have SelfLink) - just the Link (which is the name based representation vs. Rid based). For changefeed we need the Rid to handle Collection-drop-and-recreate scenarios. Unfortunately that requires IO operations - because there is no guarantee that the Rid has been retrieved from the backend and is cached.", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM1NzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2NTU5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561365593", "bodyText": "The initial intent was to make these settings configurable at some point. However we've been running with these defaults for a while now without any issues and no requests from customers to change them.", "author": "milismsft", "createdAt": "2021-01-20T23:04:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedProcessorBuilderImpl.java", "diffHunk": "@@ -72,16 +67,13 @@\n     private static final String PK_RANGE_ID_SEPARATOR = \":\";\n     private static final String SEGMENT_SEPARATOR = \"#\";\n     private static final String PROPERTY_NAME_LSN = \"_lsn\";\n-    private static final String PROPERTY_NAME_TS = \"_ts\";\n \n     private final Logger logger = LoggerFactory.getLogger(ChangeFeedProcessorBuilderImpl.class);\n-    private static final long DefaultUnhealthinessDuration = Duration.ofMinutes(15).toMillis();\n     private final Duration sleepTime = Duration.ofSeconds(15);\n     private final Duration lockTime = Duration.ofSeconds(30);\n-    private static final int DefaultQueryPartitionsMaxBatchSize = 100;\n+    private static final int DEFAULT_QUERY_PARTITIONS_MAX_BATCH_SIZE = 100;\n \n-    private int queryPartitionsMaxBatchSize = DefaultQueryPartitionsMaxBatchSize;\n-    private int degreeOfParallelism = 25; // default\n+    private final static int DEFAULT_DEGREE_OF_PARALLELISM = 25; // default", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3NzkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561777911", "bodyText": "Yeah - and if necessary this can be wired up if a need arises.", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2NTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2OTIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561369216", "bodyText": "nit: start with a non-zero value", "author": "milismsft", "createdAt": "2021-01-20T23:13:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStateVersions.java", "diffHunk": "@@ -0,0 +1,7 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public class ChangeFeedStateVersions {\n+    public final static int V1 = 0;", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc3ODU5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561778592", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM2OTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM3NjM5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561376395", "bodyText": "We need to add a public facing configuration setting to toggle between full fidelity and incremental.", "author": "milismsft", "createdAt": "2021-01-20T23:30:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -60,20 +93,24 @@ public PartitionProcessor create(Lease lease, ChangeFeedObserver observer) {\n             throw new IllegalArgumentException(\"lease\");\n         }\n \n-        String startContinuation = lease.getContinuationToken();\n-\n-        if (startContinuation == null || startContinuation.isEmpty()) {\n-            startContinuation = this.changeFeedProcessorOptions.getStartContinuation();\n+        FeedRangeInternal feedRange = new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken());\n+        ChangeFeedState state;\n+        if (Strings.isNullOrWhiteSpace(lease.getContinuationToken())) {\n+            state = new ChangeFeedStateV1(\n+                BridgeInternal.extractContainerSelfLink(this.collectionSelfLink),\n+                new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken()),\n+                ChangeFeedMode.INCREMENTAL,", "originalCommit": "4db657eebb17287f4b572ea92d3355e856c314cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTc4MTUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561781521", "bodyText": "Like discussed in the design meeting - not once you start processing for an existing continuation. You can always start a new Incremental change feed.\nI simply don't see a scenario for this - either your app needs full fidelity information - in that case casting down to incremental would still break the app - or you don't need previous images in that case you can start-off with incremental (and it allows you to pick a starting point anyway).\nI think we can reopen this discussion when looking at implementing the \"IncrementalFullFidleity\" mode Michael and company form the backend have in mind and the Compute team is pushing for. Matias and I have pushed back at adding this to public surface area because it is too confusing and we didn't have good enough understanding of possible use cases yet. But when we add that I can see how you would at least want to  fall back FullFidelity continuation to IncrementalFullFidelity in cases where your processor is out of retention window.\nDoes that make sense?", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T10:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTM3NjM5NQ=="}], "type": "inlineReview"}, {"oid": "681d994d01c7dcffb4860f1a79bc332490de10f4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/681d994d01c7dcffb4860f1a79bc332490de10f4", "message": "Reacting to code review feedback from Milis", "committedDate": "2021-01-21T10:56:39Z", "type": "commit"}, {"oid": "964c2da8f5c7754994e9018d2a3d16718bbb1e99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/964c2da8f5c7754994e9018d2a3d16718bbb1e99", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-21T10:59:35Z", "type": "commit"}, {"oid": "ab94708a0a2691d871a030d7b27691c41a639e36", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab94708a0a2691d871a030d7b27691c41a639e36", "message": "Fixing Test issues after changing ChangeFeedStateVersion from 0 to 1", "committedDate": "2021-01-21T13:37:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562036456", "bodyText": "Are these possible to put as style guides like in VS?", "author": "kirankumarkolli", "createdAt": "2021-01-21T16:50:23Z", "path": "sdk/cosmos/azure-cosmos-encryption/src/main/java/com/azure/cosmos/encryption/EncryptionCosmosAsyncContainer.java", "diffHunk": "@@ -89,7 +92,7 @@\n                 if (decryptResponse) {\n                     return setByteArrayContent(rsp,\n                         EncryptionProcessor.decrypt(EncryptionModelBridgeInternal.getByteArrayContent(rsp),\n-                            this.encryptor).map(pair -> pair.getLeft()).publishOn(encryptionScheduler));\n+                            this.encryptor).map(Pair::getLeft).publishOn(encryptionScheduler));", "originalCommit": "ab94708a0a2691d871a030d7b27691c41a639e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE3NjMxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562176312", "bodyText": "I fixed them based on Intelli-J \"style violations\". We have a couple of style (and FxCop like) rules in the CI/Build pipeline - but mostly leave the configuration of what gets enforced to the Azure central team.\nSo far on the Java side that has worked reasonably well IMO: @moderakh / @kushagraThapar - thoughts?", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T20:28:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwMTMzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562801335", "bodyText": "We already have code style enforcer which works pretty well in IMO as well and as Fabian mentioned the code-style enforcer runs as a gated CI on every PR by the central sdk team.\nAs Fabian mentioned this lambda's code style is only intellj's suggestion. I wouldn't add more rules to the existing automated enforcer. being to restrictive makes it hard for coding.", "author": "moderakh", "createdAt": "2021-01-22T17:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NjIxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562856217", "bodyText": "I agree, some of these are related to personal coding styles as well, for example I like to change things to lambda with method reference, like done above, but not everyone follows this syntax. And I don't think it will be any helpful to force these style changes.", "author": "kushagraThapar", "createdAt": "2021-01-22T19:22:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjAzNjQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA0OTQ0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562049443", "bodyText": "Does casing matters or just as convention?", "author": "kirankumarkolli", "createdAt": "2021-01-21T17:08:06Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -38,7 +38,7 @@\n         public static final String USER_AGENT = \"User-Agent\";\n         public static final String IF_MODIFIED_SINCE = \"If-Modified-Since\";\n         public static final String IF_MATCH = \"If-Match\";\n-        public static final String IF_NONE_MATCH = \"If-NONE-Match\";\n+        public static final String IF_NONE_MATCH = \"If-None-Match\";", "originalCommit": "ab94708a0a2691d871a030d7b27691c41a639e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4NjI4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562186285", "bodyText": "Http headers should be case-insensitive - although Gateway had a couple of issues with it I believe. Anyway - the motivation for this change was to be consistent with Backend and .Net.", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T20:46:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA0OTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA1MDUzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562050536", "bodyText": "nit: naming, how does RETRY_NOW sound?", "author": "kirankumarkolli", "createdAt": "2021-01-21T17:09:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ShouldRetryResult.java", "diffHunk": "@@ -5,6 +5,11 @@\n import java.time.Duration;\n \n public class ShouldRetryResult {\n+    public final static ShouldRetryResult NO_RETRY =\n+        ShouldRetryResult.noRetry();\n+    public final static ShouldRetryResult RETRY_IMMEDIATELY =", "originalCommit": "ab94708a0a2691d871a030d7b27691c41a639e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE4Nzk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562187971", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-21T20:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjA1MDUzNg=="}], "type": "inlineReview"}, {"oid": "e9401ab27837cf750ee7a5789dbe84cb793630db", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9401ab27837cf750ee7a5789dbe84cb793630db", "message": "Fix test issue", "committedDate": "2021-01-21T20:23:12Z", "type": "commit"}, {"oid": "df78ea01bf3c9fb78b1990b709dcdd0ad998d1b5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df78ea01bf3c9fb78b1990b709dcdd0ad998d1b5", "message": "Renaming ShouldretryResult.RETRY_IMMEDIATELY to RETRY_NOW", "committedDate": "2021-01-21T20:50:09Z", "type": "commit"}, {"oid": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "message": "Adding Status code to JavaDoc description when processing FF CF outside retention", "committedDate": "2021-01-21T23:53:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2NTQ2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562765466", "bodyText": "This existed in .NET because originally, we also used this for normal ReadFeed, probably not worth it here", "author": "ealsur", "createdAt": "2021-01-22T16:51:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeCompositeContinuationImpl.java", "diffHunk": "@@ -303,14 +320,14 @@ private static CompositeContinuationToken createCompositeContinuationTokenForRan\n \n     private void moveToNextToken() {\n         final CompositeContinuationToken recentToken = this.compositeContinuationTokens.poll();\n-        if (recentToken.getToken() != null) {\n+        // TODO fabianm remove if (recentToken.getToken() != null) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMDY3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562830670", "bodyText": "Fixed in next iteration (remove the commented out if statement", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T18:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2NTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2ODU2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562768569", "bodyText": "nit: We don't let users create FeedRanges in .NET other than the PartitionKey, the APIs to create the state take FeedRange optionally, so the user only needs to understand the FeedRange concept in the case they want to parallelize work (if they are reading the complete container, they never deal with it).", "author": "ealsur", "createdAt": "2021-01-22T16:56:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedRange.java", "diffHunk": "@@ -16,9 +18,38 @@\n      * @param json A string representation of a feed range\n      * @return A feed range\n      */\n-    public static FeedRange fromJsonString(String json) {\n-        return FeedRangeInternal.fromJsonString(json);\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange fromString(String json) {\n+        return FeedRangeInternal.fromBase64EncodedJsonString(json);\n     }\n \n-    public String toJsonString();\n+    /**\n+     * Gets a json representation of the feed range - the returned json string can be used\n+     * to create a new feed range instance from it - (use factory method fromJsonString to do so)\n+     * @return a JSON string representing the feed range\n+     */\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public String toString();\n+\n+    /**\n+     * Creates a range for a certain logical partition\n+     * @param partitionKey the logical partition key value\n+     * @return A feed range for a certain logical partition\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange forLogicalPartition(PartitionKey partitionKey) {\n+        checkNotNull(partitionKey, \"Argument 'partitionKey' must not be null.\");\n+\n+        return new FeedRangePartitionKeyImpl(\n+            ModelBridgeInternal.getPartitionKeyInternal(partitionKey));\n+    }\n+\n+    /**\n+     * Creates a range for an entire container\n+     * @return A feed range for an entire container\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange forFullRange() {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyNTY3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562825674", "bodyText": "Yes - am aware of it. The reason why I made FeedRange required in Java is that I can hardly ever see a scenario where you would want to use ChangeFeed Pull model and not somehow parallelize work (most often across different computational units like VMs). For many custoemrs ChangeFeed pull model is the right choice - if you use pull model I think controlling parallelization is often the goal - does that make sense?\nFor query we would obviously have an option to not having to specify FeedRange explicitly (and fall back would be full container)", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T18:26:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2ODU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3MDc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562770754", "bodyText": "If the new query is split proof, how does the PARTITION_SPLIT error bubble up?", "author": "ealsur", "createdAt": "2021-01-22T16:59:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -123,8 +121,8 @@ public PartitionProcessorImpl(ChangeFeedObserver observer, ChangeFeedContextClie\n                 if (throwable instanceof CosmosException) {\n \n                     CosmosException clientException = (CosmosException) throwable;\n-                    logger.warn(\"CosmosException: partition {} from thread {}\",\n-                        this.settings.getPartitionKeyRangeId(), Thread.currentThread().getId(), clientException);\n+                    logger.warn(\"CosmosException: FeedRange {} from thread {}\",", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMDcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562930711", "bodyText": "There are definitely two issues in the change feed processor still\n\nSplit handling as you mentioned above\nContinuation persisted right now is the base64-encoded json representation of the changefeed state - instead it should be just the plain simple lsn for this iteration/PR\n\nWill investigate both issues and fix in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T21:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3MDc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk3NzU1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562977558", "bodyText": "Fixed in the latest iteration - thanks Matias", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T23:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3MDc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzQ2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562867467", "bodyText": "Is this API being used anywhere ?\nAlso, what is the reason of using blockFirst() and not blockLast()?\nIf there is only single element in this Flux, why not use Mono<FeedResponse<T>> ?", "author": "kushagraThapar", "createdAt": "2021-01-22T19:44:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -259,6 +261,25 @@ public ThroughputResponse readThroughput() {\n         }\n     }\n \n+    /**\n+     * Block on first feed response.\n+     *\n+     * @param feedResponseFlux the feed response flux mono.\n+     * @return the cosmos item response.\n+     */\n+    <T> FeedResponse<T> blockFirstFeedResponse(Flux<FeedResponse<T>> feedResponseFlux) {\n+        try {\n+            return feedResponseFlux.blockFirst();", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMTI1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562931259", "bodyText": "Deleted - left-over of a previous version", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T21:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzgzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562867839", "bodyText": "At other places, I noticed we are also checking notNull for classType, any specific reason we are not doing it here ?", "author": "kushagraThapar", "createdAt": "2021-01-22T19:45:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosContainer.java", "diffHunk": "@@ -338,6 +359,33 @@ private TransactionalBatchResponse blockBatchResponse(Mono<TransactionalBatchRes\n         return getCosmosPagedIterable(this.asyncContainer.queryItems(querySpec, options, classType));\n     }\n \n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * The next page can be retrieved by calling queryChangeFeed again with a new instance of\n+     * {@link CosmosChangeFeedRequestOptions} created from the continuation token of the previously returned\n+     * {@link FeedResponse} instance.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one feed response page\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public <T> CosmosPagedIterable<T> queryChangeFeed(\n+        CosmosChangeFeedRequestOptions options,\n+        Class<T> classType) {\n+\n+        checkNotNull(options, \"Argument 'options' must not be null.\");", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMjAwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562932008", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-22T21:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg2NzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562804091", "bodyText": "why maxItemCount can't be primitive?", "author": "moderakh", "createdAt": "2021-01-22T17:54:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4NTExNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562985114", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDI1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562804259", "bodyText": "why return value can't be primitive?", "author": "moderakh", "createdAt": "2021-01-22T17:54:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount != null ? maxItemCount : DEFAULT_MAX_ITEM_COUNT;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxPrefetchPageCount() {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4NTA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562985086", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562805197", "bodyText": "any reason maxPrefetchPageCount can't be primitive?", "author": "moderakh", "createdAt": "2021-01-22T17:56:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount != null ? maxItemCount : DEFAULT_MAX_ITEM_COUNT;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public Integer getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(Integer maxPrefetchPageCount) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4NTA1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562985051", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562805661", "bodyText": "nit: please remove the empty line.", "author": "moderakh", "createdAt": "2021-01-22T17:57:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,380 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final Integer DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private Integer maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk3OTg3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562979870", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:06:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgwNTY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxMTA3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562811078", "bodyText": "is this high timeout value needed? do you see test timeout?", "author": "moderakh", "createdAt": "2021-01-22T18:05:00Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ChangeFeedTest.java", "diffHunk": "@@ -24,24 +32,29 @@\n import org.testng.annotations.AfterMethod;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Ignore;\n import org.testng.annotations.Test;\n+import org.testng.xml.dom.Tag;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n import java.lang.reflect.Method;\n+import java.time.Duration;\n import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n import static org.assertj.core.api.Assertions.assertThat;\n \n //TODO: change to use external TestSuiteBase\n public class ChangeFeedTest extends TestSuiteBase {\n \n     private static final int SETUP_TIMEOUT = 40000;\n-    private static final int TIMEOUT = 30000;\n+    private static final int TIMEOUT = 30000000;", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MDIzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562980232", "bodyText": "No - left-over from debugging (where the more restrictive timeouts caused issues when stepping through the code)", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxMTA3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MDI2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562980264", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxMTA3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxODY4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562818681", "bodyText": "nit: any apis in the java interface by default is public. hence you don't need to add explicit public.\nIntellj suggests dropping public from methods introduced in interface.\nplease see this:\nhttps://stackoverflow.com/questions/161633/should-methods-in-a-java-interface-be-declared-with-or-without-a-public-access-m\nsame for the other methods in the interface.", "author": "moderakh", "createdAt": "2021-01-22T18:14:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedRange.java", "diffHunk": "@@ -16,9 +18,38 @@\n      * @param json A string representation of a feed range\n      * @return A feed range\n      */\n-    public static FeedRange fromJsonString(String json) {\n-        return FeedRangeInternal.fromJsonString(json);\n+    @Beta(value = Beta.SinceVersion.V4_9_0, warningText = Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static FeedRange fromString(String json) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyMTU4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562821584", "bodyText": "should we have an error case when pkRangeHolder.v == null?\nMono<List<String>> getPartitionKeyRanges() is expected to always return a Mono of List of size 1.\nis there any scenario where here pkRangeHolder.v == null can be and needs validation?", "author": "moderakh", "createdAt": "2021-01-22T18:19:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,112 +37,152 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                Range.getPointRange(effectivePartitionKey),\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    String rangeId = pkRangeHolder.v.get(0).getId();\n-                    rangeList.add(rangeId);\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        Range.getPointRange(effectivePartitionKey),\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        ArrayList<String> rangeList = new ArrayList<>(1);\n+\n+                        if (pkRangeHolder.v != null) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyMzk2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562823968", "bodyText": "I see that ChangeFeedState and FeedRangeInternal are extending JsonSerializable.\nJsonSerializable is not thread-safe. just wondering the way we are passing ChangeFeedState and FeedRangeInternal are we ensuring thread safety in the code which handles them?", "author": "moderakh", "createdAt": "2021-01-22T18:23:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,\n+                                collection.getResourceId(),\n                                 partitionKeyRangeId,\n-                                containerRid)\n-                        ));\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n-                }\n+                                true,\n+                                null);\n+                        } else {\n+                            return Mono.just(pkRangeHolder);\n+                        }\n+                    })\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return Mono.error(\n+                                new PartitionKeyRangeGoneException(\n+                                    String.format(\n+                                        \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the \" +\n+                                            \"current \" +\n+                                            \"container %s .\",\n+                                        partitionKeyRangeId,\n+                                        collection.getResourceId())\n+                                ));\n+                        } else {\n+                            return Mono.just(pkRangeHolder.v.toRange());\n+                        }\n+                    });\n             });\n-\n-        return getPkRangeTask.flatMap((pkRangeHolder) -> {\n-            final ArrayList<Range<String>> temp = new ArrayList<>();\n-            if (pkRangeHolder != null) {\n-                temp.add(pkRangeHolder.v.toRange());\n-            }\n-\n-            return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp));\n-        });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n         final ArrayList<String> temp = new ArrayList<>();\n         temp.add(this.partitionKeyRangeId);\n \n         return Mono.just(\n-            (UnmodifiableList<String>)UnmodifiableList.unmodifiableList(temp));\n+            UnmodifiableList.unmodifiableList(temp));\n     }\n \n-    public void populatePropertyBag() {\n-        super.populatePropertyBag();\n+    @Override\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        if (this.partitionKeyRangeId != null) {\n-            setProperty(\n-                this,\n-                Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID,\n-                this.partitionKeyRangeId);\n-        }\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+\n+        request.routeTo(this.partitionKeyRangeIdentity);\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return this\n+            .getEffectiveRange(routingMapProvider, metadataDiagnosticsCtx, collectionResolutionMono)\n+            .map(effectiveRange -> {\n+                request.setEffectiveRange(effectiveRange);\n+\n+                return request;\n+            });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.partitionKeyRangeId;\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+        setProperties(this, false);\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl) o;\n-        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n+    public void removeProperties(JsonSerializable serializable) {\n+        checkNotNull(serializable, \"Argument 'serializable' must not be null.\");\n+        serializable.remove(Constants.Properties.FEED_RANGE_PARTITION_KEY_RANGE_ID);\n     }\n \n     @Override\n-    public int hashCode() {\n-        return Objects.hash(partitionKeyRangeId);\n+    public void setProperties(JsonSerializable serializable, boolean populateProperties) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyNTQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562825460", "bodyText": "we are not passing diagnostics context here. is this intentional?", "author": "moderakh", "createdAt": "2021-01-22T18:26:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgyNjU1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562826555", "bodyText": "true why do we need to do a force refresh here?\nPartitionKeyRangeGoneException should be handled by GoneAndRetryPolicy. can't we rely on the retry-policy for this?", "author": "moderakh", "createdAt": "2021-01-22T18:28:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyRangeImpl.java", "diffHunk": "@@ -39,112 +43,141 @@ public PartitionKeyRangeIdentity getPartitionKeyRangeIdentity() {\n     }\n \n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyRangeImpl that = (FeedRangePartitionKeyRangeImpl)o;\n+        return Objects.equals(this.partitionKeyRangeId, that.partitionKeyRangeId);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKeyRangeId);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        final Mono<ValueHolder<PartitionKeyRange>> getPkRangeTask = routingMapProvider\n-            .tryGetPartitionKeyRangeByIdAsync(\n-                null,\n-                containerRid,\n-                partitionKeyRangeId,\n-                false,\n-                null)\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n-                        null,\n-                        containerRid,\n-                        partitionKeyRangeId,\n-                        true,\n-                        null);\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n-            })\n-            .flatMap((pkRangeHolder) -> {\n-                if (pkRangeHolder.v == null) {\n-                    return Mono.error(\n-                        new PartitionKeyRangeGoneException(\n-                            String.format(\n-                                \"The PartitionKeyRangeId: \\\"%s\\\" is not valid for the current \" +\n-                                    \"container %s .\",\n+\n+                return routingMapProvider\n+                    .tryGetPartitionKeyRangeByIdAsync(\n+                        metadataDiagnosticsCtx,\n+                        collection.getResourceId(),\n+                        this.partitionKeyRangeId,\n+                        false,\n+                        null)\n+                    .flatMap((pkRangeHolder) -> {\n+                        if (pkRangeHolder.v == null) {\n+                            return routingMapProvider.tryGetPartitionKeyRangeByIdAsync(\n+                                null,\n+                                collection.getResourceId(),\n                                 partitionKeyRangeId,\n-                                containerRid)\n-                        ));\n-                } else {\n-                    return Mono.just(pkRangeHolder);\n-                }\n+                                true,", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMDI0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562830243", "bodyText": "this serializes the FeedRange to String and then we deserialize.\nas future optimization,\nAs there are only a few types extending FeedRange, I wonder if we can avoid the intermediate string serialization step and directly translate FeedRange to FeedRangeInternal. is that possible?", "author": "moderakh", "createdAt": "2021-01-22T18:35:05Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeInternal.java", "diffHunk": "@@ -3,52 +3,54 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n-import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n import com.azure.cosmos.implementation.Utils;\n-import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n-import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.FeedRange;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import reactor.core.publisher.Mono;\n \n import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.List;\n \n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n+@JsonDeserialize(using = FeedRangeInternalDeserializer.class)\n public abstract class FeedRangeInternal extends JsonSerializable implements FeedRange {\n     private final static Logger LOGGER = LoggerFactory.getLogger(FeedRangeInternal.class);\n \n-    public abstract void accept(FeedRangeVisitor visitor);\n-\n-    public abstract <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input);\n-\n-    public abstract <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor);\n-\n     public static FeedRangeInternal convert(final FeedRange feedRange) {\n         checkNotNull(feedRange, \"Argument 'feedRange' must not be null\");\n         if (feedRange instanceof FeedRangeInternal) {\n             return (FeedRangeInternal)feedRange;\n         }\n \n-        String json = feedRange.toJsonString();\n-        return fromJsonString(json);\n+        String json = feedRange.toString();\n+        return fromBase64EncodedJsonString(json);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMjcwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562832705", "bodyText": "can this happen on the happy path? if parsing the string fails, shouldn't we throw and log error?\nin which scenario we reach here?", "author": "moderakh", "createdAt": "2021-01-22T18:39:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +51,75 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n+\n+    private static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {\n+            return FeedRangeCompositeContinuationImpl.parse(jsonString);\n+        }\n+        catch (final IOException ioError) {\n+            LOGGER.debug(\n+                \"Failed to parse feed range continuation JSON {}\",\n+                jsonString,\n+                ioError);\n+            return null;", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk5NDIyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563994222", "bodyText": "Returning a \"null\" is not ideal here; it adds complexity on the caller to specifically handle this case. I think we should just throw an exception if there's a problem with the continuation token, at least in such cases we have a stack trace to look at and understand the reason behind it. We could also modify the logger from \"debug\" to \"warn\" if such de-serialization failure is not expected.", "author": "milismsft", "createdAt": "2021-01-25T19:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzMjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNDIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562834211", "bodyText": "nit: java style for '{' on the same line as try", "author": "moderakh", "createdAt": "2021-01-22T18:42:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +51,75 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n+\n+    private static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNTE0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562835145", "bodyText": "please fix header format to be consistent with other files:\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.", "author": "moderakh", "createdAt": "2021-01-22T18:44:04Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNjEzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562836138", "bodyText": "we have TestSuiteBase.safeDeleteCollection which does something similar.", "author": "moderakh", "createdAt": "2021-01-22T18:45:52Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerTest.java", "diffHunk": "@@ -53,12 +60,31 @@ public void afterClass() {\n         safeCloseSyncClient(client);\n     }\n \n+    @BeforeMethod(groups = { \"emulator\" })\n+    public void beforeTest() throws Exception {\n+        this.createdContainer = null;\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgzNzQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562837446", "bodyText": "safeDeleteCollection(createdContainer) ?", "author": "moderakh", "createdAt": "2021-01-22T18:48:05Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ *\n+ */\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeEpkImpl;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap;\n+import com.azure.cosmos.implementation.guava25.collect.Multimap;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.ChangeFeedPolicy;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertThrows;\n+\n+public class CosmosContainerChangeFeedTest extends TestSuiteBase {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private static final String PARTITION_KEY_FIELD_NAME = \"mypk\";\n+    private CosmosClient client;\n+    private CosmosAsyncContainer createdAsyncContainer;\n+    private CosmosAsyncDatabase createdAsyncDatabase;\n+    private CosmosContainer createdContainer;\n+    private CosmosDatabase createdDatabase;\n+    private final Multimap<String, ObjectNode> partitionKeyToDocuments = ArrayListMultimap.create();\n+    private final String preExistingDatabaseId = CosmosDatabaseForTest.generateId();\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public CosmosContainerChangeFeedTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @AfterClass(groups = { \"emulator\" }, timeOut = 3 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        logger.info(\"starting ....\");\n+        safeDeleteSyncDatabase(createdDatabase);\n+        safeCloseSyncClient(client);\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0MTM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562841343", "bodyText": "I think in FeedRange tests the number of partitions the container contains is important.\nIf you run the tests against emulator, based on the emulator configuration we may get different number of partitions.\nThere are some configs of emulator which always will result in a cosmos-container to be created with only one single partition regardless of the RU throughput you assign when creating the cosmos-container.\nPlease verify the emulator config. also it is worth for future proofing if you have a validation on the minimum number of partitions expected for this test to be meaningful.", "author": "moderakh", "createdAt": "2021-01-22T18:55:19Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosContainerChangeFeedTest.java", "diffHunk": "@@ -0,0 +1,847 @@\n+/*\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License.\n+ *\n+ */\n+\n+package com.azure.cosmos;\n+\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeEpkImpl;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.guava25.collect.ArrayListMultimap;\n+import com.azure.cosmos.implementation.guava25.collect.Multimap;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.ChangeFeedPolicy;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.CosmosContainerProperties;\n+import com.azure.cosmos.models.CosmosContainerResponse;\n+import com.azure.cosmos.models.CosmosItemResponse;\n+import com.azure.cosmos.models.FeedRange;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.testng.Assert.assertThrows;\n+\n+public class CosmosContainerChangeFeedTest extends TestSuiteBase {\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private static final String PARTITION_KEY_FIELD_NAME = \"mypk\";\n+    private CosmosClient client;\n+    private CosmosAsyncContainer createdAsyncContainer;\n+    private CosmosAsyncDatabase createdAsyncDatabase;\n+    private CosmosContainer createdContainer;\n+    private CosmosDatabase createdDatabase;\n+    private final Multimap<String, ObjectNode> partitionKeyToDocuments = ArrayListMultimap.create();\n+    private final String preExistingDatabaseId = CosmosDatabaseForTest.generateId();\n+\n+    @Factory(dataProvider = \"clientBuilders\")\n+    public CosmosContainerChangeFeedTest(CosmosClientBuilder clientBuilder) {\n+        super(clientBuilder);\n+    }\n+\n+    @AfterClass(groups = { \"emulator\" }, timeOut = 3 * SHUTDOWN_TIMEOUT, alwaysRun = true)\n+    public void afterClass() {\n+        logger.info(\"starting ....\");\n+        safeDeleteSyncDatabase(createdDatabase);\n+        safeCloseSyncClient(client);\n+    }\n+\n+    @AfterMethod(groups = { \"emulator\" })\n+    public void afterTest() throws Exception {\n+        if (this.createdContainer != null) {\n+            try {\n+                this.createdContainer.delete();\n+            } catch (CosmosException error) {\n+                if (error.getStatusCode() != 404) {\n+                    throw error;\n+                }\n+            }\n+        }\n+    }\n+\n+    @BeforeMethod(groups = { \"emulator\" })\n+    public void beforeTest() throws Exception {\n+        this.createdContainer = null;\n+        this.createdAsyncContainer = null;\n+        this.partitionKeyToDocuments.clear();\n+    }\n+\n+    @BeforeClass(groups = { \"emulator\" }, timeOut = SETUP_TIMEOUT)\n+    public void before_CosmosContainerTest() {\n+        client = getClientBuilder().buildClient();\n+        createdDatabase = createSyncDatabase(client, preExistingDatabaseId);\n+        createdAsyncDatabase = client.asyncClient().getDatabase(createdDatabase.getId());\n+    }\n+\n+    @Test(groups = { \"emulator\" }, timeOut = TIMEOUT * 5)\n+    public void asyncChangeFeed_fromBeginning_incremental_forFullRange() throws Exception {\n+        this.createContainer(", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0Mzg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562843875", "bodyText": "stale documentation.\n8 -> Duration.ofMinutes(8)", "author": "moderakh", "createdAt": "2021-01-22T18:59:36Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ChangeFeedPolicy.java", "diffHunk": "@@ -0,0 +1,195 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.util.Beta;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Represents the change feed policy configuration for the container in the Azure Cosmos DB service.\n+ *\n+ * <p>\n+ * The example below creates a new container with a change feed policy for full fidelity change feed with a\n+ * retention window of 8 minutes - so intermediary snapshots of changes as well as deleted documents would be\n+ * available for processing for 8 minutes before they vanish. Processing the change feed with full fidelity mode will\n+ * only be able within this retention window - if you attempt to process a change feed after more\n+ * than the retention window (8 minutes in this sample) an error (Status Code 400) will be returned. It would\n+ * still be possible to process changes using Incremental mode even when configuring a full fidelity change\n+ * feed policy with retention window on the container and when using Incremental mode it doesn't matter whether\n+ * your are out of the retention window or not.\n+ *\n+ * <pre>{@code\n+ *\n+ * CosmosContainerProperties containerProperties =\n+ *      new CosmosContainerProperties(\"ContainerName\", \"/somePartitionKeyProperty\");\n+ * containerProperties.setChangeFeedPolicy(ChangeFeedPolicy.createFullFidelityPolicy(8));", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MDY0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562850642", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param.\nI think it might be easier to fork this method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "author": "moderakh", "createdAt": "2021-01-22T19:12:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -147,11 +147,21 @@ public static StoredProcedureResponse toStoredProcedureResponse(RxDocumentServic\n     }\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(List<T> results,\n-                                                                         Map<String, String> headers,\n-                                                                         ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n-                                                                         QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext) {\n-        return ModelBridgeInternal.createFeedResponseWithQueryMetrics(results, headers, queryMetricsMap, diagnosticsContext);\n+    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(\n+        List<T> results,\n+        Map<String, String> headers,\n+        ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n+        QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext,\n+        boolean useEtagAsContinuation,\n+        boolean isNoChangesResponse) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MTAwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562851002", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for BridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "author": "moderakh", "createdAt": "2021-01-22T19:12:58Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/TopDocumentQueryExecutionContext.java", "diffHunk": "@@ -112,7 +112,9 @@ public boolean test(FeedResponse<T> frp) {\n                     return BridgeInternal.createFeedResponseWithQueryMetrics(t.getResults(),\n                         headers,\n                         BridgeInternal.queryMetricsFromFeedResponse(t),\n-                        ModelBridgeInternal.getQueryPlanDiagnosticsContext(t));\n+                        ModelBridgeInternal.getQueryPlanDiagnosticsContext(t),\n+                        false,\n+                        false);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1MTk5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562851997", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for BridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "author": "moderakh", "createdAt": "2021-01-22T19:15:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/GroupByDocumentQueryExecutionContext.java", "diffHunk": "@@ -122,7 +122,13 @@\n         if (this.groupingTable != null) {\n             HashMap<String, String> headers = new HashMap<>();\n             headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n-            FeedResponse<Document> frp = BridgeInternal.createFeedResponseWithQueryMetrics(groupByResults, headers, queryMetrics, null);\n+            FeedResponse<Document> frp = BridgeInternal.createFeedResponseWithQueryMetrics(\n+                groupByResults,\n+                headers,\n+                queryMetrics,\n+                null,\n+                false,", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NDk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562854977", "bodyText": "majority of Query components, top, orderby, etc need to use false, false param for ModelBridgeInternal.createFeedResponseWithQueryMetrics\nI think it might be easier to fork createFeedResponseWithQueryMetrics method into two new methods one for query and the other for changefeed.\ncustomization helps to reduce the number of params.", "author": "moderakh", "createdAt": "2021-01-22T19:20:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/ModelBridgeInternal.java", "diffHunk": "@@ -348,12 +351,21 @@ public static CosmosQueryRequestOptions partitionKeyRangeIdInternal(CosmosQueryR\n     }\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(List<T> results,\n-                                                                         Map<String,\n-                                                                         String> headers,\n-                                                                         ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n-                                                                         QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext) {\n-        FeedResponse<T> feedResponse = new FeedResponse<>(results, headers, queryMetricsMap);\n+    public static <T> FeedResponse<T> createFeedResponseWithQueryMetrics(\n+        List<T> results,\n+        Map<String,\n+        String> headers,\n+        ConcurrentMap<String, QueryMetrics> queryMetricsMap,\n+        QueryInfo.QueryPlanDiagnosticsContext diagnosticsContext,\n+        boolean useEtagAsContinuation,\n+        boolean isNoChanges) {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg1NjE4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562856186", "bodyText": "nit: codestyle { on the same line as if", "author": "moderakh", "createdAt": "2021-01-22T19:22:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -44,10 +50,37 @@ public PartitionProcessorFactoryImpl(\n             throw new IllegalArgumentException(\"collectionSelfLink\");\n         }\n \n+        if (collectionResourceId == null) {\n+            throw new IllegalArgumentException(\"collectionResourceId\");\n+        }\n+\n         this.documentClient = documentClient;\n         this.changeFeedProcessorOptions = changeFeedProcessorOptions;\n         this.leaseCheckpointer = leaseCheckpointer;\n         this.collectionSelfLink = collectionSelfLink;\n+        this.collectionResourceId = collectionResourceId;\n+    }\n+\n+    private static ChangeFeedStartFromInternal getStartFromSettings(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedProcessorOptions processorOptions) {\n+\n+        if (!Strings.isNullOrWhiteSpace(processorOptions.getStartContinuation()))\n+        {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg4OTA3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562889072", "bodyText": "diagnostics is null, please add a TODO to wire diagnostics later after this PR.", "author": "moderakh", "createdAt": "2021-01-22T20:27:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -471,14 +476,94 @@ public String getId() {\n \n                 return getDatabase().getDocClientWrapper()\n                              .queryDocuments(CosmosAsyncContainer.this.getLink(), sqlQuerySpec, cosmosQueryRequestOptions)\n-                             .map(response -> prepareFeedResponse(response, classType));\n+                             .map(response -> prepareFeedResponse(response, false, classType));\n         });\n \n         return pagedFluxOptionsFluxFunction;\n     }\n \n-    private <T> FeedResponse<T> prepareFeedResponse(FeedResponse<Document> response, Class<T> classType) {\n+    /**\n+     * Query for items in the change feed of the current container using the {@link CosmosChangeFeedRequestOptions}.\n+     * <p>\n+     * After subscription the operation will be performed. The {@link Flux} will\n+     * contain one or several feed response of the obtained items. In case of\n+     * failure the {@link CosmosPagedFlux} will error.\n+     *\n+     * @param <T> the type parameter.\n+     * @param options the change feed request options.\n+     * @param classType the class type.\n+     * @return a {@link CosmosPagedFlux} containing one or several feed response pages of the obtained\n+     * items or an error.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public <T> CosmosPagedFlux<T> queryChangeFeed(CosmosChangeFeedRequestOptions options, Class<T> classType) {\n+        checkNotNull(options, \"Argument 'options' must not be null.\");\n+        checkNotNull(classType, \"Argument 'classType' must not be null.\");\n+\n+        return queryChangeFeedInternal(options, classType);\n+    }\n+\n+    <T> CosmosPagedFlux<T> queryChangeFeedInternal(\n+        CosmosChangeFeedRequestOptions cosmosChangeFeedRequestOptions,\n+        Class<T> classType) {\n+\n+        return UtilBridgeInternal.createCosmosPagedFlux(\n+            queryChangeFeedInternalFunc(cosmosChangeFeedRequestOptions, classType));\n+    }\n+\n+    <T> Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> queryChangeFeedInternalFunc(\n+        CosmosChangeFeedRequestOptions cosmosChangeFeedRequestOptions,\n+        Class<T> classType) {\n+\n+        checkNotNull(\n+            cosmosChangeFeedRequestOptions,\n+            \"Argument 'cosmosChangeFeedRequestOptions' must not be null.\");\n+\n+        Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction = (pagedFluxOptions -> {\n+\n+            checkNotNull(\n+                pagedFluxOptions,\n+                \"Argument 'pagedFluxOptions' must not be null.\");\n+\n+            String spanName = this.queryChangeFeedSpanName;\n+            pagedFluxOptions.setTracerAndTelemetryInformation(spanName, database.getId(),\n+                this.getId(), OperationType.ReadFeed, ResourceType.Document, this.getDatabase().getClient());\n+            getEffectiveCosmosChangeFeedRequestOptions(pagedFluxOptions, cosmosChangeFeedRequestOptions);\n+\n+            final AsyncDocumentClient clientWrapper = this.database.getDocClientWrapper();\n+            return clientWrapper\n+                .getCollectionCache()\n+                .resolveByNameAsync(\n+                    null,", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkxNzI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562917293", "bodyText": "nit: java code style { on the same line as if", "author": "moderakh", "createdAt": "2021-01-22T21:20:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromPointInTimeImpl.java", "diffHunk": "@@ -0,0 +1,85 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n+\n+import java.time.Instant;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedStartFromPointInTimeImpl extends ChangeFeedStartFromInternal {\n+    private final Instant pointInTime;\n+\n+    public ChangeFeedStartFromPointInTimeImpl(Instant pointInTime) {\n+        super();\n+\n+        if (pointInTime == null) {\n+            throw new NullPointerException(\"pointInTime\");\n+        }\n+\n+        this.pointInTime = pointInTime;\n+    }\n+\n+    public Instant getPointInTime() {\n+        return this.pointInTime;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ChangeFeedStartFromPointInTimeImpl)) {\n+            return false;\n+        }\n+\n+        ChangeFeedStartFromPointInTimeImpl otherStartFrom = (ChangeFeedStartFromPointInTimeImpl)obj;\n+        return this.pointInTime.equals(otherStartFrom.pointInTime);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return this.pointInTime.hashCode();\n+    }\n+\n+    @Override\n+    public void populatePropertyBag() {\n+\n+        super.populatePropertyBag();\n+\n+        setProperty(\n+            this,\n+            com.azure.cosmos.implementation.Constants.Properties.CHANGE_FEED_START_FROM_TYPE,\n+            ChangeFeedStartFromTypes.POINT_IN_TIME);\n+\n+        setProperty(\n+            this,\n+            Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS,\n+            this.pointInTime.toEpochMilli());\n+    }\n+\n+    @Override\n+    public void populateRequest(RxDocumentServiceRequest request) {\n+        checkNotNull(request, \"Argument 'request' must not be null.\");\n+\n+        // Our current public contract for ChangeFeedProcessor uses DateTime.MinValue.ToUniversalTime as beginning.\n+        // We need to add a special case here, otherwise it would send it as normal StartTime.\n+        // The problem is Multi master accounts do not support StartTime header on ReadFeed, and thus,\n+        // it would break multi master Change Feed Processor users using Start From Beginning semantics.\n+        // It's also an optimization, since the backend won't have to binary search for the value.\n+        Instant pointInTime = this.getPointInTime();\n+        if (pointInTime != START_FROM_BEGINNING_TIME)\n+        {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkyNTYwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562925604", "bodyText": "great documentation for the cases. thanks.", "author": "moderakh", "createdAt": "2021-01-22T21:31:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,250 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder.v != null) {\n+                            final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                            for (final PartitionKeyRange pkRange : pkRanges) {\n+                                rangeList.add(pkRange.getId());\n+                            }\n+                        }\n+\n+                        return Mono.just(UnmodifiableList.unmodifiableList(rangeList));\n+                    });\n             });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.range.toString();\n-    }\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n \n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        FeedRangeEpkImpl that = (FeedRangeEpkImpl) o;\n-        return Objects.equals(this.range, that.range);\n+                final String containerRid = collection.getResourceId();\n+                request.setEffectiveRange(this.range);\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        if (pkRangeHolder == null) {\n+                            return Mono.error(new NotFoundException(\n+                                String.format(\"Stale cache for collection rid '%s'.\",\n+                                    containerRid)));\n+                        }\n+\n+                        final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                        if (pkRanges == null || pkRanges.size() == 0) {\n+                            return Mono.error(new NotFoundException(\n+                                String.format(\"Stale cache for collection rid '%s'.\",\n+                                    containerRid)));\n+                        }\n+\n+                        // For epk range filtering we can end up in one of 3 cases:", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkyOTUxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562929517", "bodyText": "as we are changing this class. please do a perf test on query to ensure we don't have query perf regression.", "author": "moderakh", "createdAt": "2021-01-22T21:40:09Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Fetcher.java", "diffHunk": "@@ -3,42 +3,39 @@\n \n package com.azure.cosmos.implementation.query;\n \n-import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.models.FeedResponse;\n import com.azure.cosmos.implementation.Resource;\n import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n-import com.azure.cosmos.implementation.apachecommons.lang.StringUtils;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import reactor.core.publisher.Mono;\n \n-import java.util.function.BiFunction;\n import java.util.function.Function;\n \n-class Fetcher<T extends Resource> {\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+abstract class Fetcher<T extends Resource> {\n     private final static Logger logger = LoggerFactory.getLogger(Fetcher.class);\n \n-    private final BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc;\n     private final Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc;\n     private final boolean isChangeFeed;\n \n     private volatile boolean shouldFetchMore;\n     private volatile int maxItemCount;\n     private volatile int top;\n-    private volatile String continuationToken;\n \n-    public Fetcher(BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-                   Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n-                   String continuationToken,\n-                   boolean isChangeFeed,\n-                   int top,\n-                   int maxItemCount) {\n+    public Fetcher(", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMjYxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562932611", "bodyText": "is this a change? what was the previous value prior to this PR?\nas reactive-stream default is Queues.XS_BUFFER_SIZE does that mean prior to this PR we were implicitly using Queues.XS_BUFFER_SIZE as the default prefetch?", "author": "moderakh", "createdAt": "2021-01-22T21:47:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Paginator.java", "diffHunk": "@@ -48,33 +45,84 @@\n     public static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n             String continuationToken,\n             BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize) {\n-        return getPaginatedQueryResultAsObservable(continuationToken, createRequestFunc, executeFunc, resourceType,\n-                top, maxPageSize, false);\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            continuationToken,\n+            createRequestFunc,\n+            executeFunc,\n+            resourceType,\n+            top,\n+            maxPageSize,\n+            false);\n+    }\n+\n+    public static <T extends Resource> Flux<FeedResponse<T>> getChangeFeedQueryResultAsObservable(\n+        RxDocumentClientImpl client,\n+        ChangeFeedState changeFeedState,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        Class<T> resourceType,\n+        int top,\n+        int maxPageSize,\n+        int preFetchCount) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ChangeFeedFetcher<>(\n+                client,\n+                createRequestFunc,\n+                executeFunc,\n+                changeFeedState,\n+                top,\n+                maxPageSize),\n+            preFetchCount);\n     }\n \n     private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n-            String continuationToken,\n-            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize, boolean isChangeFeed) {\n+        Supplier<Fetcher<T>> fetcherFactory,\n+        int preFetchCount) {\n \n         return Flux.defer(() -> {\n-            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(() ->\n-                    new Fetcher<>(createRequestFunc, executeFunc, continuationToken, isChangeFeed, top, maxPageSize),\n-                    (tFetcher, sink) -> {\n-                        if (tFetcher.shouldFetchMore()) {\n-                            Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n-                            sink.next(nextPage.flux());\n-                        } else {\n-                            logger.debug(\"No more results\");\n-                            sink.complete();\n-                        }\n-                        return tFetcher;\n-            });\n+            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(\n+                fetcherFactory::get,\n+                (tFetcher, sink) -> {\n+                    if (tFetcher.shouldFetchMore()) {\n+                        Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n+                        sink.next(nextPage.flux());\n+                    } else {\n+                        logger.debug(\"No more results\");\n+                        sink.complete();\n+                    }\n+                    return tFetcher;\n+                });\n \n-            return generate.flatMapSequential(feedResponseFlux -> feedResponseFlux, 1);\n+            return generate.flatMapSequential(\n+                feedResponseFlux -> feedResponseFlux,\n+                1,\n+                preFetchCount);\n         });\n     }\n+\n+    private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n+            String continuationToken,\n+            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize,\n+            boolean isChangeFeed) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ServerSideOnlyContinuationFetcherImpl<>(\n+                createRequestFunc,\n+                executeFunc,\n+                continuationToken,\n+                isChangeFeed,\n+                top,\n+                maxPageSize),\n+                Queues.XS_BUFFER_SIZE);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMzg0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562933846", "bodyText": "we have guards in BackPressureCrossPartitionTest for query  to ensure not more than certain number of pages will be pre-fetched.\nPlease add similar tests for change feed query there.", "author": "moderakh", "createdAt": "2021-01-22T21:50:05Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/Paginator.java", "diffHunk": "@@ -48,33 +45,84 @@\n     public static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n             String continuationToken,\n             BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize) {\n-        return getPaginatedQueryResultAsObservable(continuationToken, createRequestFunc, executeFunc, resourceType,\n-                top, maxPageSize, false);\n+            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+            Class<T> resourceType,\n+            int top,\n+            int maxPageSize) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            continuationToken,\n+            createRequestFunc,\n+            executeFunc,\n+            resourceType,\n+            top,\n+            maxPageSize,\n+            false);\n+    }\n+\n+    public static <T extends Resource> Flux<FeedResponse<T>> getChangeFeedQueryResultAsObservable(\n+        RxDocumentClientImpl client,\n+        ChangeFeedState changeFeedState,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        Class<T> resourceType,\n+        int top,\n+        int maxPageSize,\n+        int preFetchCount) {\n+\n+        return getPaginatedQueryResultAsObservable(\n+            () -> new ChangeFeedFetcher<>(\n+                client,\n+                createRequestFunc,\n+                executeFunc,\n+                changeFeedState,\n+                top,\n+                maxPageSize),\n+            preFetchCount);\n     }\n \n     private static <T extends Resource> Flux<FeedResponse<T>> getPaginatedQueryResultAsObservable(\n-            String continuationToken,\n-            BiFunction<String, Integer, RxDocumentServiceRequest> createRequestFunc,\n-            Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc, Class<T> resourceType,\n-            int top, int maxPageSize, boolean isChangeFeed) {\n+        Supplier<Fetcher<T>> fetcherFactory,\n+        int preFetchCount) {\n \n         return Flux.defer(() -> {\n-            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(() ->\n-                    new Fetcher<>(createRequestFunc, executeFunc, continuationToken, isChangeFeed, top, maxPageSize),\n-                    (tFetcher, sink) -> {\n-                        if (tFetcher.shouldFetchMore()) {\n-                            Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n-                            sink.next(nextPage.flux());\n-                        } else {\n-                            logger.debug(\"No more results\");\n-                            sink.complete();\n-                        }\n-                        return tFetcher;\n-            });\n+            Flux<Flux<FeedResponse<T>>> generate = Flux.generate(\n+                fetcherFactory::get,\n+                (tFetcher, sink) -> {\n+                    if (tFetcher.shouldFetchMore()) {\n+                        Mono<FeedResponse<T>> nextPage = tFetcher.nextPage();\n+                        sink.next(nextPage.flux());\n+                    } else {\n+                        logger.debug(\"No more results\");\n+                        sink.complete();\n+                    }\n+                    return tFetcher;\n+                });\n \n-            return generate.flatMapSequential(feedResponseFlux -> feedResponseFlux, 1);\n+            return generate.flatMapSequential(\n+                feedResponseFlux -> feedResponseFlux,\n+                1,\n+                preFetchCount);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MDUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562980538", "bodyText": "As discussed - will look into this in subsequent PR", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzMzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNDU2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562934560", "bodyText": "nit: java code style.", "author": "moderakh", "createdAt": "2021-01-22T21:51:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ChangeFeedFetcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.query;\n+\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ObservableHelper;\n+import com.azure.cosmos.implementation.Resource;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedFetcher<T extends Resource> extends Fetcher<T> {\n+    private final ChangeFeedState changeFeedState;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n+    private final IRetryPolicy feedRangeContinuationSplitRetryPolicy;\n+\n+    public ChangeFeedFetcher(\n+        RxDocumentClientImpl client,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        ChangeFeedState changeFeedState,\n+        int top,\n+        int maxItemCount) {\n+\n+        super(executeFunc, true, top, maxItemCount);\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(createRequestFunc, \"Argument 'createRequestFunc' must not be null.\");\n+        checkNotNull(changeFeedState, \"Argument 'changeFeedState' must not be null.\");\n+        this.createRequestFunc = createRequestFunc;\n+        this.changeFeedState = changeFeedState;\n+        this.feedRangeContinuationSplitRetryPolicy = new FeedRangeContinuationSplitRetryPolicy(\n+            client,\n+            this.changeFeedState);\n+    }\n+\n+    @Override\n+    public Mono<FeedResponse<T>> nextPage() {\n+        // There are two conditions that require retries\n+        // in the change feed pipeline\n+        // 1) On 410 the FeedRangeContinuation needs to evaluate\n+        //    whether continuations need to be split (in the case that any continuation\n+        //    exists that would span more than one physical partition now\n+        // 2) On 304 a retry is needed if at least one continuation has not been drained yet.\n+        //    This prevents returning a 304 before we received a 304 for all continuations\n+        //\n+        // 410 handling: this is triggered by an exception - using an\n+        //               IRetryPolicy (FeedRangeContinuationSplitRetryPolicy)\n+        // 304 handling: this is not triggered by an exception (304 doesn't result in throwing)\n+        //               so using Reactor's built-in option of repeating the chain on an empty result\n+        //               so nextPageInternal below has the logic to return empty result\n+        //               if not all continuations have been drained yet.\n+        return ObservableHelper.inlineIfPossible(\n+            this::nextPageInternal,\n+            this.feedRangeContinuationSplitRetryPolicy);\n+    }\n+\n+    private Mono<FeedResponse<T>> nextPageInternal() {\n+        return Mono.fromSupplier(this::nextPageCore)\n+                   .flatMap(Function.identity())\n+                   .flatMap((r) -> {\n+                       FeedRangeContinuation continuationSnapshot =\n+                           this.changeFeedState.getContinuation();\n+\n+                       if (continuationSnapshot != null &&\n+                           continuationSnapshot.handleChangeFeedNotModified(r) == ShouldRetryResult.RETRY_NOW) {\n+\n+                           // not all continuations have been drained yet\n+                           // repeat with the next continuation\n+                           this.reenableShouldFetchMoreForRetry();\n+                           return Mono.empty();\n+                       }\n+\n+                       return Mono.just(r);\n+                   })\n+                   .repeatWhenEmpty(o -> o);\n+    }\n+\n+    @Override\n+    protected String applyServerResponseContinuation(\n+        String serverContinuationToken,\n+        RxDocumentServiceRequest request) {\n+\n+        return this.changeFeedState.applyServerResponseContinuation(\n+            serverContinuationToken, request);\n+    }\n+\n+    @Override\n+    protected boolean isFullyDrained(boolean isChangeFeed, FeedResponse<T> response) {\n+        if (ModelBridgeInternal.noChanges(response)) {\n+            return true;\n+        }\n+\n+        FeedRangeContinuation continuation = this.changeFeedState.getContinuation();\n+        return continuation != null && continuation.isDone();\n+    }\n+\n+    @Override\n+    protected String getContinuationForLogging() {\n+        return this.changeFeedState.toJson();\n+    }\n+\n+    @Override\n+    protected RxDocumentServiceRequest createRequest(int maxItemCount) {\n+        RxDocumentServiceRequest request = this.createRequestFunc.get();\n+        this.changeFeedState.populateRequest(request, maxItemCount);\n+        return request;\n+    }\n+\n+    private static final class FeedRangeContinuationSplitRetryPolicy extends RetryPolicyWithDiagnostics {\n+        private final ChangeFeedState state;\n+        private final RxDocumentClientImpl client;\n+\n+        public FeedRangeContinuationSplitRetryPolicy(\n+            RxDocumentClientImpl client,\n+            ChangeFeedState state) {\n+\n+            this.client = client;\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public Mono<ShouldRetryResult> shouldRetry(Exception e) {\n+            if (!(e instanceof GoneException)) {\n+                return Mono.just(ShouldRetryResult.noRetry());\n+            }\n+\n+            if (this.state.getContinuation() == null)\n+            {", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MDQwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562980409", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:08:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNTM5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562935390", "bodyText": "is there any guarantee that repeatWhenEmpty() will not result in infinite loop/retry?", "author": "moderakh", "createdAt": "2021-01-22T21:53:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ChangeFeedFetcher.java", "diffHunk": "@@ -0,0 +1,169 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.query;\n+\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.IRetryPolicy;\n+import com.azure.cosmos.implementation.ObservableHelper;\n+import com.azure.cosmos.implementation.Resource;\n+import com.azure.cosmos.implementation.RetryPolicyWithDiagnostics;\n+import com.azure.cosmos.implementation.RxDocumentClientImpl;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.ShouldRetryResult;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.routing.Range;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedFetcher<T extends Resource> extends Fetcher<T> {\n+    private final ChangeFeedState changeFeedState;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n+    private final IRetryPolicy feedRangeContinuationSplitRetryPolicy;\n+\n+    public ChangeFeedFetcher(\n+        RxDocumentClientImpl client,\n+        Supplier<RxDocumentServiceRequest> createRequestFunc,\n+        Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc,\n+        ChangeFeedState changeFeedState,\n+        int top,\n+        int maxItemCount) {\n+\n+        super(executeFunc, true, top, maxItemCount);\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(createRequestFunc, \"Argument 'createRequestFunc' must not be null.\");\n+        checkNotNull(changeFeedState, \"Argument 'changeFeedState' must not be null.\");\n+        this.createRequestFunc = createRequestFunc;\n+        this.changeFeedState = changeFeedState;\n+        this.feedRangeContinuationSplitRetryPolicy = new FeedRangeContinuationSplitRetryPolicy(\n+            client,\n+            this.changeFeedState);\n+    }\n+\n+    @Override\n+    public Mono<FeedResponse<T>> nextPage() {\n+        // There are two conditions that require retries\n+        // in the change feed pipeline\n+        // 1) On 410 the FeedRangeContinuation needs to evaluate\n+        //    whether continuations need to be split (in the case that any continuation\n+        //    exists that would span more than one physical partition now\n+        // 2) On 304 a retry is needed if at least one continuation has not been drained yet.\n+        //    This prevents returning a 304 before we received a 304 for all continuations\n+        //\n+        // 410 handling: this is triggered by an exception - using an\n+        //               IRetryPolicy (FeedRangeContinuationSplitRetryPolicy)\n+        // 304 handling: this is not triggered by an exception (304 doesn't result in throwing)\n+        //               so using Reactor's built-in option of repeating the chain on an empty result\n+        //               so nextPageInternal below has the logic to return empty result\n+        //               if not all continuations have been drained yet.\n+        return ObservableHelper.inlineIfPossible(\n+            this::nextPageInternal,\n+            this.feedRangeContinuationSplitRetryPolicy);\n+    }\n+\n+    private Mono<FeedResponse<T>> nextPageInternal() {\n+        return Mono.fromSupplier(this::nextPageCore)\n+                   .flatMap(Function.identity())\n+                   .flatMap((r) -> {\n+                       FeedRangeContinuation continuationSnapshot =\n+                           this.changeFeedState.getContinuation();\n+\n+                       if (continuationSnapshot != null &&\n+                           continuationSnapshot.handleChangeFeedNotModified(r) == ShouldRetryResult.RETRY_NOW) {\n+\n+                           // not all continuations have been drained yet\n+                           // repeat with the next continuation\n+                           this.reenableShouldFetchMoreForRetry();\n+                           return Mono.empty();\n+                       }\n+\n+                       return Mono.just(r);\n+                   })\n+                   .repeatWhenEmpty(o -> o);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MzQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562983438", "bodyText": "Good point - it is a very subtle contract - basically because handleChangeFeedNotModified is guaranteed to not always return Retry_Now because it moves ahead the continuation token. Let me think about a way to cover this better in unit tests - or how to change the contract to be more explicit - will address this in subsequent PR", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNTM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNjc1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562936750", "bodyText": "why do we need both of feedRange and effectiveRange? why can't we just rely on feedRange?", "author": "moderakh", "createdAt": "2021-01-22T21:56:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentServiceRequest.java", "diffHunk": "@@ -54,6 +56,9 @@\n     // has the non serialized value of the partition-key\n     private PartitionKeyInternal partitionKeyInternal;\n \n+    private FeedRangeInternal feedRange;\n+    private Range<String> effectiveRange;", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MDk2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562980961", "bodyText": "FeedRange can't always provide you the effectiveRange \"synchronously\" - to be bale to resolve it the CollectionCache and PKRangeCache are needed. SO added both here to allow transferring the state to the right step in the pipeline where AysncDocumentClient with the caches is available", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzNjc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzODE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562938197", "bodyText": "was this unused (dead code)?", "author": "moderakh", "createdAt": "2021-01-22T22:00:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1942,10 +1963,6 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n \n                             });\n \n-                        Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n-                        List<PartitionKeyRange> ranges = new ArrayList<>();\n-                        ranges.addAll(partitionKeyRanges);", "originalCommit": "fd76cb3ec49c46da56ab1825e1c5491a1027ecf7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjk4MjE4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r562982183", "bodyText": "Correct - the partitionKeyRanges was/is never used", "author": "FabianMeiswinkel", "createdAt": "2021-01-23T00:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjkzODE5Nw=="}], "type": "inlineReview"}, {"oid": "1f9ef37d87f5f555cc2c03f3df5cdf91e46a6575", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9ef37d87f5f555cc2c03f3df5cdf91e46a6575", "message": "Fixing ChangeFeedProcessor issues Matias found\n\n- Continuation persisted in leases was stored as Base64-encoded josn of ChangeFeedState (vs. just LSN)\n- Split handling was broken because the Change feed pull model is split-proof and doesn't surface GoneException which Change Feed processor relies on for splitting leases.", "committedDate": "2021-01-22T23:51:41Z", "type": "commit"}, {"oid": "3724f5f9e6db2e6306b85487781612cb8282a8df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3724f5f9e6db2e6306b85487781612cb8282a8df", "message": "Addressing code review comments from Mo", "committedDate": "2021-01-23T00:28:14Z", "type": "commit"}, {"oid": "7fc3b5e6383792989690f9d3472e941cfb3429ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc3b5e6383792989690f9d3472e941cfb3429ae", "message": "Fixing SpotBUg issue", "committedDate": "2021-01-23T00:49:38Z", "type": "commit"}, {"oid": "9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-23T01:03:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzIxNzQ3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563217478", "bodyText": "Good catch! Also can you please add the following check at line 604 (after stopping the changeFeedProcessor:\nint leaseCount = changeFeedProcessor.getCurrentState() .map(List::size).block(); assertThat(leaseCount > 1).as(\"Found %d leases\", leaseCount).isTrue();", "author": "milismsft", "createdAt": "2021-01-24T00:29:03Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ChangeFeedProcessorTest.java", "diffHunk": "@@ -508,7 +508,7 @@ public void staledLeaseAcquiring() throws InterruptedException {\n \n     @Test(groups = { \"simple\" }, timeOut = 50 * CHANGE_FEED_PROCESSOR_TIMEOUT)\n     public void readFeedDocumentsAfterSplit() throws InterruptedException {\n-        CosmosAsyncContainer createdFeedCollectionForSplit = createLeaseCollection(FEED_COLLECTION_THROUGHPUT_FOR_SPLIT);\n+        CosmosAsyncContainer createdFeedCollectionForSplit = createFeedCollection(FEED_COLLECTION_THROUGHPUT_FOR_SPLIT);", "originalCommit": "9d55b4c5e45e0cc34108d1f579dc5a8ec8f388c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzYwNTcyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563605726", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T10:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzIxNzQ3OA=="}], "type": "inlineReview"}, {"oid": "e9f114cb0a73540c30b6da72ae12302e8c51f0fc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9f114cb0a73540c30b6da72ae12302e8c51f0fc", "message": "Adding additional assert in CFP split test", "committedDate": "2021-01-25T10:16:14Z", "type": "commit"}, {"oid": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-25T10:16:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MjI2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563972269", "bodyText": "This class corresponds to starting from either \"null\" or a given continuation state (aka ChangeFeedState), right?  It would be useful to add a short description to all these ChangeFeedStart* classes which captures the specific cases they will be used.", "author": "milismsft", "createdAt": "2021-01-25T19:05:02Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromETagAndFeedRangeImpl.java", "diffHunk": "@@ -0,0 +1,99 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+\n+import static com.azure.cosmos.BridgeInternal.setProperty;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+class ChangeFeedStartFromETagAndFeedRangeImpl extends ChangeFeedStartFromInternal {", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAzOTUyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564039520", "bodyText": "This one is used to continue changefeed query when you just have server continuation and it is for a single range (like with the Lease document in ChangeFeedProcessor) Added a comment along those lines (next iteration) - the remaining StartFrom settings have self-explanatory names.", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3MjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3ODAwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563978007", "bodyText": "Is getting the object mapper instance affected by other external settings/configs which could impact how we serialize/de-serialize the values? If true, we might need to pass our own configuration settings such that the Base64 encoded Json string is not impacted by such external changes.", "author": "milismsft", "createdAt": "2021-01-25T19:14:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedState.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@JsonDeserialize(using = ChangeFeedStateDeserializer.class)\n+public abstract class ChangeFeedState extends JsonSerializable {\n+    ChangeFeedState() {\n+    }\n+\n+    public abstract FeedRangeContinuation getContinuation();\n+\n+    public abstract ChangeFeedState setContinuation(FeedRangeContinuation continuation);\n+\n+    public abstract FeedRangeInternal getFeedRange();\n+\n+    public abstract ChangeFeedMode getMode();\n+\n+    public abstract ChangeFeedStartFromInternal getStartFromSettings();\n+\n+    public abstract String applyServerResponseContinuation(\n+        String serverContinuationToken,\n+        RxDocumentServiceRequest request);\n+\n+    public abstract String getContainerRid();\n+\n+    public static ChangeFeedState fromString(String base64EncodedJson) {\n+        checkNotNull(base64EncodedJson, \"Argument 'base64EncodedJson' must not be null\");\n+\n+        String json = new String(\n+            Base64.getUrlDecoder().decode(base64EncodedJson),\n+            StandardCharsets.UTF_8);\n+\n+        final ObjectMapper mapper = Utils.getSimpleObjectMapper();", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA0MjM1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564042354", "bodyText": "The Utils.getSimpleObjectMapper is used for the purpose of serializing other models - like PartitionKeyInternal, Offers etc. as well - so it wouldn't be possible to change the config without breaking many similar use cases. And no - the config is not passed down form the user etc. - completely implementation detail within Utils.java", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:05:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk3ODAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MjQzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563982435", "bodyText": "ChangeFeedStateV1 will always expect the ChangeFeedMode to be \"INCREMENTAL\". Rather than creating the FeedRangePartitionKeyRange here, we can make it as part of the ChangeFeedStateV1 constructor and instead pass the getStartFromSettings() as the parameter for the constructor of ChangeFeedStateV1.", "author": "milismsft", "createdAt": "2021-01-25T19:21:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorFactoryImpl.java", "diffHunk": "@@ -60,20 +93,24 @@ public PartitionProcessor create(Lease lease, ChangeFeedObserver observer) {\n             throw new IllegalArgumentException(\"lease\");\n         }\n \n-        String startContinuation = lease.getContinuationToken();\n-\n-        if (startContinuation == null || startContinuation.isEmpty()) {\n-            startContinuation = this.changeFeedProcessorOptions.getStartContinuation();\n+        FeedRangeInternal feedRange = new FeedRangePartitionKeyRangeImpl(lease.getLeaseToken());\n+        ChangeFeedState state;\n+        if (Strings.isNullOrWhiteSpace(lease.getContinuationToken())) {\n+            state = new ChangeFeedStateV1(", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA0NDQ1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564044459", "bodyText": "No - because ChangeFeedStateV1 is used across CFP and Pull model - it is the representation of teh Changefeed query pull continuation. In CFP we map it to the existing Lease format - which has some additional constraints (like always being INCREMENTAL, currently always having a PKRangeId FeedRaneg etc.) - but the ChangeFeedStateV1 is a superset - and even for the CFP we will need to change the Lease contract to allow more flexible feed ranges when enabling merge support.", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4MjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4NTIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563985214", "bodyText": "private CosmosChangeFeedRequestOptions options;\n->\nprivate volatile CosmosChangeFeedRequestOptions options;", "author": "milismsft", "createdAt": "2021-01-25T19:26:01Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -37,36 +41,31 @@\n     private final ProcessorSettings settings;\n     private final PartitionCheckpointer checkpointer;\n     private final ChangeFeedObserver observer;\n-    private final ChangeFeedOptions options;\n+    private CosmosChangeFeedRequestOptions options;", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA0NDk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564044941", "bodyText": "Fixed (next iteration)", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4NTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4OTQ0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r563989441", "bodyText": "there's some significant de-ref'ing here; might be worth to move this in a \"try/catch\" and add specific trace logging in case we fail then through the exception.", "author": "milismsft", "createdAt": "2021-01-25T19:32:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionProcessorImpl.java", "diffHunk": "@@ -207,8 +232,16 @@ public RuntimeException getResultException() {\n         return this.resultException;\n     }\n \n-    private Mono<Void> dispatchChanges(FeedResponse<JsonNode> response) {\n-        ChangeFeedObserverContext context = new ChangeFeedObserverContextImpl(this.settings.getPartitionKeyRangeId(), response, this.checkpointer);\n+    private Mono<Void> dispatchChanges(\n+        FeedResponse<JsonNode> response,\n+        ChangeFeedState continuationState) {\n+\n+        ChangeFeedObserverContext context = new ChangeFeedObserverContextImpl(\n+            // TODO fabianm - move observer to FeedRange for merge support\n+            ((FeedRangePartitionKeyRangeImpl)this.settings.getStartState().getFeedRange()).getPartitionKeyRangeId(),", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA1NTgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564055834", "bodyText": "Fixed (next iteration)", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzk4OTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxNjExOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564016118", "bodyText": "Having these settings on the public facing \"models\" class become binding to the API and hard to change after. IMHO 1000 is a bit high, I will recommend starting with 100 instead.", "author": "milismsft", "createdAt": "2021-01-25T20:18:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA0OTY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564049679", "bodyText": "Changed it to 100 - but where I define the default doesn't matter - any change to the default value is a behavior change that would be considered breaking. I'll changed it to 100 (the default in .Net implicitly and the server-side REST api as well)", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxNjExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA0OTc4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564049789", "bodyText": "Fixed (next iteration)", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxNjExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxODY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564018644", "bodyText": "My understanding is that the \"models\" classes should only capture properties, any helper functions even if \"static\" will go in a separate helper class, outside \"models\" package...", "author": "milismsft", "createdAt": "2021-01-25T20:23:03Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final int DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private int maxItemCount;\n+    private int maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private boolean isSplitHandlingDisabled;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+        this.isSplitHandlingDisabled = false;\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(int maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(int maxPrefetchPageCount) {\n+        checkArgument(\n+            maxPrefetchPageCount > 0,\n+            \"Argument 'maxPrefetchCount' must be larger than 0.\");\n+        this.maxPrefetchPageCount = maxPrefetchPageCount;\n+\n+        return this;\n+    }\n+\n+    boolean isSplitHandlingDisabled() {\n+        return this.isSplitHandlingDisabled;\n+    }\n+\n+    CosmosChangeFeedRequestOptions disableSplitHandling() {\n+        this.isSplitHandlingDisabled = true;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Gets the properties\n+     *\n+     * @return Map of request options properties\n+     */\n+    Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    ChangeFeedStartFromInternal getStartFromSettings() {\n+        return this.startFromInternal;\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the beginning of the change feed\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromBeginning(FeedRange feedRange) {\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a previous continuation\n+     *\n+     * @param continuation The continuation that was retrieved from a previously retrieved\n+     *                     FeedResponse\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA1MTI2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564051260", "bodyText": "As discussed in the Java-sync-up - not considered a hard requirement - and as long as these are factory methods not seen as a problem", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxODY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxOTIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564019211", "bodyText": "withFullFidelity -> fullFidelity", "author": "milismsft", "createdAt": "2021-01-25T20:24:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,386 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.CosmosPagedFluxOptions;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkArgument;\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+    Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final int DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private static final int DEFAULT_MAX_PREFETCH_PAGE_COUNT = 1;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private int maxItemCount;\n+    private int maxPrefetchPageCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private boolean isSplitHandlingDisabled;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.maxPrefetchPageCount = DEFAULT_MAX_PREFETCH_PAGE_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+        this.isSplitHandlingDisabled = false;\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(int maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public int getMaxPrefetchPageCount() {\n+        return this.maxPrefetchPageCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of pages that will be prefetched from the backend asynchronously\n+     * in the background. By pre-fetching these changes the throughput of processing the\n+     * change feed records can be increased because the processing doesn't have to stop while\n+     * waiting for the IO operations to retrieve a new page form the backend to complete. The\n+     * only scenario where it can be useful to disable prefetching pages (with\n+     * setMaxPrefetchPageCount(0))\n+     * would be when the caller only plans to retrieve just one page - so any prefetched pages\n+     * would not be used anyway.\n+     *\n+     * @param maxPrefetchPageCount the max number of pages that will be prefetched from the backend\n+     *                             asynchronously in the background\n+     * @return the modified change feed request options.\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions setMaxPrefetchPageCount(int maxPrefetchPageCount) {\n+        checkArgument(\n+            maxPrefetchPageCount > 0,\n+            \"Argument 'maxPrefetchCount' must be larger than 0.\");\n+        this.maxPrefetchPageCount = maxPrefetchPageCount;\n+\n+        return this;\n+    }\n+\n+    boolean isSplitHandlingDisabled() {\n+        return this.isSplitHandlingDisabled;\n+    }\n+\n+    CosmosChangeFeedRequestOptions disableSplitHandling() {\n+        this.isSplitHandlingDisabled = true;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {\n+        return this.mode;\n+    }\n+\n+    /**\n+     * Gets the properties\n+     *\n+     * @return Map of request options properties\n+     */\n+    Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    ChangeFeedStartFromInternal getStartFromSettings() {\n+        return this.startFromInternal;\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the beginning of the change feed\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromBeginning(FeedRange feedRange) {\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a previous continuation\n+     *\n+     * @param continuation The continuation that was retrieved from a previously retrieved\n+     *                     FeedResponse\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(\n+        String continuation) {\n+\n+        final ChangeFeedState changeFeedState = ChangeFeedState.fromString(continuation);\n+\n+        return createForProcessingFromContinuation(changeFeedState);\n+    }\n+\n+    static CosmosChangeFeedRequestOptions createForProcessingFromContinuation(\n+        ChangeFeedState changeFeedState) {\n+\n+        FeedRangeInternal feedRange = changeFeedState.getFeedRange();\n+        FeedRangeContinuation continuation = changeFeedState.getContinuation();\n+        ChangeFeedMode mode = changeFeedState.getMode();\n+\n+        if (continuation != null) {\n+            CompositeContinuationToken continuationToken =\n+                continuation.getCurrentContinuationToken();\n+            if (continuationToken != null) {\n+                String etag = continuationToken.getToken();\n+                return new CosmosChangeFeedRequestOptions(\n+                    feedRange,\n+                    ChangeFeedStartFromInternal.createFromETagAndFeedRange(etag, feedRange),\n+                    mode,\n+                    changeFeedState);\n+            }\n+\n+            return new CosmosChangeFeedRequestOptions(\n+                feedRange,\n+                ChangeFeedStartFromInternal.createFromBeginning(),\n+                mode,\n+                changeFeedState);\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            feedRange,\n+            changeFeedState.getStartFromSettings(),\n+            mode,\n+            changeFeedState);\n+    }\n+\n+    static CosmosChangeFeedRequestOptions createForProcessingFromEtagAndFeedRange(\n+        String etag,\n+        FeedRange feedRange) {\n+\n+        if (etag != null) {\n+            return new CosmosChangeFeedRequestOptions(\n+                FeedRangeInternal.convert(feedRange),\n+                ChangeFeedStartFromInternal.createFromETagAndFeedRange(etag,\n+                    FeedRangeInternal.convert(feedRange)),\n+                ChangeFeedMode.INCREMENTAL,\n+                null);\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromBeginning(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from the current time - so only events for all future changes will be\n+     * retrieved\n+     *\n+     * @param feedRange The {@link FeedRange} that is used to define the scope (entire container,\n+     *                  logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromNow(FeedRange feedRange) {\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromNow(),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    /**\n+     * Creates a new {@link CosmosChangeFeedRequestOptions} instance to start processing\n+     * change feed items from a certain point in time\n+     *\n+     * @param pointInTime The point in time from which processing of change feed events should start\n+     * @param feedRange   The {@link FeedRange} that is used to define the scope (entire container,\n+     *                    logical partition or subset of a container)\n+     * @return a new {@link CosmosChangeFeedRequestOptions} instance\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public static CosmosChangeFeedRequestOptions createForProcessingFromPointInTime(\n+        Instant pointInTime,\n+        FeedRange feedRange) {\n+\n+        if (pointInTime == null) {\n+            throw new NullPointerException(\"pointInTime\");\n+        }\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        return new CosmosChangeFeedRequestOptions(\n+            FeedRangeInternal.convert(feedRange),\n+            ChangeFeedStartFromInternal.createFromPointInTime(pointInTime),\n+            ChangeFeedMode.INCREMENTAL,\n+            null);\n+    }\n+\n+    void setRequestContinuation(String etag) {\n+        this.startFromInternal = ChangeFeedStartFromInternal.createFromETagAndFeedRange(\n+            etag,\n+            this.feedRangeInternal);\n+    }\n+\n+    CosmosChangeFeedRequestOptions withCosmosPagedFluxOptions(\n+        CosmosPagedFluxOptions pagedFluxOptions) {\n+\n+        if (pagedFluxOptions == null) {\n+            return this;\n+        }\n+\n+        CosmosChangeFeedRequestOptions effectiveRequestOptions = this;\n+\n+        if (pagedFluxOptions.getRequestContinuation() != null) {\n+            effectiveRequestOptions =\n+                CosmosChangeFeedRequestOptions.createForProcessingFromContinuation(\n+                    pagedFluxOptions.getRequestContinuation());\n+            effectiveRequestOptions.setMaxPrefetchPageCount(this.getMaxPrefetchPageCount());\n+        }\n+\n+        if (pagedFluxOptions.getMaxItemCount() != null) {\n+            effectiveRequestOptions.setMaxItemCount(pagedFluxOptions.getMaxItemCount());\n+        }\n+\n+        return effectiveRequestOptions;\n+    }\n+\n+    /**\n+     * Changes the change feed mode so that the change feed will contain events for creations,\n+     * deletes as well as all intermediary snapshots for updates. Enabling full fidelity change feed\n+     * mode requires configuring a retention duration in the change feed policy of the\n+     * container. {@link ChangeFeedPolicy}\n+     * <p>\n+     * Intermediary snapshots of changes as well as deleted documents would be\n+     * available for processing for 8 minutes before they vanish.\n+     * When enabling full fidelity mode you will only be able to process change feed events\n+     * within the retention window configured in the change feed policy of the container.\n+     * If you attempt to process a change feed after more than the retention window\n+     * an error (Status Code 400) will be returned because the events for intermediary\n+     * updates and deletes have vanished.\n+     * It would still be possible to process changes using Incremental mode even when\n+     * configuring a full fidelity change feed policy with retention window on the container\n+     * and when using Incremental mode it doesn't matter whether your are out of the retention\n+     * window or not - but no events for deletes or intermediary updates would be included.\n+     * When events are not getting processed within the retention window it is also possible\n+     * to continue processing future events in full fidelity mode by querying the change feed\n+     * with a new CosmosChangeFeedRequestOptions instance.\n+     * </p>\n+     *\n+     * @return a {@link CosmosChangeFeedRequestOptions} instance with full fidelity mode enabled\n+     */\n+    @Beta(value = Beta.SinceVersion.WHATEVER_NEW_VERSION, warningText =\n+        Beta.PREVIEW_SUBJECT_TO_CHANGE_WARNING)\n+    public CosmosChangeFeedRequestOptions withFullFidelity() {", "originalCommit": "f2d6dc82c09808861d71a51bf91dcf5aa6339f52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAyMTk4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564021987", "bodyText": "or is it setFullFidelity :-)", "author": "milismsft", "createdAt": "2021-01-25T20:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxOTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDA1MDcyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r564050723", "bodyText": "Fixed (next iteration)", "author": "FabianMeiswinkel", "createdAt": "2021-01-25T21:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxOTIxMQ=="}], "type": "inlineReview"}, {"oid": "37900c7c0a7bedcbec521bada2ae6978e81a9c15", "url": "https://github.com/Azure/azure-sdk-for-java/commit/37900c7c0a7bedcbec521bada2ae6978e81a9c15", "message": "Addressing code review comments from Milis", "committedDate": "2021-01-25T21:33:53Z", "type": "commit"}, {"oid": "f7ddca6b85b7ee59c3c785e500ec3fa816f646e9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f7ddca6b85b7ee59c3c785e500ec3fa816f646e9", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-25T21:42:17Z", "type": "commit"}, {"oid": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-26T00:28:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MTk0NDMzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r661944331", "bodyText": "This has a bug that is causing the lastContinuationToken to always be null. The last parameter is the continuation token which is always set to null.\nreturn new ChangeFeedStateV1(\n            containerRid,\n            feedRange,\n            ChangeFeedMode.INCREMENTAL,\n            ChangeFeedStartFromInternal.createFromETagAndFeedRange(this.ContinuationToken, feedRange),\n            null);", "author": "j82w", "createdAt": "2021-07-01T03:27:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/PartitionSynchronizerImpl.java", "diffHunk": "@@ -74,7 +78,24 @@ public PartitionSynchronizerImpl(\n         }\n \n         String leaseToken = lease.getLeaseToken();\n-        String lastContinuationToken = lease.getContinuationToken();\n+\n+        ChangeFeedState lastContinuationState = lease.getContinuationState(\n+            this.collectionResourceId,\n+            new FeedRangePartitionKeyRangeImpl(leaseToken)\n+        );\n+\n+        // TODO fabianm - this needs more elaborate processing in case the initial\n+        // FeedRangeContinuation has continuation state for multiple feed Ranges\n+        // and with merge multiple CompositeContinuationItems\n+        // Means Split/Merge needs to be pushed into the FeedRangeContinuation\n+        // Will be necessary for merge anyway\n+        // but efficient testing only works if at least EPK filtering is available in Emulator\n+        // or at least Service - this will be part of the next set of changes\n+        // For now - no merge just simple V0 of lease contract\n+        // this simplification will work\n+        final String lastContinuationToken = lastContinuationState.getContinuation() != null ?\n+            lastContinuationState.getContinuation().getCurrentContinuationToken().getToken() :", "originalCommit": "bf76ae47eb27ed4fce1cfec90303b2cc8fdaba2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21e25e7ec59ab43c0bf6a37aadcb3e218e51ba6c", "message": "Initial draft of FeedRange artifacts", "committedDate": "2020-11-04T00:58:15Z", "type": "commit"}, {"oid": "6e6930098c1df358ec74f580cb3617df00dff471", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6e6930098c1df358ec74f580cb3617df00dff471", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-04T10:30:17Z", "type": "commit"}, {"oid": "40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/40ef415a3f00188fc0a204cd0dc214cde0bbf46d", "message": "Iterating on FeedRange Apis", "committedDate": "2020-11-05T00:29:56Z", "type": "commit"}, {"oid": "54bed2e218c4d42036e4c569c5df311420ac8850", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54bed2e218c4d42036e4c569c5df311420ac8850", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-05T14:05:54Z", "type": "commit"}, {"oid": "58f98e7557075cc4859797a3d4841db3a6d3bd93", "url": "https://github.com/Azure/azure-sdk-for-java/commit/58f98e7557075cc4859797a3d4841db3a6d3bd93", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-11T23:05:03Z", "type": "commit"}, {"oid": "46662e06209505e511f01bd53027c378a375d28f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46662e06209505e511f01bd53027c378a375d28f", "message": "Adding public surface area", "committedDate": "2020-11-12T00:19:01Z", "type": "commit"}, {"oid": "03617a4b6c865db61b15eab54e644d2247028bbe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/03617a4b6c865db61b15eab54e644d2247028bbe", "message": "Adding FeedRange unit tests", "committedDate": "2020-11-12T23:13:26Z", "type": "commit"}, {"oid": "b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7de6b34f68bcc4fedc8188773f4ee7c664eb276", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Refresh", "committedDate": "2020-11-13T00:03:45Z", "type": "commit"}, {"oid": "4095bc5bc318c7c11178e3b2db19f9cec27d5637", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4095bc5bc318c7c11178e3b2db19f9cec27d5637", "message": "Adding test FeedRangePKRangeId_GetEffectiveRangesAsync_Null", "committedDate": "2020-11-13T00:33:45Z", "type": "commit"}, {"oid": "8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8e864bef45a1eac6c7b4dfec191e44975b7abf1c", "message": "Adding test feedRangeEPK_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:18:21Z", "type": "commit"}, {"oid": "4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ebd7cb8fdd916954a2d419dba6fbe056c1186be", "message": "Adding test feedRangePK_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:27:33Z", "type": "commit"}, {"oid": "2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e6eb7967c8d4a1a7ea37a2389ef6770d031a6ea", "message": "Adding test feedRangePKRangeId_getPartitionKeyRangesAsync", "committedDate": "2020-11-13T10:32:17Z", "type": "commit"}, {"oid": "dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc4c66c3402f26d1e2342ae7d02d0facadc74d62", "message": "Adding request visitor unit tests", "committedDate": "2020-11-13T11:22:22Z", "type": "commit"}, {"oid": "0ef3170e6b938b585218cb1274af297221a488a5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ef3170e6b938b585218cb1274af297221a488a5", "message": "Finishing FeedRange tests", "committedDate": "2020-11-13T14:20:56Z", "type": "commit"}, {"oid": "ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae9dd96891d3cc3ef381aaba31b9695cde1f2f9c", "message": "Cleanup and prettifying", "committedDate": "2020-11-13T14:48:00Z", "type": "commit"}, {"oid": "4811e5034bea83f2555f13ab6fb51f9c7defbd68", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4811e5034bea83f2555f13ab6fb51f9c7defbd68", "message": "Prettifying feed range tests", "committedDate": "2020-11-13T14:50:19Z", "type": "commit"}, {"oid": "6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6515ff53e639ae4b2f6c9e1afab9a1cd7ce84f1d", "message": "Fixes and new test for Conatiner.getFeedRanges()", "committedDate": "2020-11-13T15:14:38Z", "type": "commit"}, {"oid": "30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30e162e89883176c3bee6988e0e40e8b1ea0fbcd", "message": "Addressing some SpotBug violations", "committedDate": "2020-11-13T17:31:29Z", "type": "commit"}, {"oid": "b08488a3d52dd394fcd8bbd3de79184c796afe36", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b08488a3d52dd394fcd8bbd3de79184c796afe36", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/FeedRanges", "committedDate": "2020-11-16T15:31:08Z", "type": "commit"}, {"oid": "c67b1f79e0d01e710a7ce3a619fbbbfb43af1f0d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c67b1f79e0d01e710a7ce3a619fbbbfb43af1f0d", "message": "Iterating on Changefeed Pull model draft", "committedDate": "2020-11-17T00:46:10Z", "type": "commit"}, {"oid": "428be5e931d9a90b656e1519785d8cb3f63503c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/428be5e931d9a90b656e1519785d8cb3f63503c6", "message": "Snapshot to be able to switch branches", "committedDate": "2020-11-17T22:33:56Z", "type": "commit"}, {"oid": "fdfd53a84f6daf559148545dcbc0bc72643834c3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fdfd53a84f6daf559148545dcbc0bc72643834c3", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2020-11-18T14:21:37Z", "type": "commit"}, {"oid": "913725ee0435cc4e065002c125997dd0e9f6e93c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/913725ee0435cc4e065002c125997dd0e9f6e93c", "message": "Finishing switch from deleted ChangeFeedOptions to new public CosmosChangeFeedRequestOptions", "committedDate": "2020-11-18T15:22:54Z", "type": "commit"}, {"oid": "afc26781c66c3d4a1e93df240dc4d7bd5c5f004c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/afc26781c66c3d4a1e93df240dc4d7bd5c5f004c", "message": "Adding basic json serialization test coverage for FeedRangeContinuation", "committedDate": "2020-11-20T01:24:00Z", "type": "commit"}, {"oid": "3bec34f5ed6001e92fbef653d27e60e51ebbf3e0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3bec34f5ed6001e92fbef653d27e60e51ebbf3e0", "message": "Snapshot - converting Chagefeed to FeedRanges - tests not working yet", "committedDate": "2020-11-20T18:43:27Z", "type": "commit"}, {"oid": "c08a6b2484ec277ede5c9c2b9eea54e98092028b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c08a6b2484ec277ede5c9c2b9eea54e98092028b", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2020-11-23T09:11:09Z", "type": "commit"}, {"oid": "abfac43abab7455fc00c120faf13d1939e4e1b6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abfac43abab7455fc00c120faf13d1939e4e1b6a", "message": "Snapshot", "committedDate": "2020-11-25T21:28:18Z", "type": "commit"}, {"oid": "b34420421169889327f382ad1906fba07367397e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b34420421169889327f382ad1906fba07367397e", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2020-11-26T00:31:27Z", "type": "commit"}, {"oid": "93f971db277b3c4d90d749596fa6e7ad6e014e58", "url": "https://github.com/Azure/azure-sdk-for-java/commit/93f971db277b3c4d90d749596fa6e7ad6e014e58", "message": "Snapshot", "committedDate": "2020-11-26T03:45:22Z", "type": "commit"}, {"oid": "d7855790d1a7ae9365053491760609e9e6b9e8f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7855790d1a7ae9365053491760609e9e6b9e8f1", "message": "Removing TODOs", "committedDate": "2020-12-09T11:40:19Z", "type": "commit"}, {"oid": "33ab685246d302e2d7e312ddb350e27d7b1a020a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/33ab685246d302e2d7e312ddb350e27d7b1a020a", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2020-12-09T11:41:42Z", "type": "commit"}, {"oid": "3b7936e0dee02d82be4871cb3415c35a930b05d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3b7936e0dee02d82be4871cb3415c35a930b05d2", "message": "Fixing test regressions", "committedDate": "2020-12-09T22:17:58Z", "type": "commit"}, {"oid": "37b2a4612a7e196c3606c447eebe4c75b8ed6e38", "url": "https://github.com/Azure/azure-sdk-for-java/commit/37b2a4612a7e196c3606c447eebe4c75b8ed6e38", "message": "Fixing a couple SpotBug violations", "committedDate": "2020-12-09T23:19:28Z", "type": "commit"}, {"oid": "34ad1e5ed907d4d4f1129b5223c447ca7248c7a5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/34ad1e5ed907d4d4f1129b5223c447ca7248c7a5", "message": "Fixing few more SPotBug violations", "committedDate": "2020-12-09T23:41:58Z", "type": "commit"}, {"oid": "20aaccf6aaf32c3c833b97124a25c0a87b19de79", "url": "https://github.com/Azure/azure-sdk-for-java/commit/20aaccf6aaf32c3c833b97124a25c0a87b19de79", "message": "Fixing ChangeFeedState unit test", "committedDate": "2020-12-10T00:46:28Z", "type": "commit"}, {"oid": "9e55ea7fa028ff5b48674feddc8f7412ba9a30af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9e55ea7fa028ff5b48674feddc8f7412ba9a30af", "message": "Code cleanup", "committedDate": "2020-12-10T21:05:34Z", "type": "commit"}, {"oid": "90f371fcc7a00f8b452861ab8653f569cf1f8f57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90f371fcc7a00f8b452861ab8653f569cf1f8f57", "message": "Test code cleanup", "committedDate": "2020-12-10T21:09:59Z", "type": "commit"}, {"oid": "d197486ac539422c2a1183811638b42ddb7bfdf0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d197486ac539422c2a1183811638b42ddb7bfdf0", "message": "Fixing a regression in Range json serialization", "committedDate": "2020-12-11T11:30:45Z", "type": "commit"}, {"oid": "332acfe59e156dd684f72afe93bd252faed973ce", "url": "https://github.com/Azure/azure-sdk-for-java/commit/332acfe59e156dd684f72afe93bd252faed973ce", "message": "Fixing CF split unit test failure", "committedDate": "2020-12-11T23:45:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNzA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544707077", "bodyText": "nit: I would use Preconditions.checkNotNull() from shaded guava lib.", "author": "moderakh", "createdAt": "2020-12-16T23:52:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,233 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+@Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private Integer maxItemCount;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+    private final Map<String, Object> properties;\n+    private ChangeFeedMode mode;\n+    private final ChangeFeedState continuationState;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }", "originalCommit": "332acfe59e156dd684f72afe93bd252faed973ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNzc3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544707771", "bodyText": "any reason for this?", "author": "moderakh", "createdAt": "2020-12-16T23:54:08Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/PartitionKeyRange.java", "diffHunk": "@@ -107,7 +107,7 @@ public boolean equals(Object obj) {\n \n     @Override\n     public int hashCode() {\n-        int hash = 0;\n+        int hash = 1;", "originalCommit": "332acfe59e156dd684f72afe93bd252faed973ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3NjY1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r550476658", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-12-31T12:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwNzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwODYxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r544708617", "bodyText": "header.", "author": "moderakh", "createdAt": "2020-12-16T23:56:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.azure.cosmos.implementation.changefeed.implementation;", "originalCommit": "332acfe59e156dd684f72afe93bd252faed973ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ3Njg1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r550476850", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2020-12-31T12:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDcwODYxNw=="}], "type": "inlineReview"}, {"oid": "804e2943fb896b9caefed94ac1e58ea193b56c35", "url": "https://github.com/Azure/azure-sdk-for-java/commit/804e2943fb896b9caefed94ac1e58ea193b56c35", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2020-12-31T12:44:42Z", "type": "commit"}, {"oid": "ececd082368b23c98d41f1c37abc6d885471e070", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ececd082368b23c98d41f1c37abc6d885471e070", "message": "Fixes for some code review feedback", "committedDate": "2020-12-31T12:50:07Z", "type": "commit"}, {"oid": "4f8a3a9c88269755e6cf2af5d3df60c0015ec6e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4f8a3a9c88269755e6cf2af5d3df60c0015ec6e2", "message": "Fixing test flakiness (unrelated to actual change)", "committedDate": "2021-01-04T11:11:01Z", "type": "commit"}, {"oid": "b7d675f894aa91e19cbf5904c1f0470b1f38b6d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7d675f894aa91e19cbf5904c1f0470b1f38b6d4", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-04T11:11:20Z", "type": "commit"}, {"oid": "7ceacd3080ea9b395c2a1c1f52b386f2660a7410", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ceacd3080ea9b395c2a1c1f52b386f2660a7410", "message": "Adding ChangeFeedPolicy", "committedDate": "2021-01-07T15:29:58Z", "type": "commit"}, {"oid": "ec9cd238d733f2bca604585b1772dabb5acd9209", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ec9cd238d733f2bca604585b1772dabb5acd9209", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-07T15:31:13Z", "type": "commit"}, {"oid": "01a4a68bb1684f7e9fa5bd3f414aa6b8036014c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a4a68bb1684f7e9fa5bd3f414aa6b8036014c9", "message": "Adding tests for ChangeFeedPolicy", "committedDate": "2021-01-07T19:27:24Z", "type": "commit"}, {"oid": "84f36ea891d2aa95277382f4d684e355ceaa90f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/84f36ea891d2aa95277382f4d684e355ceaa90f8", "message": "Fixing build break", "committedDate": "2021-01-07T19:37:29Z", "type": "commit"}, {"oid": "2f512e219a02bad5e2d4dc377fd3be3e7c67c2c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2f512e219a02bad5e2d4dc377fd3be3e7c67c2c1", "message": "Fixing SpotBug issue", "committedDate": "2021-01-07T19:50:28Z", "type": "commit"}, {"oid": "714b9b27ccbf44c2ffd98f9ec72717d1b6dbd028", "url": "https://github.com/Azure/azure-sdk-for-java/commit/714b9b27ccbf44c2ffd98f9ec72717d1b6dbd028", "message": "Re-triggering CI", "committedDate": "2021-01-07T21:14:04Z", "type": "commit"}, {"oid": "3e149ed321dd3d2652eb2df22252f03d3535499f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e149ed321dd3d2652eb2df22252f03d3535499f", "message": "Deleting temp data", "committedDate": "2021-01-07T22:21:30Z", "type": "commit"}, {"oid": "8bbb0d30ea95db8a1179162841ef7502a875e7d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bbb0d30ea95db8a1179162841ef7502a875e7d2", "message": "Deleting CosmosDB Emulator temp data", "committedDate": "2021-01-07T22:43:20Z", "type": "commit"}, {"oid": "6f5196a2caa1fa78eb2bed681b1120843bb6c3c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6f5196a2caa1fa78eb2bed681b1120843bb6c3c6", "message": "Fixing scritp to delete temp folder", "committedDate": "2021-01-07T23:01:35Z", "type": "commit"}, {"oid": "29adeb8a00ac854438a8f22bd98acdd8bbf4f278", "url": "https://github.com/Azure/azure-sdk-for-java/commit/29adeb8a00ac854438a8f22bd98acdd8bbf4f278", "message": "Fixing PS script", "committedDate": "2021-01-07T23:11:25Z", "type": "commit"}, {"oid": "3aac6f0b64f07e2687e51e7165983bc895fc36f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aac6f0b64f07e2687e51e7165983bc895fc36f1", "message": "Adding message with Emulator version to emulator install yaml file", "committedDate": "2021-01-08T00:56:26Z", "type": "commit"}, {"oid": "7ec9f6cb90169b2fe870ac96ab746729f2746c05", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7ec9f6cb90169b2fe870ac96ab746729f2746c05", "message": "Adding Cosmos DB Emulator installation logs", "committedDate": "2021-01-08T02:00:15Z", "type": "commit"}, {"oid": "5e533c90025ef11b31cb3ee1a780f65ae984a2de", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e533c90025ef11b31cb3ee1a780f65ae984a2de", "message": "Adding logic to unistall emulator to Cosmos Emulator yml", "committedDate": "2021-01-08T03:44:45Z", "type": "commit"}, {"oid": "3d3280f9f20e5920f39df12dfbc59cbb03ff3e6f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d3280f9f20e5920f39df12dfbc59cbb03ff3e6f", "message": "Update cosmos-emulator.yml", "committedDate": "2021-01-08T04:08:26Z", "type": "commit"}, {"oid": "9a69b86b9b2801d70e8711ceb3200e3689759bee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a69b86b9b2801d70e8711ceb3200e3689759bee", "message": "Fixing missing admin elevation in the uninstall step in Cosmos Emulator yml", "committedDate": "2021-01-08T10:56:35Z", "type": "commit"}, {"oid": "2c205b016fc614311c79564f3f0b1d1ea6bac0ec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2c205b016fc614311c79564f3f0b1d1ea6bac0ec", "message": "Iterating on cosmos-emulator.yml", "committedDate": "2021-01-08T12:37:06Z", "type": "commit"}, {"oid": "8f6e0b06dce4ee553d55e9e275f78a4ddabc5f54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f6e0b06dce4ee553d55e9e275f78a4ddabc5f54", "message": "Iteratiing on cosmos-emulator.yml", "committedDate": "2021-01-08T13:02:30Z", "type": "commit"}, {"oid": "9e7f154d92bc2fc020925a76e3db42676e2837af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9e7f154d92bc2fc020925a76e3db42676e2837af", "message": "Iterating on cosmos-emulator.yml", "committedDate": "2021-01-08T13:13:41Z", "type": "commit"}, {"oid": "8891306089a01b0af60db59fa892b56f318a3582", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8891306089a01b0af60db59fa892b56f318a3582", "message": "Iterating on cosmos-emulator.yml", "committedDate": "2021-01-08T14:54:59Z", "type": "commit"}, {"oid": "2577aa03284b4b192e58de9fb488540f1ee659de", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2577aa03284b4b192e58de9fb488540f1ee659de", "message": "Iterating on comsos-emulator.yml", "committedDate": "2021-01-08T15:46:29Z", "type": "commit"}, {"oid": "b4b3e72e7e6158dcd748e998dc26d8497bc0064e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b4b3e72e7e6158dcd748e998dc26d8497bc0064e", "message": "Iterating on comsos-emulator.yml", "committedDate": "2021-01-08T17:44:27Z", "type": "commit"}, {"oid": "0f706764cc9fc74c9ad15c79c59bb2756e49df26", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f706764cc9fc74c9ad15c79c59bb2756e49df26", "message": "Iterate on cosmos-emulator.yml", "committedDate": "2021-01-08T18:34:17Z", "type": "commit"}, {"oid": "efd3c6c8204019b8f281cfd6a8e9347f9f3359d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/efd3c6c8204019b8f281cfd6a8e9347f9f3359d9", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-08T19:12:52Z", "type": "commit"}, {"oid": "f3bf00d9a986bd625640b639831c9a8f4856221b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3bf00d9a986bd625640b639831c9a8f4856221b", "message": "Adding FF changefeed unit tests", "committedDate": "2021-01-08T21:47:23Z", "type": "commit"}, {"oid": "27cd733cafebbd674eaca693ef3e32adc4a21c67", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27cd733cafebbd674eaca693ef3e32adc4a21c67", "message": "Fixing build warning", "committedDate": "2021-01-08T22:19:22Z", "type": "commit"}, {"oid": "026b0e928fad187d10291ac2ad022c2742b5fa8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/026b0e928fad187d10291ac2ad022c2742b5fa8f", "message": "Fixing test regression when ContainerTest hit emulator limit of number of containers", "committedDate": "2021-01-11T09:22:59Z", "type": "commit"}, {"oid": "024ab997b171b44764b913429c55c923ca5ce57a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/024ab997b171b44764b913429c55c923ca5ce57a", "message": "Fixing emulator config for CI tests", "committedDate": "2021-01-11T10:55:33Z", "type": "commit"}, {"oid": "90641a3f0b439a4e3e59dd463e1e916659f37949", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90641a3f0b439a4e3e59dd463e1e916659f37949", "message": "Fixing test issue - causing Begin/After Method/Class to also happen for emulator tests in ChangeFeedTest", "committedDate": "2021-01-11T11:43:26Z", "type": "commit"}, {"oid": "88b5ae503911df6a5469539f621aacf1c13774d7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/88b5ae503911df6a5469539f621aacf1c13774d7", "message": "Refactoring FeedRange visitors to populate request headers", "committedDate": "2021-01-12T02:04:36Z", "type": "commit"}, {"oid": "09eab8ea917fb2c1b30507f45e917daf99ef4b92", "url": "https://github.com/Azure/azure-sdk-for-java/commit/09eab8ea917fb2c1b30507f45e917daf99ef4b92", "message": "Implementing FeedRangeInternal.populateFeedRangeFilteringHeaders", "committedDate": "2021-01-12T19:42:50Z", "type": "commit"}, {"oid": "aec75bab48e374bb863c490e59ed58c576aba854", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aec75bab48e374bb863c490e59ed58c576aba854", "message": "Fixes for FeedRangeTest", "committedDate": "2021-01-12T21:13:51Z", "type": "commit"}, {"oid": "c5e63cb26e77ddf8e30c5466485a9232c38d527e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c5e63cb26e77ddf8e30c5466485a9232c38d527e", "message": "Refactoring FeedRangeINternal.getEffectiveRanges to getEffectiveRange", "committedDate": "2021-01-13T02:06:19Z", "type": "commit"}, {"oid": "dbbd26dd0bba064a118aec2725a38296860b2084", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbbd26dd0bba064a118aec2725a38296860b2084", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-13T02:12:33Z", "type": "commit"}, {"oid": "e0aeae1dcfed99249623996f11a0c37621549486", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e0aeae1dcfed99249623996f11a0c37621549486", "message": "Fixing test issue in FeedRangeTest", "committedDate": "2021-01-13T02:30:28Z", "type": "commit"}, {"oid": "edb744005875a9cd6d5f4432878ce92e2a28c3ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/edb744005875a9cd6d5f4432878ce92e2a28c3ee", "message": "Reacting to self-Code review", "committedDate": "2021-01-13T11:06:59Z", "type": "commit"}, {"oid": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "url": "https://github.com/Azure/azure-sdk-for-java/commit/35a901f6049e17632ffa7ce65b9dca9b8feaa861", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-13T11:22:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc5MTU4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556791588", "bodyText": "TODO - change this to whatever is the version at the time of merge before actually merging!", "author": "FabianMeiswinkel", "createdAt": "2021-01-13T19:56:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/Beta.java", "diffHunk": "@@ -55,5 +55,6 @@\n         V4_9_0,\n         /** v4.11.0 */\n         V4_11_0,\n+        WHATEVER_NEW_VERSION", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMDc3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556800775", "bodyText": "nit: Doesn't this cover the case of the above line also?", "author": "ealsur", "createdAt": "2021-01-13T20:13:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ChangeFeedQueryImpl.java", "diffHunk": "@@ -3,128 +3,103 @@\n package com.azure.cosmos.implementation;\n \n import com.azure.cosmos.BridgeInternal;\n-import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStateV1;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n import com.azure.cosmos.implementation.query.Paginator;\n-import com.azure.cosmos.implementation.routing.PartitionKeyInternal;\n-import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n+import com.azure.cosmos.models.CosmosChangeFeedRequestOptions;\n+import com.azure.cosmos.models.FeedResponse;\n+import com.azure.cosmos.models.ModelBridgeInternal;\n import reactor.core.publisher.Flux;\n import reactor.core.publisher.Mono;\n \n-import java.time.ZoneOffset;\n import java.util.HashMap;\n import java.util.Map;\n-import java.util.function.BiFunction;\n import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n class ChangeFeedQueryImpl<T extends Resource> {\n \n-    private static final String IfNonMatchAllHeaderValue = \"*\";\n+    private static final int INITIAL_TOP_VALUE = -1;\n+\n     private final RxDocumentClientImpl client;\n     private final DiagnosticsClientContext clientContext;\n-    private final ResourceType resourceType;\n-    private final Class<T> klass;\n+    private final Supplier<RxDocumentServiceRequest> createRequestFunc;\n     private final String documentsLink;\n-    private final ChangeFeedOptions options;\n+    private final Function<RxDocumentServiceRequest, Mono<FeedResponse<T>>> executeFunc;\n+    private final Class<T> klass;\n+    private final CosmosChangeFeedRequestOptions options;\n+    private final ResourceType resourceType;\n+    private final ChangeFeedState changeFeedState;\n+\n+    public ChangeFeedQueryImpl(\n+        RxDocumentClientImpl client,\n+        ResourceType resourceType,\n+        Class<T> klass,\n+        String collectionLink,\n+        CosmosChangeFeedRequestOptions requestOptions) {\n+\n+        checkNotNull(client, \"Argument 'client' must not be null.\");\n+        checkNotNull(resourceType, \"Argument 'resourceType' must not be null.\");\n+        checkNotNull(klass, \"Argument 'klass' must not be null.\");\n+        checkNotNull(requestOptions, \"Argument 'requestOptions' must not be null.\");\n+        checkNotNull(collectionLink, \"Argument 'collectionLink' must not be null.\");\n+        if (Strings.isNullOrWhiteSpace(collectionLink)) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzczNzk3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557737970", "bodyText": "Not really - the checkNotNull is throwing NullPointerException - which woudln't make sense for String.Empty - so effectively the isNullOrWhitespace is just used as IsWhitespace here.", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:25:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMDc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjgzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556802836", "bodyText": "Is this one required?", "author": "ealsur", "createdAt": "2021-01-13T20:17:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/HttpConstants.java", "diffHunk": "@@ -258,6 +258,8 @@\n \n     public static class A_IMHeaderValues {\n         public static final String INCREMENTAL_FEED = \"Incremental Feed\";\n+        public static final String FullFidelityFeed = \"Full-Fidelity Feed\";\n+        public static final String IncrementalFullFidelityFeed = \"Incremental Full-Fidelity Feed\";", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzczODczNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557738737", "bodyText": "Removed in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:26:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwMjgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwNDcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556804724", "bodyText": "Why is the continuation range needed? Isn't the information in the FeedRange enough (getFeedRange)?", "author": "ealsur", "createdAt": "2021-01-13T20:20:55Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1411,7 +1413,97 @@ private RxDocumentServiceRequest addBatchHeaders(RxDocumentServiceRequest reques\n             request.getHeaders().put(HttpConstants.HttpHeaders.ACCEPT, RuntimeConstants.MediaTypes.JSON);\n         }\n \n-        return populateAuthorizationHeader(request);\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        if (this.requiresFeedRangeFiltering(request)) {\n+            final Range<String> continuationRange = request.getContinuationRange();", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjE5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r558742195", "bodyText": "Fixed - was an attempted band-aid for a bug in the feed range continuation processing. But as bandaids ultimately always will do - it failed to fully mitigate the problem anyway. Finally took the time to fix this properly.", "author": "FabianMeiswinkel", "createdAt": "2021-01-16T01:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgwNDcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556821095", "bodyText": "Why would you need to store the complex continuation on a lease? If the lease is for a particular range within a partition, the ETAG would still be a valid continuation if the EPK filtering is in place, right?", "author": "ealsur", "createdAt": "2021-01-13T20:53:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/ServiceItemLease.java", "diffHunk": "@@ -101,6 +108,27 @@ public String getContinuationToken() {\n         return this.ContinuationToken;\n     }\n \n+    public ChangeFeedState getContinuationState(\n+        String containerRid,\n+        FeedRangeInternal feedRange) {\n+\n+        checkNotNull(containerRid, \"Argument 'containerRid' must not be null.\");\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null.\");\n+\n+        if (this.ContinuationToken != null &&\n+            this.ContinuationToken.startsWith(\"{\\\"V\\\":\")) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNTc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556825777", "bodyText": "In .NET what we do is always use the ETAG for leases. If a lease for a partition is merged, we simply continue to use that same ETAG but apply EPK filtering for the range that was related to the original partition.", "author": "ealsur", "createdAt": "2021-01-13T21:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5NzAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556897034", "bodyText": "That would work for merge - but not when you would want to allow decoupling compute from physical partitions, correct?", "author": "FabianMeiswinkel", "createdAt": "2021-01-13T22:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDYyNDA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r560624047", "bodyText": "Removed this - will use the lease V2 cotract from .Net when enabling merge", "author": "FabianMeiswinkel", "createdAt": "2021-01-20T02:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMTA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556822149", "bodyText": "During our review for Full Fidelity, on .NET, we decided to put the mode (Incremental or FF) as a required parameter in the creation of the iterator, why did we decide to put it on the options here?", "author": "ealsur", "createdAt": "2021-01-13T20:55:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/CosmosChangeFeedRequestOptions.java", "diffHunk": "@@ -0,0 +1,238 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.models;\n+\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedMode;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedStartFromInternal;\n+import com.azure.cosmos.implementation.changefeed.implementation.ChangeFeedState;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeContinuation;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.azure.cosmos.util.Beta;\n+\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n+\n+@Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+public final class CosmosChangeFeedRequestOptions {\n+    private static final Integer DEFAULT_MAX_ITEM_COUNT = 1000;\n+    private final ChangeFeedState continuationState;\n+    private final FeedRangeInternal feedRangeInternal;\n+    private final Map<String, Object> properties;\n+    private Integer maxItemCount;\n+    private ChangeFeedMode mode;\n+    private ChangeFeedStartFromInternal startFromInternal;\n+\n+    private CosmosChangeFeedRequestOptions(\n+        FeedRangeInternal feedRange,\n+        ChangeFeedStartFromInternal startFromInternal,\n+        ChangeFeedMode mode,\n+        ChangeFeedState continuationState) {\n+\n+        super();\n+\n+        if (feedRange == null) {\n+            throw new NullPointerException(\"feedRange\");\n+        }\n+\n+        if (startFromInternal == null) {\n+            throw new NullPointerException(\"startFromInternal\");\n+        }\n+\n+        this.maxItemCount = DEFAULT_MAX_ITEM_COUNT;\n+        this.feedRangeInternal = feedRange;\n+        this.startFromInternal = startFromInternal;\n+        this.continuationState = continuationState;\n+\n+        if (mode != ChangeFeedMode.INCREMENTAL && mode != ChangeFeedMode.FULL_FIDELITY) {\n+            throw new IllegalArgumentException(\n+                String.format(\n+                    \"Argument 'mode' has unsupported change feed mode %s\",\n+                    mode.toString()));\n+        }\n+\n+        this.mode = mode;\n+        this.properties = new HashMap<>();\n+    }\n+\n+    ChangeFeedState getContinuation() {\n+        return this.continuationState;\n+    }\n+\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public FeedRange getFeedRange() {\n+        return this.feedRangeInternal;\n+    }\n+\n+    /**\n+     * Gets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @return the max number of items.\n+     */\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public Integer getMaxItemCount() {\n+        return this.maxItemCount;\n+    }\n+\n+    /**\n+     * Sets the maximum number of items to be returned in the enumeration\n+     * operation.\n+     *\n+     * @param maxItemCount the max number of items.\n+     * @return the FeedOptionsBase.\n+     */\n+    @Beta(Beta.SinceVersion.WHATEVER_NEW_VERSION)\n+    public CosmosChangeFeedRequestOptions setMaxItemCount(Integer maxItemCount) {\n+        this.maxItemCount = maxItemCount;\n+        return this;\n+    }\n+\n+    ChangeFeedMode getMode() {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkxNjUxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556916517", "bodyText": "Happened independently - will consider it when actually adding the new API on CosmosAsyncContainer and CosmosContainer. But I think the model we have in Java allows adding state easily - because the actual mode is not part of public surface area - but only the factory methods. Don't really think this needs to be changed - unless we think the changeFeedMode is such a critical paramter that it would need to be elevated - but IMO that isn't true - page size will be changed by more customers than changeFeedMode for example.", "author": "FabianMeiswinkel", "createdAt": "2021-01-13T22:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk4MTMwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556981300", "bodyText": "Which would be the default value then? It is a critical part of consuming the Change Feed and the choice should be on the user. Defaulting to Incremental if the user created the container with FF support will potentially create CRIs because the users would expect the Change Feed to behave with retention and the discoverability of the options makes it so it's rather an optional parameter.", "author": "ealsur", "createdAt": "2021-01-14T01:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0MTM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557741343", "bodyText": "Let's take this separately - I kind of disagree because FullFidelity is increasing the risk for data loss. So yes - customers need to make the decision - but I don't see why we can't have a default behavior (like we do for Consistency Model). I don't see FF being used for more than a couple percent of scenarios in the near future. Making the barrier to accidentally use full fidelity (like with allow bulk in .Net - sounds cool so customers just enable it without fully understanding the consequences) high was intentional. Also FullFidelity will never GA before we have to GA CF pull model for Java to support Spark - so I rather keep it separate which allows just marking the withFullFidelity still as @beta", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyMjE0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNDAwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556824009", "bodyText": "nit: Would the response had a previous continuation? Also, are there no semantics tied to continuation being null?", "author": "ealsur", "createdAt": "2021-01-13T20:58:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/models/FeedResponse.java", "diffHunk": "@@ -287,6 +288,23 @@ public String getContinuationToken() {\n         return getValueOrNull(header, headerName);\n     }\n \n+    /**\n+     * Sets the continuation token to be used for continuing the enumeration.\n+     *\n+     * @param continuationToken updates the continuation token header of the response\n+     */\n+    void setContinuationToken(String continuationToken) {\n+        String headerName = useEtagAsContinuation\n+            ? HttpConstants.HttpHeaders.E_TAG\n+            : HttpConstants.HttpHeaders.CONTINUATION;\n+\n+        if (!Strings.isNullOrWhiteSpace(continuationToken)) {\n+            this.header.put(headerName, continuationToken);\n+        } else {\n+            this.header.remove(headerName);", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNTA0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556825049", "bodyText": "Do you need both the range in the continuation and a different range here? If the point is that the enumerator contains multiple continuation ranges (like a list of composite continuations), isn't the current continuation range enough?", "author": "ealsur", "createdAt": "2021-01-13T21:00:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentServiceRequest.java", "diffHunk": "@@ -830,6 +836,22 @@ public void routeTo(PartitionKeyRangeIdentity partitionKeyRangeIdentity) {\n         this.setPartitionKeyRangeIdentity(partitionKeyRangeIdentity);\n     }\n \n+    public FeedRangeInternal getFeedRange() {\n+        return this.feedRange;\n+    }\n+\n+    public void applyFeedRangeFilter(FeedRangeInternal feedRange) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r558742448", "bodyText": "Fixed.", "author": "FabianMeiswinkel", "createdAt": "2021-01-16T01:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNjQ1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556826455", "bodyText": "nit: If this is an enum, might be worth thinking how (if it happens) would a mode that requires some extra state parameter (like Incremental Full Fidelity) work.", "author": "ealsur", "createdAt": "2021-01-13T21:03:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public enum ChangeFeedMode {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0Mjc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557742751", "bodyText": "Because it is applied to the CF Request Options - like with withFullFidelity() it would be relatively easy to also add the Incremental-To-FullFidelity-Point-In-Time. But yes - if we change the model to push this into parameters I would prefer a similar model how you chose in .Net", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNjQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MzcwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556883702", "bodyText": "How does this type work?", "author": "ealsur", "createdAt": "2021-01-13T22:03:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedStartFromInternalDeserializer.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.Strings;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternal;\n+import com.azure.cosmos.implementation.feedranges.FeedRangeInternalDeserializer;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+public class ChangeFeedStartFromInternalDeserializer extends StdDeserializer<ChangeFeedStartFromInternal> {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public ChangeFeedStartFromInternalDeserializer() {\n+        this(null);\n+    }\n+\n+    public ChangeFeedStartFromInternalDeserializer(final Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    @Override\n+    public ChangeFeedStartFromInternal deserialize(\n+        final JsonParser parser,\n+        final DeserializationContext context)\n+        throws IOException {\n+\n+        final JsonNode rootNode = parser.getCodec().readTree(parser);\n+        final ObjectMapper mapper = (ObjectMapper)parser.getCodec();\n+\n+        return deserializeStartFromInternal(rootNode, mapper, parser);\n+    }\n+\n+    public static ChangeFeedStartFromInternal deserializeStartFromInternal(\n+        JsonNode rootNode,\n+        ObjectMapper mapper,\n+        JsonParser parser) throws IOException {\n+\n+        JsonNode typeNode = rootNode.get(Constants.Properties.CHANGE_FEED_START_FROM_TYPE);\n+        if (typeNode == null || !typeNode.isTextual() || Strings.isNullOrWhiteSpace(typeNode.textValue())) {\n+            throw JsonMappingException.from(\n+                parser,\n+                String.format(\n+                    \"Required property '%s' missing or does not have a valid value.\",\n+                    Constants.Properties.CHANGE_FEED_START_FROM_TYPE));\n+        }\n+\n+        ChangeFeedStartFromTypes type;\n+        try {\n+            type = ChangeFeedStartFromTypes.valueOf(typeNode.textValue().toUpperCase(Locale.ROOT));\n+        } catch (IllegalArgumentException argException) {\n+            throw JsonMappingException.from(\n+                parser,\n+                String.format(\n+                    \"Value '%s' for required property '%s' does not have a valid value.\",\n+                    typeNode.textValue(),\n+                    Constants.Properties.CHANGE_FEED_START_FROM_TYPE),\n+                argException);\n+        }\n+\n+        switch (type) {\n+            case BEGINNING:\n+                return new ChangeFeedStartFromBeginningImpl();\n+\n+            case NOW:\n+                return new ChangeFeedStartFromNowImpl();\n+\n+            case POINT_IN_TIME:\n+                JsonNode pitNode =\n+                    rootNode.get(Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS);\n+                if (pitNode == null || !pitNode.isLong()) {\n+                    throw JsonMappingException.from(\n+                        parser,\n+                        String.format(\n+                            \"Required property '%s' missing or does not have a valid value.\",\n+                            Constants.Properties.CHANGE_FEED_START_FROM_POINT_IN_TIME_MS));\n+                }\n+                return new ChangeFeedStartFromPointInTimeImpl(Instant.ofEpochMilli(pitNode.longValue()));\n+\n+            case LEASE:", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0NzQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557747426", "bodyText": "Code is in ChangeFeedStartFromETagAndFeedRangeImpl - basically a way to bi-directionally map the lease docuemnts V1 to ChangeFeedStateV1 - so that I can re-use it even for ChangeFeedProcessor.\nMy main idea was that I would allow customers to split continuations - like allowing to process same physical partition via multiple compute instances on the ChangeFeedState - and would disallow it for this state.\nBut I admit that I haven't finalized the proposal on how to expsoe the split/merge functionality for continuations (and whether it would be preferrable to have that unified for CF vs. query or separately) So I might be able to get rid of this type at some point - it is in the implementation package - so that is possible.", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4MzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4Nzk0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556887946", "bodyText": "Why would the ranges have the full range? What if the feedRange is smaller?", "author": "ealsur", "createdAt": "2021-01-13T22:07:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuation.java", "diffHunk": "@@ -34,25 +49,77 @@ public FeedRangeInternal getFeedRange() {\n         return this.feedRange;\n     }\n \n-    public abstract String getContinuation();\n+    public abstract CompositeContinuationToken getCurrentContinuationToken();\n \n     public abstract void replaceContinuation(String continuationToken);\n \n     public abstract boolean isDone();\n \n     public abstract void validateContainer(String containerRid);\n \n-    /* TODO fabianm - infinite recursion\n-    public static FeedRangeContinuation tryParse(String toStringValue) {\n-        return FeedRangeCompositeContinuationImpl.tryParse(toStringValue);\n-    }*/\n+    public void populatePropertyBag() {\n+        super.populatePropertyBag();\n+    }\n \n-    public abstract ShouldRetryResult handleChangeFeedNotModified(\n-        RxDocumentServiceResponse responseMessage);\n+    public static FeedRangeContinuation tryParse(String jsonString) {\n+        if (jsonString == null) {\n+            return null;\n+        }\n+\n+        try\n+        {\n+            return FeedRangeCompositeContinuationImpl.parse(jsonString);\n+        }\n+        catch (final IOException ioError) {\n+            LOGGER.debug(\n+                \"Failed to parse feed range continuation JSON {}\",\n+                jsonString,\n+                ioError);\n+            return null;\n+        }\n+    }\n+\n+    public static FeedRangeContinuation convert(final String continuationToken) {\n+        if (Strings.isNullOrWhiteSpace(continuationToken)) {\n+            throw new NullPointerException(\"continuationToken\");\n+        }\n+\n+        FeedRangeContinuation returnValue = tryParse(continuationToken);\n+        if (returnValue != null) {\n+            return returnValue;\n+        }\n+\n+        throw new IllegalArgumentException(\n+            String.format(\n+                \"Invalid Feed range continuation token '%s'\",\n+                continuationToken));\n+    }\n+\n+    public static FeedRangeContinuation createForFullFeedRange(\n+        String containerRid,\n+        FeedRangeInternal feedRange) {\n+\n+        checkNotNull(containerRid, \"Argument 'collectionLink' must not be null\");\n+        checkNotNull(feedRange, \"Argument 'feedRange' must not be null\");\n+\n+        List<Range<String>> ranges = new ArrayList<>();\n+        ranges.add(\n+            new Range<>(\n+                PartitionKeyInternalHelper.MinimumInclusiveEffectivePartitionKey,", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r558742736", "bodyText": "Fixed", "author": "FabianMeiswinkel", "createdAt": "2021-01-16T01:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg4Nzk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556890804", "bodyText": "What is the result if the container was deleted and recreated with the same name while the objects were already created? Would this return an exception?", "author": "ealsur", "createdAt": "2021-01-13T22:10:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc0Nzk5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557747999", "bodyText": "Had an issue here - because I was mixing Rid and Collection self-link. Changed that in the last iteration.", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T22:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg5MDgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDc4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556930786", "bodyText": "in other places we are registering serialzier/deserializer using @JsonSerialize annotation.\nsee this:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/routing/PartitionKeyInternal.java#L35-L36\nI imagine with the SimpleModule approach you are not paying the one-time reflection cost for discovering the serializer. correct? is there any other benefit?", "author": "moderakh", "createdAt": "2021-01-13T22:52:20Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Utils.java", "diffHunk": "@@ -77,6 +87,21 @@\n         Utils.simpleObjectMapper.configure(JsonParser.Feature.STRICT_DUPLICATE_DETECTION, true);\n         Utils.simpleObjectMapper.configure(DeserializationFeature.ACCEPT_FLOAT_AS_INT, false);\n \n+        final SimpleModule customDeserializationModules = new SimpleModule();\n+        customDeserializationModules.addDeserializer(\n+            FeedRangeInternal.class,\n+            new FeedRangeInternalDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            FeedRangeContinuation.class,\n+            new FeedRangeContinuationDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            ChangeFeedStartFromInternal.class,\n+            new ChangeFeedStartFromInternalDeserializer());\n+        customDeserializationModules.addDeserializer(\n+            ChangeFeedState.class,\n+            new ChangeFeedStateDeserializer());\n+        Utils.simpleObjectMapper.registerModule(customDeserializationModules);", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1NDQyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557754423", "bodyText": "Not intentional - simply wasn't aware of the @JsonDeserialize option - I remember vaguely that it took my some time to figure out how to register the deserializer - probably looked at old guidance on how to do it :-)\nChange in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzgxNDk1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557814955", "bodyText": "Actually - the reason why I switched to the explicit SimpleModule registration was that there are some InaccesibleObjectExceptions when using @JsonDeserialize notation\nSample exception from CI run after switching to @JsonDeserialize\njava.lang.reflect.InaccessibleObjectException: Unable to make public com.azure.cosmos.implementation.feedranges.FeedRangeInternalDeserializer() accessible: module com.azure.cosmos does not \"exports com.azure.cosmos.implementation.feedranges\" to module com.fasterxml.jackson.databind\nat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:340)\nat java.base/java.lang.reflect.AccessibleObject.checkCanSetAccessible(AccessibleObject.java:280)\nat java.base/java.lang.reflect.Constructor.checkCanSetAccessible(Constructor.java:189)\nat java.base/java.lang.reflect.Constructor.setAccessible(Constructor.java:182)\n\n[...]\nAny hard reason to use @JsonDeserialzie over this one?", "author": "FabianMeiswinkel", "createdAt": "2021-01-15T01:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4NDMwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r561184309", "bodyText": "Never mind - missed to register one namespace in module-info when I tried this approach first. Fixed now in latest iteration.", "author": "FabianMeiswinkel", "createdAt": "2021-01-20T18:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMTYzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556931637", "bodyText": "does this correlate with a String header we pass to the BE? or is it merely a client side config?", "author": "moderakh", "createdAt": "2021-01-13T22:54:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/changefeed/implementation/ChangeFeedMode.java", "diffHunk": "@@ -0,0 +1,9 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.changefeed.implementation;\n+\n+public enum ChangeFeedMode {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzQ4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557787480", "bodyText": "Will drive which A_IM header value we send to the backend.", "author": "FabianMeiswinkel", "createdAt": "2021-01-15T00:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMTYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556933361", "bodyText": "nit: indentation.", "author": "moderakh", "createdAt": "2021-01-13T22:58:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuationDeserializer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FeedRangeContinuationDeserializer extends StdDeserializer<FeedRangeContinuation>  {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public FeedRangeContinuationDeserializer() {\n+        this(null);\n+    }\n+\n+    public FeedRangeContinuationDeserializer(final Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    @Override\n+    public FeedRangeContinuation deserialize(final JsonParser parser,\n+                                         final DeserializationContext context)", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1NDgzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557754835", "bodyText": "Fixed in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMzM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1Mjc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556952781", "bodyText": "do we have unit tests for serializer/deserializer?\nif not, it is worth to add unit tests. Same for other serializer/deserializers.\nplease see this as example:\nhttps://github.com/Azure/azure-sdk-for-java/blob/master/sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/implementation/CilentConfigDiagnosticsTest.java", "author": "moderakh", "createdAt": "2021-01-13T23:50:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeContinuationDeserializer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.implementation.feedranges;\n+\n+import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.query.CompositeContinuationToken;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class FeedRangeContinuationDeserializer extends StdDeserializer<FeedRangeContinuation>  {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1NjQ2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557756462", "bodyText": "Yes - I had added test coverage for roundtrip serialization/deserialization - the names of the test have the suffix _toJsonFromJson", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1Mjc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTA1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959054", "bodyText": "as per reactive-stream contract, null value is not a permissible value hence this will be always true,\nperhaps you should check\npkRangeHolder.v != null instead", "author": "moderakh", "createdAt": "2021-01-14T00:09:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,73 +37,125 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                Range.getPointRange(effectivePartitionKey),\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    String rangeId = pkRangeHolder.v.get(0).getId();\n-                    rangeList.add(rangeId);\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        Range.getPointRange(effectivePartitionKey),\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1NjkyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557756927", "bodyText": "Fixed in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:07:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTM2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959360", "bodyText": "given that this is a FeedRange for a partition key, is the returned List always a List of size 1?", "author": "moderakh", "createdAt": "2021-01-14T00:10:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangePartitionKeyImpl.java", "diffHunk": "@@ -30,73 +37,125 @@ public PartitionKeyInternal getPartitionKeyInternal() {\n     }\n \n     @Override\n-    public void accept(FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n-    }\n-\n-    @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangePartitionKeyImpl that = (FeedRangePartitionKeyImpl)o;\n+        return Objects.equals(this.partitionKey, that.partitionKey);\n     }\n \n     @Override\n-    public <T> Mono<T> accept(FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public int hashCode() {\n+        return Objects.hash(partitionKey);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n+    public Mono<Range<String>> getEffectiveRange(\n         IRoutingMapProvider routingMapProvider,\n-        String containerRid,\n-        PartitionKeyDefinition partitionKeyDefinition) {\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n \n-        String effectivePartitionKey = this.partitionKey.getEffectivePartitionKeyString(\n-            this.partitionKey,\n-            partitionKeyDefinition);\n-        Range<String> range = Range.getPointRange(effectivePartitionKey);\n-        ArrayList<Range<String>> rangeList = new ArrayList<>();\n-        rangeList.add(range);\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n \n-        return Mono.just((UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(rangeList));\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String effectivePartitionKey =\n+                    this.partitionKey.getEffectivePartitionKeyString(\n+                    this.partitionKey,\n+                    collection.getPartitionKey());\n+\n+                Range<String> range = Range.getPointRange(effectivePartitionKey);\n+                return Mono.just(range);\n+            });\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n+    public Mono<List<String>> getPartitionKeyRanges(", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1ODQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557758499", "bodyText": "Yes - only for the Epk overload it could contain multiple ranges.", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTk5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556959990", "bodyText": "as per reactive-stream contract null value is not permissible, so this is always true.\nperhaps you want to check pkRangeHolder.v != null ?", "author": "moderakh", "createdAt": "2021-01-14T00:12:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc4NzYxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557787610", "bodyText": "Fixed in next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-15T00:30:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk1OTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk2MDMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r556960304", "bodyText": "we will never hit here. as explained above null is not a permissible value for reactive-stream", "author": "moderakh", "createdAt": "2021-01-14T00:13:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/feedranges/FeedRangeEpkImpl.java", "diffHunk": "@@ -3,125 +3,253 @@\n \n package com.azure.cosmos.implementation.feedranges;\n \n+import com.azure.cosmos.BridgeInternal;\n import com.azure.cosmos.implementation.Constants;\n+import com.azure.cosmos.implementation.DocumentCollection;\n+import com.azure.cosmos.implementation.GoneException;\n+import com.azure.cosmos.implementation.HttpConstants;\n import com.azure.cosmos.implementation.IRoutingMapProvider;\n+import com.azure.cosmos.implementation.JsonSerializable;\n+import com.azure.cosmos.implementation.MetadataDiagnosticsContext;\n+import com.azure.cosmos.implementation.NotFoundException;\n import com.azure.cosmos.implementation.PartitionKeyRange;\n+import com.azure.cosmos.implementation.ReadFeedKeyType;\n+import com.azure.cosmos.implementation.RxDocumentServiceRequest;\n+import com.azure.cosmos.implementation.Utils;\n import com.azure.cosmos.implementation.apachecommons.collections.list.UnmodifiableList;\n import com.azure.cosmos.implementation.routing.PartitionKeyInternalHelper;\n+import com.azure.cosmos.implementation.routing.PartitionKeyRangeIdentity;\n import com.azure.cosmos.implementation.routing.Range;\n import com.azure.cosmos.models.ModelBridgeInternal;\n-import com.azure.cosmos.models.PartitionKeyDefinition;\n import reactor.core.publisher.Mono;\n \n import java.util.ArrayList;\n import java.util.List;\n+import java.util.Map;\n import java.util.Objects;\n \n import static com.azure.cosmos.BridgeInternal.setProperty;\n import static com.azure.cosmos.implementation.guava25.base.Preconditions.checkNotNull;\n \n-final class FeedRangeEpkImpl extends FeedRangeInternal {\n+public final class FeedRangeEpkImpl extends FeedRangeInternal {\n     private static final FeedRangeEpkImpl fullRangeEPK =\n         new FeedRangeEpkImpl(PartitionKeyInternalHelper.FullRange);\n \n     private final Range<String> range;\n-    private final UnmodifiableList<Range<String>> rangeList;\n \n     public FeedRangeEpkImpl(final Range<String> range) {\n         checkNotNull(range, \"Argument 'range' must not be null\");\n         this.range = range;\n-        final ArrayList<Range<String>> temp = new ArrayList<>();\n-        temp.add(range);\n-\n-        this.rangeList = (UnmodifiableList<Range<String>>)UnmodifiableList.unmodifiableList(temp);\n     }\n \n     public Range<String> getRange() {\n         return this.range;\n     }\n \n-    public static FeedRangeEpkImpl forFullRange() {\n-        return fullRangeEPK;\n-    }\n-\n     @Override\n-    public void accept(final FeedRangeVisitor visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this);\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        FeedRangeEpkImpl that = (FeedRangeEpkImpl)o;\n+        return Objects.equals(this.range, that.range);\n     }\n \n     @Override\n-    public <TInput> void accept(GenericFeedRangeVisitor<TInput> visitor, TInput input) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        visitor.visit(this, input);\n+    public int hashCode() {\n+        return Objects.hash(range);\n     }\n \n-    @Override\n-    public <T> Mono<T> accept(final FeedRangeAsyncVisitor<T> visitor) {\n-        checkNotNull(visitor, \"Argument 'visitor' must not be null\");\n-        return visitor.visit(this);\n+    public static FeedRangeEpkImpl forFullRange() {\n+        return fullRangeEPK;\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<Range<String>>> getEffectiveRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n+    public Mono<Range<String>> getEffectiveRange(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n \n-        return Mono.just(this.rangeList);\n+        return Mono.just(this.range);\n     }\n \n     @Override\n-    public Mono<UnmodifiableList<String>> getPartitionKeyRanges(\n-        final IRoutingMapProvider routingMapProvider,\n-        final String containerRid,\n-        final PartitionKeyDefinition partitionKeyDefinition) {\n-\n-        return routingMapProvider\n-            .tryGetOverlappingRangesAsync(\n-                null,\n-                containerRid,\n-                this.range,\n-                false,\n-                null)\n-            .flatMap(pkRangeHolder -> {\n-                final ArrayList<String> rangeList = new ArrayList<>();\n-\n-                if (pkRangeHolder != null) {\n-                    final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n-                    for (final PartitionKeyRange pkRange : pkRanges) {\n-                        rangeList.add(pkRange.getId());\n-                    }\n+    public Mono<List<String>> getPartitionKeyRanges(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n                 }\n \n-                return Mono.just((UnmodifiableList<String>)UnmodifiableList.unmodifiableList(rangeList));\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        final ArrayList<String> rangeList = new ArrayList<>();\n+\n+                        if (pkRangeHolder != null) {\n+                            final List<PartitionKeyRange> pkRanges = pkRangeHolder.v;\n+                            for (final PartitionKeyRange pkRange : pkRanges) {\n+                                rangeList.add(pkRange.getId());\n+                            }\n+                        }\n+\n+                        return Mono.just(UnmodifiableList.unmodifiableList(rangeList));\n+                    });\n             });\n     }\n \n     @Override\n-    public String toString() {\n-        return this.range.toString();\n+    public Mono<RxDocumentServiceRequest> populateFeedRangeFilteringHeaders(\n+        IRoutingMapProvider routingMapProvider,\n+        RxDocumentServiceRequest request,\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionResolutionMono) {\n+\n+        checkNotNull(\n+            routingMapProvider,\n+            \"Argument 'routingMapProvider' must not be null\");\n+        checkNotNull(\n+            request,\n+            \"Argument 'request' must not be null\");\n+        checkNotNull(\n+            collectionResolutionMono,\n+            \"Argument 'collectionResolutionMono' must not be null\");\n+\n+        MetadataDiagnosticsContext metadataDiagnosticsCtx =\n+            BridgeInternal.getMetaDataDiagnosticContext(request.requestContext.cosmosDiagnostics);\n+\n+        return collectionResolutionMono\n+            .flatMap(documentCollectionResourceResponse -> {\n+\n+                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                if (collection == null) {\n+                    throw new IllegalStateException(\"Collection cannot be null\");\n+                }\n+\n+                final String containerRid = collection.getResourceId();\n+\n+                return routingMapProvider\n+                    .tryGetOverlappingRangesAsync(\n+                        metadataDiagnosticsCtx,\n+                        containerRid,\n+                        this.range,\n+                        false,\n+                        null)\n+                    .flatMap(pkRangeHolder -> {\n+                        if (pkRangeHolder == null) {", "originalCommit": "35a901f6049e17632ffa7ce65b9dca9b8feaa861", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc1OTM2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/18056#discussion_r557759362", "bodyText": "Fixed in the next iteration", "author": "FabianMeiswinkel", "createdAt": "2021-01-14T23:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njk2MDMwNA=="}], "type": "inlineReview"}, {"oid": "5e75d98ae1335b405bfcea7e25c3347e8ded2955", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e75d98ae1335b405bfcea7e25c3347e8ded2955", "message": "Actually adding public APIs for queryChangeFeed", "committedDate": "2021-01-14T13:44:14Z", "type": "commit"}, {"oid": "32ae487783147ddff57335d498d93cdb961764d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32ae487783147ddff57335d498d93cdb961764d2", "message": "Adding public API in CosmosContainer and SomsosAsyncContainer for CF pull model", "committedDate": "2021-01-14T22:03:49Z", "type": "commit"}, {"oid": "c955cc6414ae453db61d5961a79fec19ed3692e4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c955cc6414ae453db61d5961a79fec19ed3692e4", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into users/fabianm/cfpullWithFeedRanges", "committedDate": "2021-01-14T23:14:14Z", "type": "commit"}, {"oid": "ce2bae2375b12ce3a6a0bf0363424c3960d01651", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ce2bae2375b12ce3a6a0bf0363424c3960d01651", "message": "Reacting to CR comments", "committedDate": "2021-01-14T23:14:39Z", "type": "commit"}, {"oid": "af1469e110210d881e055e43478917ff7a35ba74", "url": "https://github.com/Azure/azure-sdk-for-java/commit/af1469e110210d881e055e43478917ff7a35ba74", "message": "SpotBug fixes", "committedDate": "2021-01-15T00:24:38Z", "type": "commit"}, {"oid": "8bb6f603fcd577ce1267002d526243ad31d79f1b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bb6f603fcd577ce1267002d526243ad31d79f1b", "message": "Fixing JavaDoc bug", "committedDate": "2021-01-15T01:12:42Z", "type": "commit"}, {"oid": "1f99a86bf70af637551b38ffc351b652d16aa7b2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f99a86bf70af637551b38ffc351b652d16aa7b2", "message": "Reverting switch to @JsonDeserialize for custom deserializers", "committedDate": "2021-01-15T01:52:30Z", "type": "commit"}, {"oid": "32f22dde64d521e5b807b130b5a0d6134d501101", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32f22dde64d521e5b807b130b5a0d6134d501101", "message": "Iterating on code review comments", "committedDate": "2021-01-16T01:26:15Z", "type": "commit"}, {"oid": "eda9329d1448a7ea354373a68d84b0e2cf51b7da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eda9329d1448a7ea354373a68d84b0e2cf51b7da", "message": "Adding more unit tests", "committedDate": "2021-01-16T03:28:28Z", "type": "commit"}, {"oid": "d256919da1b9b7f37f1661965065f18e5944e5bb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d256919da1b9b7f37f1661965065f18e5944e5bb", "message": "Spotbug fix", "committedDate": "2021-01-16T03:31:14Z", "type": "commit"}, {"oid": "e2348cefb5e874f8cfc4d6d9780fc878e0f2d954", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2348cefb5e874f8cfc4d6d9780fc878e0f2d954", "message": "Fix for test failures in FeedRangeTest", "committedDate": "2021-01-16T03:54:29Z", "type": "commit"}, {"oid": "e386a2c5eeed388500ca90a27aa95fda6f72486c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e386a2c5eeed388500ca90a27aa95fda6f72486c", "message": "Fixing SpotBUg issue", "committedDate": "2021-01-16T04:25:21Z", "type": "commit"}, {"oid": "5c8eba5670d031f6c95fb1afebade53086324f33", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c8eba5670d031f6c95fb1afebade53086324f33", "message": "Fixing test issues", "committedDate": "2021-01-18T09:43:53Z", "type": "commit"}, {"oid": "3819b373c83f28f34cab1ea6d9450436bc3ff0c8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3819b373c83f28f34cab1ea6d9450436bc3ff0c8", "message": "Iterating on Cosmos Container ChangeFeed tests", "committedDate": "2021-01-18T12:02:31Z", "type": "commit"}, {"oid": "7e78972be6ae98b83f6d6389cacdb5c60521b478", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7e78972be6ae98b83f6d6389cacdb5c60521b478", "message": "Fixing test issue for small page size", "committedDate": "2021-01-18T12:15:48Z", "type": "commit"}, {"oid": "3d88840d627ba668669874db2c59faa71703d9c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d88840d627ba668669874db2c59faa71703d9c1", "message": "Adding addiitonal unit tests for change feed pull model", "committedDate": "2021-01-18T17:03:55Z", "type": "commit"}, {"oid": "ca796ce421934ed278f92218e3b0c63792c71d00", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ca796ce421934ed278f92218e3b0c63792c71d00", "message": "Adding remaining tests for CF pull model", "committedDate": "2021-01-18T17:29:07Z", "type": "commit"}]}