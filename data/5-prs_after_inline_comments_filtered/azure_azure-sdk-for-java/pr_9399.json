{"pr_number": 9399, "pr_title": "Adding throughput /latency workload for multi client", "pr_createdAt": "2020-03-23T15:53:26Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9399", "timeline": [{"oid": "4906a65c29280d9d9b2f4e6bb0477756cc7bba4e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4906a65c29280d9d9b2f4e6bb0477756cc7bba4e", "message": "adding test for multi client", "committedDate": "2020-03-20T22:37:49Z", "type": "commit"}, {"oid": "189a4797ee947fe43282900eb8fb05e007f6955e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/189a4797ee947fe43282900eb8fb05e007f6955e", "message": "Update README.md\n\nupdating read me", "committedDate": "2020-03-23T15:43:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3OTUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396579521", "bodyText": "please use logger, not System.out/err.\nPlease do everywhere.", "author": "moderakh", "createdAt": "2020-03-23T16:22:08Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMjYyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396732629", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3OTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MDI4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396580285", "bodyText": "please don't use System.out/err.\nuse logger here and elsewhere.", "author": "moderakh", "createdAt": "2020-03-23T16:23:07Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+                        System.out.println(\"Client have been initialized with data created for host \" + hostAndKey[0]);\n+                    } else {\n+                        System.out.println(\"Client have been initialized with host \" + hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            System.out.println(\"Total number of client created for ReadThroughputWithMultipleClient \" + clientDocsMap.size());\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzQ0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396743447", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MDI4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzA0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373040", "bodyText": "you still have e.printStackTrace() throughout the file. please fix everywhere.", "author": "moderakh", "createdAt": "2020-03-27T16:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MTk4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396581987", "bodyText": "we should be using logger everywhere. Please replace System.out with logger here and elsewhere.", "author": "moderakh", "createdAt": "2020-03-23T16:25:23Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+                        System.out.println(\"Client have been initialized with data created for host \" + hostAndKey[0]);", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMjY4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396732684", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4MTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NDMwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396584306", "bodyText": "please use try-with-resources to simplify the try/catch pattern:\nhttps://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html", "author": "moderakh", "createdAt": "2020-03-23T16:28:25Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MzUxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396743514", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NDMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NjIzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396586239", "bodyText": "fix code style.", "author": "moderakh", "createdAt": "2020-03-23T16:31:04Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughPutForMultiClientValue = StringUtils.defaultString(", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMjc3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396732774", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU4NjIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MDkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396590901", "bodyText": "it seems you are using isDeleteCollections for not only deleting collections but also for creating collection?\nis that right? the config seems to be overloaded.", "author": "moderakh", "createdAt": "2020-03-23T16:37:25Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNzc5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396737798", "bodyText": "during deleteCollections workload we don't want to create db/collection/data . createClient method during initialization will create client/db/container/data.", "author": "simplynaveen20", "createdAt": "2020-03-23T20:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MDkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0NTI0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399445245", "bodyText": "discussed offline", "author": "simplynaveen20", "createdAt": "2020-03-27T17:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MDkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTEwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396591105", "bodyText": "it seems you are using deleteCollections for not only deleting collections but also for creating collection?\nis that right? the config seems to be overloaded.", "author": "moderakh", "createdAt": "2020-03-23T16:37:44Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -76,8 +76,15 @@\n     @Parameter(names = \"-enableJvmStats\", description = \"Enables JVM Stats\")\n     private boolean enableJvmStats;\n \n+    @Parameter(names = \"-throughPutForMultiClientTest\", description = \"throughput on each container for multi client test\")\n+    private int throughPutForMultiClient = 100000;\n+\n+    @Parameter(names = \"-deleteCollections\", description = \"Delete collections on all client with collectionId mentioned in the tool\")", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczNzcxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396737715", "bodyText": "during deleteCollections workload we don't want to create db/collection/data . createClient method during initialization will create client/db/container/data.", "author": "simplynaveen20", "createdAt": "2020-03-23T20:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4Mjc2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399382768", "bodyText": "two comments:\n\nawesome, it is a good idea to automatically create and delete the collection, this will be useful for non multi client scenarios as well. Could you please extend to the non multi client scenario as well.\nthe description of the parameter and its name doesn't reflect what this is doing (how about autoContainerCreationEnabled\nalso we should change throughputForMultiClient to throughput to make it applicable to non multi client scenario as well.", "author": "moderakh", "createdAt": "2020-03-27T16:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTEwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0NTA5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399445090", "bodyText": "discussed offline , new PR on benchmark will use autoCreateColection for all work flow", "author": "simplynaveen20", "createdAt": "2020-03-27T17:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5Mjk1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396592956", "bodyText": "meterRegistry is a static setting, why do we need to set it \"inside\" the for loop? shouldn't this be outside?", "author": "moderakh", "createdAt": "2020-03-23T16:40:21Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMzgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396733819", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5Mjk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MzQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396593445", "bodyText": "meterRegistry is a static setting, why do we need to set it \"inside\" the for loop? shouldn't this be outside?", "author": "moderakh", "createdAt": "2020-03-23T16:41:00Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,299 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            System.out.println(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        BufferedReader br = null;\n+        String line = \"\";\n+        String splitBy = \",\";\n+        try {\n+            br = new BufferedReader(new FileReader(csvFile));\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length == 2) {\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(hostAndKey[0])\n+                        .key(hostAndKey[1])\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+                        MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);\n+                        }\n+\n+                        registry = configuration.getGraphiteMeterRegistry();\n+\n+                        if (registry != null) {\n+                            BridgeInternal.monitorTelemetry(registry);", "originalCommit": "189a4797ee947fe43282900eb8fb05e007f6955e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjczMzc0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r396733749", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-23T20:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MzQ0NQ=="}], "type": "inlineReview"}, {"oid": "5168bca395ecd951be6374f3dc5e453c080622da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5168bca395ecd951be6374f3dc5e453c080622da", "message": "Merge branch 'latest-master' into users/nakumars/customeBenchMarkFOrMultiAccount", "committedDate": "2020-03-23T18:10:55Z", "type": "commit"}, {"oid": "88b54c96ef3cd9f184ad95aff91a8beace7487b8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/88b54c96ef3cd9f184ad95aff91a8beace7487b8", "message": "resolving comments", "committedDate": "2020-03-23T20:19:45Z", "type": "commit"}, {"oid": "82d075b7ce5202803f1ca01837131a77de01b558", "url": "https://github.com/Azure/azure-sdk-for-java/commit/82d075b7ce5202803f1ca01837131a77de01b558", "message": "Merge branch 'users/nakumars/customeBenchMarkFOrMultiAccount' of https://github.com/simplynaveen20/azure-sdk-for-java into users/nakumars/customeBenchMarkFOrMultiAccount", "committedDate": "2020-03-23T20:20:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzI4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373285", "bodyText": "ditto, we should be using logger.error", "author": "moderakh", "createdAt": "2020-03-27T16:04:24Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            registry = configuration.getGraphiteMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            logger.info(\"Total number of client created for ReadThroughputWithMultipleClient {}\",clientDocsMap.size());\n+        } catch (FileNotFoundException e) {\n+            e.printStackTrace();\n+        } catch (IOException e) {\n+            e.printStackTrace();", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3MzUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373521", "bodyText": "please fix indentation to be consistent with the rest", "author": "moderakh", "createdAt": "2020-03-27T16:04:48Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -76,8 +76,15 @@\n     @Parameter(names = \"-enableJvmStats\", description = \"Enables JVM Stats\")\n     private boolean enableJvmStats;\n \n+    @Parameter(names = \"-throughputForMultiClientTest\", description = \"throughput on each container for multi client test\")\n+    private int throughputForMultiClient = 100000;\n+\n+    @Parameter(names = \"-deleteCollections\", description = \"Delete collections on all client with collectionId mentioned in the tool\")\n+    private boolean deleteCollections = false;\n+\n     @Parameter(names = \"-operation\", description = \"Type of Workload:\\n\"\n             + \"\\tReadThroughput- run a READ workload that prints only throughput *\\n\"\n+\t\t\t+ \"\\tReadThroughputWithMultipleClients - run a READ workload that prints throughput and latency for multiple client read.*\\n\"", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Mzk2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399373964", "bodyText": "code style: you have multiple spaces String  throughputForMultiClientValue -> String throughputForMultiClientValue", "author": "moderakh", "createdAt": "2020-03-27T16:05:29Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughputForMultiClientValue = StringUtils.defaultString(", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NDEyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399374122", "bodyText": "code style: space after comma", "author": "moderakh", "createdAt": "2020-03-27T16:05:43Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/Configuration.java", "diffHunk": "@@ -359,6 +375,10 @@ void tryGetValuesFromSystem() {\n         String numberOfOperationsValue = StringUtils.defaultString(\n                 Strings.emptyToNull(System.getenv().get(\"NUMBER_OF_OPERATIONS\")), Integer.toString(numberOfOperations));\n         numberOfOperations = Integer.parseInt(numberOfOperationsValue);\n+\n+        String  throughputForMultiClientValue = StringUtils.defaultString(\n+                Strings.emptyToNull(System.getenv().get(\"THROUGHPUT_MULTICLIENT\")),Integer.toString(throughputForMultiClient));", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzI2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377265", "bodyText": "this will print the key as well. can we just print the endpoint. ideally we should not log key anywhere in the log.", "author": "moderakh", "createdAt": "2020-03-27T16:10:22Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0MDkzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399440938", "bodyText": "discussed offline", "author": "moderakh", "createdAt": "2020-03-27T17:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377391", "bodyText": "ditto. we should not log the key", "author": "moderakh", "createdAt": "2020-03-27T16:10:33Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0MTAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399441034", "bodyText": "discussed offline", "author": "moderakh", "createdAt": "2020-03-27T17:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Nzc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399377762", "bodyText": "codestyle: space after comma\nplease use intellij autoformatting on this new file.", "author": "moderakh", "createdAt": "2020-03-27T16:11:08Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            registry = configuration.getGraphiteMeterRegistry();\n+\n+            if (registry != null) {\n+                BridgeInternal.monitorTelemetry(registry);\n+            }\n+\n+            logger.info(\"Total number of client created for ReadThroughputWithMultipleClient {}\",clientDocsMap.size());", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399378672", "bodyText": "setting metrics registery should be outside of try/catch block. not related to connection string parsing.", "author": "moderakh", "createdAt": "2020-03-27T16:12:32Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();\n+                        String partitionKey = cosmosAsyncContainer.read().block().getProperties().getPartitionKeyDefinition()\n+                            .getPaths().iterator().next().split(\"/\")[1];\n+                        String dataFieldValue = RandomStringUtils.randomAlphabetic(this.configuration.getDocumentDataFieldSize());\n+                        ArrayList<Flux<PojoizedJson>> createDocumentObservables = new ArrayList<>();\n+\n+                        for (int i = 0; i < this.configuration.getNumberOfPreCreatedDocuments(); i++) {\n+                            String uuid = UUID.randomUUID().toString();\n+                            com.azure.cosmos.benchmark.PojoizedJson newDoc = generateDocument(uuid, dataFieldValue, partitionKey);\n+\n+                            Flux<PojoizedJson> obs = cosmosAsyncContainer.createItem(newDoc).map(resp -> {\n+                                    com.azure.cosmos.benchmark.PojoizedJson x =\n+                                        resp.getItem();\n+                                    return x;\n+                                }\n+                            ).flux();\n+                            createDocumentObservables.add(obs);\n+                        }\n+                        docsToRead = Flux.merge(Flux.fromIterable(createDocumentObservables), 100).collectList().block();\n+\n+                        logger.info(\"Client have been initialized with data created for host {}\", hostAndKey[0]);\n+                    } else {\n+                        logger.info(\"Client have been initialized with host {}\", hostAndKey[0]);\n+                    }\n+                    clientDocsMap.put(asyncClient, docsToRead);\n+                }\n+            }\n+            MeterRegistry registry = configuration.getAzureMonitorMeterRegistry();", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0NDQzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399444439", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-03-27T17:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3ODY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MDYyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399380624", "bodyText": "if we are creating the collection, we should allow the throughput to be configurable similar to collectionId and databaseId.", "author": "moderakh", "createdAt": "2020-03-27T16:15:24Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";\n+    private final static String ACCOUNT_ENDPOINT_TAG = \"AccountEndpoint=\";\n+    private final static String ACCOUNT_KEY_TAG = \"AccountKey=\";\n+    private final Semaphore concurrencyControlSemaphore;\n+    private final Logger logger;\n+    private final Configuration configuration;\n+    private MetricRegistry metricsRegistry = new MetricRegistry();\n+    private ScheduledReporter reporter;\n+    private Meter successMeter;\n+    private Meter failureMeter;\n+    private Timer latency;\n+    private Map<CosmosAsyncClient, List<PojoizedJson>> clientDocsMap = new HashMap<>();\n+\n+    AsynReadWithMultipleClients(Configuration cfg) {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+        this.configuration = cfg;\n+        createClients();\n+        if (configuration.getGraphiteEndpoint() != null) {\n+            final Graphite graphite = new Graphite(new InetSocketAddress(configuration.getGraphiteEndpoint(), configuration.getGraphiteEndpointPort()));\n+            reporter = GraphiteReporter.forRegistry(metricsRegistry)\n+                .prefixedWith(configuration.getOperationType().name())\n+                .convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS)\n+                .filter(MetricFilter.ALL)\n+                .build(graphite);\n+        } else {\n+            reporter = ConsoleReporter.forRegistry(metricsRegistry).convertRatesTo(TimeUnit.SECONDS)\n+                .convertDurationsTo(TimeUnit.MILLISECONDS).build();\n+        }\n+        concurrencyControlSemaphore = new Semaphore(cfg.getConcurrency());\n+    }\n+\n+    void deleteCollection() {\n+        try {\n+            for (CosmosAsyncClient cosmosAsyncClient : clientDocsMap.keySet()) {\n+                cosmosAsyncClient.getDatabase(configuration.getDatabaseId()).getContainer(configuration.getCollectionId()).delete().block();\n+            }\n+        } catch (CosmosClientException e) {\n+            if (e.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                // It can happen if container does not exist, normal scenario\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            logger.info(\"Container on all client have been deleted successfully\");\n+        }\n+    }\n+\n+    void run() throws Exception {\n+        successMeter = metricsRegistry.meter(\"#Successful Operations\");\n+        failureMeter = metricsRegistry.meter(\"#Unsuccessful Operations\");\n+        latency = metricsRegistry.timer(\"Latency\");\n+        reporter.start(configuration.getPrintingInterval(), TimeUnit.SECONDS);\n+        AtomicLong count = new AtomicLong(0);\n+        long i;\n+        long startTime = System.currentTimeMillis();\n+        for (i = 0; shouldContinue(startTime, i); i++) {\n+\n+            BaseSubscriber<PojoizedJson> baseSubscriber = new BaseSubscriber<PojoizedJson>() {\n+                @Override\n+                protected void hookOnSubscribe(Subscription subscription) {\n+                    super.hookOnSubscribe(subscription);\n+                }\n+\n+                @Override\n+                protected void hookOnNext(PojoizedJson value) {\n+                    logger.debug(\"hookOnNext: {}, count:{}\", value, count.get());\n+                }\n+\n+                @Override\n+                protected void hookOnCancel() {\n+                    this.hookOnError(new CancellationException());\n+                }\n+\n+                @Override\n+                protected void hookOnComplete() {\n+                    successMeter.mark();\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onSuccess();\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+\n+                @Override\n+                protected void hookOnError(Throwable throwable) {\n+                    failureMeter.mark();\n+                    logger.error(\"Encountered failure {} on thread {}\",\n+                        throwable.getMessage(), Thread.currentThread().getName(), throwable);\n+                    concurrencyControlSemaphore.release();\n+                    AsynReadWithMultipleClients.this.onError(throwable);\n+\n+                    synchronized (count) {\n+                        count.incrementAndGet();\n+                        count.notify();\n+                    }\n+                }\n+            };\n+\n+            performWorkload(baseSubscriber, i);\n+        }\n+        synchronized (count) {\n+            while (count.get() < i) {\n+                count.wait();\n+            }\n+        }\n+\n+        long endTime = System.currentTimeMillis();\n+        logger.info(\"[{}] operations performed in [{}] seconds.\",\n+            configuration.getNumberOfOperations(), (int) ((endTime - startTime) / 1000));\n+\n+        reporter.report();\n+        reporter.close();\n+    }\n+\n+    void shutdown() {\n+        for (CosmosAsyncClient asyncClient : clientDocsMap.keySet()) {\n+            asyncClient.close();\n+        }\n+    }\n+\n+    protected void onSuccess() {\n+    }\n+\n+    protected void onError(Throwable throwable) {\n+    }\n+\n+    private PojoizedJson generateDocument(String idString, String dataFieldValue, String partitionKey) {\n+        com.azure.cosmos.benchmark.PojoizedJson instance = new com.azure.cosmos.benchmark.PojoizedJson();\n+        Map<String, String> properties = instance.getInstance();\n+        properties.put(\"id\", idString);\n+        properties.put(partitionKey, idString);\n+\n+        for (int i = 0; i < configuration.getDocumentDataFieldCount(); i++) {\n+            properties.put(\"dataField\" + i, dataFieldValue);\n+        }\n+\n+        return instance;\n+    }\n+\n+    private boolean shouldContinue(long startTimeMillis, long iterationCount) {\n+\n+        Duration maxDurationTime = configuration.getMaxRunningTimeDuration();\n+        int maxNumberOfOperations = configuration.getNumberOfOperations();\n+\n+        if (maxDurationTime == null) {\n+            return iterationCount < maxNumberOfOperations;\n+        }\n+\n+        if (startTimeMillis + maxDurationTime.toMillis() < System.currentTimeMillis()) {\n+            return false;\n+        }\n+\n+        if (maxNumberOfOperations < 0) {\n+            return true;\n+        }\n+\n+        return iterationCount < maxNumberOfOperations;\n+    }\n+\n+    private void createClients() {\n+        String csvFile = \"clientHostAndKey.txt\";\n+        String line = \"\";\n+        String splitBy = \";\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(csvFile))) {\n+            while ((line = br.readLine()) != null) {\n+                String[] hostAndKey = line.split(splitBy);\n+                if (hostAndKey.length >= 2) {\n+                    String endpoint = hostAndKey[0].substring(hostAndKey[0].indexOf(ACCOUNT_ENDPOINT_TAG) + ACCOUNT_ENDPOINT_TAG.length());\n+                    String key = hostAndKey[1].substring(hostAndKey[1].indexOf(ACCOUNT_KEY_TAG) + ACCOUNT_KEY_TAG.length());\n+                    CosmosAsyncClient asyncClient = new CosmosClientBuilder()\n+                        .endpoint(endpoint)\n+                        .key(key)\n+                        .connectionPolicy(configuration.getConnectionPolicy())\n+                        .consistencyLevel(configuration.getConsistencyLevel())\n+                        .connectionReuseAcrossClientsEnabled(true)\n+                        .buildAsyncClient();\n+                    List<PojoizedJson> docsToRead = new ArrayList<>();\n+                    if (!configuration.isDeleteCollections()) {\n+                        CosmosAsyncDatabase cosmosAsyncDatabase = asyncClient.createDatabaseIfNotExists(this.configuration.getDatabaseId()).block().getDatabase();\n+                        CosmosAsyncContainer cosmosAsyncContainer = cosmosAsyncDatabase.createContainerIfNotExists(configuration.getCollectionId(), PARTITION_KEY, 100000).block().getContainer();", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0NDE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399444162", "bodyText": "it meant to be , had created configuration property for it .It was missed during usage , fixed it .", "author": "simplynaveen20", "createdAt": "2020-03-27T17:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MDYyNA=="}], "type": "inlineReview"}, {"oid": "43acc71a0477db1baa2c1a90cdc34183ee5b63e9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/43acc71a0477db1baa2c1a90cdc34183ee5b63e9", "message": "Merge branch 'latest-master' into users/nakumars/customeBenchMarkFOrMultiAccount", "committedDate": "2020-03-27T16:47:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzNzk0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399437943", "bodyText": "we should either make this configurable or fail if the existing collection partition key path is not /pk", "author": "moderakh", "createdAt": "2020-03-27T17:45:48Z", "path": "sdk/cosmos/azure-cosmos-benchmark/src/main/java/com/azure/cosmos/benchmark/AsynReadWithMultipleClients.java", "diffHunk": "@@ -0,0 +1,295 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.cosmos.benchmark;\n+\n+import com.azure.cosmos.BridgeInternal;\n+import com.azure.cosmos.CosmosAsyncClient;\n+import com.azure.cosmos.CosmosAsyncContainer;\n+import com.azure.cosmos.CosmosAsyncDatabase;\n+import com.azure.cosmos.CosmosClientBuilder;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.implementation.HttpConstants;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.codahale.metrics.ConsoleReporter;\n+import com.codahale.metrics.Meter;\n+import com.codahale.metrics.MetricFilter;\n+import com.codahale.metrics.MetricRegistry;\n+import com.codahale.metrics.ScheduledReporter;\n+import com.codahale.metrics.Timer;\n+import com.codahale.metrics.graphite.Graphite;\n+import com.codahale.metrics.graphite.GraphiteReporter;\n+import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.BaseSubscriber;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.io.BufferedReader;\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.CancellationException;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class AsynReadWithMultipleClients<T> {\n+    private final static String PARTITION_KEY = \"/pk\";", "originalCommit": "82d075b7ce5202803f1ca01837131a77de01b558", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ0MDczNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9399#discussion_r399440735", "bodyText": "discussed offline.", "author": "moderakh", "createdAt": "2020-03-27T17:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQzNzk0Mw=="}], "type": "inlineReview"}, {"oid": "2648b1d2dd29d27f9f7087755a9238f7b0180600", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2648b1d2dd29d27f9f7087755a9238f7b0180600", "message": "resolving comments", "committedDate": "2020-03-27T17:55:10Z", "type": "commit"}]}