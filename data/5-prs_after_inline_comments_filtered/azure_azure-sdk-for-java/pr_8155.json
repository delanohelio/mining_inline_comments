{"pr_number": 8155, "pr_title": "Prototype for Service Bus Track 2 Queue Receiver/Sender", "pr_createdAt": "2020-02-12T22:41:23Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8155", "timeline": [{"oid": "5a07c740bfbfc90482b01a6b21f686e3e3ea5eae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5a07c740bfbfc90482b01a6b21f686e3e3ea5eae", "message": "prototype to send single message to queue.", "committedDate": "2020-01-29T23:59:50Z", "type": "commit"}, {"oid": "3b7d1a2e51eef0fd14938f4f22a5f4309ffc0ab1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3b7d1a2e51eef0fd14938f4f22a5f4309ffc0ab1", "message": "Option 1 API  for review", "committedDate": "2020-02-09T19:10:40Z", "type": "commit"}, {"oid": "6ef4cd13eece98b17539b21e2c26eafb940c19ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ef4cd13eece98b17539b21e2c26eafb940c19ca", "message": "added missing defer function", "committedDate": "2020-02-09T19:34:13Z", "type": "commit"}, {"oid": "004015abe40bb460906e5544433d1d13e17305bb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/004015abe40bb460906e5544433d1d13e17305bb", "message": "Cleaning up classes", "committedDate": "2020-02-12T19:16:03Z", "type": "commit"}, {"oid": "9d41c253bbac7027eef66a600392f154bd0b05b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d41c253bbac7027eef66a600392f154bd0b05b4", "message": "pom version change", "committedDate": "2020-02-12T20:59:15Z", "type": "commit"}, {"oid": "2526ba140d1b6de3200b5ec2d8468273b88a7406", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2526ba140d1b6de3200b5ec2d8468273b88a7406", "message": "Merge branch 'feature/servicebus-track2-queuec-client-api-7697' into feature/servicebus-track2-queuec-client-draft-implementation-7697", "committedDate": "2020-02-12T21:05:09Z", "type": "commit"}, {"oid": "24498f33c62a811dd7d3060237c9a94afcc0fc9c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/24498f33c62a811dd7d3060237c9a94afcc0fc9c", "message": "Initian draft of Service bus Queue Sender and Receiver", "committedDate": "2020-02-12T21:54:53Z", "type": "commit"}, {"oid": "f9be02cff7ad638461ec39573355429f8e39bfd1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9be02cff7ad638461ec39573355429f8e39bfd1", "message": "Removed unwanted classes", "committedDate": "2020-02-12T22:38:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2Mjg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378562889", "bodyText": "This is a feature which is requested by customer where SDK calculate max size allowed for a batch message and warn client if their messages are larger than max allowed size.", "author": "hemanttanwar", "createdAt": "2020-02-12T23:00:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,254 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ *\n+\n+ *     producer.\n+ */\n+ final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;", "originalCommit": "f9be02cff7ad638461ec39573355429f8e39bfd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2NDUzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378564537", "bodyText": "Do we have a concept of message batch in service bus? If this isn't part of a feature we have committed to, we shouldn't add it in. I don't see it anywhere in the .NET SDK. There should be a discussion on how to expose this feature in SB.", "author": "conniey", "createdAt": "2020-02-12T23:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2Mjg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU3MzAyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378573026", "bodyText": "Yes https://docs.microsoft.com/en-us/java/api/com.microsoft.azure.servicebus.queueclient.sendbatch?view=azure-java-stable", "author": "hemanttanwar", "createdAt": "2020-02-12T23:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2Mjg4OQ=="}], "type": "inlineReview"}, {"oid": "52acfcacaab6feb0b7e39240f8dc4d192459da2c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/52acfcacaab6feb0b7e39240f8dc4d192459da2c", "message": "added unreleased version in version.txtfor core amqp", "committedDate": "2020-02-12T23:19:41Z", "type": "commit"}, {"oid": "e4251159db0f6e6b4ecfd545d8029af63a8cb2d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e4251159db0f6e6b4ecfd545d8029af63a8cb2d0", "message": "added unreleased version in version.txt for core amqp", "committedDate": "2020-02-13T00:07:06Z", "type": "commit"}, {"oid": "af69232aa55c3f4a3892d2c4558d124c4d731585", "url": "https://github.com/Azure/azure-sdk-for-java/commit/af69232aa55c3f4a3892d2c4558d124c4d731585", "message": "adding draft documentation", "committedDate": "2020-02-13T00:39:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNTM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378605343", "bodyText": "Why is this static field here?", "author": "conniey", "createdAt": "2020-02-13T01:24:04Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ClientConstants.java", "diffHunk": "@@ -3,10 +3,13 @@\n \n package com.azure.core.amqp.implementation;\n \n+import java.time.Duration;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNTk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378605977", "bodyText": "is there a reason we're adding transitive here?", "author": "conniey", "createdAt": "2020-02-13T01:26:25Z", "path": "sdk/core/azure-core-amqp/src/main/java/module-info.java", "diffHunk": "@@ -3,18 +3,23 @@\n \n module com.azure.core.amqp {\n     requires transitive com.azure.core;\n-    requires transitive reactor.core;\n \n-    requires com.microsoft.azure.qpid.protonj.extensions;\n-    requires proton.j;\n-    requires org.reactivestreams;\n+    requires transitive com.microsoft.azure.qpid.protonj.extensions;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2MjE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379262143", "bodyText": "transitive is  for implicit readability,  so in service bus I do not need to depend on it and it will be available implecitly.", "author": "hemanttanwar", "createdAt": "2020-02-14T05:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNjA5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378606093", "bodyText": "why are we adding this opens here?", "author": "conniey", "createdAt": "2020-02-13T01:26:50Z", "path": "sdk/core/azure-core-amqp/src/main/java/module-info.java", "diffHunk": "@@ -3,18 +3,23 @@\n \n module com.azure.core.amqp {\n     requires transitive com.azure.core;\n-    requires transitive reactor.core;\n \n-    requires com.microsoft.azure.qpid.protonj.extensions;\n-    requires proton.j;\n-    requires org.reactivestreams;\n+    requires transitive com.microsoft.azure.qpid.protonj.extensions;\n+    requires transitive proton.j;\n+    requires transitive org.reactivestreams;\n \n     exports com.azure.core.amqp;\n     exports com.azure.core.amqp.exception;\n \n     // FIXME this should not be a long-term solution\n     exports com.azure.core.amqp.implementation to\n+        com.azure.messaging.servicebus.implementation,\n+        com.azure.messaging.servicebus,\n         com.azure.messaging.eventhubs;\n+\n     exports com.azure.core.amqp.implementation.handler to\n+        com.azure.messaging.servicebus,\n         com.azure.messaging.eventhubs;\n+\n+    opens com.azure.core.amqp.implementation;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIxNjEzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379216139", "bodyText": "emoved", "author": "hemanttanwar", "createdAt": "2020-02-14T01:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNjA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNjE3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378606170", "bodyText": "nit: alphabetical order", "author": "conniey", "createdAt": "2020-02-13T01:27:05Z", "path": "sdk/core/azure-core-amqp/src/main/java/module-info.java", "diffHunk": "@@ -3,18 +3,23 @@\n \n module com.azure.core.amqp {\n     requires transitive com.azure.core;\n-    requires transitive reactor.core;\n \n-    requires com.microsoft.azure.qpid.protonj.extensions;\n-    requires proton.j;\n-    requires org.reactivestreams;\n+    requires transitive com.microsoft.azure.qpid.protonj.extensions;\n+    requires transitive proton.j;\n+    requires transitive org.reactivestreams;\n \n     exports com.azure.core.amqp;\n     exports com.azure.core.amqp.exception;\n \n     // FIXME this should not be a long-term solution\n     exports com.azure.core.amqp.implementation to\n+        com.azure.messaging.servicebus.implementation,", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNjYyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378606622", "bodyText": "nit: empty line", "author": "conniey", "createdAt": "2020-02-13T01:28:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus. Each Service Bus entity can\n+ * be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwNzUyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378607523", "bodyText": "nit: empty line.", "author": "conniey", "createdAt": "2020-02-13T01:32:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus. Each Service Bus entity can\n+ * be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param body The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] body) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param body The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code body} using UTF-8 charset.\n+     *\n+     * @param body The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    Message(byte[] body, SystemProperties systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties =  Objects.requireNonNull(systemProperties, \"'systemProperties' cannot be null.\");\n+        this.properties = new HashMap<>();\n+    }\n+\n+    /**\n+     * Gets the set of free-form event properties which may be used for passing metadata associated with the event with\n+     * the event body during Event Hubs operations. A common use-case for {@code properties()} is to associate\n+     * serialization hints for the {@link #getBody()} as an aid to consumers who wish to deserialize the binary data.\n+     *\n+     * <p><strong>Adding serialization hint using {@code getProperties()}</strong></p>\n+     * <p>In the sample, the type of telemetry is indicated by adding an application property with key \"eventType\".</p>\n+     *\n+     * @return Application properties associated with this {@link Message}.\n+     */\n+    public Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    /**\n+     * Properties that are populated by Event Hubs service. As these are populated by the Event Hubs service, they are\n+     * only present on a <b>received</b> {@link Message}.\n+     *\n+     * @return An encapsulation of all system properties appended by EventHubs service into {@link Message}.\n+     *     {@code null} if the {@link Message} is not received from the Event Hubs service.\n+     */\n+    public Map<String, Object> getSystemProperties() {\n+        return systemProperties;\n+    }\n+\n+    /**\n+     * Gets the actual payload/data wrapped by EventData.\n+     *\n+     * <p>\n+     * If the means for deserializing the raw data is not apparent to consumers, a common technique is to make use of\n+     * {@link #getProperties()} when creating the event, to associate serialization hints as an aid to consumers who\n+     * wish to deserialize the binary data.\n+     * </p>\n+     *\n+     * @return A byte array representing the data.\n+     */\n+    public byte[] getBody() {\n+        return Arrays.copyOf(body, body.length);\n+    }\n+\n+    /**\n+     * Returns event data as UTF-8 decoded string.\n+     *\n+     * @return UTF-8 decoded string representation of the event data.\n+     */\n+    public String getBodyAsString() {\n+        return new String(body, UTF_8);\n+    }\n+\n+    /**\n+     * Gets the partition hashing key if it was set when originally publishing the event. If it exists, this value was\n+     * used to compute a hash to select a partition to send the message to. This is only present on a <b>received</b>\n+     * {@link Message}.\n+     *\n+     * @return A partition key for this Event Data. {@code null} if the {@link Message} was not received from Event\n+     *     Hubs service or there was no partition key set when the event was sent to the Event Hub.\n+     */\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        Message message = (Message) o;\n+        return Arrays.equals(body, message.body);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(body);\n+    }\n+\n+    /**\n+     * A specified key-value pair of type {@link Context} to set additional information on the event.\n+     *\n+     * @return the {@link Context} object set on the event\n+     */\n+    Context getContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Adds a new key value pair to the existing context on Message.\n+     *\n+     * @param key The key for this context object\n+     * @param value The value for this context object.\n+     * @throws NullPointerException if {@code key} or {@code value} is null.\n+     * @return The updated {@link Message}.\n+     */\n+    public Message addContext(String key, Object value) {\n+        Objects.requireNonNull(key, \"The 'key' parameter cannot be null.\");\n+        Objects.requireNonNull(value, \"The 'value' parameter cannot be null.\");\n+        this.context = context.addData(key, value);\n+\n+        return this;\n+    }\n+\n+    public UUID getLockToken() {\n+        return lockToken;\n+    }\n+\n+    public void setLockToken(UUID lockToken) {\n+        this.lockToken = lockToken;\n+    }\n+", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwODUzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378608535", "bodyText": "Should we allow a user to set the lock token? this seems dangerous.", "author": "conniey", "createdAt": "2020-02-13T01:35:57Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,265 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus. Each Service Bus entity can\n+ * be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param body The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] body) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param body The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code body} using UTF-8 charset.\n+     *\n+     * @param body The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    Message(byte[] body, SystemProperties systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties =  Objects.requireNonNull(systemProperties, \"'systemProperties' cannot be null.\");\n+        this.properties = new HashMap<>();\n+    }\n+\n+    /**\n+     * Gets the set of free-form event properties which may be used for passing metadata associated with the event with\n+     * the event body during Event Hubs operations. A common use-case for {@code properties()} is to associate\n+     * serialization hints for the {@link #getBody()} as an aid to consumers who wish to deserialize the binary data.\n+     *\n+     * <p><strong>Adding serialization hint using {@code getProperties()}</strong></p>\n+     * <p>In the sample, the type of telemetry is indicated by adding an application property with key \"eventType\".</p>\n+     *\n+     * @return Application properties associated with this {@link Message}.\n+     */\n+    public Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    /**\n+     * Properties that are populated by Event Hubs service. As these are populated by the Event Hubs service, they are\n+     * only present on a <b>received</b> {@link Message}.\n+     *\n+     * @return An encapsulation of all system properties appended by EventHubs service into {@link Message}.\n+     *     {@code null} if the {@link Message} is not received from the Event Hubs service.\n+     */\n+    public Map<String, Object> getSystemProperties() {\n+        return systemProperties;\n+    }\n+\n+    /**\n+     * Gets the actual payload/data wrapped by EventData.\n+     *\n+     * <p>\n+     * If the means for deserializing the raw data is not apparent to consumers, a common technique is to make use of\n+     * {@link #getProperties()} when creating the event, to associate serialization hints as an aid to consumers who\n+     * wish to deserialize the binary data.\n+     * </p>\n+     *\n+     * @return A byte array representing the data.\n+     */\n+    public byte[] getBody() {\n+        return Arrays.copyOf(body, body.length);\n+    }\n+\n+    /**\n+     * Returns event data as UTF-8 decoded string.\n+     *\n+     * @return UTF-8 decoded string representation of the event data.\n+     */\n+    public String getBodyAsString() {\n+        return new String(body, UTF_8);\n+    }\n+\n+    /**\n+     * Gets the partition hashing key if it was set when originally publishing the event. If it exists, this value was\n+     * used to compute a hash to select a partition to send the message to. This is only present on a <b>received</b>\n+     * {@link Message}.\n+     *\n+     * @return A partition key for this Event Data. {@code null} if the {@link Message} was not received from Event\n+     *     Hubs service or there was no partition key set when the event was sent to the Event Hub.\n+     */\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        Message message = (Message) o;\n+        return Arrays.equals(body, message.body);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(body);\n+    }\n+\n+    /**\n+     * A specified key-value pair of type {@link Context} to set additional information on the event.\n+     *\n+     * @return the {@link Context} object set on the event\n+     */\n+    Context getContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Adds a new key value pair to the existing context on Message.\n+     *\n+     * @param key The key for this context object\n+     * @param value The value for this context object.\n+     * @throws NullPointerException if {@code key} or {@code value} is null.\n+     * @return The updated {@link Message}.\n+     */\n+    public Message addContext(String key, Object value) {\n+        Objects.requireNonNull(key, \"The 'key' parameter cannot be null.\");\n+        Objects.requireNonNull(value, \"The 'value' parameter cannot be null.\");\n+        this.context = context.addData(key, value);\n+\n+        return this;\n+    }\n+\n+    public UUID getLockToken() {\n+        return lockToken;\n+    }\n+\n+    public void setLockToken(UUID lockToken) {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTI4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609288", "bodyText": "The javadocs don't match up.", "author": "conniey", "createdAt": "2020-02-13T01:38:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ */\n+ final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;\n+    private final ErrorContextProvider contextProvider;\n+    private final List<Message> messageList;\n+    private final byte[] eventBytes;\n+    private int sizeInBytes;\n+    private final TracerProvider tracerProvider;\n+\n+    MessageBatch(int maxMessageSize, ErrorContextProvider contextProvider,\n+                 TracerProvider tracerProvider) {\n+        this.maxMessageSize = maxMessageSize;\n+\n+        this.contextProvider = contextProvider;\n+        this.messageList = new LinkedList<>();\n+        this.sizeInBytes = (maxMessageSize / 65536) * 1024; // reserve 1KB for every 64KB\n+        this.eventBytes = new byte[maxMessageSize];\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the number of {@link Message events} in the batch.\n+     *\n+     * @return The number of {@link Message events} in the batch.\n+     */\n+    public int getCount() {\n+        return messageList.size();\n+    }\n+\n+    /**\n+     * Gets the maximum size, in bytes, of the {@link MessageBatch}.\n+     *\n+     * @return The maximum size, in bytes, of the {@link MessageBatch}.\n+     */\n+    public int getMaxSizeInBytes() {\n+        return maxMessageSize;\n+    }\n+\n+    /**\n+     * Gets the size of the {@link MessageBatch} in bytes.\n+     *\n+     * @return the size of the {@link MessageBatch} in bytes.\n+     */\n+    public int getSizeInBytes() {\n+        return this.sizeInBytes;\n+    }\n+\n+    /**\n+     * Tries to add an {@link Message event} to the batch.\n+     *\n+     * @param message The {@link Message} to add to the batch.\n+     * @return {@code true} if the event could be added to the batch; {@code false} if the event was too large to fit in\n+     *     the batch.\n+     * @throws IllegalArgumentException if {@code eventData} is {@code null}.", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609399", "bodyText": "nit: extra line", "author": "conniey", "createdAt": "2020-02-13T01:39:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ */\n+ final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;\n+    private final ErrorContextProvider contextProvider;\n+    private final List<Message> messageList;\n+    private final byte[] eventBytes;\n+    private int sizeInBytes;\n+    private final TracerProvider tracerProvider;\n+\n+    MessageBatch(int maxMessageSize, ErrorContextProvider contextProvider,\n+                 TracerProvider tracerProvider) {\n+        this.maxMessageSize = maxMessageSize;\n+\n+        this.contextProvider = contextProvider;\n+        this.messageList = new LinkedList<>();\n+        this.sizeInBytes = (maxMessageSize / 65536) * 1024; // reserve 1KB for every 64KB\n+        this.eventBytes = new byte[maxMessageSize];\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the number of {@link Message events} in the batch.\n+     *\n+     * @return The number of {@link Message events} in the batch.\n+     */\n+    public int getCount() {\n+        return messageList.size();\n+    }\n+\n+    /**\n+     * Gets the maximum size, in bytes, of the {@link MessageBatch}.\n+     *\n+     * @return The maximum size, in bytes, of the {@link MessageBatch}.\n+     */\n+    public int getMaxSizeInBytes() {\n+        return maxMessageSize;\n+    }\n+\n+    /**\n+     * Gets the size of the {@link MessageBatch} in bytes.\n+     *\n+     * @return the size of the {@link MessageBatch} in bytes.\n+     */\n+    public int getSizeInBytes() {\n+        return this.sizeInBytes;\n+    }\n+\n+    /**\n+     * Tries to add an {@link Message event} to the batch.\n+     *\n+     * @param message The {@link Message} to add to the batch.\n+     * @return {@code true} if the event could be added to the batch; {@code false} if the event was too large to fit in\n+     *     the batch.\n+     * @throws IllegalArgumentException if {@code eventData} is {@code null}.\n+     * @throws AmqpException if {@code eventData} is larger than the maximum size of the {@link MessageBatch}.\n+     */\n+    public boolean tryAdd(final Message message) {\n+        if (message == null) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"eventData cannot be null\"));\n+        }\n+        Message event = tracerProvider.isEnabled() ? traceMessageSpan(message) : message;\n+\n+        final int size;\n+        try {\n+            size = getSize(event, messageList.isEmpty());\n+        } catch (BufferOverflowException exception) {\n+            throw logger.logExceptionAsWarning(new AmqpException(false, AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED,\n+                String.format(Locale.US, \"Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024),\n+                contextProvider.getErrorContext()));\n+        }\n+\n+        synchronized (lock) {\n+            if (this.sizeInBytes + size > this.maxMessageSize) {\n+                return false;\n+            }\n+\n+            this.sizeInBytes += size;\n+        }\n+\n+        this.messageList.add(event);\n+        return true;\n+    }\n+\n+    /**\n+     * Method to start and end a \"Azure.EventHubs.message\" span and add the \"DiagnosticId\" as a property of the message.\n+     *\n+     * @param message The Event to add tracing span for.\n+     * @return the updated event data object.\n+     */\n+    private Message traceMessageSpan(Message message) {\n+        Optional<Object> eventContextData = message.getContext().getData(SPAN_CONTEXT_KEY);\n+        if (eventContextData.isPresent()) {\n+            // if message has context (in case of retries), don't start a message span or add a new context\n+            return message;\n+        } else {\n+            // Starting the span makes the sampling decision (nothing is logged at this time)\n+            Context eventSpanContext = tracerProvider.startSpan(message.getContext(), ProcessKind.MESSAGE);\n+            Optional<Object> eventDiagnosticIdOptional = eventSpanContext.getData(DIAGNOSTIC_ID_KEY);\n+            if (eventDiagnosticIdOptional.isPresent()) {\n+                message.getProperties().put(DIAGNOSTIC_ID_KEY, eventDiagnosticIdOptional.get().toString());\n+                tracerProvider.endSpan(eventSpanContext, Signal.complete());\n+                message.addContext(SPAN_CONTEXT_KEY, eventSpanContext);\n+            }\n+        }\n+\n+        return message;\n+    }\n+\n+    List<Message> getMessageList() {\n+        return messageList;\n+    }\n+\n+\n+    private int getSize(final Message message, final boolean isFirst) {\n+        Objects.requireNonNull(message, \"'eventData' cannot be null.\");\n+\n+        final org.apache.qpid.proton.message.Message amqpMessage = createAmqpMessage(message);\n+        int eventSize = amqpMessage.encode(this.eventBytes, 0, maxMessageSize); // actual encoded bytes size\n+        eventSize += 16; // data section overhead\n+\n+        if (isFirst) {\n+            amqpMessage.setBody(null);\n+            amqpMessage.setApplicationProperties(null);\n+            amqpMessage.setProperties(null);\n+            amqpMessage.setDeliveryAnnotations(null);\n+\n+            eventSize += amqpMessage.encode(this.eventBytes, 0, maxMessageSize);\n+        }\n+\n+        return eventSize;\n+    }\n+\n+    /*\n+     * Creates the AMQP message represented by the event data\n+     */\n+    private org.apache.qpid.proton.message.Message createAmqpMessage(Message event) {\n+        final org.apache.qpid.proton.message.Message message = Proton.message();\n+\n+        if (event.getProperties() != null && !event.getProperties().isEmpty()) {\n+            final ApplicationProperties applicationProperties = new ApplicationProperties(event.getProperties());\n+            message.setApplicationProperties(applicationProperties);\n+        }\n+\n+        if (event.getSystemProperties() != null) {\n+            event.getSystemProperties().forEach((key, value) -> {\n+                if (Message.RESERVED_SYSTEM_PROPERTIES.contains(key)) {\n+                    return;\n+                }\n+\n+                final AmqpMessageConstant constant = AmqpMessageConstant.fromString(key);\n+\n+                if (constant != null) {\n+                    switch (constant) {\n+                        case MESSAGE_ID:\n+                            message.setMessageId(value);\n+                            break;\n+                        case USER_ID:\n+                            message.setUserId((byte[]) value);\n+                            break;\n+                        case TO:\n+                            message.setAddress((String) value);\n+                            break;\n+                        case SUBJECT:\n+                            message.setSubject((String) value);\n+                            break;\n+                        case REPLY_TO:\n+                            message.setReplyTo((String) value);\n+                            break;\n+                        case CORRELATION_ID:\n+                            message.setCorrelationId(value);\n+                            break;\n+                        case CONTENT_TYPE:\n+                            message.setContentType((String) value);\n+                            break;\n+                        case CONTENT_ENCODING:\n+                            message.setContentEncoding((String) value);\n+                            break;\n+                        case ABSOLUTE_EXPIRY_TIME:\n+                            message.setExpiryTime((long) value);\n+                            break;\n+                        case CREATION_TIME:\n+                            message.setCreationTime((long) value);\n+                            break;\n+                        case GROUP_ID:\n+                            message.setGroupId((String) value);\n+                            break;\n+                        case GROUP_SEQUENCE:\n+                            message.setGroupSequence((long) value);\n+                            break;\n+                        case REPLY_TO_GROUP_ID:\n+                            message.setReplyToGroupId((String) value);\n+                            break;\n+                        default:\n+                            throw logger.logExceptionAsWarning(new IllegalArgumentException(String.format(Locale.US,\n+                                \"Property is not a recognized reserved property name: %s\", key)));\n+                    }\n+                } else {\n+                    final MessageAnnotations messageAnnotations = (message.getMessageAnnotations() == null)\n+                        ? new MessageAnnotations(new HashMap<>())\n+                        : message.getMessageAnnotations();\n+                    messageAnnotations.getValue().put(Symbol.getSymbol(key), value);\n+                    message.setMessageAnnotations(messageAnnotations);\n+                }\n+            });\n+        }\n+\n+", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTQ5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609490", "bodyText": "Should have a service client here", "author": "conniey", "createdAt": "2020-02-13T01:39:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609623", "bodyText": "move final variable below static fields.", "author": "conniey", "createdAt": "2020-02-13T01:39:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTcwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609703", "bodyText": "group final and other writable variables together.", "author": "conniey", "createdAt": "2020-02-13T01:40:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY = new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+\n+\n+    private final String connectionId;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609781", "bodyText": "nit: extra lines", "author": "conniey", "createdAt": "2020-02-13T01:40:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY = new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+\n+\n+    private final String connectionId;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private boolean isSharedConnection;\n+\n+\n+    private SendOptions defaultSenderOptions;\n+", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTgyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609821", "bodyText": "What are send options?", "author": "conniey", "createdAt": "2020-02-13T01:40:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY = new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+\n+\n+    private final String connectionId;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private boolean isSharedConnection;\n+\n+\n+    private SendOptions defaultSenderOptions;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYwOTk2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378609969", "bodyText": "Does the concept of a shared connection exist in SB? I'd prefer to remove it until there is a feature request. That's why we had this in Event Hubs.", "author": "conniey", "createdAt": "2020-02-13T01:41:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY = new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+\n+\n+    private final String connectionId;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private boolean isSharedConnection;", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDEwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378610106", "bodyText": "This message is incorrect.", "author": "conniey", "createdAt": "2020-02-13T01:41:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,329 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.SendOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+@ServiceClientBuilder(serviceClients = {})\n+public final class QueueClientBuilder {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY = new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+\n+\n+    private final String connectionId;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private boolean isSharedConnection;\n+\n+\n+    private SendOptions defaultSenderOptions;\n+\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder(){\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ClientConstants.TOKEN_VALIDITY);\n+        } catch ( Exception e) {\n+            throw logger.logExceptionAsError(new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));\n+        }\n+        this.fullyQualifiedNamespace = properties.getEndpoint().getHost();\n+        this.queueName = properties.getEntityPath();\n+        return credential(properties.getEndpoint().getHost(), properties.getEntityPath(), tokenCredential);\n+    }\n+\n+\n+    public QueueClientBuilder credential(String fullyQualifiedNamespace, String queueName, TokenCredential credential) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace, \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.credentials = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+\n+        if (CoreUtils.isNullOrEmpty(fullyQualifiedNamespace)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'fullyQualifiedNamespace' cannot be an empty string.\"));\n+        } else if (CoreUtils.isNullOrEmpty(queueName)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'entityPath' cannot be an empty string.\"));\n+        }\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Creates an {@link QueueSenderAsyncClient} for transmitting {@link Message} to the Service Bus Queue.\n+     *\n+     * @return A new {@link QueueSenderAsyncClient}.\n+     */\n+    QueueSenderAsyncClient buildAsyncSenderClient() {\n+        if (retryOptions == null) {\n+            retryOptions = DEFAULT_RETRY;\n+        }\n+\n+        if (scheduler == null) {\n+            scheduler = Schedulers.elastic();\n+        }\n+        this.defaultSenderOptions = new SendOptions();\n+\n+        final MessageSerializer messageSerializer = new ServiceBusMessageSerializer();\n+\n+        if (isSharedConnection && servicerBusConnectionProcessor == null) {\n+            servicerBusConnectionProcessor = buildConnectionProcessor(messageSerializer);\n+        }\n+\n+        final ServiceBusConnectionProcessor connectionProcessor = isSharedConnection\n+            ? servicerBusConnectionProcessor\n+            : buildConnectionProcessor(messageSerializer);\n+\n+        final TracerProvider tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));\n+\n+        return new QueueSenderAsyncClient(queueName, connectionProcessor, defaultSenderOptions,  retryOptions, tracerProvider, messageSerializer, isSharedConnection);\n+    }\n+    /**\n+     * Creates an Service Bus Queue receiver responsible for reading {@link Message} from a specific Queue.\n+     *\n+     * @param prefetchCount The set of options to apply when creating the consumer.\n+     * @return An new {@link QueueReceiverAsyncClient} that receives events from the Queue.\n+     */\n+    QueueReceiverAsyncClient createAsyncReceiverClient(int prefetchCount) {\n+        if (retryOptions == null) {\n+            retryOptions = DEFAULT_RETRY;\n+        }\n+\n+        if (scheduler == null) {\n+            scheduler = Schedulers.elastic();\n+        }\n+        this.defaultSenderOptions = new SendOptions();\n+\n+        final MessageSerializer messageSerializer = new ServiceBusMessageSerializer();\n+\n+        if (isSharedConnection && servicerBusConnectionProcessor == null) {\n+            servicerBusConnectionProcessor = buildConnectionProcessor(messageSerializer);\n+        }\n+\n+        final ServiceBusConnectionProcessor connectionProcessor = isSharedConnection\n+            ? servicerBusConnectionProcessor\n+            : buildConnectionProcessor(messageSerializer);\n+\n+        final TracerProvider tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));\n+\n+        return new QueueReceiverAsyncClient(connectionProcessor.getFullyQualifiedNamespace(), queueName,\n+            connectionProcessor, tracerProvider, messageSerializer, prefetchCount, isSharedConnection);\n+    }\n+\n+    QueueReceiverAsyncClient createAsyncReceiverClient(ReceiveMode receiveMode, int prefetchCount) {\n+        return createAsyncReceiverClient(prefetchCount);\n+    }\n+\n+    /**\n+     * Sets the proxy configuration to use for {@link QueueSenderAsyncClient}. When a proxy is configured, {@link\n+     * AmqpTransportType#AMQP_WEB_SOCKETS} must be used for the transport type.\n+     *\n+     * @param proxyOptions The proxy configuration to use.\n+     *\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder proxyOptions(ProxyOptions proxyOptions) {\n+        this.proxyOptions = proxyOptions;\n+        return this;\n+    }\n+\n+    /**\n+     * Specify connection string and  queue name for connection to Queue.\n+     * @param connectionString to connect to service bus resource.\n+     * @param queueName The name of the queue.\n+     * @return The {@link QueueClientBuilder}.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString, String queueName) {\n+        this.queueName = queueName;\n+        return connectionString(connectionString);\n+    }\n+\n+    /**\n+     *\n+     * @param queueName The name of the queue.\n+     * @return The {@link QueueClientBuilder}.\n+     */\n+    public QueueClientBuilder queueName(String queueName) {\n+        this.queueName = queueName;\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param retryPolicy to recover from Connection.\n+     * @return The {@link QueueClientBuilder}.\n+     */\n+    public QueueClientBuilder retryPolicy(AmqpRetryPolicy retryPolicy) {\n+        return this;\n+    }\n+\n+    /**\n+     *\n+     * @param transportType to use.\n+     * @return The {@link QueueClientBuilder}.\n+     */\n+    public QueueClientBuilder transportType(AmqpTransportType transportType) {\n+        this.transport = transportType;\n+        return this;\n+    }\n+\n+    /** package- private method\n+     *\n+     * @param scheduler\n+     * @return The {@link QueueClientBuilder}.\n+     */\n+    QueueClientBuilder scheduler(Scheduler scheduler) {\n+        this.scheduler = scheduler;\n+        return this;\n+\n+    }\n+\n+    private ServiceBusConnectionProcessor buildConnectionProcessor(MessageSerializer messageSerializer) {\n+        final ConnectionOptions connectionOptions = getConnectionOptions();\n+        final TokenManagerProvider tokenManagerProvider = new AzureTokenManagerProvider(\n+            connectionOptions.getAuthorizationType(), connectionOptions.getFullyQualifiedNamespace(),\n+            ClientConstants.AZURE_ACTIVE_DIRECTORY_SCOPE);\n+        final ReactorProvider provider = new ReactorProvider();\n+        final ReactorHandlerProvider handlerProvider = new ReactorHandlerProvider(provider);\n+\n+        final Map<String, String> properties = CoreUtils.getProperties(SERVICEBUS_PROPERTIES_FILE);\n+        final String product = properties.getOrDefault(NAME_KEY, UNKNOWN);\n+        final String clientVersion = properties.getOrDefault(VERSION_KEY, UNKNOWN);\n+\n+        final Flux<ServiceBusAmqpConnection> connectionFlux = Mono.fromCallable(() -> {\n+            final String connectionId = StringUtil.getRandomString(\"MF\");\n+\n+            return (ServiceBusAmqpConnection) new ServiceBusReactorAmqpConnection(connectionId, connectionOptions, provider,\n+                handlerProvider, tokenManagerProvider, messageSerializer, product, clientVersion);\n+        }).repeat();\n+\n+        return connectionFlux.subscribeWith(new ServiceBusConnectionProcessor(\n+            connectionOptions.getFullyQualifiedNamespace(), connectionOptions.getEntityPath(),\n+            connectionOptions.getRetry()));\n+    }\n+\n+    public QueueClientBuilder retry(AmqpRetryOptions retryOptions) {\n+        this.retryOptions = retryOptions;\n+        return this;\n+    }\n+    private ConnectionOptions getConnectionOptions() {\n+        configuration = configuration == null ? Configuration.getGlobalConfiguration().clone() : configuration;\n+\n+        if (credentials == null) {\n+            final String connectionString = configuration.get(AZURE_SERVICE_BUS_CONNECTION_STRING);\n+\n+            if (CoreUtils.isNullOrEmpty(connectionString)) {\n+                throw logger.logExceptionAsError(new IllegalArgumentException(\"Credentials have not been set. \"\n+                    + \"They can be set using: connectionString(String), connectionString(String, String), \"", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDMzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378610338", "bodyText": "Visibility on this should be private", "author": "conniey", "createdAt": "2020-02-13T01:42:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.RetryUtil;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.SignalType;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import static com.azure.core.util.FluxUtil.fluxError;\n+\n+/**\n+ * An <b>asynchronous</b> receiver responsible for reading {@link Message} from either a specific Queue.\n+ *\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueReceiverAsyncClient implements Closeable {\n+\n+    private static final String RECEIVER_ENTITY_PATH_FORMAT = \"%s\";\n+\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClient.class);\n+    private final String fullyQualifiedNamespace;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final MessageSerializer messageSerializer;\n+    private final int prefetchCount;\n+    private final boolean isSharedConnection;\n+    private final TracerProvider tracerProvider;\n+    private final ReceiveMode defaultReceiveMode = ReceiveMode.PEEKLOCK;\n+\n+\n+    AmqpRetryOptions defaultRetryOptions =  new AmqpRetryOptions();", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDc0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378610748", "bodyText": "The concept of partitions doesn't exist here. This class was introduced so that one consumer could listen to multiple partitions in Event Hubs. What you're copying is the incorrect class.", "author": "conniey", "createdAt": "2020-02-13T01:44:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,269 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.RetryUtil;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.SignalType;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+import static com.azure.core.util.FluxUtil.fluxError;\n+\n+/**\n+ * An <b>asynchronous</b> receiver responsible for reading {@link Message} from either a specific Queue.\n+ *\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueReceiverAsyncClient implements Closeable {\n+\n+    private static final String RECEIVER_ENTITY_PATH_FORMAT = \"%s\";\n+\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClient.class);\n+    private final String fullyQualifiedNamespace;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final MessageSerializer messageSerializer;\n+    private final int prefetchCount;\n+    private final boolean isSharedConnection;\n+    private final TracerProvider tracerProvider;\n+    private final ReceiveMode defaultReceiveMode = ReceiveMode.PEEKLOCK;\n+\n+\n+    AmqpRetryOptions defaultRetryOptions =  new AmqpRetryOptions();\n+\n+    /**\n+     * Keeps track of the open consumers keyed by linkName. The link name is generated as: {@code\n+     * \"partitionId_GUID\"}. For receiving from all partitions, links are prefixed with {@code \"all-GUID-partitionId\"}.\n+     */\n+    private final ConcurrentHashMap<String, ServiceBusAsyncConsumer> openConsumers =", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2NjQ5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379266496", "bodyText": "We have multiple session , similar concept and  we could use it for that purpose.", "author": "hemanttanwar", "createdAt": "2020-02-14T06:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDc0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1MDczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379550736", "bodyText": "It wouldn't be structured in this way and be returned from the .receive() function. A QueueReceiver would be tied to a single ServiceBusAsyncConsumer. You'd probably have another class SessionReceiver or something internally.", "author": "conniey", "createdAt": "2020-02-14T17:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMDg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378610869", "bodyText": "PEEK_LOCK, and RECEIVE_AND_DELETE", "author": "conniey", "createdAt": "2020-02-13T01:45:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiveMode.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.messaging.servicebus;\n+\n+public enum ReceiveMode {\n+    /**\n+     * In this mode, received message is not deleted from the queue or subscription, instead it is temporarily locked to the receiver, making it invisible to other receivers. Then the service waits for one of the three events\n+     * <ul>\n+     * <li>If the receiver processes the message successfully, it calls <code>complete</code> and the message will be deleted.</li>\n+     * <li>If the receiver decides that it can't process the message successfully, it calls <code>abandon</code> and the message will be unlocked and made available to other receivers.</li>\n+     * <li>If the receiver wants to defer the processing of the message to a later point in time, it calls <code>defer</code> and the message will be deferred. A deferred can only be received by its sequence number.</li>\n+     * <li>If the receiver wants to dead-letter the message, it calls <code>deadLetter</code> and the message will be moved to a special sub-queue called deadletter queue.</li>\n+     * <li>If the receiver calls neither of these methods within a configurable period of time (by default, 60 seconds), the service assumes the receiver has failed. In this case, it behaves as if the receiver had called <code>abandon</code>, making the message available to other receivers</li>\n+     * </ul>\n+     */\n+    PEEKLOCK,", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611005", "bodyText": "Are rules something we have in the first preview? if not, we should remove it for now. Else, this is in the public API.", "author": "conniey", "createdAt": "2020-02-13T01:45:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Rule.java", "diffHunk": "@@ -0,0 +1,16 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+public class Rule {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTQzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611436", "bodyText": "There isn't ServiceBusProperties in SB API", "author": "conniey", "createdAt": "2020-02-13T01:47:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import com.azure.messaging.servicebus.implementation.ServiceBusProperties;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_PARTITION_NAME_KEY = \"partition\";\n+    public static final String MANAGEMENT_RESULT_PARTITION_IDS = \"partition_ids\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        // EventData - accepts only PartitionKey - which is a String & stuffed into MessageAnnotation\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing {@link\n+     * Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message eventData = (Message) object;\n+        final org.apache.qpid.proton.message.Message message = Proton.message();\n+\n+        if (eventData.getProperties() != null && !eventData.getProperties().isEmpty()) {\n+            message.setApplicationProperties(new ApplicationProperties(eventData.getProperties()));\n+        }\n+\n+        setSystemProperties(eventData, message);\n+\n+        message.setBody(new Data(new Binary(eventData.getBody())));\n+\n+        return message;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == ServiceBusProperties.class) {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTU2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611560", "bodyText": "We don't have a management node ($management) in SB afaik. Do we need this?", "author": "conniey", "createdAt": "2020-02-13T01:48:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import com.azure.messaging.servicebus.implementation.ServiceBusProperties;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_PARTITION_NAME_KEY = \"partition\";\n+    public static final String MANAGEMENT_RESULT_PARTITION_IDS = \"partition_ids\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        // EventData - accepts only PartitionKey - which is a String & stuffed into MessageAnnotation\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing {@link\n+     * Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message eventData = (Message) object;\n+        final org.apache.qpid.proton.message.Message message = Proton.message();\n+\n+        if (eventData.getProperties() != null && !eventData.getProperties().isEmpty()) {\n+            message.setApplicationProperties(new ApplicationProperties(eventData.getProperties()));\n+        }\n+\n+        setSystemProperties(eventData, message);\n+\n+        message.setBody(new Data(new Binary(eventData.getBody())));\n+\n+        return message;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == ServiceBusProperties.class) {\n+            return deserializeManagementResponse(message, clazz);\n+        } else if (clazz == Message.class) {\n+            return (T) deserializeEventData(message);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Deserialization only supports ServiceBusProperties.\"));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T deserializeManagementResponse(org.apache.qpid.proton.message.Message message, Class<T> deserializedType) {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTY2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611667", "bodyText": "deserializeEventData -> deserializeMessage. Does this match the track 1 deserialization logic?", "author": "conniey", "createdAt": "2020-02-13T01:48:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import com.azure.messaging.servicebus.implementation.ServiceBusProperties;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_PARTITION_NAME_KEY = \"partition\";\n+    public static final String MANAGEMENT_RESULT_PARTITION_IDS = \"partition_ids\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        // EventData - accepts only PartitionKey - which is a String & stuffed into MessageAnnotation\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing {@link\n+     * Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message eventData = (Message) object;\n+        final org.apache.qpid.proton.message.Message message = Proton.message();\n+\n+        if (eventData.getProperties() != null && !eventData.getProperties().isEmpty()) {\n+            message.setApplicationProperties(new ApplicationProperties(eventData.getProperties()));\n+        }\n+\n+        setSystemProperties(eventData, message);\n+\n+        message.setBody(new Data(new Binary(eventData.getBody())));\n+\n+        return message;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == ServiceBusProperties.class) {\n+            return deserializeManagementResponse(message, clazz);\n+        } else if (clazz == Message.class) {\n+            return (T) deserializeEventData(message);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Deserialization only supports ServiceBusProperties.\"));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T deserializeManagementResponse(org.apache.qpid.proton.message.Message message, Class<T> deserializedType) {\n+        if (!(message.getBody() instanceof AmqpValue)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Expected message.getBody() to be AmqpValue, but is: \" + message.getBody()));\n+        }\n+\n+        final AmqpValue body = (AmqpValue) message.getBody();\n+        if (!(body.getValue() instanceof Map)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Expected message.getBody().getValue() to be of type Map\"));\n+        }\n+\n+        final Map<?, ?> amqpBody = (Map<?, ?>) body.getValue();\n+\n+        if (deserializedType == ServiceBusProperties.class) {\n+            return (T) toServiceBusProperties(amqpBody);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(String.format(\n+                Messages.CLASS_NOT_A_SUPPORTED_TYPE, deserializedType)));\n+        }\n+    }\n+\n+\n+    private Message deserializeEventData(org.apache.qpid.proton.message.Message message) {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI2NzY5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379267691", "bodyText": "I will check for track 1 deserialization .", "author": "hemanttanwar", "createdAt": "2020-02-14T06:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTgzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611836", "bodyText": "Should make sure this aligns with the track 1 serialization code for a service bus message. iirc, it's different.", "author": "conniey", "createdAt": "2020-02-13T01:49:39Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,388 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import com.azure.messaging.servicebus.implementation.ServiceBusProperties;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_PARTITION_NAME_KEY = \"partition\";\n+    public static final String MANAGEMENT_RESULT_PARTITION_IDS = \"partition_ids\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        // EventData - accepts only PartitionKey - which is a String & stuffed into MessageAnnotation\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing {@link\n+     * Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message eventData = (Message) object;\n+        final org.apache.qpid.proton.message.Message message = Proton.message();\n+\n+        if (eventData.getProperties() != null && !eventData.getProperties().isEmpty()) {\n+            message.setApplicationProperties(new ApplicationProperties(eventData.getProperties()));\n+        }\n+\n+        setSystemProperties(eventData, message);\n+\n+        message.setBody(new Data(new Binary(eventData.getBody())));\n+\n+        return message;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == ServiceBusProperties.class) {\n+            return deserializeManagementResponse(message, clazz);\n+        } else if (clazz == Message.class) {\n+            return (T) deserializeEventData(message);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Deserialization only supports ServiceBusProperties.\"));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T deserializeManagementResponse(org.apache.qpid.proton.message.Message message, Class<T> deserializedType) {\n+        if (!(message.getBody() instanceof AmqpValue)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Expected message.getBody() to be AmqpValue, but is: \" + message.getBody()));\n+        }\n+\n+        final AmqpValue body = (AmqpValue) message.getBody();\n+        if (!(body.getValue() instanceof Map)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Expected message.getBody().getValue() to be of type Map\"));\n+        }\n+\n+        final Map<?, ?> amqpBody = (Map<?, ?>) body.getValue();\n+\n+        if (deserializedType == ServiceBusProperties.class) {\n+            return (T) toServiceBusProperties(amqpBody);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(String.format(\n+                Messages.CLASS_NOT_A_SUPPORTED_TYPE, deserializedType)));\n+        }\n+    }\n+\n+\n+    private Message deserializeEventData(org.apache.qpid.proton.message.Message message) {\n+        final Map<Symbol, Object> messageAnnotations = message.getMessageAnnotations().getValue();\n+        final HashMap<String, Object> receiveProperties = new HashMap<>();\n+\n+        for (Map.Entry<Symbol, Object> annotation : messageAnnotations.entrySet()) {\n+            receiveProperties.put(annotation.getKey().toString(), annotation.getValue());\n+        }\n+\n+        if (message.getProperties() != null) {\n+            addMapEntry(receiveProperties, AmqpMessageConstant.MESSAGE_ID, message.getMessageId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.USER_ID, message.getUserId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.TO, message.getAddress());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.SUBJECT, message.getSubject());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.REPLY_TO, message.getReplyTo());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CORRELATION_ID, message.getCorrelationId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CONTENT_TYPE, message.getContentType());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CONTENT_ENCODING, message.getContentEncoding());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.ABSOLUTE_EXPIRY_TIME, message.getExpiryTime());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CREATION_TIME, message.getCreationTime());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.GROUP_ID, message.getGroupId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.GROUP_SEQUENCE, message.getGroupSequence());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.REPLY_TO_GROUP_ID, message.getReplyToGroupId());\n+        }\n+\n+        final Section bodySection = message.getBody();\n+        byte[] body;\n+        if (bodySection instanceof Data) {\n+            Data bodyData = (Data) bodySection;\n+            body = bodyData.getValue().getArray();\n+        } else {\n+            logger.warning(String.format(Messages.MESSAGE_NOT_OF_TYPE,\n+                bodySection != null ? bodySection.getType() : \"null\"));\n+\n+            body = new byte[0];\n+        }\n+\n+        final Message.SystemProperties systemProperties = new Message.SystemProperties(receiveProperties);\n+        final Message eventData = new Message(body, systemProperties, Context.NONE);\n+        final Map<String, Object> properties = message.getApplicationProperties() == null\n+            ? new HashMap<>()\n+            : message.getApplicationProperties().getValue();\n+\n+        properties.forEach((key, value) -> eventData.getProperties().put(key, value));\n+\n+        message.clear();\n+        return eventData;\n+    }\n+\n+   private ServiceBusProperties toServiceBusProperties(Map<?, ?> amqpBody) {\n+        return new ServiceBusProperties(\n+            getValue(amqpBody, MANAGEMENT_ENTITY_NAME_KEY, String.class),\n+            getDate(amqpBody, MANAGEMENT_RESULT_CREATED_AT),\n+            getValue(amqpBody, MANAGEMENT_RESULT_PARTITION_IDS, String[].class));\n+    }\n+\n+    private <T> T getValue(Map<?, ?> amqpBody, String key, Class<T> clazz) {\n+        if (!amqpBody.containsKey(key)) {\n+            throw logger.logExceptionAsError(new AzureException(\n+                String.format(\"AMQP body did not contain expected field '%s'.\", key)));\n+        }\n+\n+        return getValue(amqpBody.get(key), key, clazz);\n+    }\n+\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private <T> T getValue(Object value, Object key, Class<T> clazz) {\n+        if (value == null) {\n+            throw logger.logExceptionAsError(new AzureException(\n+                String.format(\"AMQP body did not contain a value for key '%s'.\", key)));\n+        } else if (value.getClass() != clazz) {\n+            throw logger.logExceptionAsError(new AzureException(String.format(\n+                \"AMQP body did not contain correct value for key '%s'. Expected class: '%s'. Actual: '%s'\",\n+                key, clazz, value.getClass())));\n+        }\n+\n+        return (T) value;\n+    }\n+\n+    private Instant getDate(Map<?, ?> amqpBody, String key) {\n+        final Date value = getValue(amqpBody, key, Date.class);\n+        return value.toInstant();\n+    }\n+\n+    /*\n+     * Sets AMQP protocol header values on the AMQP message.\n+     */\n+    private static void setSystemProperties(Message eventData, org.apache.qpid.proton.message.Message message) {\n+        if (eventData.getSystemProperties() == null || eventData.getSystemProperties().isEmpty()) {\n+            return;\n+        }\n+\n+        eventData.getSystemProperties().forEach((key, value) -> {\n+            if (Message.RESERVED_SYSTEM_PROPERTIES.contains(key)) {\n+                return;\n+            }\n+\n+            final AmqpMessageConstant constant = AmqpMessageConstant.fromString(key);\n+\n+            if (constant != null) {\n+                switch (constant) {\n+                    case MESSAGE_ID:\n+                        message.setMessageId(value);\n+                        break;\n+                    case USER_ID:\n+                        message.setUserId((byte[]) value);\n+                        break;\n+                    case TO:\n+                        message.setAddress((String) value);\n+                        break;\n+                    case SUBJECT:\n+                        message.setSubject((String) value);\n+                        break;\n+                    case REPLY_TO:\n+                        message.setReplyTo((String) value);\n+                        break;\n+                    case CORRELATION_ID:\n+                        message.setCorrelationId(value);\n+                        break;\n+                    case CONTENT_TYPE:\n+                        message.setContentType((String) value);\n+                        break;\n+                    case CONTENT_ENCODING:\n+                        message.setContentEncoding((String) value);\n+                        break;\n+                    case ABSOLUTE_EXPIRY_TIME:\n+                        message.setExpiryTime((long) value);\n+                        break;\n+                    case CREATION_TIME:\n+                        message.setCreationTime((long) value);\n+                        break;\n+                    case GROUP_ID:\n+                        message.setGroupId((String) value);\n+                        break;\n+                    case GROUP_SEQUENCE:\n+                        message.setGroupSequence((long) value);\n+                        break;\n+                    case REPLY_TO_GROUP_ID:\n+                        message.setReplyToGroupId((String) value);\n+                        break;\n+                    default:\n+                        throw new IllegalArgumentException(\n+                            String.format(\n+                                \"Property is not a recognized reserved property name: %s\",\n+                                key));\n+                }\n+            } else {\n+                final MessageAnnotations messageAnnotations = (message.getMessageAnnotations() == null)\n+                    ? new MessageAnnotations(new HashMap<>())\n+                    : message.getMessageAnnotations();\n+                messageAnnotations.getValue().put(Symbol.getSymbol(key), value);\n+                message.setMessageAnnotations(messageAnnotations);\n+            }\n+        });\n+    }\n+\n+    private static int getPayloadSize(org.apache.qpid.proton.message.Message msg) {\n+", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTk5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378611990", "bodyText": "Why is tranactionId a ByteBuffer? Did we have an API review on this?", "author": "conniey", "createdAt": "2020-02-13T01:50:24Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/TransactionContext.java", "diffHunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.nio.ByteBuffer;\n+\n+public class TransactionContext {\n+\n+    public ByteBuffer getTransactionId() {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDY2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380390664", "bodyText": "No, we haven't, and I'm wondering the same thing.", "author": "JonathanGiles", "createdAt": "2020-02-17T22:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjA2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378612066", "bodyText": "I would hold off on adding types we haven't discussed until they are fleshed out.", "author": "conniey", "createdAt": "2020-02-13T01:50:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/TransactionContext.java", "diffHunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.nio.ByteBuffer;\n+\n+public class TransactionContext {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjE4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378612188", "bodyText": "commitAsync is very .NET. public Mono<Void> commit();", "author": "conniey", "createdAt": "2020-02-13T01:51:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/TransactionContext.java", "diffHunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.nio.ByteBuffer;\n+\n+public class TransactionContext {\n+\n+    public ByteBuffer getTransactionId() {\n+        return null;\n+    }\n+\n+    public void commit()  {}\n+\n+    public void commitAsync() {}", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjM0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378612342", "bodyText": "The \"MessageBatch\" is not publicly exposed. We haven't discussed having this made public.", "author": "conniey", "createdAt": "2020-02-13T01:51:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/CreateBatchOptions.java", "diffHunk": "@@ -0,0 +1,40 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.annotation.Fluent;\n+\n+/**\n+ * The set of options that can be specified when creating an batch of messages. This wrapper will help to limit\n+ * the messages with maximum allowed size.\n+ *\n+\n+ */\n+@Fluent\n+public class CreateBatchOptions {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjYzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378612635", "bodyText": "The sendBatch APIs don't expose any of these options.\nhttps://docs.microsoft.com/en-us/java/api/com.microsoft.azure.servicebus.imessagesender.sendbatch?view=azure-java-stable#com_microsoft_azure_servicebus_IMessageSender_sendBatch_Collection___extends_IMessage__", "author": "conniey", "createdAt": "2020-02-13T01:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjM0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMDQ4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382320486", "bodyText": "Why does this exist??", "author": "conniey", "createdAt": "2020-02-20T23:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMjg5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378612899", "bodyText": "We have this here because there are error messages and a corresponding \".properties\" resource file to map to. There should be that file made available.", "author": "conniey", "createdAt": "2020-02-13T01:54:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Messages.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMzAzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378613032", "bodyText": "The message class itself has \"PartitionKey\". Partition id is not a concept in SB. Do we need this class?", "author": "conniey", "createdAt": "2020-02-13T01:54:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/SendOptions.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+\n+import com.azure.core.annotation.Fluent;\n+\n+/**\n+ * The set of options that can be specified when sending a set of events to influence the way in which events are sent\n+ * to the Event Hubs service.\n+ */\n+@Fluent\n+public class SendOptions {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMzExMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378613111", "bodyText": "This class should be removed.", "author": "conniey", "createdAt": "2020-02-13T01:55:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusProperties.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMzQ2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378613468", "bodyText": "Should be named QueueReceiverAsyncClientTest", "author": "conniey", "createdAt": "2020-02-13T01:56:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/AsyncReceiverTest.java", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class AsyncReceiverTest {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxMzU2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r378613560", "bodyText": "Should be named QueueSenderAsyncClientTest", "author": "conniey", "createdAt": "2020-02-13T01:56:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/AsyncSenderTest.java", "diffHunk": "@@ -0,0 +1,162 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class AsyncSenderTest {", "originalCommit": "af69232aa55c3f4a3892d2c4558d124c4d731585", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "46bc90cd8d8fb7cfd53d9a5d4873ff5646cbd17a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46bc90cd8d8fb7cfd53d9a5d4873ff5646cbd17a", "message": "cleanupcheckstyle and spotbugs suppression", "committedDate": "2020-02-13T18:40:18Z", "type": "commit"}, {"oid": "605e062dce88d9b50381635fb570a8f5e0ae14ef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/605e062dce88d9b50381635fb570a8f5e0ae14ef", "message": "cleanupcheckstyle suppression", "committedDate": "2020-02-13T18:48:28Z", "type": "commit"}, {"oid": "30a01e56aee0a9f7ba9bc77a2e9ae9b814d8749e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30a01e56aee0a9f7ba9bc77a2e9ae9b814d8749e", "message": "clean up checkstyle", "committedDate": "2020-02-14T01:53:47Z", "type": "commit"}, {"oid": "ede75bb1160fceef768b42d652b8135c3f6b476e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ede75bb1160fceef768b42d652b8135c3f6b476e", "message": "Review comments and removed unwanted classes", "committedDate": "2020-02-14T06:34:21Z", "type": "commit"}, {"oid": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b47ea549c863772769bbbb352d0a470c6a49dbe2", "message": "Removing session id as design is not finalised.", "committedDate": "2020-02-14T17:01:43Z", "type": "commit"}, {"oid": "f9269d25fca7c65f2d4c1b8fee799ed586846ede", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9269d25fca7c65f2d4c1b8fee799ed586846ede", "message": "validating Checkstyle rules", "committedDate": "2020-02-14T17:14:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NDU1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379544556", "bodyText": "This class is package-private. These don't need to be public.", "author": "conniey", "createdAt": "2020-02-14T17:06:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ */\n+final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;\n+    private final ErrorContextProvider contextProvider;\n+    private final List<Message> messageList;\n+    private final byte[] eventBytes;\n+    private int sizeInBytes;\n+    private final TracerProvider tracerProvider;\n+\n+    MessageBatch(int maxMessageSize, ErrorContextProvider contextProvider,\n+                 TracerProvider tracerProvider) {\n+        this.maxMessageSize = maxMessageSize;\n+\n+        this.contextProvider = contextProvider;\n+        this.messageList = new LinkedList<>();\n+        this.sizeInBytes = (maxMessageSize / 65536) * 1024; // reserve 1KB for every 64KB\n+        this.eventBytes = new byte[maxMessageSize];\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the number of {@link Message events} in the batch.\n+     *\n+     * @return The number of {@link Message events} in the batch.\n+     */\n+    public int getCount() {", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTYxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379545614", "bodyText": "This should be using StepVerifier.", "author": "conniey", "createdAt": "2020-02-14T17:09:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    @Captor\n+    ArgumentCaptor<com.azure.core.amqp.EventData> singleMessageCaptor;\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message = new Message(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n+        // the event.\n+\n+        asyncSender.send(message)", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NTk2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379545966", "bodyText": "This should be using StepVerifier.", "author": "conniey", "createdAt": "2020-02-14T17:09:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueReceiverAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class QueueReceiverAsyncClientTest {\n+\n+    private static final Duration OPERATION_TIMEOUT = Duration.ofSeconds(30);\n+    private static final int NUMBER_OF_EVENTS = 10;\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClientTest.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<org.apache.qpid.proton.message.Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<org.apache.qpid.proton.message.Message> messages = new ArrayList<>();\n+\n+    private QueueReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+\n+        String connectionString = baseConnectionString + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .createAsyncReceiverClient(2);\n+    }\n+\n+    @AfterEach\n+    public void teardown() throws IOException {\n+        messages.clear();\n+        Mockito.framework().clearInlineMocks();\n+        consumer.close();\n+    }\n+\n+    /**\n+     * Verifies that this receives a number of events. Verifies that the initial credits we add are equal to the\n+     * prefetch value.\n+     */\n+    @Test\n+    public void receivesNumberOfEvents() {\n+        // Arrange\n+        final int numberOfEvents = 2;\n+\n+        // Act & Assert\n+        StepVerifier.create(consumer.receive().take(numberOfEvents))\n+            .then(() -> sendMessages(numberOfEvents))\n+            .expectNextCount(numberOfEvents)\n+            .verifyComplete();\n+\n+        verify(amqpReceiveLink, times(1)).addCredits(PREFETCH);\n+    }\n+\n+    @Test\n+    public void receivesNumberOfEventsActual() throws Exception {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+        String connectionString = baseConnectionString + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .createAsyncReceiverClient(numberOfEvents);\n+        Thread.sleep(3000);\n+\n+        consumer.receive()", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NjY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379546685", "bodyText": "nit: keep your requires, opens and uses grouped together.", "author": "conniey", "createdAt": "2020-02-14T17:11:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/module-info.java", "diffHunk": "@@ -0,0 +1,13 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+module com.azure.messaging.servicebus {\n+    requires transitive com.azure.core.amqp;", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NzQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379547450", "bodyText": "Do you have an issue open to update all the documentation?", "author": "conniey", "createdAt": "2020-02-14T17:13:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusSharedKeyCredential.java", "diffHunk": "@@ -0,0 +1,158 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+\n+import com.azure.core.annotation.Immutable;\n+import com.azure.core.credential.AccessToken;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import reactor.core.publisher.Mono;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Duration;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTcwNzI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379707277", "bodyText": "#8225", "author": "hemanttanwar", "createdAt": "2020-02-15T01:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0NzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU0OTQzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379549435", "bodyText": "This should be in the implementation package.", "author": "conniey", "createdAt": "2020-02-14T17:17:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -0,0 +1,74 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.EmitterProcessor;\n+import reactor.core.publisher.Flux;\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A package-private consumer responsible for reading {@link Message} from a specific Service Bus.\n+ */\n+class ServiceBusAsyncConsumer implements AutoCloseable {", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU1MDEyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379550122", "bodyText": "This should be package-private. MessageBatch is not accessible outside of this package.", "author": "conniey", "createdAt": "2020-02-14T17:19:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The thent to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {\n+        // Caching the created link so we don't invoke another link creation.\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer,\n+            \"'messageSerializer' cannot be null.\");\n+        this.retryOptions = Objects.requireNonNull(retryOptions, \"'retryOptions' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor,\n+            \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = tracerProvider;\n+        this.retryPolicy = getRetryPolicy(retryOptions);\n+    }\n+\n+    /**\n+     *\n+     * @param message to be sent.\n+     * @param sessionId the session id to associate. {@code null} is not a valid  value.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Message message, String sessionId) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        //TODO(sessionid) Implement session id feature\n+        return send(Flux.just(message));\n+    }\n+\n+    /**\n+     *\n+     * @param message to be sent.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Message message) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        return send(Flux.just(message));\n+    }\n+\n+    /**\n+     *\n+     * @param messages to be sent\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Iterable<Message> messages) {\n+        Objects.requireNonNull(messages, \"'messages' cannot be null.\");\n+        return send(Flux.fromIterable(messages));\n+    }\n+\n+    /**\n+     * Sends a set of messages to the associated Event Hub using a batched approach. If the size of messages exceed the\n+     * maximum size of a single batch, an exception will be triggered and the send will fail. By default, the message\n+     * size is the max amount allowed on the link.\n+     * @param messages Events to send to the service.\n+     *\n+     * @return A {@link Mono} that completes when all messages are pushed to the service.\n+     */\n+    public Mono<Void> send(Flux<Message> messages) {\n+        Objects.requireNonNull(messages, \"'messages' cannot be null.\");\n+\n+        return sendInternal(messages);\n+    }\n+\n+    private Mono<Void> sendInternal(Flux<Message> messages) {\n+        return getSendLink()\n+            .flatMap(link -> link.getLinkSize()\n+                .flatMap(size -> {\n+                    final int batchSize = size > 0 ? size : MAX_MESSAGE_LENGTH_BYTES;\n+                    final CreateBatchOptions batchOptions = new CreateBatchOptions()\n+                        .setMaximumSizeInBytes(batchSize);\n+                    return messages.collect(new AmqpMessageCollector(batchOptions, 1,\n+                        link::getErrorContext, tracerProvider));\n+                })\n+                .flatMap(list -> sendInternalBatch(Flux.fromIterable(list))));\n+    }\n+\n+    private Mono<Void> sendInternalBatch(Flux<MessageBatch> eventBatches) {\n+        return eventBatches\n+            .flatMap(this::send)\n+            .then()\n+            .doOnError(error -> {\n+                logger.error(\"Error sending batch.\", error);\n+            });\n+    }\n+\n+\n+    /**\n+     *\n+     * @param message to be scheduled\n+     * @param scheduledEnqueueTimeUt Time of the enqueue.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Long> schedule(Message message, Instant scheduledEnqueueTimeUt) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param sequenceNumber for the message to cancel.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @return The name of  the queue.\n+     */\n+    public String getQueueName() {\n+        return this.queueName;\n+    }\n+\n+    /**\n+     *\n+     * @param batch of messages which allows client to send maximum allowed size for a batch of messages.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(MessageBatch batch) {", "originalCommit": "b47ea549c863772769bbbb352d0a470c6a49dbe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5Njk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r379596975", "bodyText": "private final byte[] body; [](start = 4, length = 26)\n\nAccepting only bytes as body will break interoperability with other clients sending messages to Service Bus. If an application uses any standard AMQP client or another Service Bus client to send a non-byte message, that message cannot be represented by this class and bytes will not mean anything to a receiving application. We started the V1 Java SDK with bytes only message and then added support for other message types. If the V2 SDK is supporting only bytes means starting from square one again.", "author": "yvgopal", "createdAt": "2020-02-14T19:08:34Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,262 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus. Each Service Bus entity can\n+ * be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+\n+    private final Map<String, Object> properties;\n+    private final byte[] body;", "originalCommit": "f9269d25fca7c65f2d4c1b8fee799ed586846ede", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQ0NTQ2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380445462", "bodyText": "I am adding String , contentType, byte[] constructor for now and will compare with what else is needed. I will add more add needed.", "author": "hemanttanwar", "createdAt": "2020-02-18T04:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5Njk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNDI3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382314273", "bodyText": "It might be worth creating an issue for it so we don't lose track of this.", "author": "conniey", "createdAt": "2020-02-20T23:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5Njk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjcyNzMyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382727329", "bodyText": "Created #8384", "author": "hemanttanwar", "createdAt": "2020-02-21T18:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU5Njk3NQ=="}], "type": "inlineReview"}, {"oid": "83a9cce2995a85708319fe3b612ad821eb010a45", "url": "https://github.com/Azure/azure-sdk-for-java/commit/83a9cce2995a85708319fe3b612ad821eb010a45", "message": "review comments inclusion", "committedDate": "2020-02-17T18:25:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NjY5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380386693", "bodyText": "Your JavaDoc refers to body but the argument name is content, in this ctor and the one below.", "author": "JonathanGiles", "createdAt": "2020-02-17T22:34:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMTU0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382331545", "bodyText": "changed everything to body  as AMQP protocol uses this term.", "author": "hemanttanwar", "createdAt": "2020-02-21T00:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NjY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NzExMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380387113", "bodyText": "array() is an optional operation and may not return anything. Additionally, have you considered the possibility of the ByteBuffer being modified after the Message ctor is called, and whether the content should be copied rather than the array just being passed as-is?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:36:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] content) {\n+        this.body = Objects.requireNonNull(content, \"'content' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").array());", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4Nzc2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380387766", "bodyText": "Why not just make it Context.NONE if it is null?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:40:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] content) {\n+        this.body = Objects.requireNonNull(content, \"'content' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code content} using UTF-8 charset.\n+     *\n+     * @param content The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String content, String contentType) {\n+        this(content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(byte[] content, String contentType) {\n+        this(content);\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, String content, String contentType) {\n+        this(messageId, content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, byte[] content, String contentType) {\n+        this(content, contentType);\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    public Message(byte[] body, Map<String, Object> systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4ODAyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380388024", "bodyText": "It feels like there are too many ctor's on this class. Are they all necessary?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:41:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] content) {\n+        this.body = Objects.requireNonNull(content, \"'content' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code content} using UTF-8 charset.\n+     *\n+     * @param content The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String content, String contentType) {\n+        this(content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(byte[] content, String contentType) {\n+        this(content);\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, String content, String contentType) {\n+        this(messageId, content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, byte[] content, String contentType) {\n+        this(content, contentType);\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    public Message(byte[] body, Map<String, Object> systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties = new SystemProperties(Objects.requireNonNull(systemProperties,\n+            \"'systemProperties' cannot be null.\"));\n+        this.properties = new HashMap<>();\n+    }", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4ODE3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380388178", "bodyText": "Why do we need properties and context?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:41:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] content) {\n+        this.body = Objects.requireNonNull(content, \"'content' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code content} using UTF-8 charset.\n+     *\n+     * @param content The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String content, String contentType) {\n+        this(content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(byte[] content, String contentType) {\n+        this(content);\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, String content, String contentType) {\n+        this(messageId, content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, byte[] content, String contentType) {\n+        this(content, contentType);\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    public Message(byte[] body, Map<String, Object> systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties = new SystemProperties(Objects.requireNonNull(systemProperties,\n+            \"'systemProperties' cannot be null.\"));\n+        this.properties = new HashMap<>();\n+    }\n+\n+    /**\n+     * Gets the set of free-form event properties which may be used for passing metadata associated with the event with\n+     * the event body during Event Hubs operations. A common use-case for {@code properties()} is to associate\n+     * serialization hints for the {@link #getBody()} as an aid to consumers who wish to deserialize the binary data.\n+     *\n+     * <p><strong>Adding serialization hint using {@code getProperties()}</strong></p>\n+     * <p>In the sample, the type of telemetry is indicated by adding an application property with key \"eventType\".</p>\n+     *\n+     * @return Application properties associated with this {@link Message}.\n+     */\n+    public Map<String, Object> getProperties() {\n+        return properties;\n+    }", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4ODM2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380388368", "bodyText": "In what instances is it necessary to set the properties of this class after instantiation?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:43:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,343 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] content) {\n+        this.body = Objects.requireNonNull(content, \"'content' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates an event containing the {@code body}.\n+     *\n+     * @param content The data to set for this event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates an event by encoding the {@code content} using UTF-8 charset.\n+     *\n+     * @param content The string that will be UTF-8 encoded to create an event.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String content) {\n+        this(Objects.requireNonNull(content, \"'content' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String content, String contentType) {\n+        this(content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(byte[] content, String contentType) {\n+        this(content);\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, String content, String contentType) {\n+        this(messageId, content.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param messageId id of the message\n+     * @param content content of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(String messageId, byte[] content, String contentType) {\n+        this(content, contentType);\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     * Creates an event with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this event.\n+     * @param systemProperties System properties set by message broker for this event.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    public Message(byte[] body, Map<String, Object> systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties = new SystemProperties(Objects.requireNonNull(systemProperties,\n+            \"'systemProperties' cannot be null.\"));\n+        this.properties = new HashMap<>();\n+    }\n+\n+    /**\n+     * Gets the set of free-form event properties which may be used for passing metadata associated with the event with\n+     * the event body during Event Hubs operations. A common use-case for {@code properties()} is to associate\n+     * serialization hints for the {@link #getBody()} as an aid to consumers who wish to deserialize the binary data.\n+     *\n+     * <p><strong>Adding serialization hint using {@code getProperties()}</strong></p>\n+     * <p>In the sample, the type of telemetry is indicated by adding an application property with key \"eventType\".</p>\n+     *\n+     * @return Application properties associated with this {@link Message}.\n+     */\n+    public Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    /**\n+     * Properties that are populated by Service Bus. As these are populated by the Event Hubs service, they are\n+     * only present on a <b>received</b> {@link Message}.\n+     *\n+     * @return An encapsulation of all system properties appended by EventHubs service into {@link Message}.\n+     *     {@code null} if the {@link Message} is not received from the Event Hubs service.\n+     */\n+    public Map<String, Object> getSystemProperties() {\n+        return systemProperties;\n+    }\n+\n+    /**\n+     *\n+     * @return of the message.\n+     */\n+    public String getMessageId() {\n+        return messageId;\n+    }\n+\n+    /**\n+     *\n+     * @param messageId of the message.\n+     */\n+    public void setMessageId(String messageId) {\n+        this.messageId = messageId;\n+    }", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4OTY3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380389671", "bodyText": "presumably this is supposed to be public?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:49:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {\n+            throw logger.logExceptionAsError(\n+                new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));\n+        }\n+        this.fullyQualifiedNamespace = properties.getEndpoint().getHost();\n+        this.queueName = properties.getEntityPath();\n+        return credential(properties.getEndpoint().getHost(), properties.getEntityPath(), tokenCredential);\n+    }\n+\n+    /**\n+     *\n+     * @param fullyQualifiedNamespace for the Service Bus.\n+     * @param queueName The name of the queue.\n+     * @param credential {@link TokenCredential} to be used for authentication.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder credential(String fullyQualifiedNamespace, String queueName, TokenCredential credential) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.credentials = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+\n+        if (CoreUtils.isNullOrEmpty(fullyQualifiedNamespace)) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"'fullyQualifiedNamespace' cannot be an empty string.\"));\n+        } else if (CoreUtils.isNullOrEmpty(queueName)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'entityPath' cannot be an empty string.\"));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Creates an {@link QueueSenderAsyncClient} for transmitting {@link Message} to the Service Bus Queue.\n+     *\n+     * @return A new {@link QueueSenderAsyncClient}.\n+     */\n+    QueueSenderAsyncClient buildAsyncSenderClient() {", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380390941", "bodyText": "It isn't clear to me how the user gets or creates a TransactionContext instance to pass into these methods, or why they need to do this. If it was required, I would have assumed that there would be a method that returns the relevant TransactionContext that they should be using.", "author": "JonathanGiles", "createdAt": "2020-02-17T22:55:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,282 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.RetryUtil;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAsyncConsumer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.SignalType;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static com.azure.core.util.FluxUtil.fluxError;\n+\n+/**\n+ * An <b>asynchronous</b> receiver responsible for reading {@link Message} from either a specific Queue.\n+ *\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueReceiverAsyncClient implements Closeable {\n+\n+    private static final String RECEIVER_ENTITY_PATH_FORMAT = \"%s\";\n+\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClient.class);\n+    private final String fullyQualifiedNamespace;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final MessageSerializer messageSerializer;\n+    private final int prefetchCount;\n+    private final TracerProvider tracerProvider;\n+    private final ReceiveMode defaultReceiveMode = ReceiveMode.PEEK_LOCK;\n+\n+    /**\n+     * Keeps track of the open consumers keyed by linkName. The link name is generated as: {@code\n+     * \"partitionId_GUID\"}. For receiving from all partitions, links are prefixed with {@code \"all-GUID-partitionId\"}.\n+     */\n+    private final ConcurrentHashMap<String, ServiceBusAsyncConsumer> openConsumers = new ConcurrentHashMap<>();\n+\n+    QueueReceiverAsyncClient(String fullyQualifiedNamespace, String queueName,\n+                             ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+                             MessageSerializer messageSerializer, int prefetchCount) {\n+        this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n+        this.queueName = queueName;\n+        this.connectionProcessor = connectionProcessor;\n+        this.messageSerializer = messageSerializer;\n+        this.prefetchCount = prefetchCount;\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the fully qualified Service Bus  namespace that the connection is associated with. This is likely similar to\n+     * {@code {yournamespace}.servicebus.windows.net}.\n+     *\n+     * @return The fully qualified Service Bus namespace that the connection is associated with.\n+     */\n+    public String getFullyQualifiedNamespace() {\n+        return fullyQualifiedNamespace;\n+    }\n+\n+    /**\n+     * Gets the Queue name this client interacts with.\n+     *\n+     * @return The Queue name this client interacts with.\n+     */\n+    public String getQueueName() {\n+        return queueName;\n+    }\n+\n+    /**\n+     * Consumes messages from Queue.\n+     *\n+     * <p>This method is <b>not</b> recommended for production use; the TODO(doc) should be used for\n+     * reading messages in a production scenario, as it offers a much more robust experience with\n+     * higher throughput.\n+     *\n+     * @return A stream of messages from Queue.\n+     */\n+    public Flux<Message> receive() {\n+        return receive(defaultReceiveMode);\n+    }\n+\n+    /**\n+     *\n+     * @return A stream of messages from Queue.\n+     */\n+    public Flux<Message> peek() {\n+        return receive(defaultReceiveMode);\n+    }\n+\n+    /**\n+     * Consumes messages for given {@link ReceiveMode}.\n+     *\n+     * @param receiveMode {@link ReceiveMode} when receiving events from Queue.\n+     *\n+     * @return A stream of events for every partition from Queue.\n+     *\n+     * @throws NullPointerException if {@code receiveMode} is null.\n+     */\n+    public Flux<Message> receive(ReceiveMode receiveMode) {\n+        if (Objects.isNull(receiveMode)) {\n+            return fluxError(logger, new NullPointerException(\"'receiveMode' cannot be null.\"));\n+        }\n+\n+        final String linkName = connectionProcessor.getEntityPath();\n+        return createConsumer(linkName, receiveMode);\n+    }\n+\n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+        openConsumers.forEach((key, value) -> value.close());\n+        openConsumers.clear();\n+\n+        connectionProcessor.dispose();\n+\n+    }\n+\n+    private Flux<Message> createConsumer(String linkName, ReceiveMode receiveMode) {\n+        return openConsumers\n+            .computeIfAbsent(linkName, name -> {\n+                logger.info(\"{}: Creating receive consumer.\", linkName);\n+                return createServiceBusConsumer(name, receiveMode);\n+            })\n+            .receive()\n+            .doOnCancel(() -> removeLink(linkName, SignalType.CANCEL))\n+            .doOnComplete(() -> removeLink(linkName, SignalType.ON_COMPLETE))\n+            .doOnError(error -> removeLink(linkName, SignalType.ON_ERROR));\n+    }\n+\n+    private void removeLink(String linkName, SignalType signalType) {\n+        logger.info(\"{}: Receiving completed. Signal[{}]\", linkName, signalType);\n+        final ServiceBusAsyncConsumer consumer = openConsumers.remove(linkName);\n+\n+        if (consumer != null) {\n+            consumer.close();\n+        }\n+    }\n+    private ServiceBusAsyncConsumer createServiceBusConsumer(String linkName, ReceiveMode receiveMode) {\n+        final String entityPath = String.format(Locale.US, RECEIVER_ENTITY_PATH_FORMAT, getQueueName());\n+\n+        final Flux<AmqpReceiveLink> receiveLinkMono =\n+            connectionProcessor.flatMap(connection ->\n+                connection.createReceiveLink(linkName, entityPath, receiveMode))\n+                .doOnNext(next -> logger.verbose(\"Creating consumer for path: {}\", next.getEntityPath()))\n+                .repeat();\n+\n+        final AmqpRetryPolicy retryPolicy = RetryUtil.getRetryPolicy(connectionProcessor.getRetryOptions());\n+        final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLinkMono.subscribeWith(\n+            new ServiceBusReceiveLinkProcessor(prefetchCount, retryPolicy, connectionProcessor));\n+\n+        return new ServiceBusAsyncConsumer(linkMessageProcessor, messageSerializer, fullyQualifiedNamespace,\n+            entityPath);\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> abandon(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> complete(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> defer(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> deadLetter(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Instant renewMessageLock(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param sequenceNumber to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Message> receiveDeferredMessage(long sequenceNumber) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @param context The {@link TransactionContext} to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> complete(UUID lockToken, TransactionContext context) {", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzOTIyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382239227", "bodyText": "Since we are not implementing in first releasing. I will remove TransactionContext  for now. And we will add it in later beta releases.", "author": "hemanttanwar", "createdAt": "2020-02-20T20:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380391343", "bodyText": "If there exists a send method that does not require a sessionId (which is the case here), it feels very counter-intuitive to force this to be null here, because you're now forcing the user to null-check their sessionId even though you very easily can support the null sessionId anyway.", "author": "JonathanGiles", "createdAt": "2020-02-17T22:57:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The thent to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {\n+        // Caching the created link so we don't invoke another link creation.\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer,\n+            \"'messageSerializer' cannot be null.\");\n+        this.retryOptions = Objects.requireNonNull(retryOptions, \"'retryOptions' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor,\n+            \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = tracerProvider;\n+        this.retryPolicy = getRetryPolicy(retryOptions);\n+    }\n+\n+    /**\n+     *\n+     * @param message to be sent.\n+     * @param sessionId the session id to associate. {@code null} is not a valid  value.", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTUzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380391536", "bodyText": "What does 'scheduledEnqueueTimeUt' mean?", "author": "JonathanGiles", "createdAt": "2020-02-17T22:58:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,374 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The thent to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {\n+        // Caching the created link so we don't invoke another link creation.\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer,\n+            \"'messageSerializer' cannot be null.\");\n+        this.retryOptions = Objects.requireNonNull(retryOptions, \"'retryOptions' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor,\n+            \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = tracerProvider;\n+        this.retryPolicy = getRetryPolicy(retryOptions);\n+    }\n+\n+    /**\n+     *\n+     * @param message to be sent.\n+     * @param sessionId the session id to associate. {@code null} is not a valid  value.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Message message, String sessionId) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        //TODO(sessionid) Implement session id feature\n+        return send(Flux.just(message));\n+    }\n+\n+    /**\n+     *\n+     * @param message to be sent.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Message message) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        return send(Flux.just(message));\n+    }\n+\n+    /**\n+     *\n+     * @param messages to be sent\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> send(Iterable<Message> messages) {\n+        Objects.requireNonNull(messages, \"'messages' cannot be null.\");\n+        return send(Flux.fromIterable(messages));\n+    }\n+\n+    /**\n+     * Sends a set of messages to the associated Event Hub using a batched approach. If the size of messages exceed the\n+     * maximum size of a single batch, an exception will be triggered and the send will fail. By default, the message\n+     * size is the max amount allowed on the link.\n+     * @param messages Events to send to the service.\n+     *\n+     * @return A {@link Mono} that completes when all messages are pushed to the service.\n+     */\n+    public Mono<Void> send(Flux<Message> messages) {\n+        Objects.requireNonNull(messages, \"'messages' cannot be null.\");\n+\n+        return sendInternal(messages);\n+    }\n+\n+    private Mono<Void> sendInternal(Flux<Message> messages) {\n+        return getSendLink()\n+            .flatMap(link -> link.getLinkSize()\n+                .flatMap(size -> {\n+                    final int batchSize = size > 0 ? size : MAX_MESSAGE_LENGTH_BYTES;\n+                    final CreateBatchOptions batchOptions = new CreateBatchOptions()\n+                        .setMaximumSizeInBytes(batchSize);\n+                    return messages.collect(new AmqpMessageCollector(batchOptions, 1,\n+                        link::getErrorContext, tracerProvider));\n+                })\n+                .flatMap(list -> sendInternalBatch(Flux.fromIterable(list))));\n+    }\n+\n+    private Mono<Void> sendInternalBatch(Flux<MessageBatch> eventBatches) {\n+        return eventBatches\n+            .flatMap(this::send)\n+            .then()\n+            .doOnError(error -> {\n+                logger.error(\"Error sending batch.\", error);\n+            });\n+    }\n+\n+\n+    /**\n+     *\n+     * @param message to be scheduled\n+     * @param scheduledEnqueueTimeUt Time of the enqueue.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Long> schedule(Message message, Instant scheduledEnqueueTimeUt) {", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Nzk0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382287945", "bodyText": "I have updated documentation Declares at which time the message should appear on the Service Bus Queue.", "author": "hemanttanwar", "createdAt": "2020-02-20T22:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTUzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODQzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318430", "bodyText": "I think he wants to see scheduledEnqueueTimeUtc", "author": "conniey", "createdAt": "2020-02-20T23:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjQ3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r380392477", "bodyText": "This should have a more descriptive name", "author": "JonathanGiles", "createdAt": "2020-02-17T23:03:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ClientConstants.java", "diffHunk": "@@ -0,0 +1,15 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import java.time.Duration;\n+\n+/**\n+ *  Constants defined for service bus.\n+ */\n+public class ClientConstants {", "originalCommit": "83a9cce2995a85708319fe3b612ad821eb010a45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4OTk5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382289997", "bodyText": "ServiceBusClientConstants    Does this make sense ?", "author": "hemanttanwar", "createdAt": "2020-02-20T22:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjQ3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwNDI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r383304255", "bodyText": "Removed this class for now.", "author": "hemanttanwar", "createdAt": "2020-02-24T14:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjQ3Nw=="}], "type": "inlineReview"}, {"oid": "4e79edeb888246298f54939b2c82daf00b8a361d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e79edeb888246298f54939b2c82daf00b8a361d", "message": "changes based on review comments", "committedDate": "2020-02-18T04:59:45Z", "type": "commit"}, {"oid": "27eed34525a4170ef3a9d4ea389f413492a0e685", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27eed34525a4170ef3a9d4ea389f413492a0e685", "message": "changes based on review comments", "committedDate": "2020-02-18T06:06:24Z", "type": "commit"}, {"oid": "124fd8bf6824569ef11aff7d13987e66da6a757f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/124fd8bf6824569ef11aff7d13987e66da6a757f", "message": "Review comments", "committedDate": "2020-02-20T23:06:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNDkzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382314937", "bodyText": "Is this equality check correct? I'd assume there are other properties to compare for a Message.", "author": "conniey", "createdAt": "2020-02-20T23:23:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/Message.java", "diffHunk": "@@ -0,0 +1,335 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.Context;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import static com.azure.core.amqp.AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.PUBLISHER_ANNOTATION_NAME;\n+import static com.azure.core.amqp.AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * The data structure encapsulating the message being sent-to and received-from Service Bus.\n+ * Each Service Bus entity can be visualized as a stream of {@link Message}.\n+ *\n+ * <p>\n+ * Here's how AMQP message sections map to {@link Message}. For reference, the specification can be found here:\n+ * <a href=\"http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf\">AMQP 1.0 specification</a>\n+ *\n+ * <ol>\n+ * <li>{@link #getProperties()} - AMQPMessage.ApplicationProperties section</li>\n+ * <li>{@link #getBody()} - if AMQPMessage.Body has Data section</li>\n+ * </ol>\n+ *\n+ * <p>\n+ * Serializing a received {@link Message} with AMQP sections other than ApplicationProperties (with primitive Java\n+ * types) and Data section is not supported.\n+ * </p>\n+ *\n+ * @see MessageBatch\n+ */\n+public class Message {\n+    /*\n+     * These are properties owned by the service and set when a message is received.\n+     */\n+    static final Set<String> RESERVED_SYSTEM_PROPERTIES;\n+    private static final Charset DEFAULT_CHAR_SET = Charset.forName(\"UTF-8\");\n+    private final Map<String, Object> properties;\n+    private final byte[] body;\n+    private final SystemProperties systemProperties;\n+    private Context context;\n+    private UUID lockToken;\n+    private String messageId;\n+    private String contentType;\n+    private String sessionId;\n+\n+\n+    static {\n+        final Set<String> properties = new HashSet<>();\n+        properties.add(PARTITION_KEY_ANNOTATION_NAME.getValue());\n+        properties.add(SEQUENCE_NUMBER_ANNOTATION_NAME.getValue());\n+        properties.add(ENQUEUED_TIME_UTC_ANNOTATION_NAME.getValue());\n+        properties.add(PUBLISHER_ANNOTATION_NAME.getValue());\n+\n+        RESERVED_SYSTEM_PROPERTIES = Collections.unmodifiableSet(properties);\n+    }\n+\n+    /**\n+     * Creates a {@link Message} containing the {@code body}.\n+     *\n+     * @param body The data to set for this {@link Message}.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(byte[] body) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Context.NONE;\n+        this.properties = new HashMap<>();\n+        this.systemProperties = new SystemProperties();\n+        this.messageId = null;\n+    }\n+\n+    /**\n+     * Creates a {@link Message} containing the {@code body}.\n+     *\n+     * @param body The data to set for this {@link Message}.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(ByteBuffer body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").array());\n+    }\n+\n+    /**\n+     * Creates a {@link Message} by encoding the {@code body} using UTF-8 charset.\n+     *\n+     * @param body The string that will be UTF-8 encoded to create a {@link Message}.\n+     * @throws NullPointerException if {@code body} is {@code null}.\n+     */\n+    public Message(String body) {\n+        this(Objects.requireNonNull(body, \"'body' cannot be null.\").getBytes(UTF_8));\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array\n+     * and message body type is set to binary.\n+     * @param body body of the message\n+     * @param contentType body type of the message\n+     */\n+    public Message(String body, String contentType) {\n+        this(body.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a message from a byte array. Message body type is set to binary.\n+     * @param body body of the message\n+     * @param contentType content type of the message\n+     */\n+    public Message(byte[] body, String contentType) {\n+        this(body);\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Creates a message from a string. For backward compatibility reasons, the string is converted to a byte array.\n+     *\n+     * @param messageId id of the {@link Message}.\n+     * @param body body of the {@link Message}.\n+     * @param contentType content type of the {@link Message}.\n+     */\n+    public Message(String messageId, String body, String contentType) {\n+        this(messageId, body.getBytes(DEFAULT_CHAR_SET), contentType);\n+    }\n+\n+    /**\n+     * Creates a {@link Message} from a byte array.\n+     *\n+     * @param messageId id of the {@link Message}.\n+     * @param body body of the {@link Message}.\n+     * @param contentType content type of the {@link Message}.\n+     */\n+    public Message(String messageId, byte[] body, String contentType) {\n+        this(body, contentType);\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     * Creates a {@link Message} with the given {@code body}, system properties and context.\n+     *\n+     * @param body The data to set for this {@link Message}.\n+     * @param systemProperties System properties set by message broker for this {@link Message}.\n+     * @param context A specified key-value pair of type {@link Context}.\n+     * @throws NullPointerException if {@code body}, {@code systemProperties}, or {@code context} is {@code null}.\n+     */\n+    public Message(byte[] body, Map<String, Object> systemProperties, Context context) {\n+        this.body = Objects.requireNonNull(body, \"'body' cannot be null.\");\n+        this.context = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        this.systemProperties = new SystemProperties(Objects.requireNonNull(systemProperties,\n+            \"'systemProperties' cannot be null.\"));\n+        this.properties = new HashMap<>();\n+    }\n+\n+    /**\n+     * Gets the set of free-form {@link Message} properties which may be used for passing metadata associated with\n+     * the {@link Message}  during Service Bus operations. A common use-case for {@code properties()} is to associate\n+     * serialization hints for the {@link #getBody()} as an aid to consumers who wish to deserialize the binary data.\n+     *\n+     * <p><strong>Adding serialization hint using {@code getProperties()}</strong></p>\n+     * <p>In the sample, the type of telemetry is indicated by adding an application property with key \"messageType\".</p>\n+     *\n+     * @return Application properties associated with this {@link Message}.\n+     */\n+    public Map<String, Object> getProperties() {\n+        return properties;\n+    }\n+\n+    /**\n+     * Properties that are populated by Service Bus. As these are populated by the Service Bus, they are\n+     * only present on a <b>received</b> {@link Message}.\n+     *\n+     * @return An encapsulation of all system properties appended by Service Bus into {@link Message}. {@code null} if\n+     * the {@link Message} is not received from the Service Bus service.\n+     */\n+    public Map<String, Object> getSystemProperties() {\n+        return systemProperties;\n+    }\n+\n+    /**\n+     *\n+     * @return Id of the {@link Message}.\n+     */\n+    public String getMessageId() {\n+        return messageId;\n+    }\n+\n+    /**\n+     * Sets the message id.\n+     * @param messageId of the {@link Message}.\n+     */\n+    public void setMessageId(String messageId) {\n+        this.messageId = messageId;\n+    }\n+\n+    /**\n+     *\n+     * @return the contentType of the {@link Message}.\n+     */\n+    public String getContentType() {\n+        return contentType;\n+    }\n+\n+    /**\n+     * Sets the content type of the {@link Message}.\n+     * @param contentType of the message.\n+     */\n+    public void setContentType(String contentType) {\n+        this.contentType = contentType;\n+    }\n+\n+    /**\n+     * Gets the actual payload/data wrapped by EventData.\n+     *\n+     * <p>\n+     * If the means for deserializing the raw data is not apparent to consumers, a common technique is to make use of\n+     * {@link #getProperties()} when creating the event, to associate serialization hints as an aid to consumers who\n+     * wish to deserialize the binary data.\n+     * </p>\n+     *\n+     * @return A byte array representing the data.\n+     */\n+    public byte[] getBody() {\n+        return Arrays.copyOf(body, body.length);\n+    }\n+\n+    /**\n+     * Returns message body as UTF-8 decoded string.\n+     *\n+     * @return UTF-8 decoded string representation of the event data.\n+     */\n+    public String getBodyAsString() {\n+        return new String(body, UTF_8);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMzYzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r383303632", "bodyText": "Right now, It is comparing object and Message body. As I understand more about properties, we can add those checks.", "author": "hemanttanwar", "createdAt": "2020-02-24T14:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTQyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382315422", "bodyText": "This doesn't match the actual file name.", "author": "conniey", "createdAt": "2020-02-20T23:25:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMDkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382320936", "bodyText": "Do you have a test for this?", "author": "conniey", "createdAt": "2020-02-20T23:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwMTg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r383301890", "bodyText": "Added test for this and others.", "author": "hemanttanwar", "createdAt": "2020-02-24T14:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTczOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382315738", "bodyText": "I'd expect an IllegalArgumentException.", "author": "conniey", "createdAt": "2020-02-20T23:26:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ServiceBusClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {\n+            throw logger.logExceptionAsError(\n+                new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382315841", "bodyText": "Catching exception? Shouldn't we catch a specific one?", "author": "conniey", "createdAt": "2020-02-20T23:26:37Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ServiceBusClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjA0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382316046", "bodyText": "''queueName\" not \"entityPath\"", "author": "conniey", "createdAt": "2020-02-20T23:27:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ServiceBusClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {\n+            throw logger.logExceptionAsError(\n+                new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));\n+        }\n+        this.fullyQualifiedNamespace = properties.getEndpoint().getHost();\n+        this.queueName = properties.getEntityPath();\n+        return credential(properties.getEndpoint().getHost(), properties.getEntityPath(), tokenCredential);\n+    }\n+\n+    /**\n+     *\n+     * @param fullyQualifiedNamespace for the Service Bus.\n+     * @param queueName The name of the queue.\n+     * @param credential {@link TokenCredential} to be used for authentication.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder credential(String fullyQualifiedNamespace, String queueName, TokenCredential credential) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.credentials = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjMxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382316317", "bodyText": "Why does this method exist?", "author": "conniey", "createdAt": "2020-02-20T23:27:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ServiceBusClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {\n+            throw logger.logExceptionAsError(\n+                new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));\n+        }\n+        this.fullyQualifiedNamespace = properties.getEndpoint().getHost();\n+        this.queueName = properties.getEntityPath();\n+        return credential(properties.getEndpoint().getHost(), properties.getEntityPath(), tokenCredential);\n+    }\n+\n+    /**\n+     *\n+     * @param fullyQualifiedNamespace for the Service Bus.\n+     * @param queueName The name of the queue.\n+     * @param credential {@link TokenCredential} to be used for authentication.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder credential(String fullyQualifiedNamespace, String queueName, TokenCredential credential) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.credentials = Objects.requireNonNull(credential, \"'credential' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");\n+\n+        if (CoreUtils.isNullOrEmpty(fullyQualifiedNamespace)) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"'fullyQualifiedNamespace' cannot be an empty string.\"));\n+        } else if (CoreUtils.isNullOrEmpty(queueName)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"'entityPath' cannot be an empty string.\"));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Creates an {@link QueueSenderAsyncClient} for transmitting {@link Message} to the Service Bus Queue.\n+     *\n+     * @return A new {@link QueueSenderAsyncClient}.\n+     */\n+    QueueSenderAsyncClient buildAsyncSenderClient() {\n+        if (retryOptions == null) {\n+            retryOptions = DEFAULT_RETRY;\n+        }\n+\n+        if (scheduler == null) {\n+            scheduler = Schedulers.elastic();\n+        }\n+        final MessageSerializer messageSerializer = new ServiceBusMessageSerializer();\n+\n+        if (servicerBusConnectionProcessor == null) {\n+            servicerBusConnectionProcessor = createConnectionProcessor(messageSerializer);\n+        }\n+\n+        final ServiceBusConnectionProcessor connectionProcessor = createConnectionProcessor(messageSerializer);\n+\n+        final TracerProvider tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));\n+\n+        return new QueueSenderAsyncClient(queueName, connectionProcessor,  retryOptions, tracerProvider,\n+            messageSerializer);\n+    }\n+    /**\n+     * Creates an Service Bus Queue receiver responsible for reading {@link Message} from a specific Queue.\n+     *\n+     * @param prefetchCount The set of options to apply when creating the consumer.\n+     * @return An new {@link QueueReceiverAsyncClient} that receives events from the Queue.\n+     */\n+    QueueReceiverAsyncClient createAsyncReceiverClient(int prefetchCount) {\n+        if (retryOptions == null) {\n+            retryOptions = DEFAULT_RETRY;\n+        }\n+\n+        if (scheduler == null) {\n+            scheduler = Schedulers.elastic();\n+        }\n+        final MessageSerializer messageSerializer = new ServiceBusMessageSerializer();\n+\n+        if (servicerBusConnectionProcessor == null) {\n+            servicerBusConnectionProcessor = createConnectionProcessor(messageSerializer);\n+        }\n+\n+        final ServiceBusConnectionProcessor connectionProcessor = createConnectionProcessor(messageSerializer);\n+\n+        final TracerProvider tracerProvider = new TracerProvider(ServiceLoader.load(Tracer.class));\n+\n+        return new QueueReceiverAsyncClient(connectionProcessor.getFullyQualifiedNamespace(), queueName,\n+            connectionProcessor, tracerProvider, messageSerializer, prefetchCount);\n+    }\n+\n+    QueueReceiverAsyncClient createAsyncReceiverClient(ReceiveMode receiveMode, int prefetchCount) {\n+        return createAsyncReceiverClient(prefetchCount);", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNzM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382317399", "bodyText": "Imho, returning Mono.empty() is more friendly than returning null for writing API tests before implementation.", "author": "conniey", "createdAt": "2020-02-20T23:31:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,238 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.RetryUtil;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAsyncConsumer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.SignalType;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.azure.core.util.FluxUtil.fluxError;\n+\n+/**\n+ * An <b>asynchronous</b> receiver responsible for reading {@link Message} from either a specific Queue.\n+ *\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueReceiverAsyncClient implements Closeable {\n+\n+    private static final String RECEIVER_ENTITY_PATH_FORMAT = \"%s\";\n+\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClient.class);\n+    private final String fullyQualifiedNamespace;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final MessageSerializer messageSerializer;\n+    private final int prefetchCount;\n+    private final TracerProvider tracerProvider;\n+    private final ReceiveMode defaultReceiveMode = ReceiveMode.PEEK_LOCK;\n+\n+    /**\n+     * Consumer to maintain single connection per queue.\n+     */\n+    private final AtomicReference<ServiceBusAsyncConsumer> openConsumer =  new AtomicReference<>();\n+\n+    QueueReceiverAsyncClient(String fullyQualifiedNamespace, String queueName,\n+                             ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+                             MessageSerializer messageSerializer, int prefetchCount) {\n+        this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n+        this.queueName = queueName;\n+        this.connectionProcessor = connectionProcessor;\n+        this.messageSerializer = messageSerializer;\n+        this.prefetchCount = prefetchCount;\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the fully qualified Service Bus  namespace that the connection is associated with. This is likely similar to\n+     * {@code {yournamespace}.servicebus.windows.net}.\n+     *\n+     * @return The fully qualified Service Bus namespace that the connection is associated with.\n+     */\n+    public String getFullyQualifiedNamespace() {\n+        return fullyQualifiedNamespace;\n+    }\n+\n+    /**\n+     * Gets the Queue name this client interacts with.\n+     *\n+     * @return The Queue name this client interacts with.\n+     */\n+    public String getQueueName() {\n+        return queueName;\n+    }\n+\n+    /**\n+     * Consumes messages from Queue.\n+     *\n+     * <p>This method is <b>not</b> recommended for production use; the TODO(doc) should be used for\n+     * reading messages in a production scenario, as it offers a much more robust experience with\n+     * higher throughput.\n+     *\n+     * @return A stream of messages from Queue.\n+     */\n+    public Flux<Message> receive() {\n+        return receive(defaultReceiveMode);\n+    }\n+\n+    /**\n+     *\n+     * @return A stream of messages from Queue.\n+     */\n+    public Flux<Message> peek() {\n+        return receive(defaultReceiveMode);\n+    }\n+\n+    /**\n+     * Consumes messages for given {@link ReceiveMode}.\n+     *\n+     * @param receiveMode {@link ReceiveMode} when receiving events from Queue.\n+     *\n+     * @return A stream of events for every partition from Queue.\n+     *\n+     * @throws NullPointerException if {@code receiveMode} is null.\n+     */\n+    public Flux<Message> receive(ReceiveMode receiveMode) {\n+        if (Objects.isNull(receiveMode)) {\n+            return fluxError(logger, new NullPointerException(\"'receiveMode' cannot be null.\"));\n+        }\n+\n+        final String linkName = connectionProcessor.getEntityPath();\n+        return createConsumer(linkName, receiveMode);\n+    }\n+\n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+        if (openConsumer.get() != null) {\n+            openConsumer.get().close();\n+        }\n+\n+\n+        connectionProcessor.dispose();\n+\n+    }\n+\n+    private Flux<Message> createConsumer(String linkName, ReceiveMode receiveMode) {\n+        if (openConsumer.get() == null) {\n+            logger.info(\"{}: Creating receive consumer.\", linkName);\n+            openConsumer.set(createServiceBusConsumer(linkName, receiveMode));\n+        }\n+        return openConsumer.get()\n+            .receive()\n+            .doOnCancel(() -> removeLink(linkName, SignalType.CANCEL))\n+            .doOnComplete(() -> removeLink(linkName, SignalType.ON_COMPLETE))\n+            .doOnError(error -> removeLink(linkName, SignalType.ON_ERROR));\n+    }\n+\n+    private void removeLink(String linkName, SignalType signalType) {\n+        logger.info(\"{}: Receiving completed. Signal[{}]\", linkName, signalType);\n+\n+        if (openConsumer.get() != null) {\n+            openConsumer.get().close();\n+        }\n+    }\n+    private ServiceBusAsyncConsumer createServiceBusConsumer(String linkName, ReceiveMode receiveMode) {\n+        final String entityPath = String.format(Locale.US, RECEIVER_ENTITY_PATH_FORMAT, getQueueName());\n+\n+        final Flux<AmqpReceiveLink> receiveLinkMono =\n+            connectionProcessor.flatMap(connection ->\n+                connection.createReceiveLink(linkName, entityPath, receiveMode))\n+                .doOnNext(next -> logger.verbose(\"Creating consumer for path: {}\", next.getEntityPath()))\n+                .repeat();\n+\n+        final AmqpRetryPolicy retryPolicy = RetryUtil.getRetryPolicy(connectionProcessor.getRetryOptions());\n+        final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLinkMono.subscribeWith(\n+            new ServiceBusReceiveLinkProcessor(prefetchCount, retryPolicy, connectionProcessor));\n+\n+        return new ServiceBusAsyncConsumer(linkMessageProcessor, messageSerializer, fullyQualifiedNamespace,\n+            entityPath);\n+    }\n+\n+    /**\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> abandon(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318091", "bodyText": "Do your import statements need to be reordered?", "author": "conniey", "createdAt": "2020-02-20T23:33:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318153", "bodyText": "This comment doesn't apply.", "author": "conniey", "createdAt": "2020-02-20T23:33:27Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The client to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {\n+        // Caching the created link so we don't invoke another link creation.", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318211", "bodyText": "This message is incorrect.", "author": "conniey", "createdAt": "2020-02-20T23:33:37Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,352 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The client to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {\n+        // Caching the created link so we don't invoke another link creation.\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer,\n+            \"'messageSerializer' cannot be null.\");\n+        this.retryOptions = Objects.requireNonNull(retryOptions, \"'retryOptions' cannot be null.\");\n+        this.queueName = Objects.requireNonNull(queueName, \"'entityPath' cannot be null.\");", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODY4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318688", "bodyText": "Should this be in a model package class?", "author": "conniey", "createdAt": "2020-02-20T23:35:16Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ReceiveMode.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+/**\n+ *  Defines the Receive modes.\n+ */\n+public enum ReceiveMode {", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxODg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382318869", "bodyText": "This message is incorrect.", "author": "conniey", "createdAt": "2020-02-20T23:35:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing\n+     * {@link Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382319153", "bodyText": "What? ServiceBusproperties doesn't exist.", "author": "conniey", "createdAt": "2020-02-20T23:36:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing\n+     * {@link Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message serviceBusMessage = (Message) object;\n+        final org.apache.qpid.proton.message.Message amqpMessage = Proton.message();\n+\n+        if (serviceBusMessage.getProperties() != null && !serviceBusMessage.getProperties().isEmpty()) {\n+            amqpMessage.setApplicationProperties(new ApplicationProperties(serviceBusMessage.getProperties()));\n+        }\n+\n+        setSystemProperties(serviceBusMessage, amqpMessage);\n+\n+        amqpMessage.setBody(new Data(new Binary(serviceBusMessage.getBody())));\n+\n+        return amqpMessage;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == Message.class) {\n+            return (T) deserializeMessage(message);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Deserialization only supports ServiceBusProperties.\"));", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTk5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382319990", "bodyText": "It's easier to reason about by flipping this if statement:\nif (clazz != Message.class) {\n    throw logger...\n}\n\nreturn (T)...", "author": "conniey", "createdAt": "2020-02-20T23:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMDE4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382320183", "bodyText": "I like how it's called eventData here.", "author": "conniey", "createdAt": "2020-02-20T23:37:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+\n+\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.Messages;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Section;\n+\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+class ServiceBusMessageSerializer implements MessageSerializer {\n+    // Well-known keys from the management service responses and requests.\n+    public static final String MANAGEMENT_ENTITY_NAME_KEY = \"name\";\n+    public static final String MANAGEMENT_RESULT_CREATED_AT = \"created_at\";\n+\n+    private final ClientLogger logger = new ClientLogger(ServiceBusMessageSerializer.class);\n+\n+    /**\n+     * Gets the serialized size of the AMQP message.\n+     */\n+    @Override\n+    public int getSize(org.apache.qpid.proton.message.Message amqpMessage) {\n+        if (amqpMessage == null) {\n+            return 0;\n+        }\n+\n+        int payloadSize = getPayloadSize(amqpMessage);\n+\n+        final MessageAnnotations messageAnnotations = amqpMessage.getMessageAnnotations();\n+        final ApplicationProperties applicationProperties = amqpMessage.getApplicationProperties();\n+\n+        int annotationsSize = 0;\n+        int applicationPropertiesSize = 0;\n+\n+        if (messageAnnotations != null) {\n+            final Map<Symbol, Object> map = messageAnnotations.getValue();\n+\n+            for (Map.Entry<Symbol, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                annotationsSize += size;\n+            }\n+        }\n+\n+        if (applicationProperties != null) {\n+            final Map<String, Object> map = applicationProperties.getValue();\n+\n+            for (Map.Entry<String, Object> entry : map.entrySet()) {\n+                final int size = sizeof(entry.getKey()) + sizeof(entry.getValue());\n+                applicationPropertiesSize += size;\n+            }\n+        }\n+\n+        return annotationsSize + applicationPropertiesSize + payloadSize;\n+    }\n+\n+    /**\n+     * Creates the AMQP message represented by this {@code object}. Currently, only supports serializing\n+     * {@link Message}.\n+     *\n+     * @param object Concrete object to deserialize.\n+     *\n+     * @return A new AMQP message for this {@code object}.\n+     *\n+     * @throws IllegalArgumentException if {@code object} is not an instance of {@link Message}.\n+     */\n+    @Override\n+    public <T> org.apache.qpid.proton.message.Message serialize(T object) {\n+        Objects.requireNonNull(object, \"'object' to serialize cannot be null.\");\n+\n+        if (!(object instanceof Message)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Cannot serialize object that is not EventData. Clazz: \" + object.getClass()));\n+        }\n+\n+        final Message serviceBusMessage = (Message) object;\n+        final org.apache.qpid.proton.message.Message amqpMessage = Proton.message();\n+\n+        if (serviceBusMessage.getProperties() != null && !serviceBusMessage.getProperties().isEmpty()) {\n+            amqpMessage.setApplicationProperties(new ApplicationProperties(serviceBusMessage.getProperties()));\n+        }\n+\n+        setSystemProperties(serviceBusMessage, amqpMessage);\n+\n+        amqpMessage.setBody(new Data(new Binary(serviceBusMessage.getBody())));\n+\n+        return amqpMessage;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T deserialize(org.apache.qpid.proton.message.Message message, Class<T> clazz) {\n+        Objects.requireNonNull(message, \"'message' cannot be null.\");\n+        Objects.requireNonNull(clazz, \"'clazz' cannot be null.\");\n+\n+        if (clazz == Message.class) {\n+            return (T) deserializeMessage(message);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Deserialization only supports ServiceBusProperties.\"));\n+        }\n+    }\n+\n+    private Message deserializeMessage(org.apache.qpid.proton.message.Message message) {\n+        final Map<Symbol, Object> messageAnnotations = message.getMessageAnnotations().getValue();\n+        final HashMap<String, Object> receiveProperties = new HashMap<>();\n+\n+        for (Map.Entry<Symbol, Object> annotation : messageAnnotations.entrySet()) {\n+            receiveProperties.put(annotation.getKey().toString(), annotation.getValue());\n+        }\n+\n+        if (message.getProperties() != null) {\n+            addMapEntry(receiveProperties, AmqpMessageConstant.MESSAGE_ID, message.getMessageId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.USER_ID, message.getUserId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.TO, message.getAddress());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.SUBJECT, message.getSubject());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.REPLY_TO, message.getReplyTo());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CORRELATION_ID, message.getCorrelationId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CONTENT_TYPE, message.getContentType());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CONTENT_ENCODING, message.getContentEncoding());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.ABSOLUTE_EXPIRY_TIME, message.getExpiryTime());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.CREATION_TIME, message.getCreationTime());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.GROUP_ID, message.getGroupId());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.GROUP_SEQUENCE, message.getGroupSequence());\n+            addMapEntry(receiveProperties, AmqpMessageConstant.REPLY_TO_GROUP_ID, message.getReplyToGroupId());\n+        }\n+\n+        final Section bodySection = message.getBody();\n+        byte[] body;\n+        if (bodySection instanceof Data) {\n+            Data bodyData = (Data) bodySection;\n+            body = bodyData.getValue().getArray();\n+        } else {\n+            logger.warning(String.format(Messages.MESSAGE_NOT_OF_TYPE,\n+                bodySection != null ? bodySection.getType() : \"null\"));\n+\n+            body = new byte[0];\n+        }\n+\n+        final Message eventData = new Message(body, receiveProperties, Context.NONE);", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTIzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382321235", "bodyText": "Messages is an overloaded term because SB exposes a \"Message\" class. I would rename this to something else like ResourceStrings or something.", "author": "conniey", "createdAt": "2020-02-20T23:40:29Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Messages.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Properties;\n+\n+/**\n+ * Define various messages for different error conditions.\n+ */\n+public class Messages {", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTkwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382321906", "bodyText": "This isn't needed.", "author": "conniey", "createdAt": "2020-02-20T23:42:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message = new Message(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Service Bus. It completes with an error if an exception\n+        // occurred while sending the event.\n+        StepVerifier.create(asyncSender.send(message))\n+            .verifyComplete();\n+        Thread.sleep(1000 * 5);", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382321986", "bodyText": "Make sure to dispose of your client in a try/finally.", "author": "conniey", "createdAt": "2020-02-20T23:42:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjI2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322267", "bodyText": "This doesn't match the one you fetch from configuration in QueueClientBuilder.", "author": "conniey", "createdAt": "2020-02-20T23:43:38Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueReceiverAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class QueueReceiverAsyncClientTest {\n+\n+    private static final Duration OPERATION_TIMEOUT = Duration.ofSeconds(30);\n+    private static final int NUMBER_OF_EVENTS = 10;\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClientTest.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<org.apache.qpid.proton.message.Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjUzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322537", "bodyText": "nit: uneeded extra line.", "author": "conniey", "createdAt": "2020-02-20T23:44:27Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueReceiverAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,192 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class QueueReceiverAsyncClientTest {\n+\n+    private static final Duration OPERATION_TIMEOUT = Duration.ofSeconds(30);\n+    private static final int NUMBER_OF_EVENTS = 10;\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClientTest.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<org.apache.qpid.proton.message.Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<org.apache.qpid.proton.message.Message> messages = new ArrayList<>();\n+\n+    private QueueReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .createAsyncReceiverClient(2);\n+    }\n+\n+    @AfterEach\n+    public void teardown() throws IOException {\n+        messages.clear();\n+        Mockito.framework().clearInlineMocks();\n+        consumer.close();\n+    }\n+\n+    /**\n+     * Verifies that this receives a number of events. Verifies that the initial credits we add are equal to the\n+     * prefetch value.\n+     */\n+    @Test\n+    public void receivesNumberOfEvents() {\n+        // Arrange\n+        final int numberOfEvents = 2;\n+\n+        // Act & Assert\n+        StepVerifier.create(consumer.receive().take(numberOfEvents))\n+            .then(() -> sendMessages(numberOfEvents))\n+            .expectNextCount(numberOfEvents)\n+            .verifyComplete();\n+\n+        verify(amqpReceiveLink, times(1)).addCredits(PREFETCH);\n+    }\n+\n+    @Test\n+    public void receivesNumberOfEventsActual() throws Exception {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+        String connectionString = baseConnectionString + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .createAsyncReceiverClient(numberOfEvents);\n+\n+        // Act & Assert\n+        StepVerifier.create(\n+            consumer.receive().take(numberOfEvents)\n+        )\n+            .then(() -> sendMessages(numberOfEvents))\n+            .expectNextCount(numberOfEvents)\n+            .verifyComplete();\n+        Thread.sleep(5000);\n+    }\n+\n+    private void sendMessages(int numberOfEvents) {\n+        // When we start receiving, then send those 10 messages.\n+        FluxSink<org.apache.qpid.proton.message.Message> sink = messageProcessor.sink();\n+        for (int i = 0; i < numberOfEvents; i++) {\n+            sink.next(getMessage(PAYLOAD_BYTES, messageTrackingUUID));\n+        }\n+    }\n+\n+    // System and application properties from the generated test message.\n+    static final Instant ENQUEUED_TIME = Instant.ofEpochSecond(1561344661);\n+    static final Long OFFSET = 1534L;\n+    static final String PARTITION_KEY = \"a-partition-key\";\n+    static final Long SEQUENCE_NUMBER = 1025L;\n+    static final String OTHER_SYSTEM_PROPERTY = \"Some-other-system-property\";\n+    static final Boolean OTHER_SYSTEM_PROPERTY_VALUE = Boolean.TRUE;\n+    static final Map<String, Object> APPLICATION_PROPERTIES = new HashMap<>();\n+    // An application property key used to identify that the request belongs to a test set.\n+    static final String MESSAGE_TRACKING_ID = \"message-tracking-id\";\n+\n+    static Symbol getSymbol(AmqpMessageConstant messageConstant) {\n+        return Symbol.getSymbol(messageConstant.getValue());\n+    }\n+    /**\n+     * Creates a mock message with the contents provided.\n+     */\n+    static org.apache.qpid.proton.message.Message getMessage(byte[] contents, String messageTrackingValue) {\n+        final Map<Symbol, Object> systemProperties = new HashMap<>();\n+        systemProperties.put(getSymbol(AmqpMessageConstant.OFFSET_ANNOTATION_NAME), String.valueOf(OFFSET));\n+        systemProperties.put(getSymbol(AmqpMessageConstant.PARTITION_KEY_ANNOTATION_NAME), PARTITION_KEY);\n+        systemProperties.put(getSymbol(AmqpMessageConstant.ENQUEUED_TIME_UTC_ANNOTATION_NAME), Date.from(ENQUEUED_TIME));\n+        systemProperties.put(getSymbol(AmqpMessageConstant.SEQUENCE_NUMBER_ANNOTATION_NAME), SEQUENCE_NUMBER);\n+        systemProperties.put(Symbol.getSymbol(OTHER_SYSTEM_PROPERTY), OTHER_SYSTEM_PROPERTY_VALUE);\n+\n+        final Message message = Proton.message();\n+        message.setMessageAnnotations(new MessageAnnotations(systemProperties));\n+\n+        Map<String, Object> applicationProperties = new HashMap<>();\n+        APPLICATION_PROPERTIES.forEach(applicationProperties::put);\n+\n+        if (!CoreUtils.isNullOrEmpty(messageTrackingValue)) {\n+            applicationProperties.put(MESSAGE_TRACKING_ID, messageTrackingValue);\n+        }\n+\n+        message.setApplicationProperties(new ApplicationProperties(applicationProperties));\n+        message.setBody(new Data(new Binary(contents)));\n+\n+        return message;\n+    }\n+}\n+", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjY5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322698", "bodyText": "You don't need this.", "author": "conniey", "createdAt": "2020-02-20T23:44:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message = new Message(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Service Bus. It completes with an error if an exception\n+        // occurred while sending the event.\n+        StepVerifier.create(asyncSender.send(message))\n+            .verifyComplete();\n+        Thread.sleep(1000 * 5);\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void testPublishMultipleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Creating an Service Bus instance.\n+        // 3. Creating a \"Shared access policy\" for your Service Bus instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message1 = new Message(\"Hello world - Multiple -part 1!\".getBytes(UTF_8));\n+        Message message2 = new Message(\"Hello world - Multiple -part 2!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n+        // the event.\n+        List<Message> list = new ArrayList<Message>();\n+\n+        list.add(message1);\n+        list.add(message2);\n+        StepVerifier.create(asyncSender.send(list))\n+            .verifyComplete();\n+        Thread.sleep(5000);", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjcyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322728", "bodyText": "Dispose of client.", "author": "conniey", "createdAt": "2020-02-20T23:45:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message = new Message(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Service Bus. It completes with an error if an exception\n+        // occurred while sending the event.\n+        StepVerifier.create(asyncSender.send(message))\n+            .verifyComplete();\n+        Thread.sleep(1000 * 5);\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void testPublishMultipleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Creating an Service Bus instance.\n+        // 3. Creating a \"Shared access policy\" for your Service Bus instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjg0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322842", "bodyText": "This isn't a sample. You can remove these comments.", "author": "conniey", "createdAt": "2020-02-20T23:45:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Event Hubs namespace in Azure Portal.\n+        // 2. Creating an Event Hub instance.\n+        // 3. Creating a \"Shared access policy\" for your Event Hub instance.\n+        // 4. Copying the connection string from the policy's properties.\n+\n+        String connectionString = baseConnectionString + \";EntityPath=queue-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+        QueueSenderAsyncClient asyncSender = new QueueClientBuilder()\n+            .connectionString(connectionString)\n+            .buildAsyncSenderClient();\n+\n+        // Create an event to send.\n+        Message message = new Message(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // event has been delivered to the Service Bus. It completes with an error if an exception\n+        // occurred while sending the event.\n+        StepVerifier.create(asyncSender.send(message))\n+            .verifyComplete();\n+        Thread.sleep(1000 * 5);\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void testPublishMultipleMessage() throws Exception {\n+        // The connection string value can be obtained by:", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMjkzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382322934", "bodyText": "This isn't a sample, you can remove these comments.", "author": "conniey", "createdAt": "2020-02-20T23:45:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/QueueSenderAsyncClientTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import reactor.test.StepVerifier;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class QueueSenderAsyncClientTest {\n+\n+    private final String baseConnectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Event Hub.\n+     */\n+    @Test\n+    public void testPublishSingleMessage() throws Exception {\n+        // The connection string value can be obtained by:", "originalCommit": "124fd8bf6824569ef11aff7d13987e66da6a757f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "208f805a2839821e1eeb575041933c4795377e0b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/208f805a2839821e1eeb575041933c4795377e0b", "message": "Review comments", "committedDate": "2020-02-21T00:02:56Z", "type": "commit"}, {"oid": "c006343f8291292abdfea586af84bdef662e13af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c006343f8291292abdfea586af84bdef662e13af", "message": "separating track1 and  track 2 yaml for build", "committedDate": "2020-02-21T00:12:59Z", "type": "commit"}, {"oid": "2a175bd6380ae90415bf56b935b5dd3117f198e7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a175bd6380ae90415bf56b935b5dd3117f198e7", "message": "Review comments", "committedDate": "2020-02-21T00:34:41Z", "type": "commit"}, {"oid": "336222771ffa5a537e0c79751b94161bd09cbf1a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/336222771ffa5a537e0c79751b94161bd09cbf1a", "message": "Review comments", "committedDate": "2020-02-21T00:42:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0Mjc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382342795", "bodyText": "I'm assuming there's a reason for this - what is it? Message header overhead? Probably worth adding into the comment (and now I want to check JS to see if we do the same thing)", "author": "richardpark-msft", "createdAt": "2020-02-21T00:54:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ */\n+final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;\n+    private final ErrorContextProvider contextProvider;\n+    private final List<Message> messageList;\n+    private final byte[] eventBytes;\n+    private int sizeInBytes;\n+    private final TracerProvider tracerProvider;\n+\n+    MessageBatch(int maxMessageSize, ErrorContextProvider contextProvider,\n+                 TracerProvider tracerProvider) {\n+        this.maxMessageSize = maxMessageSize;\n+\n+        this.contextProvider = contextProvider;\n+        this.messageList = new LinkedList<>();\n+        this.sizeInBytes = (maxMessageSize / 65536) * 1024; // reserve 1KB for every 64KB", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MzA5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382343094", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"eventData cannot be null\"));\n          \n          \n            \n                        throw logger.logExceptionAsWarning(new IllegalArgumentException(\"Message cannot be null\"));", "author": "richardpark-msft", "createdAt": "2020-02-21T00:55:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/MessageBatch.java", "diffHunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpMessageConstant;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.amqp.messaging.Data;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Signal;\n+\n+import java.nio.BufferOverflowException;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * A class for aggregating {@link Message} into a single, size-limited, batch. It is treated as a single message when\n+ * sent to the Azure Service Bus service.\n+ */\n+final class MessageBatch {\n+    private final ClientLogger logger = new ClientLogger(MessageBatch.class);\n+    private final Object lock = new Object();\n+    private final int maxMessageSize;\n+    private final ErrorContextProvider contextProvider;\n+    private final List<Message> messageList;\n+    private final byte[] eventBytes;\n+    private int sizeInBytes;\n+    private final TracerProvider tracerProvider;\n+\n+    MessageBatch(int maxMessageSize, ErrorContextProvider contextProvider,\n+                 TracerProvider tracerProvider) {\n+        this.maxMessageSize = maxMessageSize;\n+\n+        this.contextProvider = contextProvider;\n+        this.messageList = new LinkedList<>();\n+        this.sizeInBytes = (maxMessageSize / 65536) * 1024; // reserve 1KB for every 64KB\n+        this.eventBytes = new byte[maxMessageSize];\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the number of {@link Message events} in the batch.\n+     *\n+     * @return The number of {@link Message events} in the batch.\n+     */\n+    int getCount() {\n+        return messageList.size();\n+    }\n+\n+    /**\n+     * Gets the maximum size, in bytes, of the {@link MessageBatch}.\n+     *\n+     * @return The maximum size, in bytes, of the {@link MessageBatch}.\n+     */\n+    int getMaxSizeInBytes() {\n+        return maxMessageSize;\n+    }\n+\n+    /**\n+     * Gets the size of the {@link MessageBatch} in bytes.\n+     *\n+     * @return the size of the {@link MessageBatch} in bytes.\n+     */\n+    int getSizeInBytes() {\n+        return this.sizeInBytes;\n+    }\n+\n+    /**\n+     * Tries to add an {@link Message message} to the batch.\n+     *\n+     * @param message The {@link Message} to add to the batch.\n+     * @return {@code true} if the message could be added to the batch; {@code false} if the event was too large\n+     * to fit in the batch.\n+     * @throws IllegalArgumentException if {@code message} is {@code null}.\n+     * @throws AmqpException if {@code message} is larger than the maximum size of the {@link MessageBatch}.\n+     */\n+    boolean tryAdd(final Message message) {\n+        if (message == null) {\n+            throw logger.logExceptionAsWarning(new IllegalArgumentException(\"eventData cannot be null\"));", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NDU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382344595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n          \n          \n            \n                private ServiceBusConnectionProcessor serviceBusConnectionProcessor;\n          \n      \n    \n    \n  \n\nOr go full bore and add more 'r's.", "author": "richardpark-msft", "createdAt": "2020-02-21T01:00:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NDk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382344992", "bodyText": "Probably a good point for us to sync on this - I think we're calling the fullyQualifiedNamespace just host.", "author": "richardpark-msft", "createdAt": "2020-02-21T01:00:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueClientBuilder.java", "diffHunk": "@@ -0,0 +1,338 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransportType;\n+import com.azure.core.amqp.ProxyAuthenticationType;\n+import com.azure.core.amqp.ProxyOptions;\n+import com.azure.core.amqp.implementation.AzureTokenManagerProvider;\n+import com.azure.core.amqp.implementation.CbsAuthorizationType;\n+import com.azure.core.amqp.implementation.ConnectionOptions;\n+import com.azure.core.amqp.implementation.ConnectionStringProperties;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.ReactorHandlerProvider;\n+import com.azure.core.amqp.implementation.ReactorProvider;\n+import com.azure.core.amqp.implementation.StringUtil;\n+import com.azure.core.amqp.implementation.TokenManagerProvider;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.TokenCredential;\n+import com.azure.core.exception.AzureException;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusClientConstants;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReactorAmqpConnection;\n+import com.azure.messaging.servicebus.implementation.ServiceBusSharedKeyCredential;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+\n+/***\n+ * The builder to create {@link QueueReceiverAsyncClient} and {@link QueueSenderAsyncClient}.\n+ */\n+@ServiceClientBuilder(serviceClients = { QueueReceiverAsyncClient.class, QueueSenderAsyncClient.class})\n+public final class QueueClientBuilder {\n+\n+    private static final String AZURE_SERVICE_BUS_CONNECTION_STRING = \"AZURE_SERVICE_BUS_CONNECTION_STRING\";\n+    private static final AmqpRetryOptions DEFAULT_RETRY =\n+        new AmqpRetryOptions().setTryTimeout(ServiceBusClientConstants.OPERATION_TIMEOUT);\n+\n+    private static final String SERVICEBUS_PROPERTIES_FILE = \"azure-messaging-servicebus.properties\";\n+    private static final String NAME_KEY = \"name\";\n+    private static final String VERSION_KEY = \"version\";\n+    private static final String UNKNOWN = \"UNKNOWN\";\n+\n+    private final ClientLogger logger = new ClientLogger(QueueClientBuilder.class);\n+\n+    private ProxyOptions proxyOptions;\n+    private TokenCredential credentials;\n+    private Configuration configuration;\n+    private AmqpRetryOptions retryOptions;\n+    private Scheduler scheduler;\n+    private AmqpTransportType transport = AmqpTransportType.AMQP;\n+    private String fullyQualifiedNamespace;\n+    private String queueName;\n+    private ServiceBusConnectionProcessor servicerBusConnectionProcessor;\n+    private final String connectionId;\n+\n+    /**\n+     * Creates a new instance with the default transport {@link AmqpTransportType#AMQP}.\n+     */\n+    public QueueClientBuilder() {\n+        this.connectionId = StringUtil.getRandomString(\"MF\");\n+    }\n+\n+    /**\n+     *\n+     * @param connectionString to connect to Queue.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder connectionString(String connectionString) {\n+        final ConnectionStringProperties properties = new ConnectionStringProperties(connectionString);\n+        final TokenCredential tokenCredential;\n+        try {\n+            tokenCredential = new ServiceBusSharedKeyCredential(properties.getSharedAccessKeyName(),\n+                properties.getSharedAccessKey(), ServiceBusClientConstants.TOKEN_VALIDITY);\n+        } catch (Exception e) {\n+            throw logger.logExceptionAsError(\n+                new AzureException(\"Could not create the ServiceBusSharedKeyCredential.\", e));\n+        }\n+        this.fullyQualifiedNamespace = properties.getEndpoint().getHost();\n+        this.queueName = properties.getEntityPath();\n+        return credential(properties.getEndpoint().getHost(), properties.getEntityPath(), tokenCredential);\n+    }\n+\n+    /**\n+     *\n+     * @param fullyQualifiedNamespace for the Service Bus.\n+     * @param queueName The name of the queue.\n+     * @param credential {@link TokenCredential} to be used for authentication.\n+     * @return The updated {@link QueueClientBuilder} object.\n+     */\n+    public QueueClientBuilder credential(String fullyQualifiedNamespace, String queueName, TokenCredential credential) {", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDk0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382784945", "bodyText": "I got impression that EH had issues where useres were confused with host . I am open to idea but we should get review by EH team.", "author": "hemanttanwar", "createdAt": "2020-02-21T20:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NDk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382345460", "bodyText": "In the JS stuff I just did I just took the entire message as the parameter. What do you think about that? I figure it requires the user to know less - just give me the whole object.", "author": "richardpark-msft", "createdAt": "2020-02-21T01:02:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,303 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.RetryUtil;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.ServiceBusAsyncConsumer;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusReceiveLinkProcessor;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.SignalType;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static com.azure.core.util.FluxUtil.fluxError;\n+\n+/**\n+ * An <b>asynchronous</b> receiver responsible for receiving {@link Message} from a specific Queue.\n+ *\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueReceiverAsyncClient implements Closeable {\n+\n+    private static final String RECEIVER_ENTITY_PATH_FORMAT = \"%s\";\n+\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final ClientLogger logger = new ClientLogger(QueueReceiverAsyncClient.class);\n+    private final String fullyQualifiedNamespace;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final MessageSerializer messageSerializer;\n+    private final int prefetchCount;\n+    private final TracerProvider tracerProvider;\n+    private final ReceiveMode defaultReceiveMode = ReceiveMode.PEEK_LOCK;\n+\n+    /**\n+     * Consumer to maintain single connection per queue.\n+     */\n+    private final AtomicReference<ServiceBusAsyncConsumer> openConsumer =  new AtomicReference<>();\n+\n+    QueueReceiverAsyncClient(String fullyQualifiedNamespace, String queueName,\n+                             ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+                             MessageSerializer messageSerializer, int prefetchCount) {\n+        this.fullyQualifiedNamespace = fullyQualifiedNamespace;\n+        this.queueName = queueName;\n+        this.connectionProcessor = connectionProcessor;\n+        this.messageSerializer = messageSerializer;\n+        this.prefetchCount = prefetchCount;\n+        this.tracerProvider = tracerProvider;\n+    }\n+\n+    /**\n+     * Gets the fully qualified Service Bus namespace that the connection is associated with. This is likely similar to\n+     * {@code {yournamespace}.servicebus.windows.net}.\n+     *\n+     * @return The fully qualified Service Bus namespace that the connection is associated with.\n+     */\n+    public String getFullyQualifiedNamespace() {\n+        return fullyQualifiedNamespace;\n+    }\n+\n+    /**\n+     * Gets the Queue name this client interacts with.\n+     *\n+     * @return The Queue name this client interacts with.\n+     */\n+    public String getQueueName() {\n+        return queueName;\n+    }\n+\n+    /**\n+     * Receives a stream of {@link Message} with default server wait time.\n+     *\n+     * @return A stream of messages from Queue.\n+     */\n+    public Flux<Message> receive() {\n+        return receive(defaultReceiveMode);\n+    }\n+\n+    /**\n+     * Consumes messages for given {@link ReceiveMode}.\n+     *\n+     * @param receiveMode {@link ReceiveMode} when receiving events from Queue.\n+     *\n+     * @return A stream of events for every partition from Queue.\n+     *\n+     * @throws NullPointerException if {@code receiveMode} is null.\n+     */\n+    public Flux<Message> receive(ReceiveMode receiveMode) {\n+        if (Objects.isNull(receiveMode)) {\n+            return fluxError(logger, new NullPointerException(\"'receiveMode' cannot be null.\"));\n+        }\n+\n+        final String linkName = connectionProcessor.getEntityPath();\n+        return createConsumer(linkName, receiveMode);\n+    }\n+\n+    /**\n+     * Disposes of the consumer by closing the underlying connection to the service.\n+     */\n+    @Override\n+    public void close() {\n+        if (isDisposed.getAndSet(true)) {\n+            return;\n+        }\n+        if (openConsumer.get() != null) {\n+            openConsumer.get().close();\n+        }\n+\n+        connectionProcessor.dispose();\n+\n+    }\n+\n+    private Flux<Message> createConsumer(String linkName, ReceiveMode receiveMode) {\n+        if (openConsumer.get() == null) {\n+            logger.info(\"{}: Creating receive consumer.\", linkName);\n+            openConsumer.set(createServiceBusConsumer(linkName, receiveMode));\n+        }\n+        return openConsumer.get()\n+            .receive()\n+            .doOnCancel(() -> removeLink(linkName, SignalType.CANCEL))\n+            .doOnComplete(() -> removeLink(linkName, SignalType.ON_COMPLETE))\n+            .doOnError(error -> removeLink(linkName, SignalType.ON_ERROR));\n+    }\n+\n+    private void removeLink(String linkName, SignalType signalType) {\n+        logger.info(\"{}: Receiving completed. Signal[{}]\", linkName, signalType);\n+\n+        if (openConsumer.get() != null) {\n+            openConsumer.get().close();\n+        }\n+    }\n+    private ServiceBusAsyncConsumer createServiceBusConsumer(String linkName, ReceiveMode receiveMode) {\n+        final String entityPath = String.format(Locale.US, RECEIVER_ENTITY_PATH_FORMAT, getQueueName());\n+\n+        final Flux<AmqpReceiveLink> receiveLinkMono =\n+            connectionProcessor.flatMap(connection ->\n+                connection.createReceiveLink(linkName, entityPath, receiveMode))\n+                .doOnNext(next -> logger.verbose(\"Creating consumer for path: {}\", next.getEntityPath()))\n+                .repeat();\n+\n+        final AmqpRetryPolicy retryPolicy = RetryUtil.getRetryPolicy(connectionProcessor.getRetryOptions());\n+        final ServiceBusReceiveLinkProcessor linkMessageProcessor = receiveLinkMono.subscribeWith(\n+            new ServiceBusReceiveLinkProcessor(prefetchCount, retryPolicy, connectionProcessor));\n+\n+        return new ServiceBusAsyncConsumer(linkMessageProcessor, messageSerializer, fullyQualifiedNamespace,\n+            entityPath);\n+    }\n+\n+    /**\n+     * Abandon {@link Message} with lock token and updated message property. This will make the message available\n+     * again for processing. Abandoning a message will increase the delivery count on the message.\n+     *\n+     * @param lockToken to be used.\n+     * @param propertiesToModify Message properties to modify.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> abandon(UUID lockToken, Map<String, Object> propertiesToModify) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     * Abandon {@link Message} with lock token. This will make the message available again for processing.\n+     * Abandoning a message will increase the delivery count on the message.\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> abandon(UUID lockToken) {\n+        //TODO(feature-to-implement)\n+        return null;\n+    }\n+\n+    /**\n+     * Completes a {@link Message} using its lock token. This will delete the message from the service.\n+     *\n+     * @param lockToken to be used.\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Void> complete(UUID lockToken) {\n+        //TODO(feature-to-implement)", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc4NDExNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382784117", "bodyText": "I like the idea of \"user know less\". This is one place where all the languages can be same. Lets get it finalized during API review. One point to consider , does user have to cache whole object instead of id if they are dealing with multiple messages.", "author": "hemanttanwar", "createdAt": "2020-02-21T20:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjAxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r382346013", "bodyText": "What are some examples of message serializers? I'm guessing we're all going to have JSON, strings. Do you have any Java specific serializers?", "author": "richardpark-msft", "createdAt": "2020-02-21T01:04:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/QueueSenderAsyncClient.java", "diffHunk": "@@ -0,0 +1,353 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpRetryOptions;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpException;\n+\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.amqp.implementation.ErrorContextProvider;\n+\n+import static com.azure.core.amqp.implementation.RetryUtil.getRetryPolicy;\n+import static com.azure.core.amqp.implementation.RetryUtil.withRetry;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.util.Context;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.messaging.servicebus.implementation.CreateBatchOptions;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.Closeable;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collector;\n+\n+import static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\n+import static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\n+import static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\n+\n+/**\n+ * The client to send messages to Queue.\n+ */\n+@ServiceClient(builder = QueueClientBuilder.class, isAsync = true)\n+public final class QueueSenderAsyncClient implements Closeable {\n+\n+    private final ClientLogger logger = new ClientLogger(QueueSenderAsyncClient.class);\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryOptions retryOptions;\n+    private final AmqpRetryPolicy retryPolicy;\n+    private final String queueName;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+\n+    /**\n+     * The default maximum allowable size, in bytes, for a batch to be sent.\n+     */\n+    public static final int MAX_MESSAGE_LENGTH_BYTES = 256 * 1024;\n+\n+    /**\n+     * Creates a new instance of this {@link QueueSenderAsyncClient} that sends messages to\n+     */\n+    QueueSenderAsyncClient(String queueName, ServiceBusConnectionProcessor connectionProcessor,\n+                           AmqpRetryOptions retryOptions, TracerProvider tracerProvider,\n+                           MessageSerializer messageSerializer) {", "originalCommit": "336222771ffa5a537e0c79751b94161bd09cbf1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzI5NDYyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r383294626", "bodyText": "Currently, this serializer will support converting AMQP message in Java SDK representation Message . Making sure the property from AMQP message are translated properly. As of now Binary and json will be supported. We have to bring parity with track 1.", "author": "hemanttanwar", "createdAt": "2020-02-24T14:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjAxMw=="}], "type": "inlineReview"}, {"oid": "bf3a18fe6d1eaf6a4c4205830ef8218ebc8ec726", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf3a18fe6d1eaf6a4c4205830ef8218ebc8ec726", "message": "Review comments and readmes", "committedDate": "2020-02-21T20:50:20Z", "type": "commit"}, {"oid": "e48c8c752e0c68559cf68986565eac3dd8140bf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e48c8c752e0c68559cf68986565eac3dd8140bf7", "message": "added java doc for servicebus", "committedDate": "2020-02-21T21:08:31Z", "type": "commit"}, {"oid": "35dce4b78e9eb80d359681ac14769c6f054f2e20", "url": "https://github.com/Azure/azure-sdk-for-java/commit/35dce4b78e9eb80d359681ac14769c6f054f2e20", "message": "Resolving conflict with master", "committedDate": "2020-02-21T21:24:35Z", "type": "commit"}, {"oid": "93d2d66fad945b9c56d5e97486e9c2d6ccc0695f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/93d2d66fad945b9c56d5e97486e9c2d6ccc0695f", "message": "Resolving conflict with master", "committedDate": "2020-02-21T22:03:28Z", "type": "commit"}, {"oid": "cf8f94f313661b56d74ec60d940fb09683bf3f6f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cf8f94f313661b56d74ec60d940fb09683bf3f6f", "message": "Resolving conflict with master", "committedDate": "2020-02-21T22:15:14Z", "type": "commit"}, {"oid": "4acf6c016fa3f4ba0ae57c8f1bcc385ebe5cbc5f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4acf6c016fa3f4ba0ae57c8f1bcc385ebe5cbc5f", "message": "Resolving conflict with master", "committedDate": "2020-02-21T22:32:12Z", "type": "commit"}, {"oid": "b608c7b1ff1feaba7abb523c21b60aa80c100dec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b608c7b1ff1feaba7abb523c21b60aa80c100dec", "message": "Remove un used method", "committedDate": "2020-02-21T23:18:01Z", "type": "commit"}, {"oid": "ab89e3011f187cd028e2e62e0838392f9b862624", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab89e3011f187cd028e2e62e0838392f9b862624", "message": "adding MS license", "committedDate": "2020-02-22T00:36:28Z", "type": "commit"}, {"oid": "6df0191ecc9b6f600c282f75b4a23be229186d6b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6df0191ecc9b6f600c282f75b4a23be229186d6b", "message": "Merge branch 'master' into feature/servicebus-track2-queuec-client-draft-implementation-7697", "committedDate": "2020-02-22T03:06:15Z", "type": "commit"}, {"oid": "340edab06832fdc36e7bc92e8b4d5a6357137e0f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/340edab06832fdc36e7bc92e8b4d5a6357137e0f", "message": "Removing unused method", "committedDate": "2020-02-22T03:17:50Z", "type": "commit"}, {"oid": "9482e44279b60963e6daeb936fa22bdd7618dfdb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9482e44279b60963e6daeb936fa22bdd7618dfdb", "message": "added unit test case.", "committedDate": "2020-02-23T07:17:20Z", "type": "commit"}, {"oid": "b96ca863ea315eb71d3e766270d67332d7c3fe34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b96ca863ea315eb71d3e766270d67332d7c3fe34", "message": "more test", "committedDate": "2020-02-23T22:08:08Z", "type": "commit"}, {"oid": "3ccada8ffd208d7fddf3c272436259bab32ec2a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3ccada8ffd208d7fddf3c272436259bab32ec2a4", "message": "More test", "committedDate": "2020-02-24T00:30:55Z", "type": "commit"}, {"oid": "1ebd35c11b1c6f1088cb20fe6e625f58fdd1e711", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1ebd35c11b1c6f1088cb20fe6e625f58fdd1e711", "message": "removing unwanted change.", "committedDate": "2020-02-24T00:35:11Z", "type": "commit"}, {"oid": "d2d269d1e90c7172df7478b042baf194b1133fe9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d2d269d1e90c7172df7478b042baf194b1133fe9", "message": "Added core netty client in modules", "committedDate": "2020-02-24T14:45:21Z", "type": "commit"}, {"oid": "0a1f4d1816d430dd577736f052a6f09eb9014961", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0a1f4d1816d430dd577736f052a6f09eb9014961", "message": "Merge branch 'master' into feature/servicebus-track2-queuec-client-draft-implementation-7697", "committedDate": "2020-02-27T23:21:19Z", "type": "commit"}, {"oid": "13c2427bc0cb627b638e15861095467764a5e485", "url": "https://github.com/Azure/azure-sdk-for-java/commit/13c2427bc0cb627b638e15861095467764a5e485", "message": "incorporated review comments", "committedDate": "2020-02-28T16:51:53Z", "type": "commit"}, {"oid": "577d0c32aa292f692208e9b700bfc953d37eeb92", "url": "https://github.com/Azure/azure-sdk-for-java/commit/577d0c32aa292f692208e9b700bfc953d37eeb92", "message": "incorporated review comments", "committedDate": "2020-02-28T17:00:18Z", "type": "commit"}, {"oid": "2a0f2d8e65c2e007b3c8406c8f02ef16f51382aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a0f2d8e65c2e007b3c8406c8f02ef16f51382aa", "message": "incorporated review comments", "committedDate": "2020-02-28T23:46:34Z", "type": "commit"}, {"oid": "71b882b711eb4697e28d0d94888ce8435bef0b63", "url": "https://github.com/Azure/azure-sdk-for-java/commit/71b882b711eb4697e28d0d94888ce8435bef0b63", "message": "Adding ReceiveMessageOptions\n\nMove classes in to model folder.\n\nUpdate Message and remove unneeded methods.\n\nRename MessageBatch.java -> ServiceBusMessageBatch\n\nAdd missing properties to ServiceBusMessage.\n\nUpdating serialization logic for service bus.", "committedDate": "2020-02-29T19:08:31Z", "type": "commit"}, {"oid": "324725bc1bf4f2603313ff7c8143806363d802b6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/324725bc1bf4f2603313ff7c8143806363d802b6", "message": "code for peek", "committedDate": "2020-03-01T04:31:05Z", "type": "commit"}, {"oid": "89e2e6f14b1abe711ab2197a656fc7c78efeca86", "url": "https://github.com/Azure/azure-sdk-for-java/commit/89e2e6f14b1abe711ab2197a656fc7c78efeca86", "message": "added peek", "committedDate": "2020-03-01T06:09:17Z", "type": "commit"}, {"oid": "00839328922d9acf774d1e1db71b1d79cf76bad2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/00839328922d9acf774d1e1db71b1d79cf76bad2", "message": "Removing duplicated ReceiveOptions class.\n\nAdd receive options into receive processor.\n\nAdding message processor for ServiceBus.\n\nFix name of ServiceBusSender.\n\nUpdating default method to PEEK_LOCK\n\nAdding integration test.\n\nAdd deserialization test.\n\nUpdating logging for sender and adding parameters for send test.\n\nAdding Mono.empty() so it does not nul reference", "committedDate": "2020-03-02T17:48:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5MDYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8155#discussion_r386590619", "bodyText": "This is used by Event Hubs too. Why are we setting You should be creating PRs so we can review these changes.\nsession.open() has to be invoked on the reactor dispatcher thread.", "author": "conniey", "createdAt": "2020-03-02T19:07:55Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RequestResponseChannel.java", "diffHunk": "@@ -91,18 +91,25 @@\n         this.operationTimeout = retryOptions.getTryTimeout();\n         this.retryPolicy = RetryUtil.getRetryPolicy(retryOptions);\n \n+        // Create sender\n         this.replyTo = entityPath.replace(\"$\", \"\") + \"-client-reply-to\";\n         this.messageSerializer = messageSerializer;\n+        session.setOutgoingWindow(Integer.MAX_VALUE);", "originalCommit": "301013828154e761bffa281c53a27fa480434ddd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a0c493e93d08e8eb1a3afe5a9193a9ded850ebfb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0c493e93d08e8eb1a3afe5a9193a9ded850ebfb", "message": "Merge branch 'master' of https://github.com/azure/azure-sdk-for-java into hemanttanwar/feature/servicebus-track2-queuec-client-draft-implementation-7697", "committedDate": "2020-03-05T20:36:06Z", "type": "commit"}, {"oid": "102091039d2e06f6152dc138a9520b34b92aa866", "url": "https://github.com/Azure/azure-sdk-for-java/commit/102091039d2e06f6152dc138a9520b34b92aa866", "message": "Fix javadoc warnings.", "committedDate": "2020-03-05T20:38:13Z", "type": "commit"}, {"oid": "a15984b8cf5a0b27798c41c44d97efba02dfd4c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a15984b8cf5a0b27798c41c44d97efba02dfd4c9", "message": "fix broken test.", "committedDate": "2020-03-05T20:44:48Z", "type": "commit"}, {"oid": "f5d28c55da22c5b9a96aece9530c3c09addf493b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5d28c55da22c5b9a96aece9530c3c09addf493b", "message": "Fix message", "committedDate": "2020-03-05T20:54:36Z", "type": "commit"}, {"oid": "98d4b591420dff6ee84499676ae391d1973f2f72", "url": "https://github.com/Azure/azure-sdk-for-java/commit/98d4b591420dff6ee84499676ae391d1973f2f72", "message": "Cleaning up javadocs.", "committedDate": "2020-03-05T21:02:04Z", "type": "commit"}, {"oid": "2e5317be06ed1125903b8ce4b9390efe4aa4c31d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2e5317be06ed1125903b8ce4b9390efe4aa4c31d", "message": "Fix class.", "committedDate": "2020-03-05T21:09:12Z", "type": "commit"}, {"oid": "cdac58507e4c86b8bee969718c2959574993ba56", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cdac58507e4c86b8bee969718c2959574993ba56", "message": "Fixing documentation.", "committedDate": "2020-03-05T21:16:33Z", "type": "commit"}, {"oid": "aedcf82608ce0bd65220484573318d6a404679d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aedcf82608ce0bd65220484573318d6a404679d4", "message": "Fixing checkstyle issues.", "committedDate": "2020-03-05T21:34:25Z", "type": "commit"}, {"oid": "5743048e710fc026d236595227a0a996d9cd7dbe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5743048e710fc026d236595227a0a996d9cd7dbe", "message": "Adding tests for MessageBatch.", "committedDate": "2020-03-05T21:52:27Z", "type": "commit"}, {"oid": "fe07764da24ba7eab3aa0c8d0782e6527f5407b8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe07764da24ba7eab3aa0c8d0782e6527f5407b8", "message": "Fixing documentation.", "committedDate": "2020-03-05T21:59:06Z", "type": "commit"}, {"oid": "2cc89852cdbf57605ed338a8d00731cc43832c6b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2cc89852cdbf57605ed338a8d00731cc43832c6b", "message": "Clean up receiver.", "committedDate": "2020-03-05T22:01:37Z", "type": "commit"}, {"oid": "e86552a2d12590662ab8b2f3ec548ca3106051c2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e86552a2d12590662ab8b2f3ec548ca3106051c2", "message": "Fix broken tests.", "committedDate": "2020-03-05T22:24:22Z", "type": "commit"}, {"oid": "0eb272a489bc023c22c281cc0090e2149cd3bef0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0eb272a489bc023c22c281cc0090e2149cd3bef0", "message": "Checkstyle fixes.", "committedDate": "2020-03-05T22:29:00Z", "type": "commit"}, {"oid": "2b44b38fbd8e97bdc4f2806c84b3bc1024164a4a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2b44b38fbd8e97bdc4f2806c84b3bc1024164a4a", "message": "Move CreateBatchOptions", "committedDate": "2020-03-05T22:35:29Z", "type": "commit"}, {"oid": "14b2bfd77e15949889680a62c612c701660264fb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/14b2bfd77e15949889680a62c612c701660264fb", "message": "Fix spotbugs.", "committedDate": "2020-03-05T22:39:10Z", "type": "commit"}, {"oid": "663cfce59b43b65dbb12699c445e3cdb3797def3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/663cfce59b43b65dbb12699c445e3cdb3797def3", "message": "Fix ci.yml", "committedDate": "2020-03-05T22:48:19Z", "type": "commit"}]}