{"pr_number": 12064, "pr_title": "Nio output stream", "pr_createdAt": "2020-06-11T00:23:50Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/12064", "timeline": [{"oid": "f5111d98949ab6a6615f78bbe9f61e7a948880de", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5111d98949ab6a6615f78bbe9f61e7a948880de", "message": "Created OS type", "committedDate": "2020-06-09T19:12:47Z", "type": "commit"}, {"oid": "6ddba475295bcba8cc536b7f83afe53db1ed78a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ddba475295bcba8cc536b7f83afe53db1ed78a4", "message": "Added most tests", "committedDate": "2020-06-10T21:32:42Z", "type": "commit"}, {"oid": "0b8beb5dcb2592cb980887734923b5f9a4aa2027", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0b8beb5dcb2592cb980887734923b5f9a4aa2027", "message": "Finished tests and javadocs", "committedDate": "2020-06-10T23:54:14Z", "type": "commit"}, {"oid": "96acad8d9acc7169ebfad230f3dc2e6be9f76b82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96acad8d9acc7169ebfad230f3dc2e6be9f76b82", "message": "Added recordings", "committedDate": "2020-06-11T00:11:30Z", "type": "commit"}, {"oid": "fd25b2f65bb2796215cf41a8d003b79f131ad5e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fd25b2f65bb2796215cf41a8d003b79f131ad5e2", "message": "CI fixes", "committedDate": "2020-06-11T20:30:02Z", "type": "commit"}, {"oid": "c89b68727cc773a2f81ad6214e7b57f79c415686", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89b68727cc773a2f81ad6214e7b57f79c415686", "message": "CI", "committedDate": "2020-06-11T22:57:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439539585", "bodyText": "blockSize is long now right?", "author": "gapra-msft", "createdAt": "2020-06-12T17:03:22Z", "path": "sdk/storage/azure-storage-blob-nio/src/main/java/com/azure/storage/blob/nio/AzureFileSystemProvider.java", "diffHunk": "@@ -221,10 +228,111 @@ public InputStream newInputStream(Path path, OpenOption... options) throws IOExc\n                 + \"Path must point to a file. Path: \" + path.toString()));\n         }\n \n-        // Note that methods on BlobInputSTream are already synchronized.\n+        // Note that methods on BlobInputStream are already synchronized.\n         return new NioBlobInputStream(resource.getBlobClient().openInputStream());\n     }\n \n+    /**\n+     * Opens an {@link OutputStream} to the given path. The resulting file will be stored as a block blob.\n+     * <p>\n+     * The only supported options are {@link StandardOpenOption#CREATE}, {@link StandardOpenOption#CREATE_NEW},\n+     * {@link StandardOpenOption#WRITE}, {@link StandardOpenOption#TRUNCATE_EXISTING}. Any other options will throw an\n+     * {@link UnsupportedOperationException}. {@code WRITE} and {@code TRUNCATE_EXISTING} must be specified or an\n+     * {@link IllegalArgumentException} will be thrown. Hence, files cannot be updated, only overwritten completely.\n+     * <p>\n+     * This stream will not attempt to buffer the entire file, however some buffering will be done for potential\n+     * optimizations and to avoid network thrashing. Specifically, up to\n+     * {@link AzureFileSystem#AZURE_STORAGE_PUT_BLOB_THRESHOLD} bytes will be buffered initially. If that threshold is\n+     * exceeded, the data will be broken into chunks and sent in blocks, and writes will be buffered into sizes of\n+     * {@link AzureFileSystem#AZURE_STORAGE_UPLOAD_BLOCK_SIZE}. The maximum number of buffers of this size to be\n+     * allocated is defined by {@link AzureFileSystem#AZURE_STORAGE_MAX_CONCURRENCY_PER_REQUEST}, which also configures\n+     * the level of parallelism with which we may write and thus may affect write speeds as well.\n+     * <p>\n+     * The data is only committed when the steam is closed. Hence data cannot be read from the destination until the\n+     * stream is closed. When the close method returns, it is guaranteed that, barring any errors, the data is finalized\n+     * and available for reading.\n+     * <p>\n+     * Writing happens asynchronously. Bytes passed for writing are stored until either the threshold or block size are\n+     * met at which time they are sent to the service. When the write method returns, there is no guarantee about which\n+     * phase of this process the data is in other than it has been accepted and will be written. Again, closing will\n+     * guarantee that the data is written and available.\n+     * <p>\n+     * Flush is a no-op as regards data transfers, but it can be used to check the state of the stream for errors.\n+     * This can be a useful tool because writing happens asynchronously, and therefore an error from a previous write\n+     * may not otherwise be thrown unless the stream is flushed, closed, or written to again.\n+     *\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public OutputStream newOutputStream(Path path, OpenOption... options) throws IOException {\n+        // If options are empty, add Create, Write, TruncateExisting as defaults per nio docs.\n+        if (options == null || options.length == 0) {\n+            options = new OpenOption[] {\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.TRUNCATE_EXISTING };\n+        }\n+        List<OpenOption> optionsList = Arrays.asList(options);\n+\n+        // Check for unsupported options.\n+        List<OpenOption> supportedOptions = Arrays.asList(\n+            StandardOpenOption.CREATE_NEW,\n+            StandardOpenOption.CREATE,\n+            StandardOpenOption.WRITE,\n+            // Though we don't actually truncate, the same result is achieved by overwriting the destination.\n+            StandardOpenOption.TRUNCATE_EXISTING);\n+        for (OpenOption option : optionsList) {\n+            if (!supportedOptions.contains(option)) {\n+                throw new UnsupportedOperationException(\"Unsupported option: \" + option.toString());\n+            }\n+        }\n+\n+        // Write and truncate must be specified\n+        if (!optionsList.contains(StandardOpenOption.WRITE)\n+            || !optionsList.contains(StandardOpenOption.TRUNCATE_EXISTING)) {\n+            throw new IllegalArgumentException(\"Write and TruncateExisting must be specified to open an OutputStream\");\n+        }\n+\n+        AzureResource resource = new AzureResource(path);\n+        DirectoryStatus status = resource.checkDirStatus();\n+\n+        // Cannot write to a directory.\n+        if (DirectoryStatus.isDirectory(status)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Cannot open an OutputStream to a directory. Path: \"\n+                + path.toString()));\n+        }\n+\n+        // Writing to an empty location requires a create option.\n+        if (status.equals(DirectoryStatus.DOES_NOT_EXIST)\n+            && !(optionsList.contains(StandardOpenOption.CREATE)\n+            || optionsList.contains(StandardOpenOption.CREATE_NEW))) {\n+            throw LoggingUtility.logError(logger, new IOException(\"Writing to an empty location requires a create \"\n+                + \"option. Path: \" + path.toString()));\n+        }\n+\n+        // Cannot write to an existing file if create new was specified.\n+        if (status.equals(DirectoryStatus.NOT_A_DIRECTORY) && optionsList.contains(StandardOpenOption.CREATE_NEW)) {\n+            throw LoggingUtility.logError(logger, new IOException(\"A file already exists at this location and \"\n+                + \"CREATE_NEW was specified. Path: \" + path.toString()));\n+        }\n+\n+        // Create options based on file system config\n+        AzureFileSystem fs = (AzureFileSystem) (path.getFileSystem());\n+        Integer blockSize = fs.getBlockSize() == null ? null : fs.getBlockSize().intValue();", "originalCommit": "c89b68727cc773a2f81ad6214e7b57f79c415686", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTk2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439539966", "bodyText": "Or is this on purpose due to constraints below?", "author": "gapra-msft", "createdAt": "2020-06-12T17:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0MDgzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12064#discussion_r439540833", "bodyText": "It's long in 73, which is why I made the config value a long in anticipation of that, but this branch doesn't have those updates yet, so I'll strike these conversions to int once all that gets merged in.", "author": "rickle-msft", "createdAt": "2020-06-12T17:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUzOTU4NQ=="}], "type": "inlineReview"}]}