{"pr_number": 14469, "pr_title": "mgmt add azure-resourcemanager-eventhubs", "pr_createdAt": "2020-08-26T05:17:20Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14469", "timeline": [{"oid": "9ceeecb01196ee3185128f173fdd873ab1c48426", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ceeecb01196ee3185128f173fdd873ab1c48426", "message": "copy eventhubs code from azure-libraries-for-java", "committedDate": "2020-08-25T04:55:24Z", "type": "commit"}, {"oid": "12049a117a1b454542634162186510d6f759c0f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/12049a117a1b454542634162186510d6f759c0f2", "message": "rename package", "committedDate": "2020-08-25T05:08:41Z", "type": "commit"}, {"oid": "0dbf307e78b162c842bae370c6aedd38cac9c69c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0dbf307e78b162c842bae370c6aedd38cac9c69c", "message": "update api-spec", "committedDate": "2020-08-25T05:13:07Z", "type": "commit"}, {"oid": "f17004b9af80af6ad7fdd362efeac5670f276fbc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f17004b9af80af6ad7fdd362efeac5670f276fbc", "message": "generate eventhubs", "committedDate": "2020-08-25T05:15:48Z", "type": "commit"}, {"oid": "09dc56d15c874464185c45bb7ac306edf3457ed7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/09dc56d15c874464185c45bb7ac306edf3457ed7", "message": "fix compile errors", "committedDate": "2020-08-25T10:33:25Z", "type": "commit"}, {"oid": "4a16ab26a0e9a8f7986516f1d3b5d82ac62465a7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4a16ab26a0e9a8f7986516f1d3b5d82ac62465a7", "message": "update session records", "committedDate": "2020-08-26T02:39:38Z", "type": "commit"}, {"oid": "f1aa4ecd8f290faa8ec0cd111a47a9f6a63ba3a8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1aa4ecd8f290faa8ec0cd111a47a9f6a63ba3a8", "message": "update for storage changes", "committedDate": "2020-08-26T03:31:06Z", "type": "commit"}, {"oid": "caf0bacb859a20348cb3afe82f59d179de9090a5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/caf0bacb859a20348cb3afe82f59d179de9090a5", "message": "update eventhubs in azure client", "committedDate": "2020-08-26T03:31:49Z", "type": "commit"}, {"oid": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "message": "add samples for eventhubs", "committedDate": "2020-08-26T05:16:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MDkyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477040926", "bodyText": "Here we adopt com.microsoft.azure: azure-storage to com.azure: azure-storage-blob, comparing to previous code.", "author": "xseeseesee", "createdAt": "2020-08-26T05:23:14Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                    final String containerName) {\n+            return getBlobClientAsync(storageAccount)\n+                .flatMap(blobServiceAsyncClient -> blobServiceAsyncClient\n+                    .getBlobContainerAsyncClient(containerName)\n+                    .exists()\n+                    .flatMap(aBoolean -> {\n+                        if (aBoolean) {\n+                            return Mono.empty();\n+                        }\n+                        return blobServiceAsyncClient.getBlobContainerAsyncClient(containerName).create();\n+                    }));\n+        }\n+\n+        private Mono<BlobServiceAsyncClient> getBlobClientAsync(final StorageAccount storageAccount) {", "originalCommit": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTMxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477111319", "bodyText": "Remove this as we can do in mgmt storage.", "author": "xseeseesee", "createdAt": "2020-08-26T08:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA0MDkyNg=="}], "type": "inlineReview"}, {"oid": "5e7d6ba14af0bcbcaa302a189d0a16b41b354984", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5e7d6ba14af0bcbcaa302a189d0a16b41b354984", "message": "update credcheck and session records", "committedDate": "2020-08-26T05:43:26Z", "type": "commit"}, {"oid": "0356ee79c0d6fad3cc12b4467a477d65f07e63f6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0356ee79c0d6fad3cc12b4467a477d65f07e63f6", "message": "rename and reformat", "committedDate": "2020-08-26T05:49:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477057936", "bodyText": "Mgmt should be able to create a storage blob container?", "author": "weidongxu-microsoft", "createdAt": "2020-08-26T06:15:22Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,532 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.blob.BlobServiceAsyncClient;\n+import com.azure.storage.blob.BlobServiceClientBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName)\n+                .flatMap(aVoid -> context.voidMono()));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName)\n+                        .flatMap(aVoid -> context.voidMono());\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Void> createContainerIfNotExistsAsync(final StorageAccount storageAccount,", "originalCommit": "c4c9e9a7a0240dd2cb7a176fd02936e5216e1ef8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExMTQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477111463", "bodyText": "Changed to mgmt storage.", "author": "xseeseesee", "createdAt": "2020-08-26T08:04:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzkzNg=="}], "type": "inlineReview"}, {"oid": "33141d8d2fa25b031eb0a22481b65db069064316", "url": "https://github.com/Azure/azure-sdk-for-java/commit/33141d8d2fa25b031eb0a22481b65db069064316", "message": "rename EventHubManager to EventHubsManager", "committedDate": "2020-08-26T07:12:23Z", "type": "commit"}, {"oid": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/846bff2ed7a7ad2d7d77c92629586bd8ff048db4", "message": "remove azure-storage-blob", "committedDate": "2020-08-26T08:01:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1OTg1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477159850", "bodyText": "blobContainer is a indexable, don't flatmap to void", "author": "ChenTanyi", "createdAt": "2020-08-26T09:19:12Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -383,7 +383,7 @@ public CaptureSettings withNewStorageAccountForCapturedData(\n                     StorageAccount storageAccount = (StorageAccount) indexable;\n                     ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n                     return createContainerIfNotExistsAsync(storageAccount, containerName)\n-                        .flatMap(aVoid -> context.voidMono());\n+                        .flatMap(blobContainer -> context.voidMono());", "originalCommit": "846bff2ed7a7ad2d7d77c92629586bd8ff048db4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE3NTQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477175426", "bodyText": "updated.", "author": "xseeseesee", "createdAt": "2020-08-26T09:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE1OTg1MA=="}], "type": "inlineReview"}, {"oid": "5ac97ba2bffe000bf59720c12f5b6dfb9d45fdf0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ac97ba2bffe000bf59720c12f5b6dfb9d45fdf0", "message": "update indexable cast", "committedDate": "2020-08-26T09:44:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODM4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908384", "bodyText": "I think it better throws exception when else, due to it need such properties in request.", "author": "ChenTanyi", "createdAt": "2020-08-27T01:56:35Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -70,10 +66,13 @@ public ProvisioningStateDR provisioningState() {\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewPrimaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "originalCommit": "09dc56d15c874464185c45bb7ac306edf3457ed7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwODYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477908609", "bodyText": "same as above", "author": "ChenTanyi", "createdAt": "2020-08-27T01:56:45Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubDisasterRecoveryPairingImpl.java", "diffHunk": "@@ -96,10 +96,13 @@ public EventHubDisasterRecoveryPairingImpl withExistingPrimaryNamespaceId(String\n     }\n \n     @Override\n-    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+    public EventHubDisasterRecoveryPairingImpl withNewSecondaryNamespace(\n+        Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.inner().withPartnerNamespace(namespace.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.inner().withPartnerNamespace(namespace.name());", "originalCommit": "09dc56d15c874464185c45bb7ac306edf3457ed7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkwOTg2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r477909868", "bodyText": "same as above", "author": "ChenTanyi", "createdAt": "2020-08-27T01:57:39Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -153,8 +139,10 @@ public int messageRetentionPeriodInDays() {\n     @Override\n     public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n         this.addDependency(namespaceCreatable);\n-        EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n-        this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());", "originalCommit": "09dc56d15c874464185c45bb7ac306edf3457ed7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f0ac4106c27d4f8265b211c9c2df2761957fe98", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0f0ac4106c27d4f8265b211c9c2df2761957fe98", "message": "throw illegal argument exception when casting", "committedDate": "2020-08-27T04:38:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODExODM4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478118384", "bodyText": "@weidongxu-microsoft This is the main changes after migration. I apply azure-resourcemanager-storage for the scenario to create a container if not exists instead of using azure-storage/azure-storage-blob. The rest part keeps as it is.", "author": "xseeseesee", "createdAt": "2020-08-27T04:57:21Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewManageRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withManageAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutAuthorizationRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), ruleName)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewConsumerGroup(final String name, final String metadata) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .define(name)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withUserMetadata(metadata)\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withoutConsumerGroup(final String name) {\n+        addPostRunDependent(context -> manager().consumerGroups()\n+            .deleteByNameAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), name)\n+            .then(context.voidMono()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withPartitionCount(long count) {\n+        this.inner().withPartitionCount(count);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withRetentionPeriodInDays(long period) {\n+        this.inner().withMessageRetentionInDays(period);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl update() {\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        return super.update();\n+    }\n+\n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        this.inner().withCaptureDescription(this.captureSettings.validateAndGetSettings());\n+    }\n+\n+    @Override\n+    public Mono<EventHub> createResourceAsync() {\n+        return this.manager.inner().getEventHubs()\n+                .createOrUpdateAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name(), this.inner())\n+                .map(innerToFluentMap(this));\n+    }\n+\n+    @Override\n+    protected Mono<EventhubInner> getInnerAsync() {\n+        return this.manager.inner().getEventHubs().getAsync(this.ancestor().resourceGroupName(),\n+                this.ancestor().ancestor1Name(),\n+                this.name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubConsumerGroup> listConsumerGroupsAsync() {\n+        return this.manager.consumerGroups()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedFlux<EventHubAuthorizationRule> listAuthorizationRulesAsync() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHubAsync(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubConsumerGroup> listConsumerGroups() {\n+        return this.manager.consumerGroups()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    @Override\n+    public PagedIterable<EventHubAuthorizationRule> listAuthorizationRules() {\n+        return this.manager.eventHubAuthorizationRules()\n+                .listByEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name());\n+    }\n+\n+    private Ancestors.OneAncestor ancestor() {\n+        Objects.requireNonNull(this.ancestor);\n+        return this.ancestor;\n+    }\n+\n+    private String selfId(String parentId) {\n+        return String.format(\"%s/eventhubs/%s\", parentId, this.name());\n+    }\n+\n+    private class CaptureSettings {\n+        private final CaptureDescription currentSettings;\n+        private CaptureDescription newSettings;\n+\n+        CaptureSettings(final EventhubInner eventhubInner) {\n+            this.currentSettings = eventhubInner.captureDescription();\n+        }\n+\n+        public CaptureSettings withNewStorageAccountForCapturedData(\n+            final Creatable<StorageAccount> creatableStorageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(\"temp-id\");\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create storage account and container.\n+            //\n+            addDependency(context -> creatableStorageAccount\n+                .createAsync()\n+                .last()\n+                .flatMap(indexable -> {\n+                    StorageAccount storageAccount = (StorageAccount) indexable;\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final StorageAccount storageAccount, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> createContainerIfNotExistsAsync(storageAccount, containerName));\n+            return this;\n+        }\n+\n+        public CaptureSettings withExistingStorageAccountForCapturedData(\n+            final String storageAccountId, final String containerName) {\n+            this.ensureSettings().destination().withStorageAccountResourceId(storageAccountId);\n+            this.ensureSettings().destination().withBlobContainer(containerName);\n+            //\n+            // Schedule task to create container if not exists.\n+            //\n+            addDependency(context -> storageManager.storageAccounts()\n+                .getByIdAsync(storageAccountId)\n+                .flatMap(storageAccount -> {\n+                    ensureSettings().destination().withStorageAccountResourceId(storageAccount.id());\n+                    return createContainerIfNotExistsAsync(storageAccount, containerName);\n+                }));\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureEnabled() {\n+            this.ensureSettings().withEnabled(true);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureDisabled() {\n+            this.ensureSettings().withEnabled(false);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+            this.ensureSettings().withSkipEmptyArchives(skipEmptyArchives);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+            this.ensureSettings().withIntervalInSeconds(sizeInSeconds);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureWindowSizeInMB(int sizeInMB) {\n+            this.ensureSettings().withSizeLimitInBytes(sizeInMB * 1024 * 1024);\n+            return this;\n+        }\n+\n+        public CaptureSettings withDataCaptureFileNameFormat(String format) {\n+            this.ensureSettings().destination().withArchiveNameFormat(format);\n+            return this;\n+        }\n+\n+        public CaptureDescription validateAndGetSettings() {\n+            if (this.newSettings == null) {\n+                return this.currentSettings;\n+            } else if (this.newSettings.destination() == null\n+                    || this.newSettings.destination().storageAccountResourceId() == null\n+                    || this.newSettings.destination().blobContainer() == null) {\n+                throw logger.logExceptionAsError(new IllegalStateException(\n+                    \"Setting any of the capture properties requires \"\n+                        + \"capture destination [StorageAccount, DataLake] to be specified\"));\n+            }\n+            if (this.newSettings.destination().name() == null) {\n+                this.newSettings.destination().withName(\"EventHubArchive.AzureBlockBlob\");\n+            }\n+            if (this.newSettings.encoding() == null) {\n+                this.newSettings.withEncoding(EncodingCaptureDescription.AVRO);\n+            }\n+            return this.newSettings;\n+        }\n+\n+        private CaptureDescription ensureSettings() {\n+            if (this.newSettings != null) {\n+                return this.newSettings;\n+            } else if (this.currentSettings == null) {\n+                this.newSettings = new CaptureDescription().withDestination(new Destination());\n+                return this.newSettings;\n+            } else {\n+                // Clone the current settings to new settings (one time)\n+                //\n+                this.newSettings = cloneCurrentSettings();\n+                return this.newSettings;\n+            }\n+        }\n+\n+        private Mono<Indexable> createContainerIfNotExistsAsync(final StorageAccount storageAccount,\n+                                                                final String containerName) {\n+            return storageManager.blobContainers()", "originalCommit": "0f0ac4106c27d4f8265b211c9c2df2761957fe98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478132043", "bodyText": "Please try test case which do both (NewSend and NewListen) in one Create/Update. I remember service not able to handle concurrent requests under eventhub, so these had to be done in sequence.\nAzure/azure-libraries-for-net#891", "author": "weidongxu-microsoft", "createdAt": "2020-08-27T05:18:44Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -0,0 +1,515 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.eventhubs.implementation;\n+\n+import com.azure.core.http.rest.PagedFlux;\n+import com.azure.core.http.rest.PagedIterable;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.resourcemanager.eventhubs.EventHubsManager;\n+import com.azure.resourcemanager.eventhubs.fluent.inner.EventhubInner;\n+import com.azure.resourcemanager.eventhubs.models.CaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.Destination;\n+import com.azure.resourcemanager.eventhubs.models.EncodingCaptureDescription;\n+import com.azure.resourcemanager.eventhubs.models.EventHub;\n+import com.azure.resourcemanager.eventhubs.models.EventHubAuthorizationRule;\n+import com.azure.resourcemanager.eventhubs.models.EventHubConsumerGroup;\n+import com.azure.resourcemanager.eventhubs.models.EventHubNamespace;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Indexable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.StorageManager;\n+import com.azure.resourcemanager.storage.models.PublicAccess;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+/**\n+ * Implementation for {@link EventHub}.\n+ */\n+class EventHubImpl\n+    extends NestedResourceImpl<EventHub, EventhubInner, EventHubImpl>\n+    implements EventHub, EventHub.Definition, EventHub.Update {\n+\n+    private Ancestors.OneAncestor ancestor;\n+    private CaptureSettings captureSettings;\n+    private StorageManager storageManager;\n+\n+    private final ClientLogger logger = new ClientLogger(EventHubImpl.class);\n+\n+    EventHubImpl(String name, EventhubInner inner, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, inner, manager);\n+        this.ancestor = new Ancestors().new OneAncestor(inner.id());\n+        this.captureSettings = new CaptureSettings(this.inner());\n+        this.storageManager = storageManager;\n+    }\n+\n+    EventHubImpl(String name, EventHubsManager manager, StorageManager storageManager) {\n+        super(name, new EventhubInner(), manager);\n+        this.storageManager = storageManager;\n+        this.captureSettings = new CaptureSettings(this.inner());\n+    }\n+\n+    @Override\n+    public String namespaceResourceGroupName() {\n+        return this.ancestor().resourceGroupName();\n+    }\n+\n+    @Override\n+    public String namespaceName() {\n+        return this.ancestor().ancestor1Name();\n+    }\n+\n+    @Override\n+    public boolean isDataCaptureEnabled() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return Utils.toPrimitiveBoolean(this.inner().captureDescription().enabled());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInSeconds() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        return Utils.toPrimitiveInt(this.inner().captureDescription().intervalInSeconds());\n+    }\n+\n+    @Override\n+    public int dataCaptureWindowSizeInMB() {\n+        if (this.inner().captureDescription() == null) {\n+            return 0;\n+        }\n+        int inBytes = Utils.toPrimitiveInt(this.inner().captureDescription().sizeLimitInBytes());\n+        if (inBytes != 0) {\n+            return inBytes / (1024 * 1024);\n+        } else {\n+            return 0;\n+        }\n+    }\n+\n+    @Override\n+    public boolean dataCaptureSkipEmptyArchives() {\n+        if (this.inner().captureDescription() == null) {\n+            return false;\n+        }\n+        return this.inner().captureDescription().skipEmptyArchives();\n+    }\n+\n+    @Override\n+    public String dataCaptureFileNameFormat() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else if (this.inner().captureDescription().destination() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination().archiveNameFormat();\n+        }\n+    }\n+\n+    @Override\n+    public Destination captureDestination() {\n+        if (this.inner().captureDescription() == null) {\n+            return null;\n+        } else {\n+            return this.inner().captureDescription().destination();\n+        }\n+    }\n+\n+    @Override\n+    public Set<String> partitionIds() {\n+        if (this.inner().partitionIds() == null) {\n+            return Collections.unmodifiableSet(new HashSet<String>());\n+        } else {\n+            return Collections.unmodifiableSet(new HashSet<String>(this.inner().partitionIds()));\n+        }\n+    }\n+\n+    @Override\n+    public int messageRetentionPeriodInDays() {\n+        return Utils.toPrimitiveInt(this.inner().messageRetentionInDays());\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewNamespace(Creatable<EventHubNamespace> namespaceCreatable) {\n+        this.addDependency(namespaceCreatable);\n+        if (namespaceCreatable instanceof EventHubNamespaceImpl) {\n+            EventHubNamespaceImpl namespace = ((EventHubNamespaceImpl) namespaceCreatable);\n+            this.ancestor = new Ancestors().new OneAncestor(namespace.resourceGroupName(), namespaceCreatable.name());\n+        } else {\n+            logger.logExceptionAsError(new IllegalArgumentException(\"The namespaceCreatable is invalid.\"));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(EventHubNamespace namespace) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespace.id()));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespace(String resourceGroupName, String namespaceName) {\n+        this.ancestor = new Ancestors().new OneAncestor(resourceGroupName, namespaceName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingNamespaceId(String namespaceId) {\n+        this.ancestor = new Ancestors().new OneAncestor(selfId(namespaceId));\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewStorageAccountForCapturedData(\n+        Creatable<StorageAccount> storageAccountCreatable, String containerName) {\n+        this.captureSettings.withNewStorageAccountForCapturedData(storageAccountCreatable, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        StorageAccount storageAccount, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccount, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withExistingStorageAccountForCapturedData(\n+        String storageAccountId, String containerName) {\n+        this.captureSettings.withExistingStorageAccountForCapturedData(storageAccountId, containerName);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureEnabled() {\n+        this.captureSettings.withDataCaptureEnabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureDisabled() {\n+        this.captureSettings.withDataCaptureDisabled();\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInSeconds(int sizeInSeconds) {\n+        this.captureSettings.withDataCaptureWindowSizeInSeconds(sizeInSeconds);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureSkipEmptyArchives(Boolean skipEmptyArchives) {\n+        this.captureSettings.withDataCaptureSkipEmptyArchives(skipEmptyArchives);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureWindowSizeInMB(int sizeInMB) {\n+        this.captureSettings.withDataCaptureWindowSizeInMB(sizeInMB);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withDataCaptureFileNameFormat(String format) {\n+        this.captureSettings.withDataCaptureFileNameFormat(format);\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewSendRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withSendAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }\n+\n+    @Override\n+    public EventHubImpl withNewListenRule(final String ruleName) {\n+        addPostRunDependent(context -> manager().eventHubAuthorizationRules()\n+            .define(ruleName)\n+            .withExistingEventHub(ancestor().resourceGroupName(), ancestor().ancestor1Name(), name())\n+            .withListenAccess()\n+            .createAsync()\n+            .last());\n+        return this;\n+    }", "originalCommit": "0f0ac4106c27d4f8265b211c9c2df2761957fe98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMzUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478133506", "bodyText": "Do they have without method?", "author": "weidongxu-microsoft", "createdAt": "2020-08-27T05:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE2NTkzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478165933", "bodyText": "I will add new method withNewSendAndListenRule(ruleName). There is withoutAuthorizationRule(ruleName) to remove the authorization rule no matter what access it has.", "author": "xseeseesee", "createdAt": "2020-08-27T06:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE3MzUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478173531", "bodyText": "Eh, I didn't get it. What I mean is these REST requests under \"eventhub\" might need to be called sequentially, it might not be limited to this 2.", "author": "weidongxu-microsoft", "createdAt": "2020-08-27T06:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MzYzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478863638", "bodyText": "After discuss offline, we decide to concat the post run tasks in eventhubs.", "author": "xseeseesee", "createdAt": "2020-08-28T06:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODEzMjA0Mw=="}], "type": "inlineReview"}, {"oid": "f62436201ae005669094c9a48c1a607a6d206eef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f62436201ae005669094c9a48c1a607a6d206eef", "message": "support add both send and listen access", "committedDate": "2020-08-27T06:13:04Z", "type": "commit"}, {"oid": "025514c54e6d2c4af3753e48063a5f9b46c6704f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/025514c54e6d2c4af3753e48063a5f9b46c6704f", "message": "concatenate post run tasks in eventhubs", "committedDate": "2020-08-28T06:42:05Z", "type": "commit"}, {"oid": "1910ece9fcd65144d6eb98250d5d0c1c62a215b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1910ece9fcd65144d6eb98250d5d0c1c62a215b3", "message": "update credcheck and session records", "committedDate": "2020-08-28T06:44:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3ODU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478878544", "bodyText": "postRunTasks = null;\nreturn Mono.empty();", "author": "ChenTanyi", "createdAt": "2020-08-28T07:20:35Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubImpl.java", "diffHunk": "@@ -333,6 +340,15 @@ public void beforeGroupCreateOrUpdate() {\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();\n+    }", "originalCommit": "025514c54e6d2c4af3753e48063a5f9b46c6704f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg3OTMzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14469#discussion_r478879331", "bodyText": "same above", "author": "ChenTanyi", "createdAt": "2020-08-28T07:22:21Z", "path": "sdk/resourcemanager/azure-resourcemanager-eventhubs/src/main/java/com/azure/resourcemanager/eventhubs/implementation/EventHubNamespaceImpl.java", "diffHunk": "@@ -204,13 +210,29 @@ public EventHubNamespaceImpl withThroughputUnitsUpperLimit(int units) {\n         return this;\n     }\n \n+    @Override\n+    public void beforeGroupCreateOrUpdate() {\n+        if (postRunTasks != null) {\n+            addPostRunDependent(context -> postRunTasks.last());\n+        }\n+    }\n+\n     @Override\n     public Mono<EventHubNamespace> createResourceAsync() {\n         return this.manager().inner().getNamespaces()\n                 .createOrUpdateAsync(resourceGroupName(), name(), this.inner())\n                 .map(innerToFluentMap(this));\n     }\n \n+    @Override\n+    public Mono<Void> afterPostRunAsync(boolean isGroupFaulted) {\n+        return Mono.just(true)\n+            .map(aBoolean -> {\n+                postRunTasks = null;\n+                return aBoolean;\n+            }).then();", "originalCommit": "025514c54e6d2c4af3753e48063a5f9b46c6704f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a7c01b8ca1726588e2b4a9c78b22ce65d6fbc76", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a7c01b8ca1726588e2b4a9c78b22ce65d6fbc76", "message": "update test case after running credcheck", "committedDate": "2020-08-28T07:49:40Z", "type": "commit"}]}