{"pr_number": 10500, "pr_title": "Field builder and Field annotation.", "pr_createdAt": "2020-04-25T01:19:23Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10500", "timeline": [{"oid": "8f32c9ebed58e9411e8282fe7b43f88fc3e552b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8f32c9ebed58e9411e8282fe7b43f88fc3e552b9", "message": "Added field annotations and FieldBuilder", "committedDate": "2020-04-25T01:07:55Z", "type": "commit"}, {"oid": "0b6bdb39139cebcf9b6cb8c82742daa1219bd1ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0b6bdb39139cebcf9b6cb8c82742daa1219bd1ea", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FieldBuilder", "committedDate": "2020-04-25T01:10:23Z", "type": "commit"}, {"oid": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c33cb98bdf5dbf91b0e55b6f91744461868584a9", "message": "Rename the field", "committedDate": "2020-04-25T01:18:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NTIzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415545234", "bodyText": "Is this auto-generated? Trying to understand why we would use this annotation without any documentation.", "author": "conniey", "createdAt": "2020-04-27T06:31:08Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.azure.search.annotation;", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzMxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416133319", "bodyText": "I am working with search team to get clear about how customer uses the annotation. I will add doc after major workflow works.", "author": "sima-zhu", "createdAt": "2020-04-27T20:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0NTIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0Nzk4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415547980", "bodyText": "Some documentation for this would be nice?", "author": "conniey", "createdAt": "2020-04-27T06:36:50Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415548289", "bodyText": "Curious why this doesn't have default values like the FieldProperty?", "author": "conniey", "createdAt": "2020-04-27T06:37:30Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package com.azure.search.annotation;", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODcyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415548728", "bodyText": "Why doesn't this extend from the one above?", "author": "conniey", "createdAt": "2020-04-27T06:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTA5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551094", "bodyText": "Looking at the properties on FieldProperty, couldn't we just use \"isSearchable\" to be true? I don't see the extra value in adding this annotation.", "author": "conniey", "createdAt": "2020-04-27T06:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg1MzQ5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416853494", "bodyText": "The namespace should go for com.azure.search.documents.indexes.annotation.", "author": "sima-zhu", "createdAt": "2020-04-28T19:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416942101", "bodyText": "Do we need the \"annotation\" namespace? I wasn't planning on it, just to reduce the number of usings/imports people have to author. com.azure.search.documents.indexes should be enough.", "author": "heaths", "createdAt": "2020-04-28T21:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAzNDcyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417034726", "bodyText": "I am worrying customer has trouble to find this. I will move to com.azure.search.documents.indexes first. Will check with UX study", "author": "sima-zhu", "createdAt": "2020-04-29T02:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTI4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551285", "bodyText": "Same here... Not sure of the value.", "author": "conniey", "createdAt": "2020-04-27T06:43:55Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.azure.search.annotation;", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTc5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r415551792", "bodyText": "This should be a string constant \"null\". But why is the default \"null\" rather than just a null object?", "author": "conniey", "createdAt": "2020-04-27T06:44:55Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());\n+            }\n+        }\n+        return searchFieldList;\n+    }\n+\n+    private static void buildSimpleField(Field searchField, SimpleFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(true);\n+        searchField.setFilterable(true);\n+        searchField.setFacetable(true);\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.analyzer())));\n+        }\n+        if (!\"null\".equals(annotation.searchAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.searchAnalyzer())));\n+        }\n+        if (!\"null\".equals(annotation.indexAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.indexAnalyzer())));\n+        }\n+        if (annotation.synonymMaps().length != 0) {\n+            searchField.setSynonymMaps(Arrays.asList(annotation.synonymMaps()));\n+        }\n+    }\n+\n+    private static void buildSearchableField(Field searchField, SearchableFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(annotation.isSortable());\n+        searchField.setFilterable(annotation.isFilterable());\n+        searchField.setFacetable(annotation.isFacetable());\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.analyzer())));\n+        }\n+        if (!\"null\".equals(annotation.searchAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.searchAnalyzer())));\n+        }\n+        if (!\"null\".equals(annotation.indexAnalyzer())) {\n+            searchField.setAnalyzer(AnalyzerName.fromString((annotation.indexAnalyzer())));\n+        }\n+        if (annotation.synonymMaps().length != 0) {\n+            searchField.setSynonymMaps(Arrays.asList(annotation.synonymMaps()));\n+        }\n+    }\n+\n+    private static void buildField(Field searchField, FieldProperty annotation) {\n+        searchField.setSearchable(annotation.isSearchable());\n+        searchField.setSortable(annotation.isSortable());\n+        searchField.setFilterable(annotation.isFilterable());\n+        searchField.setFacetable(annotation.isFacetable());\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzNDQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416134438", "bodyText": "I will make it default to String \"null\"", "author": "sima-zhu", "createdAt": "2020-04-27T20:43:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI4NzM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416287361", "bodyText": "Annotation for string method cannot default to null object. The field is not required, so I made it default to null string.", "author": "sima-zhu", "createdAt": "2020-04-28T02:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU1MTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416129793", "bodyText": "What about IgnoreField? Not only does it read better, but fits word order better (comments below).", "author": "heaths", "createdAt": "2020-04-27T20:35:38Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.azure.search.annotation;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1MDg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416150898", "bodyText": "Mimic Jackson package naming.\nThey use @JsonIgnore if they don't want to serialize the property.", "author": "sima-zhu", "createdAt": "2020-04-27T21:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTIyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971220", "bodyText": "I'm not completely certain we want to copy JSON as this is more of an ORM concept.", "author": "alzimmermsft", "createdAt": "2020-04-28T22:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0MDM2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417040369", "bodyText": "Do you have any name suggestion?\n@IgnoreField ?", "author": "sima-zhu", "createdAt": "2020-04-29T02:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEyOTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDUyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416130526", "bodyText": "I thought we had agreed on using attribute names and properties that match the convenience fields, e.g. SimpleField, SearchableField, and ComplexField.", "author": "heaths", "createdAt": "2020-04-27T20:36:46Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldProperty.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.FIELD;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+\n+@Retention(RUNTIME)\n+@Target({FIELD})\n+public @interface FieldProperty {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMDk4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416130989", "bodyText": "Some of these can only be set on SearchableField and shouldn't appear here. Make sure they don't in the convenience classes as well.", "author": "heaths", "createdAt": "2020-04-27T20:37:39Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    boolean isKey();\n+    boolean isRetrievable();\n+    boolean isFacetable();\n+    boolean isSearchable();\n+    boolean isSortable();\n+    boolean isFilterable();\n+    String analyzer();", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416131404", "bodyText": "What about ComplexField? Just not implemented yet?", "author": "heaths", "createdAt": "2020-04-27T20:38:21Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1MzIyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416153221", "bodyText": "This is for the \"static\" case where we're reflecting over a type, right? In that case, you shouldn't need an attribute to identify complex types -- the type of the property/accessor should indicate that (by not being a primitive, string, or geo-point or collection of those).", "author": "brjohnstmsft", "createdAt": "2020-04-27T21:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NzYzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416157638", "bodyText": "That's implying that non-attributed fields should be reflected and turned into fields. That doesn't seem to follow what track 1 did, though I only took a cursory glance. If we should reflect non-attributed fields, then that means all attributes' properties' values would be default, correct?", "author": "heaths", "createdAt": "2020-04-27T21:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTk1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416161954", "bodyText": "@heaths Track 1 reflected all public properties, even those without attributes. One reason is that complex fields don't require any additional attributes (because they already have a name and type). As for defaults, in Track 1 it was the client's defaults (everything disabled by default). In Track 2, that would be a safe default to have, but I'm not sure if that's different than the defaults for explicitly-constructed SearchFields.", "author": "brjohnstmsft", "createdAt": "2020-04-27T21:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MzUwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416163509", "bodyText": "Okay, so long as we're agreed that since we're following convenience classes' defaults for these convenience attributes (or lack thereof), then we will have a consistent experience. E.g. if a string field/property has no attributes, it will be equivalent to a SimpleField of \"Edm.String\" and no other traits enabled, including that IsHidden is false so it will appear in results.", "author": "heaths", "createdAt": "2020-04-27T21:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE3Njc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416176754", "bodyText": "Thank for comments! Will treat non-attributed field to complex field if it is non-primitive.", "author": "sima-zhu", "createdAt": "2020-04-27T21:55:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMTk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416131940", "bodyText": "Mentioned above, but just to reiterate here (and applies below): analyzers, synonymMaps, etc., are only settable on searchable fields and shouldn't be here.", "author": "heaths", "createdAt": "2020-04-27T20:39:18Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,154 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.FieldProperty;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.annotation.Annotation;\n+import java.time.OffsetDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Helper to build search field\n+ */\n+public class FieldBuilder {\n+    /**\n+     * Creates a collection of <see cref=\"Field\"/> objects corresponding to\n+     * the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        java.lang.reflect.Field[] fields = modelClass.getFields();\n+        List<Field> searchFieldList = new ArrayList<>();\n+        for (java.lang.reflect.Field field: fields) {\n+            Annotation[] annotations = field.getAnnotations();\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof FieldIgnore) {\n+                    continue;\n+                }\n+                Field searchField = new Field();\n+                searchField.setName(field.getName());\n+                searchField.setType(covertToDataType(field, logger));\n+                if (annotation instanceof SimpleFieldProperty) {\n+                    buildSimpleField(searchField, (SimpleFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof SearchableFieldProperty) {\n+                    buildSearchableField(searchField, (SearchableFieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                } else if (annotation instanceof FieldProperty) {\n+                    buildField(searchField, (FieldProperty) annotation);\n+                    searchFieldList.add(searchField);\n+                }\n+                logger.info(\"The property {} is not a search field.\", field.getName());\n+            }\n+        }\n+        return searchFieldList;\n+    }\n+\n+    private static void buildSimpleField(Field searchField, SimpleFieldProperty annotation) {\n+        searchField.setSearchable(true);\n+        searchField.setSortable(true);\n+        searchField.setFilterable(true);\n+        searchField.setFacetable(true);\n+        searchField.setKey(annotation.isKey());\n+        if (!\"null\".equals(annotation.analyzer())) {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMjIyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416132220", "bodyText": "Couldn't you just use the same one as for the convenience classes?", "author": "heaths", "createdAt": "2020-04-27T20:39:52Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexDataType.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+\n+/**\n+ * Simple DataType is used to create SimpleSearchField.\n+ */\n+public class ComplexDataType extends ExpandableStringEnum<ComplexDataType> {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMjQ2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416132468", "bodyText": "You mention \"search field\" here. Copy/paste error?", "author": "heaths", "createdAt": "2020-04-27T20:40:16Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416133023", "bodyText": "You can't use the same one as for the convenience type? Less chance of breaking across generations.", "author": "heaths", "createdAt": "2020-04-27T20:41:10Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleDataType.java", "diffHunk": "@@ -0,0 +1,59 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import java.util.Collection;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Simple DataType is used to create SimpleSearchField.\n+ */\n+public class SimpleDataType extends ExpandableStringEnum<SimpleDataType> {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEzMzM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416133365", "bodyText": "This an others below are not supported on SimpleField. Only SearchableField.", "author": "heaths", "createdAt": "2020-04-27T20:41:41Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleField.java", "diffHunk": "@@ -0,0 +1,76 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class SimpleField {\n+    private String name;\n+    private PrimitiveType dataType;\n+    private Boolean facetable;\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public SimpleField setName(String name) {\n+        this.name = name;\n+        return this;\n+    }\n+\n+    public PrimitiveType getDataType() {\n+        return dataType;\n+    }\n+\n+    public SimpleField setDataType(PrimitiveType dataType) {\n+        this.dataType = dataType;\n+        return this;\n+    }\n+\n+\n+    public Boolean getFacetable() {\n+        return facetable;\n+    }\n+\n+    public SimpleField setFacetable(Boolean facetable) {\n+        this.facetable = facetable;\n+        return this;\n+    }\n+\n+    public AnalyzerName getAnalyzer() {", "originalCommit": "c33cb98bdf5dbf91b0e55b6f91744461868584a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8292f6aafc9c61d66fc3ed94d7388ea02d6a9963", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8292f6aafc9c61d66fc3ed94d7388ea02d6a9963", "message": "Initial check in with implementations", "committedDate": "2020-04-28T16:38:55Z", "type": "commit"}, {"oid": "5bb3118ce5e2af5bb721ed4d28acf8cff5518bfa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5bb3118ce5e2af5bb721ed4d28acf8cff5518bfa", "message": "Added some tests on failure", "committedDate": "2020-04-28T17:40:34Z", "type": "commit"}, {"oid": "b3019557941bd81c08ad9fb8e18940c9ce02b922", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3019557941bd81c08ad9fb8e18940c9ce02b922", "message": "Remove unnecessary files", "committedDate": "2020-04-28T17:48:26Z", "type": "commit"}, {"oid": "48ccdb589459a4e2cab093b6891e72f3cfe839c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/48ccdb589459a4e2cab093b6891e72f3cfe839c9", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java into FieldBuilder", "committedDate": "2020-04-28T17:49:02Z", "type": "commit"}, {"oid": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "message": "Added change log", "committedDate": "2020-04-28T19:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MTQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416941492", "bodyText": "Shouldn't the presence of the attribute always imply true, or is that not typical in Java? In .NET, similar attributes' existence means ignore with no possible way to author a value (e.g. [FieldIgnore(false)] is redundant with just not authoring it).", "author": "heaths", "createdAt": "2020-04-28T21:42:01Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {\n+    /**\n+     * Optional argument that defines whether this annotation is active or not.\n+     *\n+     * @return True if annotation is enabled (by default); false if it is to be ignored.\n+     */\n+    boolean value() default true;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0MjA3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417042071", "bodyText": "Right. I also have the same thought. Will remove.", "author": "sima-zhu", "createdAt": "2020-04-29T03:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MTQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjkzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416942935", "bodyText": "Why \"null\" as a string? Shouldn't it just be null? Not specifying this property in an attribute should just default to null (not defined) anyway, right? This seems like an anti-pattern. For example, you have false above for other boolean properties, not \"false\".", "author": "heaths", "createdAt": "2020-04-28T21:44:58Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0MzIzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417043230", "bodyText": "Switch to empty, as Java annotation has no way to default to null object.", "author": "sima-zhu", "createdAt": "2020-04-29T03:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0Mzk2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416943964", "bodyText": "For this and all attributes, what about the name? The name could be overridden. Example, maybe they want a property/field like keyId, but in the index it's the shorter kid.", "author": "heaths", "createdAt": "2020-04-28T21:47:04Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MTk1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418361954", "bodyText": "I think the name is retrieved from the attribute name. This is also what I get from track 1. If  we want to config name here as well, I can create an issue to track this.", "author": "sima-zhu", "createdAt": "2020-05-01T00:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0Mzk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjE4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416946182", "bodyText": "I wouldn't hold up the PR for this, but why not map narrower-width field types? May overflow when parsing, but maybe we could log that and use the default value (e.g. numeric types 0). Maybe that's too presumptuous. I wouldn't do that here in this PR, but consider opening an issue to track.", "author": "heaths", "createdAt": "2020-04-28T21:52:10Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzI0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418363248", "bodyText": "#10647", "author": "sima-zhu", "createdAt": "2020-05-01T00:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416946699", "bodyText": "How was this value chosen? Can the user override, or is it based on index creation? /cc @brjohnstmsft", "author": "heaths", "createdAt": "2020-04-28T21:53:19Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0NDUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417044515", "bodyText": "This is kind of protection to avoid deep calling. We just recommend customer to redesign their index if it is call path is too deep. Like complexField 1-> 2 -> 3 ... -> 10 -> 11 (Fail here). I don't have reference for the number(willing to change). Also, it is just a 'good to have' validation.", "author": "sima-zhu", "createdAt": "2020-04-29T03:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0ODQwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417048405", "bodyText": "Depth validation should be left to the service. The depth check done by the REST API can vary based on pricing tier, so having a hard-coded value here is likely to cause breakage for at least some customers, unless you pick a very large value.\nIf you're checking for recursive types, then unbounded stack growth isn't possible. If you're just concerned about a very deep tree of other types, pick a much larger value, like 10000, that is likely to always be greater than the REST API's own limits.", "author": "brjohnstmsft", "createdAt": "2020-04-29T03:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM2MzgwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418363800", "bodyText": "Change it to 10000", "author": "sima-zhu", "createdAt": "2020-05-01T00:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0ODgyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416948821", "bodyText": "Shouldn't you also check FieldIgnore.value if it's settable? Or just don't have it.", "author": "heaths", "createdAt": "2020-04-28T21:57:48Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA1MDI1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417050258", "bodyText": "I have removed value setting.", "author": "sima-zhu", "createdAt": "2020-04-29T03:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0ODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1MTA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416951065", "bodyText": "Field should be SearchField per mode renames.", "author": "heaths", "createdAt": "2020-04-28T22:02:52Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA1MDUzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417050532", "bodyText": "We have two Field in builder, one is Java reflection, one is our search field.\nWill have rename changes afterwards to make this clear", "author": "sima-zhu", "createdAt": "2020-04-29T03:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1MTA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Mzc3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416953770", "bodyText": "If these all default to false, why set them just to potentially override them later with enrichWithAnnotations ?", "author": "heaths", "createdAt": "2020-04-28T22:08:43Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0NjYxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417046611", "bodyText": "This is good for some field without annotation.\ne.g.\nprivate String id;\n\nWe convert this to Field with Field (name=id, type=EDM.String, isSortable=true, etc)\nThis is align with the one with annotation.", "author": "sima-zhu", "createdAt": "2020-04-29T03:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Mzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDM1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416954355", "bodyText": "Should just be a simple null check if not defined as a string, right? What if they set it to null explicitly when declaring?", "author": "heaths", "createdAt": "2020-04-28T22:10:00Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,268 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.annotation.FieldIgnore;\n+import com.azure.search.annotation.SearchableFieldProperty;\n+import com.azure.search.annotation.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.azure.search.documents.models.SearchableField;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class type for which fields will be created, based on its properties.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+\n+        if (classChain.contains(curClass)) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"There is circular dependencies %s, %s\", classChain, curClass)));\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(\n+                new RuntimeException(\"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return CLASS_FIELD_HASH_MAP.get(type);\n+        }\n+        List<Field> childFields = build((Class<?>)type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        searchField.setSearchable(false); // TODO\n+        searchField.setFilterable(false); // TODO\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>)componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);\n+        searchField.setSearchable(false);\n+        searchField.setFacetable(false);\n+        searchField.setHidden(false);\n+        searchField.setFilterable(false);\n+        searchField.setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger\n+                .logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously for %s\",\n+                        classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false);\n+            searchField.setSortable(simpleFieldPropertyAnnotation.isSortable());\n+            searchField.setFilterable(simpleFieldPropertyAnnotation.isFilterable());\n+            searchField.setFacetable(simpleFieldPropertyAnnotation.isFacetable());\n+            searchField.setKey(simpleFieldPropertyAnnotation.isKey());\n+            searchField.setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)){\n+            if (!searchField.getType().equals(DataType.EDM_STRING) &&\n+                !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true);\n+            searchField.setSortable(searchableFieldPropertyAnnotation.isSortable());\n+            searchField.setFilterable(searchableFieldPropertyAnnotation.isFilterable());\n+            searchField.setFacetable(searchableFieldPropertyAnnotation.isFacetable());\n+            searchField.setKey(searchableFieldPropertyAnnotation.isKey());\n+            searchField.setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!\"null\".equals(searchableFieldPropertyAnnotation.analyzer())) {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0NjY1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417046654", "bodyText": "Switch to empty", "author": "sima-zhu", "createdAt": "2020-04-29T03:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955685", "bodyText": "Don't use FieldBase (at least in .NET, \"Base\" is not allowed for base classes). See the model rename issue for the suggestion (I forget off hand).", "author": "heaths", "createdAt": "2020-04-28T22:12:58Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzAwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416973006", "bodyText": "XBase is the pattern we use in Java, but I would also say that FieldBase isn't really needed.", "author": "alzimmermsft", "createdAt": "2020-04-28T22:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTY4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0NzMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417047304", "bodyText": "name and dataType initialization and validation apply to all three SimpleField, SearchableField, ComplexField\nDon't want to repeat them again", "author": "sima-zhu", "createdAt": "2020-04-29T03:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955862", "bodyText": "Just getFields. \"Sub\" is redundant and atypical.", "author": "heaths", "createdAt": "2020-04-28T22:13:24Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {\n+    private List<Field> subFields;\n+\n+    /**\n+     * Initializes a new instance of the {@link ComplexField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     */\n+    public ComplexField(String name, boolean collection) {\n+        super(name, collection ? DataType.collection(DataType.EDM_COMPLEX_TYPE) : DataType.EDM_COMPLEX_TYPE);\n+    }\n+\n+    /**\n+     * Gets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @return The list of sub-fields.\n+     */\n+    public List<Field> getSubFields() {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NTk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416955986", "bodyText": "Just setFields.", "author": "heaths", "createdAt": "2020-04-28T22:13:43Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/ComplexField.java", "diffHunk": "@@ -0,0 +1,55 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A helper Field model to build a simple search field.\n+ */\n+public class ComplexField extends FieldBase {\n+    private List<Field> subFields;\n+\n+    /**\n+     * Initializes a new instance of the {@link ComplexField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     */\n+    public ComplexField(String name, boolean collection) {\n+        super(name, collection ? DataType.collection(DataType.EDM_COMPLEX_TYPE) : DataType.EDM_COMPLEX_TYPE);\n+    }\n+\n+    /**\n+     * Gets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @return The list of sub-fields.\n+     */\n+    public List<Field> getSubFields() {\n+        return subFields;\n+    }\n+\n+    /**\n+     * Sets a collection of {@link SimpleField} or {@link ComplexField} child fields.\n+     *\n+     * @param subFields The list of sub-fields.\n+     * @return The {@link ComplexField} object itself.\n+     */\n+    public ComplexField setSubFields(List<Field> subFields) {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1ODU0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416958542", "bodyText": "Need an overload for whether this is also a collection (like you did in ComplexField).", "author": "heaths", "createdAt": "2020-04-28T22:19:49Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SimpleField.java", "diffHunk": "@@ -0,0 +1,150 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+\n+import java.util.Objects;\n+\n+/**\n+ * A helper Field model to build a simple {@link Field}.\n+ */\n+public class SimpleField extends FieldBase {\n+    private boolean key;\n+    private boolean facetable;\n+    private boolean sortable;\n+    private boolean filterable;\n+    private boolean hidden;\n+\n+    /**\n+     * Initializes a new instance of the {@link SimpleField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The {@link DataType} of the {@link Field}.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SimpleField(String name, DataType dataType) {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTU0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416959545", "bodyText": "Nit: wouldn't \"build...FromModel\" mean using the field builder against a model type? This seems more like manual index creation / defining of fields.", "author": "heaths", "createdAt": "2020-04-28T22:22:09Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/FieldBuilderTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.azure.search.documents;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.ComplexField;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.SearchableField;\n+import com.azure.search.documents.models.SimpleField;\n+import com.azure.search.documents.test.environment.models.Hotel;\n+import com.azure.search.documents.test.environment.models.HotelSearchException;\n+import com.azure.search.documents.test.environment.models.HotelSearchableExceptionOnList;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FieldBuilderTest {\n+    @Test\n+    public void hotelComparison() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(Hotel.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelFieldsFromModel());\n+        assertEquals(expectedFields.size(), actualFields.size());\n+        for (int i = 0; i < expectedFields.size(); i++) {\n+            TestHelpers.assertObjectEquals(expectedFields.get(i), actualFields.get(i));\n+        }\n+    }\n+\n+    @Test\n+    public void hotelSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchException.class);\n+        });\n+        assertTrue(exception.getMessage().contains(\"hotelId\"));\n+        assertTrue(exception.getMessage().contains(DataType.EDM_INT32.toString()));\n+    }\n+\n+    @Test\n+    public void hotelListFieldSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchableExceptionOnList.class);\n+        });\n+        assertTrue(exception.getMessage().contains(\"passcode\"));\n+        assertTrue(exception.getMessage().contains(DataType.collection(DataType.EDM_INT32).toString()));\n+    }\n+\n+    private List<Field> buildHotelFieldsFromModel() {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0NzcyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417047723", "bodyText": "Will rename", "author": "sima-zhu", "createdAt": "2020-04-29T03:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1OTU0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDcxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416960717", "bodyText": "Might be good to have the cycle a level deeper just to make sure the recursive stack push/check is working correctly (and continues to do so when changed).", "author": "heaths", "createdAt": "2020-04-28T22:25:13Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/models/HotelSearchException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.azure.search.documents.test.environment.models;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDQ1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416970458", "bodyText": "If we plan to keep this annotation this isn't needed, why would we allow FieldIgnore(false)? The simple existence of this annotation on a field should indicate that it won't be included in the generated FieldMapping.", "author": "alzimmermsft", "createdAt": "2020-04-28T22:50:25Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {\n+    /**\n+     * Optional argument that defines whether this annotation is active or not.\n+     *\n+     * @return True if annotation is enabled (by default); false if it is to be ignored.\n+     */\n+    boolean value() default true;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0ODYzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417048638", "bodyText": "Removed.", "author": "sima-zhu", "createdAt": "2020-04-29T03:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDkzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416970935", "bodyText": "Do we want to use a pattern of all fields are included unless stated otherwise or fields are only included if stated?", "author": "alzimmermsft", "createdAt": "2020-04-28T22:51:36Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/FieldIgnore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.azure.search.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Marker annotation that indicates the field is to be ignored by converting to SearchField.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface FieldIgnore {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MjIzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416982230", "bodyText": "Talking with @brjohnstmsft yesterday, it should be opt-out since that's how track 1 works. That said, by not attributing/annotating properties, you don't get much by default.", "author": "heaths", "createdAt": "2020-04-28T23:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTU1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971550", "bodyText": "This should be null right?", "author": "alzimmermsft", "createdAt": "2020-04-28T22:53:16Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTk0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416971948", "bodyText": "SearchableFieldProperty feels to me that it indicates Filterable = true by default.", "author": "alzimmermsft", "createdAt": "2020-04-28T22:54:24Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MjQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416982429", "bodyText": "We intentionally default everything to false for consistency.", "author": "heaths", "createdAt": "2020-04-28T23:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzIzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416973233", "bodyText": "Given this is a super class for some public APIs this should be public as well. Also, should this be an abstract class?", "author": "alzimmermsft", "createdAt": "2020-04-28T22:57:51Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+class FieldBase {", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974739", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:01:59Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MjU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416982595", "bodyText": "No. We pass false by default. All values default to their defaults (bool false, int 0, etc.).", "author": "heaths", "createdAt": "2020-04-28T23:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MjY4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416982685", "bodyText": "Same for similar questions elsewhere.", "author": "heaths", "createdAt": "2020-04-28T23:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDc2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974763", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:02:04Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDgwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416974809", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:02:10Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTA3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975076", "bodyText": "This should be null right?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:02:56Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975105", "bodyText": "This should be null right?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:03:01Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String indexAnalyzer() default \"null\";", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975154", "bodyText": "This should be null right?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:03:11Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String analyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the search analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String searchAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.\n+     */\n+    String indexAnalyzer() default \"null\";\n+\n+    /**\n+     * Optional arguments defines the array of synonymMaps used for the field.\n+     *\n+     * @return An array of synonym map values. Or default to empty string array.\n+     */\n+    String[] synonymMaps() default {};", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTM0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975347", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:03:42Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTM3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975376", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:03:49Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTQwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416975406", "bodyText": "Shouldn't this be true to match the service documentation?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:03:54Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/annotation/SimpleFieldProperty.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package com.azure.search.annotation;\n+\n+import com.azure.search.documents.models.Field;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a simple field. This annotation can only set boolean field of\n+ * {@link Field}. {@code isSearchable} will set to {@code false}.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SimpleFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976531", "bodyText": "Are these imports being used?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:06:41Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -22,6 +23,11 @@\n import java.io.IOException;\n import java.net.InetAddress;\n import java.security.SecureRandom;\n+import java.time.LocalDateTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjU5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976591", "bodyText": "Is this import being used?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:06:52Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -22,6 +23,11 @@\n import java.io.IOException;\n import java.net.InetAddress;\n import java.security.SecureRandom;\n+import java.time.LocalDateTime;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjYxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r416976610", "bodyText": "Is this import being used?", "author": "alzimmermsft", "createdAt": "2020-04-28T23:06:56Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/test/environment/setup/AzureSearchResources.java", "diffHunk": "@@ -6,6 +6,7 @@\n import com.azure.core.test.utils.TestResourceNamer;\n import com.azure.core.util.Configuration;\n import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.DateTimeRfc1123;", "originalCommit": "68f2ba4c90cb83db751a4ee4cb30667c5ebfd2f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA0OTU2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417049560", "bodyText": "It is not supposed to have any changes in this class. I will try to remove the diff here.", "author": "sima-zhu", "createdAt": "2020-04-29T03:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NjYxMA=="}], "type": "inlineReview"}, {"oid": "32957663bff633afc3d0bd5fdf024c1a92b955a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32957663bff633afc3d0bd5fdf024c1a92b955a1", "message": "String value defaults to empty", "committedDate": "2020-04-29T02:55:33Z", "type": "commit"}, {"oid": "c07a7338178c118ed9bee85acecbcbadf986b9c3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c07a7338178c118ed9bee85acecbcbadf986b9c3", "message": "Address major comments", "committedDate": "2020-04-29T03:38:02Z", "type": "commit"}, {"oid": "17650d0251551efd99d623e688a1ebe21074f7e9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17650d0251551efd99d623e688a1ebe21074f7e9", "message": "Added tests for circular dependencies", "committedDate": "2020-04-29T06:39:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NzcwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417477701", "bodyText": "Do we want to log a warning for a circular dependency? There are a lot of data structures that will have this, for example a binary tree. Would it be better to just return null to break the cycle?", "author": "alzimmermsft", "createdAt": "2020-04-29T17:12:57Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNzQ1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417517457", "bodyText": "I have returned null below.\nif (classChain.contains(curClass)) {\n    logger.warning(...);\n    return null;\n}\n\nThis is decided by team, which we ignore any property of a type that's already been \"seen\".", "author": "sima-zhu", "createdAt": "2020-04-29T18:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NzcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUzODg2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417538868", "bodyText": "No. As discussed with @brjohnstmsft and in other meetings we've had, we want the defaults for model properties and parameters to match the language defaults for those types (e.g. boolean is false). Those should be sent to the service as-is to avoid confusion and force customers to look what the docs currently list as defaults.", "author": "heaths", "createdAt": "2020-04-29T18:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ3NzcwMQ=="}], "type": "inlineReview"}, {"oid": "aaf3c46092de4e54f56708dd5fc786ba3f1364e8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaf3c46092de4e54f56708dd5fc786ba3f1364e8", "message": "Remove map since it needs deep copy", "committedDate": "2020-04-29T18:13:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNzE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417507153", "bodyText": "Do we need to create a new logger instance each time this method is called? If this method is called frequently, it's better to make the logger a static instance.", "author": "srnagar", "createdAt": "2020-04-29T17:59:50Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUyMDUyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417520523", "bodyText": "This is a helper for building index schema for search. The operation will not happen frequently. Probably only when customer wants to update the index (rarely happen, a breaking change).", "author": "sima-zhu", "createdAt": "2020-04-29T18:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNzE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjk0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417512945", "bodyText": "Use the fluent pattern instead.", "author": "srnagar", "createdAt": "2020-04-29T18:10:00Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    private static final Map<Class<?>, Field> CLASS_FIELD_HASH_MAP = new HashMap<>();\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        if (CLASS_FIELD_HASH_MAP.containsKey(type)) {\n+            return deepCopyFieldWithName(CLASS_FIELD_HASH_MAP.get(type), classField.getName() ,logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        CLASS_FIELD_HASH_MAP.put((Class<?>) type, searchField);\n+        return searchField;\n+    }\n+\n+    private static Field deepCopyFieldWithName(Field field, String name, ClientLogger logger) {\n+        try {\n+            Field copyField = new ObjectMapper().readValue(new ObjectMapper().writeValueAsString(field), Field.class);\n+            return copyField.setName(name);\n+        } catch (JsonProcessingException e) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                String.format(\"Something wrong when copy field of %s\", name)));\n+        }\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType);\n+        searchField.setKey(false);\n+        searchField.setSearchable(false);\n+        searchField.setFacetable(false);\n+        searchField.setHidden(false);\n+        searchField.setFilterable(false);\n+        searchField.setSortable(false);", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMzg2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417513864", "bodyText": "Since this class is a collection of static helper methods, it should be final and also add a private constructor.", "author": "srnagar", "createdAt": "2020-04-29T18:11:39Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.\n+ */\n+public class FieldBuilder {", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMzk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417513975", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Helper to covert model class to search field {@link Field}.\n          \n          \n            \n             * Helper to convert model class to search field {@link Field}.", "author": "srnagar", "createdAt": "2020-04-29T18:11:48Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,277 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to covert model class to search field {@link Field}.", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNDkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417514904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Package containing the annotations used by FieldBuilder which help covert\n          \n          \n            \n             * Package containing the annotations used by FieldBuilder which help convert", "author": "srnagar", "createdAt": "2020-04-29T18:13:25Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/package-info.java", "diffHunk": "@@ -0,0 +1,8 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+/**\n+ * Package containing the annotations used by FieldBuilder which help covert", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxNTg5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r417515898", "bodyText": "It might be more readable if you have one setter per line.", "author": "srnagar", "createdAt": "2020-04-29T18:15:04Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SearchableField.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+\n+/**\n+ * A helper Field model to build a searchable {@link Field}.\n+ */\n+public class SearchableField extends SimpleField {\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+    private List<String> synonymMaps;\n+\n+    /**\n+     * Initializes a new instance of the {@link SearchableField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SearchableField(String name, boolean collection) {\n+        super(name, DataType.EDM_STRING, collection);\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for analyzer.\n+     */\n+    public AnalyzerName getAnalyzer() {\n+        return analyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @param analyzer The {@link AnalyzerName} used for analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setAnalyzer(AnalyzerName analyzer) {\n+        this.analyzer = analyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for search analyzer.\n+     */\n+    public AnalyzerName getSearchAnalyzer() {\n+        return searchAnalyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param searchAnalyzer The {@link AnalyzerName} used for search analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSearchAnalyzer(AnalyzerName searchAnalyzer) {\n+        this.searchAnalyzer = searchAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for index analyzer.\n+     */\n+    public AnalyzerName getIndexAnalyzer() {\n+        return indexAnalyzer;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param indexAnalyzer The {@link AnalyzerName} used for index analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setIndexAnalyzer(AnalyzerName indexAnalyzer) {\n+        this.indexAnalyzer = indexAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @return List of names of synonym maps to associate with this field.\n+     */\n+    public List<String> getSynonymMaps() {\n+        return synonymMaps;\n+    }\n+\n+    /**\n+     * Sets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @param synonymMaps list of names of synonym maps to associate with this field.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSynonymMaps(List<String> synonymMaps) {\n+        this.synonymMaps = synonymMaps;\n+        return this;\n+    }\n+\n+    /**\n+     * Convert SearchableField to {@link Field}.\n+     *\n+     * @return The {@link Field} object.\n+     */\n+    public Field build() {\n+        return new Field().setName(super.getName()).setType(super.getDataType()).setSearchable(true)\n+            .setKey(super.isKey()).setSortable(super.isSortable()).setFilterable(super.isFilterable())\n+            .setHidden(super.isHidden()).setFacetable(super.isFacetable()).setAnalyzer(this.analyzer)\n+            .setSearchAnalyzer(this.searchAnalyzer).setIndexAnalyzer(this.indexAnalyzer)\n+            .setSynonymMaps(this.synonymMaps);", "originalCommit": "17650d0251551efd99d623e688a1ebe21074f7e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ec488d5d8f83599c0c3b3390823b9982a665e2b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ec488d5d8f83599c0c3b3390823b9982a665e2b7", "message": "Update sdk/search/azure-search-documents/CHANGELOG.md\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>", "committedDate": "2020-04-29T18:18:37Z", "type": "commit"}, {"oid": "46e52f8e62a6a408ba43eaaa9f2f2d39a5d4a10b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/46e52f8e62a6a408ba43eaaa9f2f2d39a5d4a10b", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/package-info.java\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>", "committedDate": "2020-04-29T18:19:08Z", "type": "commit"}, {"oid": "36228d01d1438c5c96c0a9e7c5c23c5942515d8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36228d01d1438c5c96c0a9e7c5c23c5942515d8f", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>", "committedDate": "2020-04-29T18:19:24Z", "type": "commit"}, {"oid": "738777b9587cfceb166b5f0750351454e4f405e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/738777b9587cfceb166b5f0750351454e4f405e2", "message": "Update sdk/search/azure-search-documents/CHANGELOG.md\n\nCo-Authored-By: Srikanta <51379715+srnagar@users.noreply.github.com>", "committedDate": "2020-04-29T18:19:53Z", "type": "commit"}, {"oid": "ea804ece2154ae1009e82c3eebcfe00db0842a3e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea804ece2154ae1009e82c3eebcfe00db0842a3e", "message": "CHnage to fluent pattern call", "committedDate": "2020-04-29T19:17:40Z", "type": "commit"}, {"oid": "97ed8fa3a24c4561fa1371e251dcaa258243b32d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/97ed8fa3a24c4561fa1371e251dcaa258243b32d", "message": "Merge branch 'FieldBuilder' of https://github.com/sima-zhu/azure-sdk-for-java into FieldBuilder", "committedDate": "2020-04-29T19:17:46Z", "type": "commit"}, {"oid": "9bd1d4675e883363ac55d106aab3f945244cf36b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9bd1d4675e883363ac55d106aab3f945244cf36b", "message": "Added final the FieldBuilder", "committedDate": "2020-04-29T19:18:27Z", "type": "commit"}, {"oid": "e424f309bb0daf6f46e7247272077d5fa696c47a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e424f309bb0daf6f46e7247272077d5fa696c47a", "message": "add javadoc", "committedDate": "2020-04-30T03:23:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzODAxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418138019", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Helper to convert model class to search field {@link Field}.\n          \n          \n            \n             * Helper to convert model class to Search {@link Field fields}.", "author": "alzimmermsft", "createdAt": "2020-04-30T16:30:22Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MjA4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418142081", "bodyText": "This name confuses me a bit, is this a mapping of parameterized types that aren't allowed?", "author": "alzimmermsft", "createdAt": "2020-04-30T16:37:01Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzYzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418157631", "bodyText": "After looking at the PR further could we rename this SUPPORTED_SIMPLE_TYPES.", "author": "alzimmermsft", "createdAt": "2020-04-30T17:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MjA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MDg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418170889", "bodyText": "That's off a bit.\nSimpleType includes (primitive, boxing of primitive, array/list of boxing primitive)\nWhat I want to put here is: (primitive, boxing of primitive)\nThis is java class reflection term.", "author": "sima-zhu", "createdAt": "2020-04-30T17:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MjA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0Mjc5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418142794", "bodyText": "Should CharSequence also be added as an EDM_STRING mapping? Do these mappings check for the type being an instanceof or child of said class?", "author": "alzimmermsft", "createdAt": "2020-04-30T16:38:10Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NjI1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418176258", "bodyText": "First of all, I think we can force people to use String instead of CharSequence since I cannot think of why String cannot support customer needs. I would prefer to put it into UNSUPPORTED_TYPE.\nIf customer request to have CharSequence, I prefer to put into map directly instead of using instanceof as it is not a heavy load and there is not too much such cases in the real world, still constant cost. Adding instanceof add extra cost for most of the cases.", "author": "sima-zhu", "createdAt": "2020-04-30T17:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0Mjc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418157205", "bodyText": "Should this check Collection as that is the super type for List and will capture Set, Queue, etc.", "author": "alzimmermsft", "createdAt": "2020-04-30T17:02:37Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NzY5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418177695", "bodyText": "@brjohnstmsft\nWhat collection type should we support for Collection (DataType)  in search? Does service support Set, Queue etc? I currently only support user to have array or list as collection type. Let me know if Java Collection is better in this case.", "author": "sima-zhu", "createdAt": "2020-04-30T17:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0ODM4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418248381", "bodyText": "@sima-zhu This seems more like a question about what's idiomatic for Java. As long as it serializes to a JSON array, the service can work with it.", "author": "brjohnstmsft", "createdAt": "2020-04-30T19:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjc3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418316773", "bodyText": "Based on service side only take JSON array, I would leave array/list as the choice of collection DataType.\nFirst, they are enough for most of the use case.\nMoreover, as java sdk is not the only entry point of search service, I don't think it is necessary to leave customer the flexibility of set, queue to manipulate the data which service cannot maintain.", "author": "sima-zhu", "createdAt": "2020-04-30T22:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Mzg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418753877", "bodyText": "But if there's a common base class for arrays, collections, lists, etc. (in .NET, this is ICollection<T> or ICollection), that's best. It's not about what comes back from the service, but what is passed in and can be reconstituted. Any collection (in the general sense) can send a JSON array. When round-tripping, as long as a set or queue can be instantiated with an array (they can in .NET - not sure about Java) then the class should work. I think the flexibility is worth it, but you could always punt this change to preview 4 (just open a separate bug to track). In .NET, I can say I'm not limiting the classes they can use - just that it implements IEnumerable<T>.", "author": "heaths", "createdAt": "2020-05-01T21:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418158047", "bodyText": "Is this helper method needed?", "author": "alzimmermsft", "createdAt": "2020-04-30T17:04:05Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE4MTcwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418181707", "bodyText": "It is used for distinguish whether it is Supported type or complex one. It is necessary to have in top level checking.", "author": "sima-zhu", "createdAt": "2020-04-30T17:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418348739", "bodyText": "The reason I think it isn't needed as it is checking something we can do without calling another method in a single line, just replacing all instances of this being called with:\nSUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);", "author": "alzimmermsft", "createdAt": "2020-04-30T23:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0ODc5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418348798", "bodyText": "Does not need to be removed now.", "author": "alzimmermsft", "createdAt": "2020-04-30T23:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM0OTg5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418349893", "bodyText": "Make sense. Will simplify", "author": "sima-zhu", "createdAt": "2020-04-30T23:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1ODk1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418158958", "bodyText": "Can we add an actual exception message if we ever run into this issue in production.", "author": "alzimmermsft", "createdAt": "2020-04-30T17:05:39Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MDUyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418160529", "bodyText": "Doesn't needed to be changed now, but does this make more sense as an IllegalStateException?", "author": "alzimmermsft", "createdAt": "2020-04-30T17:08:22Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE4MzgwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418183802", "bodyText": "This means user uses both annotation at the same time. This can be fixed by customer.", "author": "sima-zhu", "createdAt": "2020-04-30T17:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE4NDAzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418184036", "bodyText": "IllegalStateException sounds like not able to fix by customer.", "author": "sima-zhu", "createdAt": "2020-04-30T17:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MDUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418163345", "bodyText": "Should we attempt to cleanse any potential null values in the annotation value? Ignore this if Java doesn't allow { \"aSynonym\", null, \"anotherSynonym\" }.", "author": "alzimmermsft", "createdAt": "2020-04-30T17:13:16Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to search field {@link Field}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (isSupportedNoneParameterizedType(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static boolean isSupportedNoneParameterizedType(Type type) {\n+        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (isSupportedNoneParameterizedType(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"Should not be there\"));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }\n+            if (searchableFieldPropertyAnnotation.synonymMaps().length != 0) {\n+                searchField.setSynonymMaps(Arrays.asList(searchableFieldPropertyAnnotation.synonymMaps()));", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3OTI3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418179276", "bodyText": "@brjohnstmsft I think this is valid.\nDo you think we need extra step of removing null out of map or throw error here?", "author": "sima-zhu", "createdAt": "2020-04-30T17:40:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0OTAyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418249021", "bodyText": "@sima-zhu I don't recall if the service ignores or rejects null in the list of synonym maps. Nulls are not meaningful in that context, so I think it would be fine to ignore them.", "author": "brjohnstmsft", "createdAt": "2020-04-30T19:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyMzczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418323736", "bodyText": "Will remove null from the list.", "author": "sima-zhu", "createdAt": "2020-04-30T22:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NDI1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418164251", "bodyText": "Should we also validate that DataType != null.", "author": "alzimmermsft", "createdAt": "2020-04-30T17:14:44Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));", "originalCommit": "e424f309bb0daf6f46e7247272077d5fa696c47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e45de6ac543692b9f74c1540b6b6d6998c738adb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e45de6ac543692b9f74c1540b6b6d6998c738adb", "message": "Update sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java\n\nCo-authored-by: Alan Zimmer <48699787+alzimmermsft@users.noreply.github.com>", "committedDate": "2020-04-30T17:19:11Z", "type": "commit"}, {"oid": "1e20f21b41b3b85eb357d88ebd3af7062e951183", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1e20f21b41b3b85eb357d88ebd3af7062e951183", "message": "Added blank field filter", "committedDate": "2020-04-30T23:05:50Z", "type": "commit"}, {"oid": "bf8cfc346e018d748bfc93cc0574a7f85f0e4f3f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bf8cfc346e018d748bfc93cc0574a7f85f0e4f3f", "message": "Merge branch 'FieldBuilder' of https://github.com/sima-zhu/azure-sdk-for-java into FieldBuilder", "committedDate": "2020-04-30T23:06:15Z", "type": "commit"}, {"oid": "a5659dec6b760fb1b886488c507163ebf145da78", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a5659dec6b760fb1b886488c507163ebf145da78", "message": "fixed linting", "committedDate": "2020-04-30T23:30:42Z", "type": "commit"}, {"oid": "86dc191974e68def26ceab4bcbaa320122a59a4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/86dc191974e68def26ceab4bcbaa320122a59a4b", "message": "Simplify the code", "committedDate": "2020-04-30T23:49:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MTg0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418451840", "bodyText": "I'd stay away from abbreviations like this unless they're well-known. It makes it hard to read. currentClass reads better.", "author": "conniey", "createdAt": "2020-05-01T07:52:12Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MTkzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418451932", "bodyText": "Do we really want to return null? Maybe an exception is better.", "author": "conniey", "createdAt": "2020-05-01T07:52:34Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU2OTE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418569149", "bodyText": "We shouldn\u2019t throw because the user might not intend for all properties of the type to be mapped to fields. Throwing an exception prevents the type from being used at all. Better to ignore properties we can\u2019t handle.", "author": "brjohnstmsft", "createdAt": "2020-05-01T14:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MTkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MjQwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418452405", "bodyText": "Creating the list is not necessary. You can use Arrays.stream()", "author": "conniey", "createdAt": "2020-05-01T07:54:36Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MjkyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418452922", "bodyText": "\"Collection type is not supported.\" rather than first person pronouns like \"We\"", "author": "conniey", "createdAt": "2020-05-01T07:56:39Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"We currently do not support the collection type: \"", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzU4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418453588", "bodyText": "This is easier to read as:\nreturn type.getClass().isArray() || isList(type);", "author": "conniey", "createdAt": "2020-05-01T07:59:18Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1Mzk1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418453951", "bodyText": "I'm a fan of bailing out of a method early. I think it makes it easier to read and the actual logic isn't shifted to the right with a ton of spaces if there are nested if-statements. It's a personal preference. You can leave as-is if you want.\nif (!(type instanceof ParameterizedType)) {\n    return false;\n}\n\nType rawType = ((ParameterizedType) type).getRawType();\nreturn List.class.isAssignableFrom((Class<?>) rawType);", "author": "conniey", "createdAt": "2020-05-01T08:00:49Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NDU1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418454556", "bodyText": "I'd invert this if to avoid the nested ifs.", "author": "conniey", "createdAt": "2020-05-01T08:03:29Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,259 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param curClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code curClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that curClass is built to.\n+     */\n+    private static List<Field> build(Class<?> curClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(curClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, curClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(curClass);\n+        List<java.lang.reflect.Field> classFields = Arrays.asList(curClass.getDeclaredFields());\n+        List<Field> searchFields = classFields.stream()\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+//    private static boolean isSupportedNoneParameterizedType(Type type) {\n+//        return SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type);\n+//    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        if (type.getClass().isArray()) {\n+            return true;\n+        }\n+        return isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            return List.class.isAssignableFrom((Class<?>) rawType);\n+        }\n+        return false;\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(\"We currently do not support the collection type: \"\n+                + arrayOrListType.getTypeName()));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }\n+            if (searchableFieldPropertyAnnotation.synonymMaps().length != 0) {\n+                List<String> synonymMaps = Arrays.stream(searchableFieldPropertyAnnotation.synonymMaps())\n+                    .filter(synonym -> !synonym.trim().isEmpty()).collect(Collectors.toList());\n+                searchField.setSynonymMaps(synonymMaps);\n+            }\n+        }\n+        return searchField;\n+    }\n+\n+    private static void validateType(Class<?> type, boolean hasArrayOrCollectionWrapped, ClientLogger logger) {\n+        if (Map.class.isAssignableFrom(type)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Map and its subclasses are not supported\"));\n+        }\n+        if (UNSUPPORTED_TYPES.contains(type)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(String.format(\"%s is not supported\",\n+                    type.getName())));\n+        }\n+        if (Collection.class.isAssignableFrom(type)) {", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NDg4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418454880", "bodyText": "You can save a line by using:\nthis.dataType = Objects.requireNonNull(dataType, \"'dataType' cannot be null.\");", "author": "conniey", "createdAt": "2020-05-01T08:04:53Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));\n+        }\n+        Objects.requireNonNull(dataType, \"DataType cannot be null.\");\n+        this.name = name;\n+        this.dataType = dataType;", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1NTM1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418455358", "bodyText": "Have you tried Collections.sort(fields, (o1, o2) -> {})? It'll save you from having to turn this from a list to a stream, then back into a list.", "author": "conniey", "createdAt": "2020-05-01T08:06:55Z", "path": "sdk/search/azure-search-documents/src/test/java/com/azure/search/documents/FieldBuilderTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.ComplexField;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.SearchableField;\n+import com.azure.search.documents.models.SimpleField;\n+import com.azure.search.documents.test.environment.models.Hotel;\n+import com.azure.search.documents.test.environment.models.HotelCircularDependencies;\n+import com.azure.search.documents.test.environment.models.HotelSearchException;\n+import com.azure.search.documents.test.environment.models.HotelSearchableExceptionOnList;\n+import com.azure.search.documents.test.environment.models.HotelWithEmptyInSynonymMaps;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class FieldBuilderTest {\n+    @Test\n+    public void hotelComparison() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(Hotel.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelFields());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    @Test\n+    public void hotelSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchException.class);\n+        });\n+        assertExceptionMassageAndDataType(exception, \"hotelId\", DataType.EDM_INT32);\n+    }\n+\n+    @Test\n+    public void hotelListFieldSearchableThrowException() {\n+        Exception exception = assertThrows(RuntimeException.class, () -> {\n+            FieldBuilder.build(HotelSearchableExceptionOnList.class);\n+        });\n+        assertExceptionMassageAndDataType(exception, \"passcode\", DataType.collection(DataType.EDM_INT32));\n+    }\n+\n+    @Test\n+    public void hotelCircularDependencies() {\n+        List<Field> actualFields = sortByFieldName(FieldBuilder.build(HotelCircularDependencies.class));\n+        List<Field> expectedFields = sortByFieldName(buildHotelCircularDependenciesModel());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    @Test\n+    public void hotelWithEmptySynonymMaps() {\n+        // We cannot put null in the annotation. So no need to test null case.\n+        List<Field> actualFields = FieldBuilder.build(HotelWithEmptyInSynonymMaps.class);\n+        List<Field> expectedFields = Collections.singletonList(new SearchableField(\"tags\", true)\n+            .setSynonymMaps(Arrays.asList(\"asynonymMaps\", \"maps\")).build());\n+        assertListFieldEquals(expectedFields, actualFields);\n+    }\n+\n+    private void assertListFieldEquals(List<Field> expected, List<Field> actual) {\n+        assertEquals(expected.size(), actual.size());\n+        for (int i = 0; i < expected.size(); i++) {\n+            TestHelpers.assertObjectEquals(expected.get(i), actual.get(i));\n+        }\n+    }\n+\n+    private void assertExceptionMassageAndDataType(Exception exception, String msg, DataType dataType) {\n+        assertTrue(exception.getMessage().contains(msg));\n+        assertTrue(exception.getMessage().contains(dataType.toString()));\n+    }\n+\n+    private List<Field> buildHotelCircularDependenciesModel() {\n+        Field homeAddress = new ComplexField(\"homeAddress\", false).setFields(buildHotelInAddress()).build();\n+        Field billingAddress = new ComplexField(\"billingAddress\", false).setFields(buildHotelInAddress()).build();\n+        return Arrays.asList(homeAddress, billingAddress);\n+    }\n+\n+    private List<Field> buildHotelInAddress() {\n+        Field hotel = new ComplexField(\"hotel\", false).build();\n+        return Collections.singletonList(hotel);\n+    }\n+\n+    private List<Field> buildHotelFields() {\n+        Field hotelId = new SimpleField(\"hotelId\", DataType.EDM_STRING, false).setSortable(true)\n+            .setKey(true).build();\n+        Field hotelName = new SearchableField(\"hotelName\", false).setAnalyzer(AnalyzerName.fromString(\"en.lucene\"))\n+            .setSortable(true).build();\n+        Field description = new SimpleField(\"description\", DataType.EDM_STRING, false).build();\n+        Field category = new SimpleField(\"category\", DataType.EDM_STRING, false).build();\n+        Field tags = new SearchableField(\"tags\", true).build();\n+        Field parkingIncluded = new SimpleField(\"parkingIncluded\", DataType.EDM_BOOLEAN, false).build();\n+        Field smokingAllowed = new SimpleField(\"smokingAllowed\", DataType.EDM_BOOLEAN, false).build();\n+        Field lastRenovationDate = new SimpleField(\"lastRenovationDate\", DataType.EDM_DATE_TIME_OFFSET, false).build();\n+        Field rating = new SimpleField(\"rating\", DataType.EDM_INT32, false).build();\n+        Field location = new SimpleField(\"location\", DataType.EDM_GEOGRAPHY_POINT, false).build();\n+        Field address = new ComplexField(\"address\", false)\n+            .setFields(buildHotelAddressField()).build();\n+        Field rooms = new ComplexField(\"rooms\", true).setFields(buildHotelRoomField()).build();\n+\n+        return Arrays.asList(hotelId, hotelName, description, category, tags, parkingIncluded, smokingAllowed,\n+            lastRenovationDate, rating, location, address, rooms);\n+    }\n+\n+    private List<Field> buildHotelAddressField() {\n+        Field streetAddress = new SimpleField(\"streetAddress\", DataType.EDM_STRING, false).setFacetable(true)\n+            .setKey(true).build();\n+        Field city = new SearchableField(\"city\", false).setFilterable(true).build();\n+        Field stateProvince = new SearchableField(\"stateProvince\", false).build();\n+        Field country = new SearchableField(\"country\", false)\n+            .setSynonymMaps(Arrays.asList(\"America -> USA\", \"USA -> US\")).build();\n+        Field postalCode = new SimpleField(\"postalCode\", DataType.EDM_STRING, false).build();\n+        return Arrays.asList(streetAddress, city, stateProvince, country, postalCode);\n+    }\n+\n+    private List<Field> buildHotelRoomField() {\n+        Field description = new SimpleField(\"description\", DataType.EDM_STRING, false).build();\n+        Field descriptionFr = new SimpleField(\"descriptionFr\", DataType.EDM_STRING, false).build();\n+        Field type = new SimpleField(\"type\", DataType.EDM_STRING, false).build();\n+        Field baseRate = new SimpleField(\"baseRate\", DataType.EDM_DOUBLE, false).build();\n+        Field bedOptions = new SimpleField(\"bedOptions\", DataType.EDM_STRING, false).build();\n+        Field sleepsCount = new SimpleField(\"sleepsCount\", DataType.EDM_INT32, false).build();\n+        Field smokingAllowed = new SimpleField(\"smokingAllowed\", DataType.EDM_BOOLEAN, false).build();\n+        Field tags = new SimpleField(\"tags\", DataType.EDM_STRING, true).build();\n+        return Arrays.asList(description, descriptionFr, type, baseRate, bedOptions, sleepsCount, smokingAllowed, tags);\n+    }\n+\n+    private List<Field> sortByFieldName(List<Field> fields) {\n+        return fields.stream().sorted((o1, o2) -> o1.getName().compareTo(o2.getName())).collect(Collectors.toList());", "originalCommit": "86dc191974e68def26ceab4bcbaa320122a59a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "367a661aab0362a385c3e47f072401b5b0e409cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/367a661aab0362a385c3e47f072401b5b0e409cd", "message": "some changes", "committedDate": "2020-05-01T17:08:12Z", "type": "commit"}, {"oid": "8587a2f9990fd11130be940451b77bf7dec47168", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8587a2f9990fd11130be940451b77bf7dec47168", "message": "Address feedback", "committedDate": "2020-05-01T18:04:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MjA1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418752057", "bodyText": "@brjohnstmsft is there a max depth for complex fields in the Search service itself we should use here - maybe even + some buffer in case the service changes?", "author": "heaths", "createdAt": "2020-05-01T21:47:02Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2NTIyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418765224", "bodyText": "Yes. Had this conversation with Sima already. The limits in the service are not static. This hard-coded value is orders of magnitude higher than the highest server-side limit on purpose so that the client doesn\u2019t disallow valid field definitions.", "author": "brjohnstmsft", "createdAt": "2020-05-01T22:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1MjA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Njk4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418756987", "bodyText": "The field name needs to be overridable. Imagine a key named \"hid\" but the field is hotelId.", "author": "heaths", "createdAt": "2020-05-01T22:03:08Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param currentClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code currentClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that currentClass is built to.\n+     */\n+    private static List<Field> build(Class<?> currentClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(currentClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, currentClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(currentClass);\n+        List<Field> searchFields = Arrays.stream(currentClass.getDeclaredFields())\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        return type.getClass().isArray() || isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (!(type instanceof ParameterizedType)) {\n+            return false;\n+        }\n+\n+        Type rawType = ((ParameterizedType) type).getRawType();\n+        return List.class.isAssignableFrom((Class<?>) rawType);\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        validateType(componentOrElementType, true, logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(String.format(\n+            \"Collection type %s is not supported.\", arrayOrListType.getTypeName())));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NDU1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418774550", "bodyText": "Same one as below.", "author": "sima-zhu", "createdAt": "2020-05-01T23:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Njk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Nzc2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418757763", "bodyText": "After this, you should assert that only analyzer or both searchAnalyzer and indexAnalyzer are specified.", "author": "heaths", "createdAt": "2020-05-01T22:05:37Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/FieldBuilder.java", "diffHunk": "@@ -0,0 +1,256 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.search.documents.indexes.FieldIgnore;\n+import com.azure.search.documents.indexes.SearchableFieldProperty;\n+import com.azure.search.documents.indexes.SimpleFieldProperty;\n+import com.azure.search.documents.models.AnalyzerName;\n+import com.azure.search.documents.models.DataType;\n+import com.azure.search.documents.models.Field;\n+import com.azure.search.documents.models.GeoPoint;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.time.OffsetDateTime;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper to convert model class to Search {@link Field fields}.\n+ */\n+public final class FieldBuilder {\n+    private static final int MAX_DEPTH = 10000;\n+    private static final Map<Class<?>, DataType> SUPPORTED_NONE_PARAMETERIZED_TYPE = new HashMap<>();\n+\n+    static {\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Integer.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(int.class, DataType.EDM_INT32);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(long.class, DataType.EDM_INT64);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(double.class, DataType.EDM_DOUBLE);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(boolean.class, DataType.EDM_BOOLEAN);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(String.class, DataType.EDM_STRING);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(Date.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(OffsetDateTime.class, DataType.EDM_DATE_TIME_OFFSET);\n+        SUPPORTED_NONE_PARAMETERIZED_TYPE.put(GeoPoint.class, DataType.EDM_GEOGRAPHY_POINT);\n+    }\n+\n+    private static final List<Class<?>> UNSUPPORTED_TYPES = Arrays.asList(Byte.class,\n+        CharSequence.class,\n+        Character.class,\n+        char.class,\n+        Float.class,\n+        float.class,\n+        Short.class,\n+        short.class);\n+\n+    /**\n+     * Creates a collection of {@link Field} objects corresponding to the properties of the type supplied.\n+     *\n+     * @param modelClass The class for which fields will be created, based on its properties.\n+     * @param <T> The generic type of the model class.\n+     * @return A collection of fields.\n+     */\n+    public static <T> List<Field> build(Class<T> modelClass) {\n+        ClientLogger logger = new ClientLogger(FieldBuilder.class);\n+        return build(modelClass, new Stack<>(), logger);\n+    }\n+\n+    /**\n+     * Recursive class to build complex data type.\n+     *\n+     * @param currentClass Current class to be built.\n+     * @param classChain A class chain from {@code modelClass} to prior of {@code currentClass}.\n+     * @param logger {@link ClientLogger}.\n+     * @return A list of {@link Field} that currentClass is built to.\n+     */\n+    private static List<Field> build(Class<?> currentClass, Stack<Class<?>> classChain, ClientLogger logger) {\n+        if (classChain.contains(currentClass)) {\n+            logger.warning(String.format(\"There is circular dependencies %s, %s\", classChain, currentClass));\n+            return null;\n+        }\n+        if (classChain.size() > MAX_DEPTH) {\n+            throw logger.logExceptionAsError(new RuntimeException(\n+                \"The dependency graph is too deep. Please review your schema.\"));\n+        }\n+        classChain.push(currentClass);\n+        List<Field> searchFields = Arrays.stream(currentClass.getDeclaredFields())\n+            .filter(classField -> !classField.isAnnotationPresent(FieldIgnore.class))\n+            .map(classField -> buildField(classField, classChain, logger))\n+            .collect(Collectors.toList());\n+        classChain.pop();\n+        return searchFields;\n+    }\n+\n+    private static Field buildField(java.lang.reflect.Field classField, Stack<Class<?>> classChain,\n+        ClientLogger logger) {\n+        Type type = classField.getGenericType();\n+\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(type)) {\n+            return buildNoneParameterizedType(classField, logger);\n+        }\n+        if (isArrayOrList(type)) {\n+            return buildCollectionField(classField, classChain, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) type, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Field buildNoneParameterizedType(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        return enrichWithAnnotation(searchField, classField, logger);\n+    }\n+\n+\n+    private static boolean isArrayOrList(Type type) {\n+        return type.getClass().isArray() || isList(type);\n+    }\n+\n+    private static boolean isList(Type type) {\n+        if (!(type instanceof ParameterizedType)) {\n+            return false;\n+        }\n+\n+        Type rawType = ((ParameterizedType) type).getRawType();\n+        return List.class.isAssignableFrom((Class<?>) rawType);\n+    }\n+\n+    private static Field buildCollectionField(java.lang.reflect.Field classField,\n+        Stack<Class<?>> classChain, ClientLogger logger) {\n+        Type componentOrElementType = getComponentOrElementType(classField.getGenericType(), logger);\n+        validateType(componentOrElementType, true, logger);\n+        if (SUPPORTED_NONE_PARAMETERIZED_TYPE.containsKey(componentOrElementType)) {\n+            Field searchField = convertToBasicSearchField(classField, logger);\n+            return enrichWithAnnotation(searchField, classField, logger);\n+        }\n+        List<Field> childFields = build((Class<?>) componentOrElementType, classChain, logger);\n+        Field searchField = convertToBasicSearchField(classField, logger);\n+        searchField.setFields(childFields);\n+        return searchField;\n+    }\n+\n+    private static Type getComponentOrElementType(Type arrayOrListType, ClientLogger logger) {\n+        if (arrayOrListType.getClass().isArray()) {\n+            return arrayOrListType.getClass().getComponentType();\n+        }\n+        if (isList(arrayOrListType)) {\n+            ParameterizedType pt = (ParameterizedType) arrayOrListType;\n+            return pt.getActualTypeArguments()[0];\n+        }\n+        throw logger.logExceptionAsError(new RuntimeException(String.format(\n+            \"Collection type %s is not supported.\", arrayOrListType.getTypeName())));\n+    }\n+\n+    private static Field convertToBasicSearchField(java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        Field searchField = new Field();\n+        searchField.setName(classField.getName());\n+        DataType dataType = covertToDataType(classField.getGenericType(), false, logger);\n+        searchField.setType(dataType)\n+            .setKey(false)\n+            .setSearchable(false)\n+            .setFacetable(false)\n+            .setHidden(false)\n+            .setFilterable(false)\n+            .setSortable(false);\n+        return searchField;\n+    }\n+\n+    private static Field enrichWithAnnotation(Field searchField, java.lang.reflect.Field classField,\n+        ClientLogger logger) {\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)\n+            && classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                    String.format(\"@SimpleFieldProperty and @SearchableFieldProperty cannot be present simultaneously \"\n+                        + \"for %s\", classField.getName())));\n+        }\n+        if (classField.isAnnotationPresent(SimpleFieldProperty.class)) {\n+            SimpleFieldProperty simpleFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SimpleFieldProperty.class);\n+            searchField.setSearchable(false)\n+                .setSortable(simpleFieldPropertyAnnotation.isSortable())\n+                .setFilterable(simpleFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(simpleFieldPropertyAnnotation.isFacetable())\n+                .setKey(simpleFieldPropertyAnnotation.isKey())\n+                .setHidden(simpleFieldPropertyAnnotation.isHidden());\n+        } else if (classField.isAnnotationPresent(SearchableFieldProperty.class)) {\n+            if (!searchField.getType().equals(DataType.EDM_STRING)\n+                && !searchField.getType().equals(DataType.collection(DataType.EDM_STRING))) {\n+                throw logger.logExceptionAsError(new RuntimeException(String.format(\"SearchFieldProperty can only\"\n+                    + \" be used on string properties. Property %s returns a %s value.\",\n+                    classField.getName(), searchField.getType())));\n+            }\n+            SearchableFieldProperty searchableFieldPropertyAnnotation =\n+                classField.getDeclaredAnnotation(SearchableFieldProperty.class);\n+            searchField.setSearchable(true)\n+                .setSortable(searchableFieldPropertyAnnotation.isSortable())\n+                .setFilterable(searchableFieldPropertyAnnotation.isFilterable())\n+                .setFacetable(searchableFieldPropertyAnnotation.isFacetable())\n+                .setKey(searchableFieldPropertyAnnotation.isKey())\n+                .setHidden(searchableFieldPropertyAnnotation.isHidden());\n+            if (!searchableFieldPropertyAnnotation.analyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.analyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.searchAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.searchAnalyzer())));\n+            }\n+            if (!searchableFieldPropertyAnnotation.indexAnalyzer().isEmpty()) {\n+                searchField.setAnalyzer(AnalyzerName.fromString((searchableFieldPropertyAnnotation.indexAnalyzer())));\n+            }", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NTE3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418775178", "bodyText": "Several ways to achieve this:\n\nThrow error if they both categories exist.\nDefault to analyzer when both categories exist.", "author": "sima-zhu", "createdAt": "2020-05-01T23:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Nzc2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NTM4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418775387", "bodyText": "To make it simple, I will throw error for now. Can come back to this we want different behavior.", "author": "sima-zhu", "createdAt": "2020-05-01T23:15:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1Nzc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODM2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758368", "bodyText": "I'd call this synonymMapNames since it's the names of synonymMaps. IIRC, that's what I did for that reason.", "author": "heaths", "createdAt": "2020-05-01T22:07:39Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/SearchableField.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import java.util.List;\n+\n+/**\n+ * A helper Field model to build a searchable {@link Field}.\n+ */\n+public class SearchableField extends SimpleField {\n+    private AnalyzerName analyzer;\n+    private AnalyzerName searchAnalyzer;\n+    private AnalyzerName indexAnalyzer;\n+    private List<String> synonymMaps;\n+\n+    /**\n+     * Initializes a new instance of the {@link SearchableField} class.\n+     *\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param collection Whether the field is a collection of strings.\n+     * @throws NullPointerException when {@code name} is null.\n+     */\n+    public SearchableField(String name, boolean collection) {\n+        super(name, DataType.EDM_STRING, collection);\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for analyzer.\n+     */\n+    public AnalyzerName getAnalyzer() {\n+        return analyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer. This property cannot be set when either {@code searchAnalyzer} or\n+     * {@code indexAnalyzer} are set. Once the analyzer is chosen, it cannot be changed for the field in the index.\n+     *\n+     * @param analyzer The {@link AnalyzerName} used for analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setAnalyzer(AnalyzerName analyzer) {\n+        this.analyzer = analyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for search analyzer.\n+     */\n+    public AnalyzerName getSearchAnalyzer() {\n+        return searchAnalyzer;\n+    }\n+\n+    /**\n+     * Sets the name of the language analyzer for searching. This property must be set together with\n+     * {@code indexAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param searchAnalyzer The {@link AnalyzerName} used for search analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSearchAnalyzer(AnalyzerName searchAnalyzer) {\n+        this.searchAnalyzer = searchAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @return The {@link AnalyzerName} used for index analyzer.\n+     */\n+    public AnalyzerName getIndexAnalyzer() {\n+        return indexAnalyzer;\n+    }\n+\n+    /**\n+     * Gets the name of the language analyzer for indexing. This property must be set together with\n+     * {@code searchAnalyzer}, and cannot be set when {@code analyzer} is set. Once the analyzer is chosen, it cannot be\n+     * changed for the field in the index.\n+     *\n+     * @param indexAnalyzer The {@link AnalyzerName} used for index analyzer.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setIndexAnalyzer(AnalyzerName indexAnalyzer) {\n+        this.indexAnalyzer = indexAnalyzer;\n+        return this;\n+    }\n+\n+    /**\n+     * Gets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @return List of names of synonym maps to associate with this field.\n+     */\n+    public List<String> getSynonymMaps() {\n+        return synonymMaps;\n+    }\n+\n+    /**\n+     * Sets a list of names of synonym maps to associate with this field.\n+     * Currently, only one synonym map per field is supported.\n+     *\n+     * Assigning a synonym map to a field ensures that query terms targeting that field are expanded at query-time using\n+     * the rules in the synonym map. This attribute can be changed on existing fields.\n+     *\n+     * @param synonymMaps list of names of synonym maps to associate with this field.\n+     * @return The SearchableField object itself.\n+     */\n+    public SearchableField setSynonymMaps(List<String> synonymMaps) {", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758732", "bodyText": "When you do the renames, you might call this SearchFieldBase given our discussion internally.", "author": "heaths", "createdAt": "2020-05-01T22:09:00Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2NjA5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418766094", "bodyText": "Will do. Thanks for reminding! Will add you as review for renaming changes.", "author": "sima-zhu", "createdAt": "2020-05-01T22:36:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1ODkxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418758917", "bodyText": "Nit: \"The name of the field cannot be null\"", "author": "heaths", "createdAt": "2020-05-01T22:09:38Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/models/FieldBase.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.models;\n+\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Objects;\n+\n+/**\n+ * Base field type for helper classes to more easily create a {@link Index}.\n+ */\n+public abstract class FieldBase {\n+    private final ClientLogger logger = new ClientLogger(FieldBase.class);\n+    private final String name;\n+    private final DataType dataType;\n+\n+    /**\n+     * Initializes a new instance of the {@link FieldBase} class.\n+     * @param name The name of the field, which must be unique within the index or parent field.\n+     * @param dataType The data type of the field.\n+     */\n+    protected FieldBase(String name, DataType dataType) {\n+        if (CoreUtils.isNullOrEmpty(name)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"The name of field cannot be null\"));", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTM0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418759349", "bodyText": "The comment is off, since the default is not \"null\". Also, why can't the default just be null (null reference, not a string with contents \"null\")? Is that not typical in Java?", "author": "heaths", "createdAt": "2020-05-01T22:11:21Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,82 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.indexes;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {\n+    /**\n+     * Optional arguments defines whether the field is a key field or not.\n+     *\n+     * @return True if it is the key of SearchField, and false by default for non-key field.\n+     */\n+    boolean isKey() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is hidden or not.\n+     *\n+     * @return True if it is not retrievable, and false by default for retrievable field.\n+     */\n+    boolean isHidden() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is facetable or not.\n+     *\n+     * @return True if it is facetable, and false by default for non-facetable field.\n+     */\n+    boolean isFacetable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is sortable or not.\n+     *\n+     * @return True if it is sortable, and false by default for non-sortable field.\n+     */\n+    boolean isSortable() default false;\n+\n+    /**\n+     * Optional arguments defines whether the field is filterable or not.\n+     *\n+     * @return True if it is filterable, and false by default for non-filterable field.\n+     */\n+    boolean isFilterable() default false;\n+\n+    /**\n+     * Optional arguments defines the name of the analyzer used for the field.\n+     *\n+     * @return {@link AnalyzerName} String value. Or default to \"null\" String type.", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2NTM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418765379", "bodyText": "Will change JavaDoc. Good catch!\nJava annotation does not allow to take default of null reference.", "author": "sima-zhu", "createdAt": "2020-05-01T22:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTY2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418759664", "bodyText": "Missing name. The name must be overridable. It can default to the property name, but that isn't always desirable. Same for all other attribute classes below.", "author": "heaths", "createdAt": "2020-05-01T22:12:25Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/indexes/SearchableFieldProperty.java", "diffHunk": "@@ -0,0 +1,82 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.indexes;\n+\n+import com.azure.search.documents.models.AnalyzerName;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * The annotation is to indicate whether the field is a searchable field. The boolean field of isSearchable\n+ * defaults to true if use the annotation.\n+ */\n+@Target({ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface SearchableFieldProperty {", "originalCommit": "8587a2f9990fd11130be940451b77bf7dec47168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3MTYyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418771628", "bodyText": "I have added name for Searchable, Simple attributes.", "author": "sima-zhu", "createdAt": "2020-05-01T22:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3MzAzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418773038", "bodyText": "This leaves a problem for complex fields since we don't have an attribute.\nMaybe we need to punt field renaming to preview 4. Come to think of it, in .NET different attributes (from Json.NET, though in track 2 we'd use the built-in ones) could rename it. You could do the same with your JSON serialization framework (I forget the name off hand).\n/cc @brjohnstmsft", "author": "heaths", "createdAt": "2020-05-01T23:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NDM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10500#discussion_r418774379", "bodyText": "#10647\nThis is a summery issue for all open questions not going to address for this PR.", "author": "sima-zhu", "createdAt": "2020-05-01T23:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1OTY2NA=="}], "type": "inlineReview"}, {"oid": "29f6ee7e95a6727a00176ac7e1b0b0fee8f935a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/29f6ee7e95a6727a00176ac7e1b0b0fee8f935a9", "message": "more link locale removal", "committedDate": "2020-05-01T22:21:22Z", "type": "commit"}, {"oid": "b06281f7e16b1e5a12fdd2bf9bb703c3c5df9d06", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b06281f7e16b1e5a12fdd2bf9bb703c3c5df9d06", "message": "Address comments", "committedDate": "2020-05-01T23:37:40Z", "type": "commit"}, {"oid": "d6174467374831a08e20aa27332326b9242d5069", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6174467374831a08e20aa27332326b9242d5069", "message": "Merge from master", "committedDate": "2020-05-01T23:47:13Z", "type": "commit"}]}