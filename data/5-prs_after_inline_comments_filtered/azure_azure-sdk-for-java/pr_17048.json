{"pr_number": 17048, "pr_title": "Add Service Bus Processor Client to receive messages", "pr_createdAt": "2020-11-01T21:47:21Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/17048", "timeline": [{"oid": "d212035e9353eec053d504ca7ca1ac474a5a50e3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d212035e9353eec053d504ca7ca1ac474a5a50e3", "message": "Initial commit for Service Bus processor", "committedDate": "2020-10-27T06:45:19Z", "type": "commit"}, {"oid": "a6d3da5b7289f1cf96ab252c881ceb30a1734983", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a6d3da5b7289f1cf96ab252c881ceb30a1734983", "message": "Merge remote-tracking branch 'upstream/master' into sb-processor", "committedDate": "2020-10-31T09:17:20Z", "type": "commit"}, {"oid": "0e2b8c6df6a902f48274e7e0f84f6c493f77f6b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0e2b8c6df6a902f48274e7e0f84f6c493f77f6b9", "message": "Service Bus processor changes", "committedDate": "2020-11-01T21:04:13Z", "type": "commit"}, {"oid": "87a1fad3c55744b4d04562b7f4454b56db760748", "url": "https://github.com/Azure/azure-sdk-for-java/commit/87a1fad3c55744b4d04562b7f4454b56db760748", "message": "JavaDoc updates", "committedDate": "2020-11-01T21:48:00Z", "type": "commit"}, {"oid": "cadc9aebd8714e31e510f822fcf410c0dfc227e1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cadc9aebd8714e31e510f822fcf410c0dfc227e1", "message": "Fix javadoc", "committedDate": "2020-11-02T04:49:19Z", "type": "commit"}, {"oid": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e137020007e26d47d17ce9ade0b08eefa4fc75cc", "message": "Make isRunning final", "committedDate": "2020-11-02T05:16:36Z", "type": "commit"}, {"oid": "d15b453a31f306c8fdca44900c28f2124ec8fb3b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d15b453a31f306c8fdca44900c28f2124ec8fb3b", "message": "Merge remote-tracking branch 'upstream/master' into sb-processor", "committedDate": "2020-11-02T17:58:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzYwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516163602", "bodyText": "I was wondering why we don't extend from AutoCloseable for this because the interface seems to be what this method is doing.", "author": "conniey", "createdAt": "2020-11-02T18:09:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3OTA0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516179049", "bodyText": "Sure, I'll implement AutoCloseable.", "author": "srnagar", "createdAt": "2020-11-02T18:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2MzYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0NzkxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516147910", "bodyText": "Since this is first split where user will be introduced to processor,  May be we can explain little bit about it and all the goodies  user get from it.  I see that you have explained it at ServiceBusSessionProcessorClientBuilder but a short explanation here will be good.", "author": "hemanttanwar", "createdAt": "2020-11-02T17:42:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -266,6 +294,23 @@ public ServiceBusSessionReceiverClientBuilder sessionReceiver() {\n         return new ServiceBusSessionReceiverClientBuilder();\n     }\n \n+    /**\n+     * A new instance of {@link ServiceBusProcessorClientBuilder} used to configure Service Bus processor instance.\n+     * @return A new instance of {@link ServiceBusProcessorClientBuilder}.\n+     */", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMDg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516210875", "bodyText": "I have updated this to include links to the processor client documentation.", "author": "srnagar", "createdAt": "2020-11-02T19:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE0NzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTY1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516151652", "bodyText": "Should we check for null processMessage.", "author": "hemanttanwar", "createdAt": "2020-11-02T17:48:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -574,6 +619,177 @@ public ServiceBusSenderClient buildClient() {\n         }\n     }\n \n+    /**\n+     * Builder for creating {@link ServiceBusProcessorClient} to consume messages from a session-based Service Bus\n+     * entity. {@link ServiceBusProcessorClient ServiceBusProcessorClients} provides a push-based mechanism that\n+     * invokes the message processing callback when a message is received or the error handler when an error occurs\n+     * when receiving messages. To create an instance, therefore, configuring the two callbacks -\n+     * {@link #processMessage(Consumer)} and {@link #processError(Consumer)} are necessary. By default, a\n+     * {@link ServiceBusProcessorClient} is configured with auto-completion and auto-lock renewal capabilities.\n+     * {@link ServiceBusProcessorClient ServiceBusProcessorClients} created by this builder can be configured to\n+     * consume messages from {@link #maxConcurrentSessions(int) multiple sessions concurrently}. By default, the\n+     * processor will receive messages from a single session with rollover.\n+     *\n+     * <p><strong>Sample code to instantiate a session-enabled processor client</strong></p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.sessionclientinstantiation}\n+     *\n+     * @see ServiceBusProcessorClient\n+     */\n+    public final class ServiceBusSessionProcessorClientBuilder {\n+        private final ServiceBusProcessorClientOptions processorClientOptions;\n+        private final ServiceBusSessionReceiverClientBuilder sessionReceiverClientBuilder;\n+        private Consumer<ServiceBusProcessorMessageContext> processMessage;\n+        private Consumer<Throwable> processError;\n+\n+        private ServiceBusSessionProcessorClientBuilder() {\n+            sessionReceiverClientBuilder = new ServiceBusSessionReceiverClientBuilder();\n+            processorClientOptions = new ServiceBusProcessorClientOptions();\n+            sessionReceiverClientBuilder.maxConcurrentSessions(1);\n+            processorClientOptions.setMaxConcurrentCalls(1);\n+        }\n+\n+        /**\n+         * Enables session processing roll-over by processing at most {@code maxConcurrentSessions}.\n+         *\n+         * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder maxConcurrentSessions(int maxConcurrentSessions) {\n+            if (maxConcurrentSessions < 1) {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"'maxConcurrentSessions' cannot be less than 1\"));\n+            }\n+            sessionReceiverClientBuilder.maxConcurrentSessions(maxConcurrentSessions);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the prefetch count of the processor. For both {@link ReceiveMode#PEEK_LOCK PEEK_LOCK} and {@link\n+         * ReceiveMode#RECEIVE_AND_DELETE RECEIVE_AND_DELETE} modes the default value is 1.\n+         *\n+         * Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when\n+         * and before the application starts the processor.\n+         * Setting a non-zero value will prefetch that number of messages. Setting the value to zero turns prefetch off.\n+         *\n+         * @param prefetchCount The prefetch count.\n+         *\n+         * @return The modified {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder prefetchCount(int prefetchCount) {\n+            sessionReceiverClientBuilder.prefetchCount(prefetchCount);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the queue to create a processor for.\n+         * @param queueName Name of the queue.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder queueName(String queueName) {\n+            sessionReceiverClientBuilder.queueName(queueName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the receive mode for the processor.\n+         * @param receiveMode Mode for receiving messages.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder receiveMode(ReceiveMode receiveMode) {\n+            sessionReceiverClientBuilder.receiveMode(receiveMode);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the subscription in the topic to listen to. <b>{@link #topicName(String)} must also be set.\n+         * </b>\n+         * @param subscriptionName Name of the subscription.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #topicName A topic name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder subscriptionName(String subscriptionName) {\n+            sessionReceiverClientBuilder.subscriptionName(subscriptionName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the topic. <b>{@link #subscriptionName(String)} must also be set.</b>\n+         * @param topicName Name of the topic.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #subscriptionName A subscription name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder topicName(String topicName) {\n+            sessionReceiverClientBuilder.topicName(topicName);\n+            return this;\n+        }\n+\n+        /**\n+         * The message processing callback for the processor that will be executed when a message is received.\n+         * @param processMessage The message processing consumer that will be executed when a message is received.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processMessage(\n+            Consumer<ServiceBusProcessorMessageContext> processMessage) {\n+            this.processMessage = processMessage;", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3Njg1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516176854", "bodyText": "I see  it is done at build time", "author": "hemanttanwar", "createdAt": "2020-11-02T18:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE1MTc4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516151788", "bodyText": "same null check  ?", "author": "hemanttanwar", "createdAt": "2020-11-02T17:48:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -574,6 +619,177 @@ public ServiceBusSenderClient buildClient() {\n         }\n     }\n \n+    /**\n+     * Builder for creating {@link ServiceBusProcessorClient} to consume messages from a session-based Service Bus\n+     * entity. {@link ServiceBusProcessorClient ServiceBusProcessorClients} provides a push-based mechanism that\n+     * invokes the message processing callback when a message is received or the error handler when an error occurs\n+     * when receiving messages. To create an instance, therefore, configuring the two callbacks -\n+     * {@link #processMessage(Consumer)} and {@link #processError(Consumer)} are necessary. By default, a\n+     * {@link ServiceBusProcessorClient} is configured with auto-completion and auto-lock renewal capabilities.\n+     * {@link ServiceBusProcessorClient ServiceBusProcessorClients} created by this builder can be configured to\n+     * consume messages from {@link #maxConcurrentSessions(int) multiple sessions concurrently}. By default, the\n+     * processor will receive messages from a single session with rollover.\n+     *\n+     * <p><strong>Sample code to instantiate a session-enabled processor client</strong></p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.sessionclientinstantiation}\n+     *\n+     * @see ServiceBusProcessorClient\n+     */\n+    public final class ServiceBusSessionProcessorClientBuilder {\n+        private final ServiceBusProcessorClientOptions processorClientOptions;\n+        private final ServiceBusSessionReceiverClientBuilder sessionReceiverClientBuilder;\n+        private Consumer<ServiceBusProcessorMessageContext> processMessage;\n+        private Consumer<Throwable> processError;\n+\n+        private ServiceBusSessionProcessorClientBuilder() {\n+            sessionReceiverClientBuilder = new ServiceBusSessionReceiverClientBuilder();\n+            processorClientOptions = new ServiceBusProcessorClientOptions();\n+            sessionReceiverClientBuilder.maxConcurrentSessions(1);\n+            processorClientOptions.setMaxConcurrentCalls(1);\n+        }\n+\n+        /**\n+         * Enables session processing roll-over by processing at most {@code maxConcurrentSessions}.\n+         *\n+         * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder maxConcurrentSessions(int maxConcurrentSessions) {\n+            if (maxConcurrentSessions < 1) {\n+                throw logger.logExceptionAsError(\n+                    new IllegalArgumentException(\"'maxConcurrentSessions' cannot be less than 1\"));\n+            }\n+            sessionReceiverClientBuilder.maxConcurrentSessions(maxConcurrentSessions);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the prefetch count of the processor. For both {@link ReceiveMode#PEEK_LOCK PEEK_LOCK} and {@link\n+         * ReceiveMode#RECEIVE_AND_DELETE RECEIVE_AND_DELETE} modes the default value is 1.\n+         *\n+         * Prefetch speeds up the message flow by aiming to have a message readily available for local retrieval when\n+         * and before the application starts the processor.\n+         * Setting a non-zero value will prefetch that number of messages. Setting the value to zero turns prefetch off.\n+         *\n+         * @param prefetchCount The prefetch count.\n+         *\n+         * @return The modified {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder prefetchCount(int prefetchCount) {\n+            sessionReceiverClientBuilder.prefetchCount(prefetchCount);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the queue to create a processor for.\n+         * @param queueName Name of the queue.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder queueName(String queueName) {\n+            sessionReceiverClientBuilder.queueName(queueName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the receive mode for the processor.\n+         * @param receiveMode Mode for receiving messages.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder receiveMode(ReceiveMode receiveMode) {\n+            sessionReceiverClientBuilder.receiveMode(receiveMode);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the subscription in the topic to listen to. <b>{@link #topicName(String)} must also be set.\n+         * </b>\n+         * @param subscriptionName Name of the subscription.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #topicName A topic name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder subscriptionName(String subscriptionName) {\n+            sessionReceiverClientBuilder.subscriptionName(subscriptionName);\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the name of the topic. <b>{@link #subscriptionName(String)} must also be set.</b>\n+         * @param topicName Name of the topic.\n+         *\n+         * @return The modified {@link ServiceBusSessionProcessorClientBuilder} object.\n+         * @see #subscriptionName A subscription name should be set as well.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder topicName(String topicName) {\n+            sessionReceiverClientBuilder.topicName(topicName);\n+            return this;\n+        }\n+\n+        /**\n+         * The message processing callback for the processor that will be executed when a message is received.\n+         * @param processMessage The message processing consumer that will be executed when a message is received.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object.\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processMessage(\n+            Consumer<ServiceBusProcessorMessageContext> processMessage) {\n+            this.processMessage = processMessage;\n+            return this;\n+        }\n+\n+        /**\n+         * The error handler for the processor which will be invoked in the event of an error while receiving messages.\n+         * @param processError The error handler which will be executed when an error occurs.\n+         *\n+         * @return The updated {@link ServiceBusProcessorClientBuilder} object\n+         */\n+        public ServiceBusSessionProcessorClientBuilder processError(Consumer<Throwable> processError) {\n+            this.processError = processError;", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516166190", "bodyText": "If  user's processHandler throw error when they want to abandon the message , are we abandoning the message ?", "author": "hemanttanwar", "createdAt": "2020-11-02T18:13:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return isRunning.get();\n+    }\n+\n+    private synchronized void receiveMessages() {\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().request(1);\n+            return;\n+        }\n+        ServiceBusReceiverAsyncClient receiverClient = asyncClient.get();\n+        receiverClient.receiveMessages()\n+            .parallel(processorOptions.getMaxConcurrentCalls())\n+            .runOn(Schedulers.boundedElastic())\n+            .subscribe(new Subscriber<ServiceBusReceivedMessageContext>() {\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    receiverSubscription.set(subscription);\n+                    receiverSubscription.get().request(1);\n+                }\n+\n+                @Override\n+                public void onNext(ServiceBusReceivedMessageContext serviceBusReceivedMessageContext) {\n+                    if (serviceBusReceivedMessageContext.hasError()) {\n+                        handleError(serviceBusReceivedMessageContext.getThrowable());\n+                    } else {\n+                        try {\n+                            ServiceBusProcessorMessageContext serviceBusProcessorMessageContext =\n+                                new ServiceBusProcessorMessageContext(receiverClient, serviceBusReceivedMessageContext);\n+                            processMessage.accept(serviceBusProcessorMessageContext);\n+                        } catch (Exception exception) {", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjQyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516212421", "bodyText": "Yes, we should abandon the message if user's message handler throws an exception. Updated to abandon the message.", "author": "srnagar", "createdAt": "2020-11-02T19:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MTQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516171450", "bodyText": "Could we also add  case where user processingHandler throw Exception and that trigger abandoning of the message.", "author": "hemanttanwar", "createdAt": "2020-11-02T18:23:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusProcessorTest.java", "diffHunk": "@@ -0,0 +1,238 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Unit tests for {@link ServiceBusProcessorClient}.\n+ */\n+public class ServiceBusProcessorTest {", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxMjUwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516212509", "bodyText": "Added unit test for this.", "author": "srnagar", "createdAt": "2020-11-02T19:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MTQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NTg1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516175856", "bodyText": "Once user calls close()  and start() after that ? Are we recreating Link ?\nprocessor.close();\nprocessor.start();", "author": "hemanttanwar", "createdAt": "2020-11-02T18:31:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3OTE5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516179194", "bodyText": "Yes, this will result in a whole new client getting created with new links.", "author": "srnagar", "createdAt": "2020-11-02T18:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3NTg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2OTg1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516169855", "bodyText": "Nitpick. Do we need this to be synchronized? This is a read-only operation and isRunning is an AtomicBoolean.", "author": "YijunXieMS", "createdAt": "2020-11-02T18:20:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIxNDA0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516214049", "bodyText": "Even though isRunning boolean is atomic, the whole method has to be synchronized to provide an accurate state of the processor. Because a thread might have called start() which flips the isRunning boolean to true but the call to receiveMessages() may not yet be made when another thread tries to call isRunning().", "author": "srnagar", "createdAt": "2020-11-02T19:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2OTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3ODczMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516178731", "bodyText": "receiveMessages calls restartMessageReceiver, which will call receiveMessages again. Will this cause stackoverflow if the processor keeps running for long enough time?", "author": "YijunXieMS", "createdAt": "2020-11-02T18:36:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusProcessorClient.java", "diffHunk": "@@ -0,0 +1,216 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.models.ServiceBusProcessorClientOptions;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+/**\n+ *  The processor client for processing Service Bus messages. {@link ServiceBusProcessorClient\n+ *  ServiceBusProcessorClients} provides a push-based mechanism that invokes the message processing callback when a\n+ *  message is received or the error handler when an error occurs when receiving messages. A\n+ *  {@link ServiceBusProcessorClient} can be created to process messages for a session-enabled Service Bus entity or\n+ *  a non session-enabled Service Bus entity.\n+ *\n+ * <p><strong>Sample code to start a processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.start}\n+ *\n+ * <p><strong>Sample code to start a session-enabled processor client</strong></p>\n+ * {@codesnippet com.azure.messaging.servicebus.servicebusprocessorclient.startsession}\n+ *\n+ * @see ServiceBusClientBuilder\n+ */\n+public final class ServiceBusProcessorClient {\n+\n+    private static final int SCHEDULER_INTERVAL_IN_SECONDS = 10;\n+    private final ClientLogger logger = new ClientLogger(ServiceBusProcessorClient.class);\n+    private final ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder;\n+    private final ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder;\n+    private final Consumer<ServiceBusProcessorMessageContext> processMessage;\n+    private final Consumer<Throwable> processError;\n+    private final ServiceBusProcessorClientOptions processorOptions;\n+    private final AtomicReference<Subscription> receiverSubscription = new AtomicReference<>();\n+    private final AtomicReference<ServiceBusReceiverAsyncClient> asyncClient = new AtomicReference<>();\n+    private final AtomicBoolean isRunning = new AtomicBoolean();\n+    private ScheduledExecutorService scheduledExecutor;\n+\n+    /**\n+     * Constructor to create a sessions-enabled processor.\n+     *\n+     * @param sessionReceiverBuilder The session processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusSessionReceiverClientBuilder sessionReceiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.sessionReceiverBuilder = Objects.requireNonNull(sessionReceiverBuilder,\n+            \"'sessionReceiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(sessionReceiverBuilder.buildAsyncClientForProcessor());\n+        this.receiverBuilder = null;\n+    }\n+\n+    /**\n+     * Constructor to create a processor.\n+     *\n+     * @param receiverBuilder The processor builder to create new instances of async clients.\n+     * @param processMessage The message processing callback.\n+     * @param processError The error handler.\n+     * @param processorOptions Options to configure this instance of the processor.\n+     */\n+    ServiceBusProcessorClient(ServiceBusClientBuilder.ServiceBusReceiverClientBuilder receiverBuilder,\n+                              Consumer<ServiceBusProcessorMessageContext> processMessage,\n+                              Consumer<Throwable> processError, ServiceBusProcessorClientOptions processorOptions) {\n+        this.receiverBuilder = Objects.requireNonNull(receiverBuilder, \"'receiverBuilder' cannot be null\");\n+        this.processMessage = Objects.requireNonNull(processMessage, \"'processMessage' cannot be null\");\n+        this.processError = Objects.requireNonNull(processError, \"'processError' cannot be null\");\n+        this.processorOptions = Objects.requireNonNull(processorOptions, \"'processorOptions' cannot be null\");\n+        this.asyncClient.set(receiverBuilder.buildAsyncClient());\n+        this.sessionReceiverBuilder = null;\n+    }\n+\n+    /**\n+     * Starts the processor in the background. When this method is called, the processor will initiate a message\n+     * receiver that will invoke the message handler when new messages are available. This method is idempotent i.e\n+     * calling {@link #start()} again after the processor is already running is a no-op. Calling {@link #start()}\n+     * after calling {@link #stop()} will resume processing messages using the same underlying links or active\n+     * sessions. Calling {@link #start()} after calling {@link #close()} will start the processor with new links and\n+     * a new set of sessions will be processed.\n+     */\n+    public synchronized void start() {\n+        if (isRunning.getAndSet(true)) {\n+            logger.info(\"Processor is already running\");\n+            return;\n+        }\n+        receiveMessages();\n+\n+        // Start an executor to periodically check if the client's connection is active\n+        this.scheduledExecutor = Executors.newSingleThreadScheduledExecutor();\n+        scheduledExecutor.scheduleWithFixedDelay(() -> {\n+            if (this.asyncClient.get().isConnectionClosed()) {\n+                restartMessageReceiver();\n+            }\n+        }, SCHEDULER_INTERVAL_IN_SECONDS, SCHEDULER_INTERVAL_IN_SECONDS, TimeUnit.SECONDS);\n+\n+    }\n+\n+    /**\n+     * Stops the message processing for this processor. The receiving links and sessions are kept active and this\n+     * processor can resume processing messages by calling {@link #start()} again.\n+     */\n+    public synchronized void stop() {\n+        isRunning.set(false);\n+    }\n+\n+    /**\n+     * Stops message processing and closes the processor. The receiving links and sessions are closed and calling\n+     * {@link #start()} will create a new processing cycle with new links and new sessions.\n+     */\n+    public synchronized void close() {\n+        isRunning.set(false);\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().cancel();\n+        }\n+        asyncClient.get().close();\n+        scheduledExecutor.shutdown();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the processor is running. If the processor is stopped or closed, this method returns\n+     * {@code false}.\n+     *\n+     * @return {@code true} if the processor is running.\n+     */\n+    public synchronized boolean isRunning() {\n+        return isRunning.get();\n+    }\n+\n+    private synchronized void receiveMessages() {\n+        if (receiverSubscription.get() != null) {\n+            receiverSubscription.get().request(1);\n+            return;\n+        }\n+        ServiceBusReceiverAsyncClient receiverClient = asyncClient.get();\n+        receiverClient.receiveMessages()\n+            .parallel(processorOptions.getMaxConcurrentCalls())\n+            .runOn(Schedulers.boundedElastic())\n+            .subscribe(new Subscriber<ServiceBusReceivedMessageContext>() {\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    receiverSubscription.set(subscription);\n+                    receiverSubscription.get().request(1);\n+                }\n+\n+                @Override\n+                public void onNext(ServiceBusReceivedMessageContext serviceBusReceivedMessageContext) {\n+                    if (serviceBusReceivedMessageContext.hasError()) {\n+                        handleError(serviceBusReceivedMessageContext.getThrowable());\n+                    } else {\n+                        try {\n+                            ServiceBusProcessorMessageContext serviceBusProcessorMessageContext =\n+                                new ServiceBusProcessorMessageContext(receiverClient, serviceBusReceivedMessageContext);\n+                            processMessage.accept(serviceBusProcessorMessageContext);\n+                        } catch (Exception exception) {\n+                            handleError(exception);\n+                        }\n+                    }\n+                    if (isRunning.get()) {\n+                        logger.verbose(\"Requesting 1 more message from upstream\");\n+                        receiverSubscription.get().request(1);\n+                    }\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                    logger.info(\"Error receiving messages.\", throwable);\n+                    handleError(throwable);\n+                    if (isRunning.get()) {\n+                        restartMessageReceiver();\n+                    }\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                    logger.info(\"Completed receiving messages.\");\n+                    if (isRunning.get()) {\n+                        restartMessageReceiver();", "originalCommit": "e137020007e26d47d17ce9ade0b08eefa4fc75cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE4ODAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516188028", "bodyText": "I wrote a code snippet to test it. It doesn't. But It does throw stackoverflow if I comment out two lines (parallel and runOn). You're safe because you use multiple threads.\nimport reactor.core.publisher.Flux;\nimport reactor.core.scheduler.Schedulers;\nimport java.io.IOException;\n\npublic class Main {\n    public static void foo() {\n        Flux.just(1, 2)\n                .parallel(2)\n                .runOn(Schedulers.boundedElastic())\n                .subscribe(\n                        System.out::println,\n                        System.out::println,\n                        Main::foo2\n        );\n    }\n    public static void foo2() {\n        foo();\n    }\n    public static void main(String[] args) throws IOException {\n        foo();\n        System.in.read();\n    }\n}", "author": "YijunXieMS", "createdAt": "2020-11-02T18:54:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3ODczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE5ODM1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/17048#discussion_r516198352", "bodyText": "Yeah, this will run on a different thread pool and shouldn't cause stackoverflow.", "author": "srnagar", "createdAt": "2020-11-02T19:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3ODczMQ=="}], "type": "inlineReview"}, {"oid": "892d762c2bbf33e38611bcfa4abcf875551524f0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/892d762c2bbf33e38611bcfa4abcf875551524f0", "message": "Pull in BinaryData changes and address PR comments", "committedDate": "2020-11-02T19:46:04Z", "type": "commit"}, {"oid": "b91216243936153ccb845c3561c3c497c189e01c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b91216243936153ccb845c3561c3c497c189e01c", "message": "Minor refactoring", "committedDate": "2020-11-02T21:24:39Z", "type": "commit"}]}