{"pr_number": 11305, "pr_title": "Service bus track2 transaction commit and rollback ", "pr_createdAt": "2020-05-19T15:14:55Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/11305", "timeline": [{"oid": "dc1e7a796c720c7c5b99d2be2e9d917e9db3052f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc1e7a796c720c7c5b99d2be2e9d917e9db3052f", "message": "continue to fix live test", "committedDate": "2020-06-08T04:37:05Z", "type": "commit"}, {"oid": "2962fabdb5ada06fba88a10c18091f9721eeb302", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2962fabdb5ada06fba88a10c18091f9721eeb302", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java", "committedDate": "2020-06-08T04:37:42Z", "type": "commit"}, {"oid": "cea3902a5ff5d7338194877dfecb04e3580ff23c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cea3902a5ff5d7338194877dfecb04e3580ff23c", "message": "Live test using separate resources.", "committedDate": "2020-06-08T06:19:08Z", "type": "commit"}, {"oid": "54a2f511b61199fa82a879d81744f39e42c2c06b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54a2f511b61199fa82a879d81744f39e42c2c06b", "message": "Fix Live test.", "committedDate": "2020-06-08T13:58:04Z", "type": "commit"}, {"oid": "77744e79daf73cfe048da1b53fcb1c6b4310b66c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77744e79daf73cfe048da1b53fcb1c6b4310b66c", "message": "Fix Live test.", "committedDate": "2020-06-08T14:01:57Z", "type": "commit"}, {"oid": "c4daefe559e87e449dc2228789263592d48b45ba", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4daefe559e87e449dc2228789263592d48b45ba", "message": "Fix Live test.", "committedDate": "2020-06-08T15:09:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MzM3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436853371", "bodyText": "clean this up. Also, format this document, there shouldn't be two spaces after instanceof TransactionalState", "author": "conniey", "createdAt": "2020-06-08T16:55:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorReceiver.java", "diffHunk": "@@ -177,13 +152,18 @@ public void dispose() {\n         if (!pendingUpdates.isEmpty()) {\n             final List<Mono<Void>> pending = new ArrayList<>();\n             final StringJoiner builder = new StringJoiner(\", \");\n-\n             for (UpdateDispositionWorkItem workItem : pendingUpdates.values()) {\n+\n                 if (workItem.hasTimedout()) {\n                     continue;\n                 }\n \n-                pending.add(workItem.getMono());\n+                if (workItem.getDeliveryState() instanceof  TransactionalState) {\n+                    pending.add(updateDispositionInternal(workItem.getLockToken(), Released.getInstance()));\n+                    //pending.add(workItem.getMono());", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MzYyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436853627", "bodyText": "Change back to final.", "author": "conniey", "createdAt": "2020-06-08T16:55:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorReceiver.java", "diffHunk": "@@ -365,7 +374,7 @@ private void completeWorkItem(String lockToken, Delivery delivery, MonoSink<Void\n \n     private static final class UpdateDispositionWorkItem {\n         private final String lockToken;\n-        private final DeliveryState state;\n+        private DeliveryState state;", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1MzgzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436853831", "bodyText": "remove", "author": "conniey", "createdAt": "2020-06-08T16:56:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -250,32 +256,38 @@ protected ServiceBusClientBuilder getBuilder(boolean useCredentials) {\n         }\n     }\n \n+\n     protected ServiceBusSenderClientBuilder getSenderBuilder(boolean useCredentials, MessagingEntityType entityType,\n-        int entityIndex, boolean isSessionAware) {\n+        int entityIndex, boolean isSessionAware, boolean sharedConnection) {\n+\n+        //TestResourceDescription testResourceDescription = getTestResourceDescription(useCase, isSessionAware);", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NDA5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436854099", "bodyText": "nit: newline", "author": "conniey", "createdAt": "2020-06-08T16:56:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -389,10 +464,26 @@ protected void assertMessageEquals(ServiceBusReceivedMessage message, String mes\n \n         // Disabling message ID assertion. Since we do multiple operations on the same queue/topic, it's possible\n         // the queue or topic contains messages from previous test cases.\n-        assertEquals(messageId, message.getMessageId());\n+        assertNotNull(message.getMessageId());\n+        //assertEquals(messageId, message.getMessageId());\n \n         if (isSessionEnabled) {\n-            assertEquals(sessionId, message.getSessionId());\n+            assertNotNull(message.getSessionId());\n+            // Disabling session ID exact match assertion. Since we do multiple operations on the same queue/topic, it's possible\n+            // the queue or topic contains messages from previous test cases.\n+            // assertEquals(sessionId, message.getSessionId());\n+        }\n+    }\n+    private ServiceBusClientBuilder getBuilder(boolean useCredentials, boolean sharedConnection) {", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTExMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436855112", "bodyText": "The receiver in line 36 is the receiveAndDeleteReceiver.", "author": "conniey", "createdAt": "2020-06-08T16:58:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java", "diffHunk": "@@ -16,24 +16,40 @@\n import reactor.test.StepVerifier;\n \n import java.time.Duration;\n+import java.time.Instant;\n import java.util.List;\n import java.util.UUID;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n import java.util.stream.Stream;\n \n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n /**\n  * Integration tests for {@link ServiceBusSenderAsyncClient} from queues or subscriptions.\n  */\n @Tag(\"integration\")\n class ServiceBusSenderAsyncClientIntegrationTest extends IntegrationTestBase {\n     private ServiceBusSenderAsyncClient sender;\n     private ServiceBusReceiverAsyncClient receiver;\n+    /**\n+     * Receiver used to clean up resources in {@link #afterTest()}.\n+     */\n+    private ServiceBusReceiverAsyncClient receiveAndDeleteReceiver;", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1NTUzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436855530", "bodyText": "nit: clean up new lines.", "author": "conniey", "createdAt": "2020-06-08T16:59:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java", "diffHunk": "@@ -151,39 +209,77 @@ void sendWithCredentials(MessagingEntityType entityType) {\n             .verify();\n     }\n \n-    void setSenderAndReceiver(MessagingEntityType entityType, int entityIndex, boolean useCredentials) {\n-        switch (entityType) {\n-            case QUEUE:\n-                final String queueName = getQueueName(0);\n-\n-                Assertions.assertNotNull(queueName, \"'queueName' cannot be null.\");\n-\n-                sender = getBuilder(useCredentials).sender()\n-                    .queueName(queueName)\n-                    .buildAsyncClient();\n-                receiver = getBuilder(useCredentials).receiver()\n-                    .queueName(queueName)\n-                    .receiveMode(ReceiveMode.RECEIVE_AND_DELETE)\n-                    .buildAsyncClient();\n-                break;\n-            case SUBSCRIPTION:\n-                final String topicName = getTopicName();\n-                final String subscriptionName = getSubscriptionName(entityIndex);\n-\n-                Assertions.assertNotNull(topicName, \"'topicName' cannot be null.\");\n-                Assertions.assertNotNull(subscriptionName, \"'subscriptionName' cannot be null.\");\n-\n-                sender = getBuilder(useCredentials).sender()\n-                    .topicName(topicName)\n-                    .buildAsyncClient();\n-                receiver = getBuilder(useCredentials).receiver()\n-                    .topicName(topicName)\n-                    .subscriptionName(subscriptionName)\n-                    .receiveMode(ReceiveMode.RECEIVE_AND_DELETE)\n-                    .buildAsyncClient();\n-                break;\n-            default:\n-                throw logger.logExceptionAsError(new IllegalArgumentException(\"Unknown entity type: \" + entityType));\n+    /**\n+     * Verifies that we can create transaction, scheduleMessage and commit.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionScheduleAndCommitTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, 0, isSessionEnabled);\n+        final Duration scheduleDuration = Duration.ofSeconds(3);\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(5), transaction.get()))\n+            .assertNext(sequenceNumber -> {\n+                assertNotNull(sequenceNumber);\n+                assertTrue(sequenceNumber.intValue() > 0);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+        StepVerifier.create(Mono.delay(scheduleDuration).then(receiveAndDeleteReceiver.receive().next()))\n+            .assertNext(receivedMessage -> {\n+                assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+                messagesPending.decrementAndGet();\n+            })\n+            .verifyComplete();\n+    }\n+", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg1OTY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436859680", "bodyText": "I'm not sure what you are testing here. There is only one send operation in this transaction. Transactions are multiple operations.\nHow did you verify the rollback worked?", "author": "conniey", "createdAt": "2020-06-08T17:05:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientIntegrationTest.java", "diffHunk": "@@ -128,17 +143,60 @@ void nonSessionMessageBatch(MessagingEntityType entityType) {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can do following\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. Rollback/commit this transaction.\n+     */\n+    @MethodSource(\"messagingEntityProviderWithTransaction\")\n+    @ParameterizedTest\n+    void transactionMessageSendAndCompleteTransaction(MessagingEntityType entityType, boolean isCommit) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, 0, false);\n+        final boolean isSessionEnabled =  false;\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        assertNotNull(transaction.get());\n+\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message, transaction.get()))\n+            .verifyComplete();\n+        if (isCommit) {\n+            StepVerifier.create(sender.commitTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(1)))\n+                .verifyComplete();\n+            StepVerifier.create(receiveAndDeleteReceiver.receive().next())\n+                .assertNext(receivedMessage -> {\n+                    assertMessageEquals(receivedMessage, messageId, isSessionEnabled);\n+                    messagesPending.decrementAndGet();\n+                })\n+                .verifyComplete();\n+        } else {\n+            StepVerifier.create(sender.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(1)))", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MDIyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436860223", "bodyText": "there is no EC prefix.", "author": "conniey", "createdAt": "2020-06-08T17:06:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -333,6 +418,39 @@ void sendMessagesListExceedSize() {\n         verify(sendLink, never()).send(anyList());\n     }\n \n+    /**\n+     * Verifies that sending a single message will result in calling sender.send(Message, transaction).\n+     */\n+    @Test\n+    void sendSingleMessageWithTransaction() {\n+        // Arrange\n+        final ServiceBusMessage testData = new ServiceBusMessage(TEST_CONTENTS.getBytes(UTF_8));\n+\n+        // EC is the prefix they use when creating a link that sends to the service round-robin.", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MDU3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436860578", "bodyText": "you don't need to capture them. if the arguments didn't match, it would return null and fail teh tests.", "author": "conniey", "createdAt": "2020-06-08T17:07:29Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -370,17 +488,48 @@ void scheduleMessage() {\n         when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n             .thenReturn(Mono.just(sendLink));\n         when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n-        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any()))\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any(), isNull()))\n             .thenReturn(just(sequenceNumberReturned));\n \n         // Act & Assert\n         StepVerifier.create(sender.scheduleMessage(message, instant))\n             .expectNext(sequenceNumberReturned)\n             .verifyComplete();\n \n-        verify(managementNode).schedule(message, instant, MAX_MESSAGE_LENGTH_BYTES, LINK_NAME);\n+        verify(managementNode).schedule(message, instant, MAX_MESSAGE_LENGTH_BYTES, LINK_NAME, null);\n+    }\n+\n+    @Test\n+    void scheduleMessageWithTransaction() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+        Instant instant = mock(Instant.class);\n+        ArgumentCaptor<Instant> instantCapture = ArgumentCaptor.forClass(Instant.class);\n+        ArgumentCaptor<Integer> lengthCapture = ArgumentCaptor.forClass(Integer.class);\n+        ArgumentCaptor<String> linkNameCapture = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<ServiceBusTransactionContext> transactionCapture = ArgumentCaptor.forClass(ServiceBusTransactionContext.class);\n+\n+        when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n+            .thenReturn(Mono.just(sendLink));\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any(), any(ServiceBusTransactionContext.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(message, instant, transactionContext))\n+            .expectNext(sequenceNumberReturned)\n+            .verifyComplete();\n+\n+        verify(managementNode).schedule(singleSBMessageCaptor.capture(), instantCapture.capture(), lengthCapture.capture(), linkNameCapture.capture(), transactionCapture.capture());\n+\n+        Assertions.assertEquals(message, singleSBMessageCaptor.getValue());", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MDkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436860911", "bodyText": "scope this to argThat(e -> e.getTransactionId().equals(...)).", "author": "conniey", "createdAt": "2020-06-08T17:08:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -370,17 +488,48 @@ void scheduleMessage() {\n         when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n             .thenReturn(Mono.just(sendLink));\n         when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n-        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any()))\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any(), isNull()))\n             .thenReturn(just(sequenceNumberReturned));\n \n         // Act & Assert\n         StepVerifier.create(sender.scheduleMessage(message, instant))\n             .expectNext(sequenceNumberReturned)\n             .verifyComplete();\n \n-        verify(managementNode).schedule(message, instant, MAX_MESSAGE_LENGTH_BYTES, LINK_NAME);\n+        verify(managementNode).schedule(message, instant, MAX_MESSAGE_LENGTH_BYTES, LINK_NAME, null);\n+    }\n+\n+    @Test\n+    void scheduleMessageWithTransaction() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+        Instant instant = mock(Instant.class);\n+        ArgumentCaptor<Instant> instantCapture = ArgumentCaptor.forClass(Instant.class);\n+        ArgumentCaptor<Integer> lengthCapture = ArgumentCaptor.forClass(Integer.class);\n+        ArgumentCaptor<String> linkNameCapture = ArgumentCaptor.forClass(String.class);\n+        ArgumentCaptor<ServiceBusTransactionContext> transactionCapture = ArgumentCaptor.forClass(ServiceBusTransactionContext.class);\n+\n+        when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n+            .thenReturn(Mono.just(sendLink));\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class), any(), any(ServiceBusTransactionContext.class)))", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MTU4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436861584", "bodyText": "Revert: This is the key for the header.", "author": "conniey", "createdAt": "2020-06-08T17:09:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java", "diffHunk": "@@ -31,15 +32,24 @@\n import static java.nio.charset.StandardCharsets.UTF_8;\n \n public class TestUtils {\n+    private static final ClientLogger LOGGER = new ClientLogger(TestUtils.class);\n+\n     // System and application properties from the generated test message.\n     static final Instant ENQUEUED_TIME = Instant.ofEpochSecond(1561344661);\n     static final Long SEQUENCE_NUMBER = 1025L;\n     static final String OTHER_SYSTEM_PROPERTY = \"Some-other-system-property\";\n     static final Boolean OTHER_SYSTEM_PROPERTY_VALUE = Boolean.TRUE;\n     static final Map<String, Object> APPLICATION_PROPERTIES = new HashMap<>();\n+    static final int USE_CASE_DEFAULT = 0;\n+    static final int USE_CASE_RECEIVE_BY_NUMBER = 1;\n+    static final int USE_CASE_RECEIVE_BY_TIME = 2;\n+    static final int USE_CASE_RECEIVE_NO_MESSAGES = 3;\n+    static final int USE_CASE_SEND_RECEIVE_WITH_PROPERTIES = 4;\n+    static final int USE_CASE_MULTIPLE_RECEIVE_ONE_TIMEOUT = 5;\n+    static final int USE_CASE_PEEK_BATCH_MESSAGES = 6;\n \n     // An application property key to identify where in the stream this message was created.\n-    static final String MESSAGE_POSITION_ID = \"message-position\";\n+    static final String MESSAGE_POSITION_ID = \"1\";", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MjAzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436862036", "bodyText": "They are not environment variables. I have a method in TestUtils.getEntityName", "author": "conniey", "createdAt": "2020-06-08T17:10:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java", "diffHunk": "@@ -74,6 +84,52 @@ public static String getQueueBaseName() {\n         return System.getenv(\"AZURE_SERVICEBUS_QUEUE_NAME\");\n     }\n \n+    /**\n+     * The Service Bus resource name\n+     *\n+     * @return The Service Bus {@link TestResourceDescription}.\n+     */\n+    public static TestResourceDescription getTestResource(int useCase, boolean isSessionEnabled) {\n+\n+        StringBuilder queueBuilder = new StringBuilder();\n+        StringBuilder topicBuilder = new StringBuilder(\"AZURE_SERVICEBUS_TOPIC_NAME-\");\n+        StringBuilder subscriptionBuilder = new StringBuilder();\n+\n+        if (isSessionEnabled) {\n+            queueBuilder.append(\"AZURE_SERVICEBUS_SESSION_QUEUE_NAME-\");\n+            subscriptionBuilder.append(\"AZURE_SERVICEBUS_SESSION_SUBSCRIPTION_NAME-\");\n+        } else {\n+            queueBuilder.append(\"AZURE_SERVICEBUS_QUEUE_NAME-\");\n+            subscriptionBuilder.append(\"AZURE_SERVICEBUS_SUBSCRIPTION_NAME-\");\n+        }\n+\n+        TestResourceDescription testResourceDescription;\n+\n+        switch (useCase) {\n+            case USE_CASE_DEFAULT :\n+                testResourceDescription =  new TestResourceDescription(\n+                    System.getenv(queueBuilder.append(\"0\").toString()),", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MzI3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436863274", "bodyText": "Do these need to be variables here? Can they live in their respective test cases. Some of these are only used once.", "author": "conniey", "createdAt": "2020-06-08T17:11:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/TestUtils.java", "diffHunk": "@@ -31,15 +32,24 @@\n import static java.nio.charset.StandardCharsets.UTF_8;\n \n public class TestUtils {\n+    private static final ClientLogger LOGGER = new ClientLogger(TestUtils.class);\n+\n     // System and application properties from the generated test message.\n     static final Instant ENQUEUED_TIME = Instant.ofEpochSecond(1561344661);\n     static final Long SEQUENCE_NUMBER = 1025L;\n     static final String OTHER_SYSTEM_PROPERTY = \"Some-other-system-property\";\n     static final Boolean OTHER_SYSTEM_PROPERTY_VALUE = Boolean.TRUE;\n     static final Map<String, Object> APPLICATION_PROPERTIES = new HashMap<>();\n+    static final int USE_CASE_DEFAULT = 0;", "originalCommit": "c4daefe559e87e449dc2228789263592d48b45ba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg3OTU4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436879588", "bodyText": "If these numbers lie in their respective test files then another test file can use same number again without knowing it.\nPutting here, gives next developer visibility to ensure that same index number is not reused by mistake.", "author": "hemanttanwar", "createdAt": "2020-06-08T17:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjg2MzI3NA=="}], "type": "inlineReview"}, {"oid": "20521185df2dd44d8187abf78916f2b2c8063ac4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/20521185df2dd44d8187abf78916f2b2c8063ac4", "message": "review comments", "committedDate": "2020-06-08T18:06:46Z", "type": "commit"}, {"oid": "e0dee7c53dd1f8e11a16f7edf40c792d5367bdb4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e0dee7c53dd1f8e11a16f7edf40c792d5367bdb4", "message": "review comments", "committedDate": "2020-06-08T18:08:33Z", "type": "commit"}, {"oid": "447321ee99239cb547016c160cedc6d4085155a6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/447321ee99239cb547016c160cedc6d4085155a6", "message": "review comments", "committedDate": "2020-06-08T18:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwODY2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436908665", "bodyText": "format this document. there are two spaces here.", "author": "conniey", "createdAt": "2020-06-08T18:28:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -389,10 +457,27 @@ protected void assertMessageEquals(ServiceBusReceivedMessage message, String mes\n \n         // Disabling message ID assertion. Since we do multiple operations on the same queue/topic, it's possible\n         // the queue or topic contains messages from previous test cases.\n-        assertEquals(messageId, message.getMessageId());\n+        assertNotNull(message.getMessageId());\n+        //assertEquals(messageId, message.getMessageId());\n \n         if (isSessionEnabled) {\n-            assertEquals(sessionId, message.getSessionId());\n+            assertNotNull(message.getSessionId());\n+            // Disabling session ID exact match assertion. Since we do multiple operations on the same queue/topic, it's possible\n+            // the queue or topic contains messages from previous test cases.\n+            // assertEquals(sessionId, message.getSessionId());\n+        }\n+    }\n+\n+    private ServiceBusClientBuilder getBuilder(boolean useCredentials, boolean sharedConnection) {\n+        ServiceBusClientBuilder builder;\n+        if (sharedConnection && sharedBuilder ==  null) {", "originalCommit": "447321ee99239cb547016c160cedc6d4085155a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "908ea437c75e6ff6107037682a84f0c7dcf9c0a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/908ea437c75e6ff6107037682a84f0c7dcf9c0a4", "message": "review comments", "committedDate": "2020-06-08T18:38:06Z", "type": "commit"}, {"oid": "5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c3cf988ac1c65cb1c4d14e6105d1d05fcc47648", "message": "Increment package version after release of com.azure azure-messaging-servicebus", "committedDate": "2020-05-08T21:29:37Z", "type": "commit"}, {"oid": "39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39b9a1a6d1bfd9adf54c91fea1a90144cb02f288", "message": "resolve merge conflict", "committedDate": "2020-05-12T19:40:58Z", "type": "commit"}, {"oid": "f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9cc7d2d82c36e62ea253071a1ec5ae29b4f1848", "message": "Merge branch 'azure-sdk-increment-package-version-servicebus-386162'", "committedDate": "2020-05-12T19:50:47Z", "type": "commit"}, {"oid": "3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a4b16fd9cc42f7dbc5d746e81ffc8de94e55b6b", "message": "merge master", "committedDate": "2020-05-13T00:26:33Z", "type": "commit"}, {"oid": "b67ac9b65651a41709584818e2c3417b6aed44ca", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b67ac9b65651a41709584818e2c3417b6aed44ca", "message": "Merge branch 'master' of github.com:hemanttanwar/azure-sdk-for-java", "committedDate": "2020-05-13T04:02:38Z", "type": "commit"}, {"oid": "fe29a73ccc44c366f6e15e66356d62bd8ce22d48", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe29a73ccc44c366f6e15e66356d62bd8ce22d48", "message": "service-bus-track2-transaction-commit-rollback-11095", "committedDate": "2020-05-13T15:11:31Z", "type": "commit"}, {"oid": "366475534b92221cdfe1d21326bc4b80c60ad17b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/366475534b92221cdfe1d21326bc4b80c60ad17b", "message": "changing api and adding sample for API review", "committedDate": "2020-05-14T02:55:47Z", "type": "commit"}, {"oid": "7311196cd2cc5cb858990c2701c513db1178a69d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7311196cd2cc5cb858990c2701c513db1178a69d", "message": "Continue implementation", "committedDate": "2020-05-15T15:42:09Z", "type": "commit"}, {"oid": "3b8eda172e3bebb485d54eab6cea63b006573929", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3b8eda172e3bebb485d54eab6cea63b006573929", "message": "Continue  work", "committedDate": "2020-05-16T16:09:11Z", "type": "commit"}, {"oid": "df821cd02f0319007af209ae0d90c77b9fbd749a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df821cd02f0319007af209ae0d90c77b9fbd749a", "message": "Draft implementation for creating and commiting transactions", "committedDate": "2020-05-19T15:12:23Z", "type": "commit"}, {"oid": "68886cd39fe233045aa4e2a0fe05ff3b50bc40ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68886cd39fe233045aa4e2a0fe05ff3b50bc40ab", "message": "Renaming transaction type", "committedDate": "2020-05-19T15:35:56Z", "type": "commit"}, {"oid": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39802e72a07628032fe1b7cc6111c49fa0e17fa4", "message": "continue work", "committedDate": "2020-05-19T20:02:46Z", "type": "commit"}, {"oid": "510e76c7ffb58e006a09779558d7b01246f054a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/510e76c7ffb58e006a09779558d7b01246f054a9", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java", "committedDate": "2020-05-20T05:17:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNDEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428124101", "bodyText": "This is an addition to the public surface area of azure-core-amqp. Do you need to add this? It doesn't seem different from createProducer above.", "author": "conniey", "createdAt": "2020-05-20T15:54:44Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpSession.java", "diffHunk": "@@ -40,6 +40,18 @@\n      */\n     Mono<AmqpLink> createProducer(String linkName, String entityPath, Duration timeout, AmqpRetryPolicy retryPolicy);\n \n+    /**\n+     * Creates a new AMQP link that publishes events to the message broker.\n+     *\n+     * @param linkName Name of the link.\n+     * @param timeout Timeout required for creating and opening AMQP link.\n+     * @param retryPolicy The retry policy to use when sending messages.\n+     *\n+     * @return A newly created AMQP link.\n+     */\n+    Mono<AmqpLink> createTransactionProducer(String linkName, Duration timeout,", "originalCommit": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNjk2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428126967", "bodyText": "Spell out the entire word. I would expect it to be called NULL_TRANSACTION", "author": "conniey", "createdAt": "2020-05-20T15:58:45Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpConstants.java", "diffHunk": "@@ -18,4 +21,8 @@\n     public static final Symbol STRING_FILTER = Symbol.getSymbol(APACHE + \":selector-filter:string\");\n \n     static final int AMQP_BATCH_MESSAGE_FORMAT = 0x80013700; // 2147563264L;\n+\n+    // Used as null transaction\n+    public static final ByteBuffer TXN_NULL = ByteBuffer.wrap(\"NULL\".getBytes(StandardCharsets.UTF_8));", "originalCommit": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428127453", "bodyText": "Is there another way to understand if there is a transaction or not? This variable seems like an easy hack.", "author": "conniey", "createdAt": "2020-05-20T15:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNjk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQyOTI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428429293", "bodyText": "Transaction in Service bus is just binary and there is no way we can tell which binary is normally looks like this  txn:4fac2a9cd9cc4b0bb6cfcea1ddcdbac2__G57:311546_G57 . So using some reserved string or empty string is safe for validation.\nOther  option is to introduce TransactionContext  class in amqp package and null check that.", "author": "hemanttanwar", "createdAt": "2020-05-21T03:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNzY4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428127683", "bodyText": "Fix this log message.", "author": "conniey", "createdAt": "2020-05-20T15:59:45Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,6 +295,86 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n+    @Override\n+    public Mono<DeliveryState> completeTransaction(ByteBuffer transactionId, boolean isCommit) {\n+        logger.verbose(\"!!!! Will complete transaction isCommit [{}]. Transaction id [{}]\", isCommit, (new String(transactionId.array(), Charset.defaultCharset())));", "originalCommit": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyODQ3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428128470", "bodyText": "There is a lot of duplicated code here. You should be able to condense the common parts and not.", "author": "conniey", "createdAt": "2020-05-20T16:00:50Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,6 +295,86 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n+    @Override", "originalCommit": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEzMDM0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r428130349", "bodyText": "These call the same thing down in the chain, but we generally use Proton.message(). This was probably taken from track 1 SB where they use Message.Factory.create()", "author": "conniey", "createdAt": "2020-05-20T16:03:28Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,6 +295,86 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n+    @Override\n+    public Mono<DeliveryState> completeTransaction(ByteBuffer transactionId, boolean isCommit) {\n+        logger.verbose(\"!!!! Will complete transaction isCommit [{}]. Transaction id [{}]\", isCommit, (new String(transactionId.array(), Charset.defaultCharset())));\n+        if (hasConnected.get()) {\n+            return Mono.create(sink -> {\n+                Message message = Message.Factory.create();\n+                Discharge discharge = new Discharge();\n+                discharge.setFail(!isCommit);\n+                discharge.setTxnId(new Binary(transactionId.array()));\n+                message.setBody(new AmqpValue(discharge));\n+\n+                final int payloadSize = messageSerializer.getSize(message);\n+                final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+                final byte[] bytes = new byte[allocationSize];\n+\n+                int encodedSize = message.encode(bytes, 0, allocationSize);\n+                sendWithAck(new RetriableResponseWorkItem(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT,\n+                    sink, timeout));\n+            });\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(Mono.create(sink -> {\n+                    Message message = Message.Factory.create();\n+                    Discharge discharge = new Discharge();\n+                    discharge.setFail(!isCommit);\n+                    discharge.setTxnId(new Binary(transactionId.array()));\n+                    message.setBody(new AmqpValue(discharge));\n+\n+                    final int payloadSize = messageSerializer.getSize(message);\n+                    final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+                    final byte[] bytes = new byte[allocationSize];\n+\n+                    int encodedSize = message.encode(bytes, 0, allocationSize);\n+                    sendWithAck(new RetriableResponseWorkItem(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT,\n+                        sink, timeout));\n+                }));\n+        }\n+    }\n+\n+    @Override\n+    public Mono<DeliveryState> createTransaction() {\n+        logger.verbose(\"!!!! Will create new transaction \");\n+        if (hasConnected.get()) {\n+            return Mono.create(sink -> {\n+                Message message = Message.Factory.create();\n+                Declare declare = new Declare();\n+                message.setBody(new AmqpValue(declare));\n+\n+                final int payloadSize = messageSerializer.getSize(message);\n+                final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+                final byte[] bytes = new byte[allocationSize];\n+\n+                int encodedSize = message.encode(bytes, 0, allocationSize);\n+                sendWithAck(new RetriableResponseWorkItem(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT,\n+                    sink, timeout));\n+            });\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(Mono.create(sink -> {\n+                    Message message = Message.Factory.create();", "originalCommit": "39802e72a07628032fe1b7cc6111c49fa0e17fa4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7cd7aa724bf43c064ea4a8ed0c8d7f3d8dea14d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7cd7aa724bf43c064ea4a8ed0c8d7f3d8dea14d9", "message": "Cleaning up after testing", "committedDate": "2020-05-20T19:20:05Z", "type": "commit"}, {"oid": "133332cf6645b78a2620655c29e9b83524c8de5b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/133332cf6645b78a2620655c29e9b83524c8de5b", "message": "code cleanup", "committedDate": "2020-05-21T03:35:14Z", "type": "commit"}, {"oid": "3d48082032df7742f46779c16ee04a150db9ea9a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3d48082032df7742f46779c16ee04a150db9ea9a", "message": "code cleanup", "committedDate": "2020-05-21T04:02:03Z", "type": "commit"}, {"oid": "e6c30a4a70e48450c6f17f23dd9271297efcf6d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e6c30a4a70e48450c6f17f23dd9271297efcf6d9", "message": "adding test cleanup", "committedDate": "2020-05-21T04:45:59Z", "type": "commit"}, {"oid": "a98a306f4b9d46dbf597ff794ab42834450136d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a98a306f4b9d46dbf597ff794ab42834450136d9", "message": "Merge master into branch", "committedDate": "2020-05-21T04:59:15Z", "type": "commit"}, {"oid": "4a7afe6b79154e49fcc366f0da738f1fc1d79f8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4a7afe6b79154e49fcc366f0da738f1fc1d79f8c", "message": "Added test", "committedDate": "2020-05-21T06:16:35Z", "type": "commit"}, {"oid": "a3e7980a265c727e35e3de18c8c45130a5f77cea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a3e7980a265c727e35e3de18c8c45130a5f77cea", "message": "Renaming the classes for transaction manager", "committedDate": "2020-05-22T07:42:16Z", "type": "commit"}, {"oid": "89906a135dbccc82ea193320350578e8d1fa5863", "url": "https://github.com/Azure/azure-sdk-for-java/commit/89906a135dbccc82ea193320350578e8d1fa5863", "message": "Changing claases names", "committedDate": "2020-05-22T07:46:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzNDY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r429334678", "bodyText": "I'm not convinced we need this class, why not change them all to use a Mono<DeliveryState> and in the latter case, it completes with empty.", "author": "conniey", "createdAt": "2020-05-22T16:13:48Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetriableResponseWorkItem.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import reactor.core.publisher.MonoSink;\n+\n+import java.time.Duration;\n+\n+/**\n+ * Work item which returns {@link DeliveryState} to subscriber and that can be scheduled multiple times..\n+ */\n+final class RetriableResponseWorkItem extends WorkItem {", "originalCommit": "89906a135dbccc82ea193320350578e8d1fa5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDM2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r429344360", "bodyText": "Do you have a bug for this?", "author": "conniey", "createdAt": "2020-05-22T16:33:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -221,6 +224,10 @@ public String getEntityPath() {\n         return abandon(lockToken, propertiesToModify, receiverOptions.getSessionId());\n     }\n \n+    public Mono<Void> abandon(MessageLockToken lockToken, Map<String, Object> propertiesToModify, ServiceBusTransactionContext transactionContext) {\n+        throw new UnsupportedOperationException(\"Not implemented\");", "originalCommit": "89906a135dbccc82ea193320350578e8d1fa5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDQ5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r429344491", "bodyText": "Why create a variable for this?", "author": "conniey", "createdAt": "2020-05-22T16:33:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -257,10 +270,15 @@ public String getEntityPath() {\n         if (lockToken instanceof ServiceBusReceivedMessage) {\n             return complete(lockToken, ((ServiceBusReceivedMessage) lockToken).getSessionId());\n         } else {\n-            return complete(lockToken, null);\n+            String sessionId = null;", "originalCommit": "89906a135dbccc82ea193320350578e8d1fa5863", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM0ODAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433348028", "bodyText": "There are overloads for complete() which makes this call ambiguous for compiler. This this was needed, But I am replacing this with direct call to updateDisposition", "author": "hemanttanwar", "createdAt": "2020-06-01T16:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDcyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r429344727", "bodyText": "Remove log message", "author": "conniey", "createdAt": "2020-05-22T16:34:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -866,12 +918,13 @@ public void close() {\n      * @return {@code true} if the management node contains the lock token and false otherwise.\n      */\n     private boolean isManagementToken(String lockToken) {\n+        logger.verbose(\"!!!! This token is management token ? \", managementNodeLocks.contains(lockToken));", "originalCommit": "89906a135dbccc82ea193320350578e8d1fa5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NTI3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r429345273", "bodyText": "I'd spell this out.", "author": "conniey", "createdAt": "2020-05-22T16:35:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/TransactionChannelImpl.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.amqp.exception.AmqpErrorContext;\n+import com.azure.core.amqp.exception.SessionErrorContext;\n+import com.azure.core.amqp.implementation.AmqpSendLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.ServiceBusTransactionContext;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+\n+/**\n+ * Implements {@link TransactionChannel} which provide utility for transaction API.\n+ */\n+public class TransactionChannelImpl implements TransactionChannel {\n+\n+    private final Mono<AmqpSendLink> sendLink;\n+    private final String fullyQualifiedNamespace;\n+    private final String linkName;\n+    private final ClientLogger logger =  new ClientLogger(TransactionChannelImpl.class);\n+\n+    TransactionChannelImpl(Mono<AmqpSendLink> sendLink, String fullyQualifiedNamespace, String linkName) {\n+        this.sendLink = Objects.requireNonNull(sendLink, \"'sendLink' cannot be null.\");\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.linkName = Objects.requireNonNull(linkName, \"'linkName' cannot be null.\");\n+\n+    }\n+\n+    @Override\n+    public Mono<ByteBuffer> txSelect() {\n+\n+        return  sendLink.flatMap(sendLink ->\n+            sendLink.createTransaction()).map(state -> {\n+            Binary txnId = null;\n+            if (state instanceof Declared) {\n+                Declared declared = (Declared) state;\n+                txnId = declared.getTxnId();\n+                logger.verbose(\"Created new TX started: {}\", txnId);\n+            } else {\n+                logger.error(\"Error in creating transaction, Not supported response: state {}\", state);\n+            }\n+\n+            return txnId.asByteBuffer();\n+        });\n+\n+    }\n+\n+    @Override\n+    public Mono<Void> txCommit(ServiceBusTransactionContext transactionContext) {\n+        return sendLink.flatMap(sendLink ->\n+            sendLink.completeTransaction(transactionContext.getTransactionId(), true)).then();\n+    }\n+\n+    @Override\n+    public Mono<Void> txRollback(ServiceBusTransactionContext transactionContext) {", "originalCommit": "89906a135dbccc82ea193320350578e8d1fa5863", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17f3b8aeb873cdd085f8d5a7a6400beb6b62024c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17f3b8aeb873cdd085f8d5a7a6400beb6b62024c", "message": "added transaction feature in send", "committedDate": "2020-05-23T19:24:41Z", "type": "commit"}, {"oid": "b8d128de55923b2bbb2a7571c6ccce1adf370d13", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b8d128de55923b2bbb2a7571c6ccce1adf370d13", "message": "Added test for sending,receiving foir all the message settling operations", "committedDate": "2020-05-26T03:54:42Z", "type": "commit"}, {"oid": "3e0a5ea4d2a8cf1a856cdbb1d4817d97c65027dc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e0a5ea4d2a8cf1a856cdbb1d4817d97c65027dc", "message": "Added test for schedule", "committedDate": "2020-05-26T05:56:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUwOTAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r430509028", "bodyText": "Do we need this to live in implementation. Is there a way we can create \"DeliveryStates\" that aren't used by proton-j and map them internally? I'm trying to decrease the number of classes that live in implementation that we'll have to pull out later.", "author": "conniey", "createdAt": "2020-05-26T15:37:28Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpCoordinatorLink.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpLink;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This is AMQP coordinator link which allow operations related to transactions.\n+ */\n+public interface AmqpCoordinatorLink extends AmqpLink {", "originalCommit": "3e0a5ea4d2a8cf1a856cdbb1d4817d97c65027dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10e5d61a4a412663bb6081273024db2cb5204b23", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10e5d61a4a412663bb6081273024db2cb5204b23", "message": "continue work", "committedDate": "2020-05-26T15:50:16Z", "type": "commit"}, {"oid": "d4637607e2074b94b4cc07508aa30b09231ce1cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4637607e2074b94b4cc07508aa30b09231ce1cd", "message": "Adding AmqpTransaction", "committedDate": "2020-05-26T22:19:37Z", "type": "commit"}, {"oid": "d724041d6ab151140de02cda706e85bbb215c896", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d724041d6ab151140de02cda706e85bbb215c896", "message": "Adding AmqpTransaction", "committedDate": "2020-05-26T22:41:13Z", "type": "commit"}, {"oid": "89c8838bf89e272a00a44a83d891e600f5306460", "url": "https://github.com/Azure/azure-sdk-for-java/commit/89c8838bf89e272a00a44a83d891e600f5306460", "message": "Adding AmqpTransaction", "committedDate": "2020-05-26T22:44:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0ODYzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r430748631", "bodyText": "I don't think we need this because transactions are abstracted now.", "author": "conniey", "createdAt": "2020-05-26T22:47:25Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpSession.java", "diffHunk": "@@ -35,10 +35,13 @@\n      * @param entityPath The entity path this link connects to when producing events.\n      * @param timeout Timeout required for creating and opening AMQP link.\n      * @param retryPolicy The retry policy to use when sending messages.\n+     * @param authenticationRequired is authentication required.\n+     * @param isTransactionCoordinator is it transaction corrdinator.\n      *\n      * @return A newly created AMQP link.\n      */\n-    Mono<AmqpLink> createProducer(String linkName, String entityPath, Duration timeout, AmqpRetryPolicy retryPolicy);\n+    Mono<AmqpLink> createProducer(String linkName, String entityPath, Duration timeout, AmqpRetryPolicy retryPolicy,", "originalCommit": "89c8838bf89e272a00a44a83d891e600f5306460", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0OTE3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r430749171", "bodyText": "I don't think we need this at all. It's basically null.", "author": "conniey", "createdAt": "2020-05-26T22:48:58Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpConstants.java", "diffHunk": "@@ -18,4 +19,8 @@\n     public static final Symbol STRING_FILTER = Symbol.getSymbol(APACHE + \":selector-filter:string\");\n \n     static final int AMQP_BATCH_MESSAGE_FORMAT = 0x80013700; // 2147563264L;\n+\n+    // Using null transaction to match that there is no transaction.\n+    public static final AmqpTransaction NULL_TRANSACTION = null;", "originalCommit": "89c8838bf89e272a00a44a83d891e600f5306460", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0OTI2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r430749269", "bodyText": "Does it have to be a bytebuffer? In your usages of it, I see you getting byte[]", "author": "conniey", "createdAt": "2020-05-26T22:49:14Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,31 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents transaction.\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;", "originalCommit": "89c8838bf89e272a00a44a83d891e600f5306460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ5ODc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431498791", "bodyText": "We have compile time check which does not allow com.azure.core.amqp.AmqpTransaction.getTransactionId() may expose internal representation by returning AmqpTransaction.transactionId  and I do not want to copy them in constructor and in getter.", "author": "hemanttanwar", "createdAt": "2020-05-27T23:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc0OTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1MDE5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r430750194", "bodyText": "nit: messages rather than messageBatch.", "author": "conniey", "createdAt": "2020-05-26T22:51:54Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpSendLink.java", "diffHunk": "@@ -24,6 +25,27 @@\n      */\n     Mono<Void> send(Message message);\n \n+    /**\n+     * Batches the messages given into a single proton-j message that is sent down the wire.\n+     *\n+     * @param messageBatch The batch of messages to send to the service.\n+     * @param transactionId to be sent along with message.\n+     * @return A Mono that completes when all the batched messages are successfully transmitted to Event Hub.\n+     * @throws AmqpException if the serialized contents of {@code messageBatch} exceed the link's capacity for a single\n+     * message.\n+     */\n+    Mono<Void> send(List<Message> messageBatch, AmqpTransaction transactionId);", "originalCommit": "89c8838bf89e272a00a44a83d891e600f5306460", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d52a13d1122b7a2153b0f6afb8aa08384413bc38", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d52a13d1122b7a2153b0f6afb8aa08384413bc38", "message": "continue work", "committedDate": "2020-05-27T23:24:59Z", "type": "commit"}, {"oid": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9975ee1bf4f6cd2781efa514629db76b16e1f214", "message": "continue work", "committedDate": "2020-05-27T23:56:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMTM4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431511388", "bodyText": "Spell these comments out (txn). ANd missing summary at the top.", "author": "conniey", "createdAt": "2020-05-28T00:08:33Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpSession.java", "diffHunk": "@@ -68,4 +68,24 @@\n      * @return A stream of endpoint states for the AMQP session.\n      */\n     Flux<AmqpEndpointState> getEndpointStates();\n+\n+    /**\n+     *\n+     * @return A newly created AMQPTransaction.\n+     */\n+    Mono<AmqpTransaction> createTransaction();\n+\n+    /**\n+     * Commit the txn.", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNDQ3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431514470", "bodyText": "Event Hub?", "author": "conniey", "createdAt": "2020-05-28T00:19:11Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpSendLink.java", "diffHunk": "@@ -24,6 +25,27 @@\n      */\n     Mono<Void> send(Message message);\n \n+    /**\n+     * Batches the messages given into a single proton-j message that is sent down the wire.\n+     *\n+     * @param messages The list of messages to send to the service.\n+     * @param transaction to be sent along with message.\n+     * @return A Mono that completes when all the batched messages are successfully transmitted to Event Hub.", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNDc5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431514792", "bodyText": "Override?", "author": "conniey", "createdAt": "2020-05-28T00:20:25Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorCoordinator.java", "diffHunk": "@@ -0,0 +1,512 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpLink;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpErrorContext;\n+import com.azure.core.amqp.exception.AmqpException;\n+import com.azure.core.amqp.exception.OperationCancelledException;\n+import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.Delivery;\n+import org.apache.qpid.proton.engine.EndpointState;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.Locale;\n+import java.util.PriorityQueue;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+import static com.azure.core.amqp.implementation.ClientConstants.SERVER_BUSY_BASE_SLEEP_TIME_IN_SECS;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Handles messages via coordinator sender link with Serviceus.\n+ */\n+class ReactorCoordinator implements AmqpLink {\n+\n+   // private final String entityPath;\n+    private final Sender sender;\n+    private final SendLinkHandler handler;\n+    private final ReactorProvider reactorProvider;\n+    private final Disposable.Composite subscriptions;\n+    private final ClientLogger logger = new ClientLogger(ReactorCoordinator.class);\n+    private final AtomicBoolean hasConnected = new AtomicBoolean();\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicInteger retryAttempts = new AtomicInteger();\n+    private final Object pendingSendLock = new Object();\n+    private final ConcurrentHashMap<String, WorkItem> pendingSendsMap = new ConcurrentHashMap<>();\n+    private final PriorityQueue<ReactorCoordinator.WeightedDeliveryTag> pendingSendsQueue =\n+        new PriorityQueue<>(1000, new ReactorCoordinator.DeliveryTagComparator());\n+\n+    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n+        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n+    private FluxSink<AmqpEndpointState> endpointStateSink = endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryPolicy retry;\n+    private final Duration timeout;\n+    private final Timer sendTimeoutTimer = new Timer(\"SendTimeout-timer\");\n+\n+    private final Object errorConditionLock = new Object();\n+\n+    private volatile Exception lastKnownLinkError;\n+    private volatile Instant lastKnownErrorReportedAt;\n+\n+    ReactorCoordinator(Sender sender, SendLinkHandler handler, ReactorProvider reactorProvider,\n+        MessageSerializer messageSerializer, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        this.sender = sender;\n+        this.handler = handler;\n+        this.reactorProvider = reactorProvider;\n+\n+        this.messageSerializer = messageSerializer;\n+        this.retry = retry;\n+        this.timeout = timeout;\n+        this.subscriptions = Disposables.composite(\n+            this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+\n+            this.handler.getLinkCredits().subscribe(credit -> {\n+                logger.verbose(\"Credits on link: {}\", credit);\n+                this.scheduleWorkOnDispatcher();\n+            }),\n+\n+            this.handler.getEndpointStates().subscribe(\n+                state -> {\n+                    logger.verbose(\"[{}] Connection state: {}\", sender.getName(), state);\n+                    this.hasConnected.set(state == EndpointState.ACTIVE);\n+                    endpointStateSink.next(AmqpEndpointStateUtil.getConnectionState(state));\n+                }, error -> {\n+                    logger.error(\"[{}] Error occurred in coordinator endpoint handler.\", sender.getName(), error);\n+                    endpointStateSink.error(error);\n+                }, () -> {\n+                    endpointStateSink.next(AmqpEndpointState.CLOSED);\n+                    endpointStateSink.complete();\n+                    hasConnected.set(false);\n+                }),\n+\n+            this.handler.getErrors().subscribe(error -> {\n+                logger.error(\"[{}] Error occurred in coordinator error handler.\", getLinkName(), error);\n+                endpointStateSink.error(error);\n+            }),\n+            () -> { }\n+        );\n+    }\n+\n+\n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    //@Override", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNTAwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431515005", "bodyText": "Why isCommit? I would expect completing the transaction to be commiting a transaction.", "author": "conniey", "createdAt": "2020-05-28T00:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNDc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk4NzM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431987344", "bodyText": "A transaction needs to be completed with either commit or rollback. SB uses this flag to wither commit or rollback this transaction.", "author": "hemanttanwar", "createdAt": "2020-05-28T17:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNDc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNjMyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431516329", "bodyText": "empty subscriber?", "author": "conniey", "createdAt": "2020-05-28T00:26:00Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorCoordinator.java", "diffHunk": "@@ -0,0 +1,512 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpLink;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpErrorContext;\n+import com.azure.core.amqp.exception.AmqpException;\n+import com.azure.core.amqp.exception.OperationCancelledException;\n+import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.Delivery;\n+import org.apache.qpid.proton.engine.EndpointState;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.Locale;\n+import java.util.PriorityQueue;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+import static com.azure.core.amqp.implementation.ClientConstants.SERVER_BUSY_BASE_SLEEP_TIME_IN_SECS;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Handles messages via coordinator sender link with Serviceus.\n+ */\n+class ReactorCoordinator implements AmqpLink {\n+\n+   // private final String entityPath;\n+    private final Sender sender;\n+    private final SendLinkHandler handler;\n+    private final ReactorProvider reactorProvider;\n+    private final Disposable.Composite subscriptions;\n+    private final ClientLogger logger = new ClientLogger(ReactorCoordinator.class);\n+    private final AtomicBoolean hasConnected = new AtomicBoolean();\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicInteger retryAttempts = new AtomicInteger();\n+    private final Object pendingSendLock = new Object();\n+    private final ConcurrentHashMap<String, WorkItem> pendingSendsMap = new ConcurrentHashMap<>();\n+    private final PriorityQueue<ReactorCoordinator.WeightedDeliveryTag> pendingSendsQueue =\n+        new PriorityQueue<>(1000, new ReactorCoordinator.DeliveryTagComparator());\n+\n+    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n+        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n+    private FluxSink<AmqpEndpointState> endpointStateSink = endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryPolicy retry;\n+    private final Duration timeout;\n+    private final Timer sendTimeoutTimer = new Timer(\"SendTimeout-timer\");\n+\n+    private final Object errorConditionLock = new Object();\n+\n+    private volatile Exception lastKnownLinkError;\n+    private volatile Instant lastKnownErrorReportedAt;\n+\n+    ReactorCoordinator(Sender sender, SendLinkHandler handler, ReactorProvider reactorProvider,\n+        MessageSerializer messageSerializer, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        this.sender = sender;\n+        this.handler = handler;\n+        this.reactorProvider = reactorProvider;\n+\n+        this.messageSerializer = messageSerializer;\n+        this.retry = retry;\n+        this.timeout = timeout;\n+        this.subscriptions = Disposables.composite(\n+            this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+\n+            this.handler.getLinkCredits().subscribe(credit -> {\n+                logger.verbose(\"Credits on link: {}\", credit);\n+                this.scheduleWorkOnDispatcher();\n+            }),\n+\n+            this.handler.getEndpointStates().subscribe(\n+                state -> {\n+                    logger.verbose(\"[{}] Connection state: {}\", sender.getName(), state);\n+                    this.hasConnected.set(state == EndpointState.ACTIVE);\n+                    endpointStateSink.next(AmqpEndpointStateUtil.getConnectionState(state));\n+                }, error -> {\n+                    logger.error(\"[{}] Error occurred in coordinator endpoint handler.\", sender.getName(), error);\n+                    endpointStateSink.error(error);\n+                }, () -> {", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNjQ0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431516449", "bodyText": "empty subscriber?", "author": "conniey", "createdAt": "2020-05-28T00:26:30Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorCoordinator.java", "diffHunk": "@@ -0,0 +1,512 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpLink;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpErrorContext;\n+import com.azure.core.amqp.exception.AmqpException;\n+import com.azure.core.amqp.exception.OperationCancelledException;\n+import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.Delivery;\n+import org.apache.qpid.proton.engine.EndpointState;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.Locale;\n+import java.util.PriorityQueue;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+import static com.azure.core.amqp.implementation.ClientConstants.SERVER_BUSY_BASE_SLEEP_TIME_IN_SECS;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Handles messages via coordinator sender link with Serviceus.\n+ */\n+class ReactorCoordinator implements AmqpLink {\n+\n+   // private final String entityPath;\n+    private final Sender sender;\n+    private final SendLinkHandler handler;\n+    private final ReactorProvider reactorProvider;\n+    private final Disposable.Composite subscriptions;\n+    private final ClientLogger logger = new ClientLogger(ReactorCoordinator.class);\n+    private final AtomicBoolean hasConnected = new AtomicBoolean();\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicInteger retryAttempts = new AtomicInteger();\n+    private final Object pendingSendLock = new Object();\n+    private final ConcurrentHashMap<String, WorkItem> pendingSendsMap = new ConcurrentHashMap<>();\n+    private final PriorityQueue<ReactorCoordinator.WeightedDeliveryTag> pendingSendsQueue =\n+        new PriorityQueue<>(1000, new ReactorCoordinator.DeliveryTagComparator());\n+\n+    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n+        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n+    private FluxSink<AmqpEndpointState> endpointStateSink = endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryPolicy retry;\n+    private final Duration timeout;\n+    private final Timer sendTimeoutTimer = new Timer(\"SendTimeout-timer\");\n+\n+    private final Object errorConditionLock = new Object();\n+\n+    private volatile Exception lastKnownLinkError;\n+    private volatile Instant lastKnownErrorReportedAt;\n+\n+    ReactorCoordinator(Sender sender, SendLinkHandler handler, ReactorProvider reactorProvider,\n+        MessageSerializer messageSerializer, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        this.sender = sender;\n+        this.handler = handler;\n+        this.reactorProvider = reactorProvider;\n+\n+        this.messageSerializer = messageSerializer;\n+        this.retry = retry;\n+        this.timeout = timeout;\n+        this.subscriptions = Disposables.composite(\n+            this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+\n+            this.handler.getLinkCredits().subscribe(credit -> {\n+                logger.verbose(\"Credits on link: {}\", credit);\n+                this.scheduleWorkOnDispatcher();\n+            }),\n+\n+            this.handler.getEndpointStates().subscribe(\n+                state -> {\n+                    logger.verbose(\"[{}] Connection state: {}\", sender.getName(), state);\n+                    this.hasConnected.set(state == EndpointState.ACTIVE);\n+                    endpointStateSink.next(AmqpEndpointStateUtil.getConnectionState(state));\n+                }, error -> {\n+                    logger.error(\"[{}] Error occurred in coordinator endpoint handler.\", sender.getName(), error);\n+                    endpointStateSink.error(error);\n+                }, () -> {\n+                    endpointStateSink.next(AmqpEndpointState.CLOSED);\n+                    endpointStateSink.complete();\n+                    hasConnected.set(false);\n+                }),\n+\n+            this.handler.getErrors().subscribe(error -> {\n+                logger.error(\"[{}] Error occurred in coordinator error handler.\", getLinkName(), error);\n+                endpointStateSink.error(error);\n+            }),\n+            () -> { }", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNzE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431517190", "bodyText": "This looks like a carbon copy of reactor sender with some modifications. Is there any way to consolidate code?\nAt its heart, this is basically the reactor sender, that listens to delivered messages.", "author": "conniey", "createdAt": "2020-05-28T00:29:20Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorCoordinator.java", "diffHunk": "@@ -0,0 +1,512 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpLink;\n+import com.azure.core.amqp.AmqpRetryPolicy;\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.amqp.exception.AmqpErrorCondition;\n+import com.azure.core.amqp.exception.AmqpErrorContext;\n+import com.azure.core.amqp.exception.AmqpException;\n+import com.azure.core.amqp.exception.OperationCancelledException;\n+import com.azure.core.amqp.implementation.handler.SendLinkHandler;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.Delivery;\n+import org.apache.qpid.proton.engine.EndpointState;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.Disposable;\n+import reactor.core.Disposables;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.FluxSink;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.MonoSink;\n+import reactor.core.publisher.ReplayProcessor;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.Locale;\n+import java.util.PriorityQueue;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+import static com.azure.core.amqp.implementation.ClientConstants.SERVER_BUSY_BASE_SLEEP_TIME_IN_SECS;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Handles messages via coordinator sender link with Serviceus.\n+ */\n+class ReactorCoordinator implements AmqpLink {\n+\n+   // private final String entityPath;\n+    private final Sender sender;\n+    private final SendLinkHandler handler;\n+    private final ReactorProvider reactorProvider;\n+    private final Disposable.Composite subscriptions;\n+    private final ClientLogger logger = new ClientLogger(ReactorCoordinator.class);\n+    private final AtomicBoolean hasConnected = new AtomicBoolean();\n+    private final AtomicBoolean isDisposed = new AtomicBoolean();\n+    private final AtomicInteger retryAttempts = new AtomicInteger();\n+    private final Object pendingSendLock = new Object();\n+    private final ConcurrentHashMap<String, WorkItem> pendingSendsMap = new ConcurrentHashMap<>();\n+    private final PriorityQueue<ReactorCoordinator.WeightedDeliveryTag> pendingSendsQueue =\n+        new PriorityQueue<>(1000, new ReactorCoordinator.DeliveryTagComparator());\n+\n+    private final ReplayProcessor<AmqpEndpointState> endpointStates =\n+        ReplayProcessor.cacheLastOrDefault(AmqpEndpointState.UNINITIALIZED);\n+    private FluxSink<AmqpEndpointState> endpointStateSink = endpointStates.sink(FluxSink.OverflowStrategy.BUFFER);\n+\n+    private final MessageSerializer messageSerializer;\n+    private final AmqpRetryPolicy retry;\n+    private final Duration timeout;\n+    private final Timer sendTimeoutTimer = new Timer(\"SendTimeout-timer\");\n+\n+    private final Object errorConditionLock = new Object();\n+\n+    private volatile Exception lastKnownLinkError;\n+    private volatile Instant lastKnownErrorReportedAt;\n+\n+    ReactorCoordinator(Sender sender, SendLinkHandler handler, ReactorProvider reactorProvider,\n+        MessageSerializer messageSerializer, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        this.sender = sender;\n+        this.handler = handler;\n+        this.reactorProvider = reactorProvider;\n+\n+        this.messageSerializer = messageSerializer;\n+        this.retry = retry;\n+        this.timeout = timeout;\n+        this.subscriptions = Disposables.composite(\n+            this.handler.getDeliveredMessages().subscribe(this::processDeliveredMessage),\n+\n+            this.handler.getLinkCredits().subscribe(credit -> {\n+                logger.verbose(\"Credits on link: {}\", credit);\n+                this.scheduleWorkOnDispatcher();\n+            }),\n+\n+            this.handler.getEndpointStates().subscribe(\n+                state -> {\n+                    logger.verbose(\"[{}] Connection state: {}\", sender.getName(), state);\n+                    this.hasConnected.set(state == EndpointState.ACTIVE);\n+                    endpointStateSink.next(AmqpEndpointStateUtil.getConnectionState(state));\n+                }, error -> {\n+                    logger.error(\"[{}] Error occurred in coordinator endpoint handler.\", sender.getName(), error);\n+                    endpointStateSink.error(error);\n+                }, () -> {\n+                    endpointStateSink.next(AmqpEndpointState.CLOSED);\n+                    endpointStateSink.complete();\n+                    hasConnected.set(false);\n+                }),\n+\n+            this.handler.getErrors().subscribe(error -> {\n+                logger.error(\"[{}] Error occurred in coordinator error handler.\", getLinkName(), error);\n+                endpointStateSink.error(error);\n+            }),\n+            () -> { }\n+        );\n+    }\n+\n+\n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    //@Override\n+    public Mono<DeliveryState> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        if (hasConnected.get()) {\n+            return Mono.create(sink -> send(getCompleteTransactionMessage(transaction,\n+                isCommit), sink));\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(Mono.create(sink -> send(getCompleteTransactionMessage(transaction,\n+                    isCommit), sink)));\n+        }\n+    }\n+\n+    //@Override\n+    public Mono<DeliveryState> createTransaction() {\n+        if (hasConnected.get()) {\n+            return Mono.create(sink -> send(getCreateTransactionMessage(), sink));\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(Mono.create(sink -> send(getCreateTransactionMessage(), sink)));\n+        }\n+    }\n+\n+    /**\n+     * Send the AMQP {@link Message}.\n+     *\n+     * @param message AMQP {@link Message}\n+     * @param sink to send back {@link DeliveryState}.\n+     */\n+    private void send(Message message, MonoSink<DeliveryState> sink) {\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize = message.encode(bytes, 0, allocationSize);\n+        send(new RetriableResponseWorkItem(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT,\n+            sink, timeout));\n+    }\n+\n+    /**\n+     * Add the work item in pending send to be processed on {@link ReactorDispatcher} thread.\n+     *\n+     * @param workItem to be processed.\n+     */\n+    private void send(WorkItem workItem) {\n+        final String deliveryTag = UUID.randomUUID().toString().replace(\"-\", \"\");\n+\n+        synchronized (pendingSendLock) {\n+            this.pendingSendsMap.put(deliveryTag, workItem);\n+            this.pendingSendsQueue.offer(new ReactorCoordinator.WeightedDeliveryTag(deliveryTag,\n+                workItem.hasBeenRetried() ? 1 : 0));\n+        }\n+\n+        this.scheduleWorkOnDispatcher();\n+    }\n+\n+    /**\n+     * Invokes work on the Reactor. Should only be called from ReactorDispatcher.invoke()\n+     */\n+    private void processSendWork() {\n+        if (!hasConnected.get()) {\n+            logger.warning(\"Not connected. Not processing send work.\");\n+            return;\n+        }\n+        while (hasConnected.get() && sender.getCredit() > 0) {\n+            final ReactorCoordinator.WeightedDeliveryTag weightedDelivery;\n+            final WorkItem workItem;\n+            final String deliveryTag;\n+            synchronized (pendingSendLock) {", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNDkzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432614938", "bodyText": "I am merging the logic and removing ReactorCoordinator.", "author": "hemanttanwar", "createdAt": "2020-05-29T16:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMDM5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r431520394", "bodyText": "We don't have a concept of a channel in Service Bus... why would we need transaction channel?", "author": "conniey", "createdAt": "2020-05-28T00:41:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusAmqpConnection.java", "diffHunk": "@@ -63,4 +74,11 @@\n      */\n     Mono<ServiceBusReceiveLink> createReceiveLink(String linkName, String entityPath, ReceiveMode receiveMode,\n         String transferEntityPath, MessagingEntityType entityType, String sessionId);\n+\n+    /**\n+     * Gets the transaction manager for a Service Bus resource and performs transaction related operations using it.\n+     *\n+     * @return A Mono that completes with that resources's management node.\n+     */\n+    Mono<TransactionChannel> createChannel();", "originalCommit": "9975ee1bf4f6cd2781efa514629db76b16e1f214", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNDMxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432614316", "bodyText": "This was taken from RabbitMQ , but I removed it now and using TransactionManager.", "author": "hemanttanwar", "createdAt": "2020-05-29T16:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMDM5NA=="}], "type": "inlineReview"}, {"oid": "90126e34fb7f88d51bb31e739ff38fad903fc7af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/90126e34fb7f88d51bb31e739ff38fad903fc7af", "message": "Fixed management client transactions and added sync receiver client implementation", "committedDate": "2020-05-28T06:42:17Z", "type": "commit"}, {"oid": "d4835989ee89b1bbc339be3c340c04dd564c6122", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4835989ee89b1bbc339be3c340c04dd564c6122", "message": "Refactoring classes and documentation", "committedDate": "2020-05-28T18:22:21Z", "type": "commit"}, {"oid": "fed6811c493bb058afbee594348653132b77dd39", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fed6811c493bb058afbee594348653132b77dd39", "message": "refactoring", "committedDate": "2020-05-28T23:30:33Z", "type": "commit"}, {"oid": "69fdb42eb8207bbae9b1039f9522cba83243098a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/69fdb42eb8207bbae9b1039f9522cba83243098a", "message": "Added unit test in core amqp", "committedDate": "2020-05-29T16:48:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNTM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432615361", "bodyText": "Why is this inside a runnable?", "author": "conniey", "createdAt": "2020-05-29T16:57:33Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNTg0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432615844", "bodyText": "This method is only used once, Does it need to be a method?", "author": "conniey", "createdAt": "2020-05-29T16:57:59Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432616200", "bodyText": "Same with this method.", "author": "conniey", "createdAt": "2020-05-29T16:58:18Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNjUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432616521", "bodyText": "Group the visibility of your methods together", "author": "conniey", "createdAt": "2020-05-29T16:58:35Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzA3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432617072", "bodyText": "Is there a reason this needs to be locally declared?", "author": "conniey", "createdAt": "2020-05-29T16:59:13Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        Mono<DeliveryState> completeTransaction = Mono.create(sink -> sendTransaction(\n+            getCompleteTransactionMessage(transaction, isCommit), sink));\n+        if (hasConnected.get()) {\n+            return completeTransaction.then();\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(completeTransaction)\n+                .then();\n+        }\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<AmqpTransaction> createTransaction() {\n+        Mono<DeliveryState> createTransaction = Mono.create(sink -> sendTransaction(", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxNzY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432617672", "bodyText": "Instead of chaining .then() to both usages, why not make completeTransaction be a Mono<Void>", "author": "conniey", "createdAt": "2020-05-29T17:00:17Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        Mono<DeliveryState> completeTransaction = Mono.create(sink -> sendTransaction(\n+            getCompleteTransactionMessage(transaction, isCommit), sink));\n+        if (hasConnected.get()) {\n+            return completeTransaction.then();", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxODI3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432618275", "bodyText": "I'm not a fan of abbreviating variables when they don't need to be.\ntxnId -> transactionId", "author": "conniey", "createdAt": "2020-05-29T17:01:24Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        Mono<DeliveryState> completeTransaction = Mono.create(sink -> sendTransaction(\n+            getCompleteTransactionMessage(transaction, isCommit), sink));\n+        if (hasConnected.get()) {\n+            return completeTransaction.then();\n+        } else {\n+            return RetryUtil.withRetry(\n+                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE), timeout, retry)\n+                .then(completeTransaction)\n+                .then();\n+        }\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<AmqpTransaction> createTransaction() {\n+        Mono<DeliveryState> createTransaction = Mono.create(sink -> sendTransaction(\n+            getCreateTransactionMessage(), sink));\n+\n+        Mono<AmqpTransaction> amqpTransactionMono = createTransaction.map(state -> {\n+            Binary txnId = null;", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYxODc1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432618758", "bodyText": "This hasConnected.get() or retryUtil occurs a lot. We make this into a private method that invokes some Publisher.", "author": "conniey", "createdAt": "2020-05-29T17:02:25Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -126,27 +133,134 @@\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n             }),\n-\n-            this.tokenManager.getAuthorizationResults().subscribe(\n-                response -> {\n-                    logger.verbose(\"Token refreshed: {}\", response);\n-                    hasAuthorized.set(true);\n-                },\n-                error -> {\n-                    logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n-                        handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n-                    hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n+            () -> {\n+                if (tokenManager != null) {\n+                    this.tokenManager.getAuthorizationResults().subscribe(\n+                        response -> {\n+                            logger.verbose(\"Token refreshed: {}\", response);\n+                            hasAuthorized.set(true);\n+                        },\n+                        error -> {\n+                            logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n+                                handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n+                            hasAuthorized.set(false);\n+                        }, () -> hasAuthorized.set(false));\n+                }\n+            }\n         );\n     }\n \n+    /**\n+     * Create AMQP {@link Message} for completing the transaction.\n+     *\n+     * @param transaction to be used for completing the transaction.\n+     * @param isCommit for commiting or rollback\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCompleteTransactionMessage(AmqpTransaction transaction, boolean isCommit) {\n+        Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+        return message;\n+    }\n+\n+    /**\n+     * Create AMQP {@link Message} for creating the transaction.\n+     *\n+     * @return created AMQP {@link Message}.\n+     */\n+    private Message getCreateTransactionMessage() {\n+        Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+        return message;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        Mono<DeliveryState> completeTransaction = Mono.create(sink -> sendTransaction(\n+            getCompleteTransactionMessage(transaction, isCommit), sink));\n+        if (hasConnected.get()) {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MDUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432640506", "bodyText": "There are multiple overloads of sendTransaction. Can you group these methods together. Also, why is one private and the other ones package-private?", "author": "conniey", "createdAt": "2020-05-29T17:42:49Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +408,29 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n+    Mono<Void> sendTransaction(byte[] bytes, int arrayOffset, int messageFormat, AmqpTransaction transactionId) {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MDcxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432640712", "bodyText": "This parameter is also \"transaction\" rather than transactionId", "author": "conniey", "createdAt": "2020-05-29T17:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MDUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MTc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432641742", "bodyText": "In many instances, you are creating a MonoSink. Can all these instances be abstracted? Also, it seems many instances, you follow the Mono<DeliveryState> call, with \"then\". It appears to defeat the purpose of returning a value at all. I'd suggest moving this to Mono<Void>.", "author": "conniey", "createdAt": "2020-05-29T17:45:09Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +408,29 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n+    Mono<Void> sendTransaction(byte[] bytes, int arrayOffset, int messageFormat, AmqpTransaction transactionId) {\n+\n+        Mono<DeliveryState> workToSend = Mono.create(sink -> sendTransaction(new RetriableWorkItem(bytes,", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432642123", "bodyText": "Remove println.", "author": "conniey", "createdAt": "2020-05-29T17:45:49Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +408,29 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n+    Mono<Void> sendTransaction(byte[] bytes, int arrayOffset, int messageFormat, AmqpTransaction transactionId) {\n+\n+        Mono<DeliveryState> workToSend = Mono.create(sink -> sendTransaction(new RetriableWorkItem(bytes,\n+            arrayOffset, messageFormat, sink, timeout, transactionId)));\n+\n         if (hasConnected.get()) {\n-            return Mono.create(sink -> send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout)));\n+            return workToSend.then();\n         } else {\n             return RetryUtil.withRetry(\n                 handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE),\n                 timeout, retry)\n-                .then(Mono.create(sink ->\n-                    send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout))));\n+                .then(workToSend)\n+                .then();\n         }\n     }\n \n-    private void send(RetriableWorkItem workItem) {\n+    /**\n+     * Add the work item in pending send to be processed on {@link ReactorDispatcher} thread.\n+     *\n+     * @param workItem to be processed.\n+     */\n+    void sendTransaction(RetriableWorkItem workItem) {\n+        System.out.println(\"!!!! in sendTransaction with RetriableWorkItem\");", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r432642531", "bodyText": "This isn't always the case that there is a transaction with the send. Method name should remain as send.\nAlso, why is it package-private?", "author": "conniey", "createdAt": "2020-05-29T17:46:41Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +408,29 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n+    Mono<Void> sendTransaction(byte[] bytes, int arrayOffset, int messageFormat, AmqpTransaction transactionId) {\n+\n+        Mono<DeliveryState> workToSend = Mono.create(sink -> sendTransaction(new RetriableWorkItem(bytes,\n+            arrayOffset, messageFormat, sink, timeout, transactionId)));\n+\n         if (hasConnected.get()) {\n-            return Mono.create(sink -> send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout)));\n+            return workToSend.then();\n         } else {\n             return RetryUtil.withRetry(\n                 handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE),\n                 timeout, retry)\n-                .then(Mono.create(sink ->\n-                    send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout))));\n+                .then(workToSend)\n+                .then();\n         }\n     }\n \n-    private void send(RetriableWorkItem workItem) {\n+    /**\n+     * Add the work item in pending send to be processed on {@link ReactorDispatcher} thread.\n+     *\n+     * @param workItem to be processed.\n+     */\n+    void sendTransaction(RetriableWorkItem workItem) {", "originalCommit": "69fdb42eb8207bbae9b1039f9522cba83243098a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dedfaa0a0b037b890429431e32abf267a3d7ff87", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dedfaa0a0b037b890429431e32abf267a3d7ff87", "message": "refactoring amqp ReactorSender", "committedDate": "2020-05-30T23:41:29Z", "type": "commit"}, {"oid": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f12743f20689f92f7234fcdb78985a2cda3c3e1d", "message": "fixing test, unit test and delay in settlement", "committedDate": "2020-06-01T20:53:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMDA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433510041", "bodyText": "Why Mono.defer rather than Mono.fromRunnable", "author": "conniey", "createdAt": "2020-06-01T21:51:46Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -136,8 +146,72 @@\n                     logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n                         handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n                     hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n-        );\n+                }, () -> hasAuthorized.set(false)));\n+        }\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.defer(() -> {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMDE0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433510148", "bodyText": "Consistent use of final", "author": "conniey", "createdAt": "2020-06-01T21:52:03Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -136,8 +146,72 @@\n                     logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n                         handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n                     hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n-        );\n+                }, () -> hasAuthorized.set(false)));\n+        }\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.defer(() -> {\n+            Message message = Proton.message();", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMDUzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433510534", "bodyText": ".handle rather than .map seems like the proper operator here", "author": "conniey", "createdAt": "2020-06-01T21:53:00Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -136,8 +146,72 @@\n                     logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n                         handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n                     hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n-        );\n+                }, () -> hasAuthorized.set(false)));\n+        }\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.defer(() -> {\n+            Message message = Proton.message();\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(!isCommit);\n+            discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+            message.setBody(new AmqpValue(discharge));\n+\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize = message.encode(bytes, 0, allocationSize);\n+            return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null);\n+        }).map(state -> {\n+            if (!(state instanceof Accepted)) {\n+                AmqpException error = new AmqpException(false, state.toString(), getErrorContext());\n+                throw logger.logExceptionAsError(Exceptions.propagate(error));\n+            }\n+            return state;\n+        }).then();\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<AmqpTransaction> createTransaction() {\n+        return Mono.defer(() -> {\n+            Message message = Proton.message();\n+            Declare declare = new Declare();\n+            message.setBody(new AmqpValue(declare));\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize = message.encode(bytes, 0, allocationSize);\n+            return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null);\n+        }).map(state -> {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMTIzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433511237", "bodyText": "in general you shouldn't throw exceptions from a downstream subscriber. It should return normally. This is another reason to use handle.\nhttps://github.com/reactive-streams/reactive-streams-jvm#2.13", "author": "conniey", "createdAt": "2020-06-01T21:54:46Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -136,8 +146,72 @@\n                     logger.info(\"clientId[{}], path[{}], linkName[{}] - tokenRenewalFailure[{}]\",\n                         handler.getConnectionId(), this.entityPath, getLinkName(), error.getMessage());\n                     hasAuthorized.set(false);\n-                }, () -> hasAuthorized.set(false))\n-        );\n+                }, () -> hasAuthorized.set(false)));\n+        }\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.defer(() -> {\n+            Message message = Proton.message();\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(!isCommit);\n+            discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+            message.setBody(new AmqpValue(discharge));\n+\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize = message.encode(bytes, 0, allocationSize);\n+            return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null);\n+        }).map(state -> {\n+            if (!(state instanceof Accepted)) {\n+                AmqpException error = new AmqpException(false, state.toString(), getErrorContext());\n+                throw logger.logExceptionAsError(Exceptions.propagate(error));\n+            }\n+            return state;\n+        }).then();\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    public Mono<AmqpTransaction> createTransaction() {\n+        return Mono.defer(() -> {\n+            Message message = Proton.message();\n+            Declare declare = new Declare();\n+            message.setBody(new AmqpValue(declare));\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize = message.encode(bytes, 0, allocationSize);\n+            return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null);\n+        }).map(state -> {\n+            if (state instanceof Declared) {\n+                Binary txnId;\n+                Declared declared = (Declared) state;\n+                txnId = declared.getTxnId();\n+                logger.verbose(\"Created new TX started: {}\", txnId);\n+                return new AmqpTransaction(txnId.asByteBuffer());\n+            } else {\n+                AmqpException error = new AmqpException(false, state.toString(), getErrorContext());\n+                throw logger.logExceptionAsError(Exceptions.propagate(error));", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzY3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433513676", "bodyText": "Is there any reason to use Mono<DeliveryState> send(..) when all usages are .then()", "author": "conniey", "createdAt": "2020-06-01T22:00:57Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -166,14 +245,19 @@\n                         errorMessage, exception, handler.getErrorContext(sender));\n                     return Mono.error(error);\n                 }\n-                return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT);\n-            });\n+                return send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, transaction);", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NTc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433545756", "bodyText": "We need DeliveryState because in some cases, we need to read the values from it and return to user.", "author": "hemanttanwar", "createdAt": "2020-06-01T23:45:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzY3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxMzk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433513975", "bodyText": "You can use Mono.fromRunnable", "author": "conniey", "createdAt": "2020-06-01T22:01:42Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +373,31 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n-        if (hasConnected.get()) {\n-            return Mono.create(sink -> send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout)));\n-        } else {\n-            return RetryUtil.withRetry(\n-                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE),\n-                timeout, retry)\n-                .then(Mono.create(sink ->\n-                    send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout))));\n-        }\n+    Mono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, AmqpTransaction transactionId) {\n+        return validateEndpoint()\n+            .then(Mono.create(sink -> sendWork(new RetriableWorkItem(bytes,\n+                arrayOffset, messageFormat, sink, timeout, transactionId)))\n+            );\n     }\n \n-    private void send(RetriableWorkItem workItem) {\n+    private Mono<Void> validateEndpoint() {\n+        return Mono.defer(() -> {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDIyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433514227", "bodyText": "You need to reformat this document, there are two spaces after instanceof", "author": "conniey", "createdAt": "2020-06-01T22:02:28Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -411,15 +513,20 @@ private void processDeliveredMessage(Delivery delivery) {\n             return;\n         }\n \n-        if (outcome instanceof Accepted) {\n+        if (outcome instanceof Accepted\n+            || (outcome instanceof TransactionalState && ((TransactionalState) outcome)\n+            .getOutcome() instanceof  Accepted)) {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDMwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433514301", "bodyText": "nit: new line", "author": "conniey", "createdAt": "2020-06-01T22:02:41Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -411,15 +513,20 @@ private void processDeliveredMessage(Delivery delivery) {\n             return;\n         }\n \n-        if (outcome instanceof Accepted) {\n+        if (outcome instanceof Accepted\n+            || (outcome instanceof TransactionalState && ((TransactionalState) outcome)\n+            .getOutcome() instanceof  Accepted)) {\n             synchronized (errorConditionLock) {\n                 lastKnownLinkError = null;\n                 lastKnownErrorReportedAt = null;\n                 retryAttempts.set(0);\n             }\n \n-            workItem.getSink().success();\n-        } else if (outcome instanceof Rejected) {\n+            workItem.success(outcome);\n+", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433514451", "bodyText": "same with spaces.", "author": "conniey", "createdAt": "2020-06-01T22:03:04Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -411,15 +513,20 @@ private void processDeliveredMessage(Delivery delivery) {\n             return;\n         }\n \n-        if (outcome instanceof Accepted) {\n+        if (outcome instanceof Accepted\n+            || (outcome instanceof TransactionalState && ((TransactionalState) outcome)\n+            .getOutcome() instanceof  Accepted)) {\n             synchronized (errorConditionLock) {\n                 lastKnownLinkError = null;\n                 lastKnownErrorReportedAt = null;\n                 retryAttempts.set(0);\n             }\n \n-            workItem.getSink().success();\n-        } else if (outcome instanceof Rejected) {\n+            workItem.success(outcome);\n+\n+        } else if (outcome instanceof Rejected\n+            || (outcome instanceof TransactionalState && ((TransactionalState) outcome)\n+            .getOutcome() instanceof  Rejected)) {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzOTMyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434039328", "bodyText": "Still unresolved.", "author": "conniey", "createdAt": "2020-06-02T17:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433514911", "bodyText": "Are you only allowed one transaction per session? It seems like a limitation.", "author": "conniey", "createdAt": "2020-06-01T22:04:19Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -34,11 +36,15 @@\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentMap;\n import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n \n /**\n  * Represents an AMQP session using proton-j reactor.\n  */\n public class ReactorSession implements AmqpSession {\n+\n+    private static final String TRANSACTION_LINK_NAME = \"coordinator\";", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0NjEzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433546136", "bodyText": "These is only one sender link with this name per session. Thats how it is implemented in track1 and in other languages also.", "author": "hemanttanwar", "createdAt": "2020-06-01T23:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzODM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434038357", "bodyText": "Why is this controlled by a map then (line 50)? There can only be one.", "author": "conniey", "createdAt": "2020-06-02T17:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNTM1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433515352", "bodyText": "Why do we need this constructor overload if we can just add a retry to the existing ctor.", "author": "conniey", "createdAt": "2020-06-01T22:05:35Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -60,6 +66,35 @@\n     private final ReactorHandlerProvider handlerProvider;\n     private final Mono<ClaimsBasedSecurityNode> cbsNodeSupplier;\n \n+    private final AtomicReference<LinkSubscription<AmqpLink>> coordinator = new AtomicReference<>();\n+\n+    private AmqpRetryPolicy retryPolicy;\n+\n+    /**\n+     *\n+     * Creates a new AMQP session using proton-j.\n+     *\n+     * @param session Proton-j session for this AMQP session.\n+     * @param sessionHandler Handler for events that occur in the session.\n+     * @param sessionName Name of the session.\n+     * @param provider Provides reactor instances for messages to sent with.\n+     * @param handlerProvider Providers reactor handlers for listening to proton-j reactor events.\n+     * @param cbsNodeSupplier Mono that returns a reference to the {@link ClaimsBasedSecurityNode}.\n+     * @param tokenManagerProvider Provides {@link TokenManager} that authorizes the client when performing\n+     *     operations on the message broker.\n+     * @param retryPolicy for the session operation to complete.\n+     */\n+    public ReactorSession(Session session, SessionHandler sessionHandler, String sessionName, ReactorProvider provider,\n+                          ReactorHandlerProvider handlerProvider, Mono<ClaimsBasedSecurityNode> cbsNodeSupplier,", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNjcyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433516728", "bodyText": "I'm wary of casting this to ReactorSender. Does the TransactionCoordinator also have a ReactorSender? Your current implementation adds more responsibility to ReactorSender. It not only handles sending messages, but also transactions. It would be a better separation of concerns to have a TransactionCoordinator class that contains a AmqpSendLink that verifies send operations of the \"transaction\" message.\nclass TransactionCoordinator {\n    private final AmqpSendLink sendLink;\n    TransactionCoordinator(AmqpSendLink link) {\n        // This could be reactor sender underneath.\n        this.sendLink = link;\n    }\n}", "author": "conniey", "createdAt": "2020-06-01T22:09:27Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -162,6 +201,106 @@ public Duration getOperationTimeout() {\n         return openTimeout;\n     }\n \n+    private Mono<AmqpLink> createTransactionCoordinator() {\n+        return createTransactionCoordinator(TRANSACTION_LINK_NAME, openTimeout, retryPolicy);\n+    }\n+\n+    private Mono<AmqpLink> createTransactionCoordinator(String linkName, Duration timeout, AmqpRetryPolicy retry) {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator link '%s' from a closed session.\", linkName))));\n+        }\n+\n+        final LinkSubscription<AmqpLink> existing = coordinator.get();\n+        if (existing != null) {\n+            logger.verbose(\"linkName[{}]: Returning existing coordinator link.\", linkName);\n+            return Mono.just(existing.getLink());\n+        }\n+\n+        return RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),\n+            timeout, retry)\n+            .then(Mono.<AmqpLink>create(sink -> {\n+                try {\n+                    // We have to invoke this in the same thread or else proton-j will not properly link up the created\n+                    // sender because the link names are not unique. Link name == entity path.\n+                    provider.getReactorDispatcher().invoke(() -> {\n+                        LinkSubscription<AmqpLink> linkLinkSubscription = getCoordinator(linkName, timeout, retry);\n+\n+                        if (coordinator.compareAndSet(null, linkLinkSubscription)) {\n+                            logger.info(\"linkName[{}]: coordinator link created.\", linkName);\n+                        } else {\n+                            logger.info(\"linkName[{}]: Another coordinator link exists. Disposing of new one.\",\n+                                linkName);\n+                            linkLinkSubscription.dispose();\n+                        }\n+\n+                        sink.success(coordinator.get().getLink());\n+                    });\n+                } catch (IOException e) {\n+                    sink.error(e);\n+                }\n+            }));\n+    }\n+\n+    /**\n+     * NOTE: Ensure this is invoked using the reactor dispatcher because proton-j is not thread-safe.\n+     */\n+    private LinkSubscription<AmqpLink> getCoordinator(String linkName, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        final Sender sender = session.sender(linkName);\n+        sender.setTarget(new Coordinator());\n+\n+        final Source source = new Source();\n+        sender.setSource(source);\n+        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);\n+\n+        final SendLinkHandler sendLinkHandler = handlerProvider.createSendLinkHandler(\n+            sessionHandler.getConnectionId(), sessionHandler.getHostname(), linkName, linkName);\n+        BaseHandler.setHandler(sender, sendLinkHandler);\n+\n+        sender.open();\n+\n+        final ReactorSender coordinator = new ReactorSender(linkName, sender, sendLinkHandler, provider, null,\n+            messageSerializer, timeout, retry);\n+\n+        final Disposable subscription = coordinator.getEndpointStates().subscribe(state -> { },\n+            error -> {\n+                logger.info(\"linkName[{}]: Error occurred. Removing and disposing coordinator link.\", linkName, error);\n+                removeLink(openSendLinks, linkName);\n+            }, () -> {\n+                logger.info(\"linkName[{}]: Complete. Removing and disposing coordinator link.\", linkName);\n+                removeLink(openSendLinks, linkName);\n+            });\n+        return new LinkSubscription<>(coordinator, subscription);\n+    }\n+\n+    public Mono<AmqpTransaction> createTransaction() {\n+        return createTransactionCoordinator()\n+            .cast(ReactorSender.class)", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU0MDIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433540202", "bodyText": "I already had a separate class ReactorCoordinator , in order to separate concern butI had to replicate most of the code from ReactorSender  into this. You pointed that out in  your comment #11305 (comment)  and you asked to consolidate the code . Actually Transaction/Coordinator a logical name, we are actually sending Amqp Message over AmqpSendLink  . We are sending Amqp Message with different properties to create transactions.  So I think keeping all this in ReactorSender make sense, otherwise we have to replicate 95% same logic from ReactorSender in whatever new class we make.", "author": "hemanttanwar", "createdAt": "2020-06-01T23:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU1NjUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433556538", "bodyText": "Clean up imports.", "author": "conniey", "createdAt": "2020-06-02T00:24:37Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -35,6 +45,9 @@\n import org.junit.jupiter.api.Assertions;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+//import org.mockito.ArgumentCaptor;", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwOTIyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433609228", "bodyText": "AmqpTransaction should be transaction, not transactionId. Same with other usages of this.", "author": "conniey", "createdAt": "2020-06-02T04:10:04Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetriableWorkItem.java", "diffHunk": "@@ -13,39 +15,50 @@\n  */\n class RetriableWorkItem {\n     private final AtomicInteger retryAttempts = new AtomicInteger();\n-    private final MonoSink<Void> monoSink;\n+    private final MonoSink<DeliveryState> monoSink;\n     private final TimeoutTracker timeoutTracker;\n     private final byte[] amqpMessage;\n     private final int messageFormat;\n     private final int encodedMessageSize;\n+    private final AmqpTransaction transactionId;\n \n     private boolean waitingForAck;\n     private Exception lastKnownException;\n \n-    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                      Duration timeout) {\n-        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout, false));\n+    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState> monoSink,\n+                      Duration timeout, AmqpTransaction transactionId) {\n+        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout,\n+            false), transactionId);\n     }\n \n-    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                              TimeoutTracker timeout) {\n+    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState>\n+        monoSink, TimeoutTracker timeout, AmqpTransaction transactionId) {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwOTU0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433609549", "bodyText": "getTransaction()", "author": "conniey", "createdAt": "2020-06-02T04:11:32Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetriableWorkItem.java", "diffHunk": "@@ -13,39 +15,50 @@\n  */\n class RetriableWorkItem {\n     private final AtomicInteger retryAttempts = new AtomicInteger();\n-    private final MonoSink<Void> monoSink;\n+    private final MonoSink<DeliveryState> monoSink;\n     private final TimeoutTracker timeoutTracker;\n     private final byte[] amqpMessage;\n     private final int messageFormat;\n     private final int encodedMessageSize;\n+    private final AmqpTransaction transactionId;\n \n     private boolean waitingForAck;\n     private Exception lastKnownException;\n \n-    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                      Duration timeout) {\n-        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout, false));\n+    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState> monoSink,\n+                      Duration timeout, AmqpTransaction transactionId) {\n+        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout,\n+            false), transactionId);\n     }\n \n-    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                              TimeoutTracker timeout) {\n+    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState>\n+        monoSink, TimeoutTracker timeout, AmqpTransaction transactionId) {\n         this.amqpMessage = amqpMessage;\n         this.encodedMessageSize = encodedMessageSize;\n         this.messageFormat = messageFormat;\n         this.monoSink = monoSink;\n         this.timeoutTracker = timeout;\n+        this.transactionId = transactionId;\n     }\n \n     byte[] getMessage() {\n         return amqpMessage;\n     }\n \n+    AmqpTransaction getTransactionId() {", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYwOTcxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433609719", "bodyText": "transactionId.", "author": "conniey", "createdAt": "2020-06-02T04:12:22Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +130,76 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    @Test\n+    public void testCompleteTransaction() {\n+        final String txnId = \"1\";", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDg1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433610852", "bodyText": "This can be even more abstracted by accepting a deliveryState parameter rather than an AmqpTransaction. That way, all usages of AmqpTransaction are removed from this class and abstracted into the coordinator. The RetriableWorkItem no longer has a reference on a transaction, and a delivery state instead.\nMono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, DeliveryState deliveryState) {\n}", "author": "conniey", "createdAt": "2020-06-02T04:17:32Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -356,6 +452,12 @@ private void processSendWork() {\n                 delivery = sender.delivery(deliveryTag.getBytes(UTF_8));\n                 delivery.setMessageFormat(workItem.getMessageFormat());\n \n+                AmqpTransaction transactionId = workItem.getTransactionId();", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcyNDQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433724438", "bodyText": "We use AmqpSendLink directly in ServiceBusSenderAsyncClient to send message. This change will introduce a amqp deep concept of DeliveryState  into ServiceBusSenderAsyncClient which is unnecessary, I think .  AmqpTransaction is working as abstraction here.", "author": "hemanttanwar", "createdAt": "2020-06-02T08:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMTUzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433611535", "bodyText": "subscribe() is non-blocking. It may not have finished by the time verify line is hit.", "author": "conniey", "createdAt": "2020-06-02T04:20:28Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +130,76 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    @Test\n+    public void testCompleteTransaction() {\n+        final String txnId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(txnId.getBytes())));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        ReactorSender reactorSender = new ReactorSender(entityPath, sender, handler, reactorProvider, tokenManager,\n+            messageSerializer, Duration.ofSeconds(1), new ExponentialAmqpRetryPolicy(new AmqpRetryOptions()));\n+        ReactorSender spyReactorSender = spy(reactorSender);\n+\n+        doReturn(Mono.just(transactionState)).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), isNull());\n+\n+        spyReactorSender.completeTransaction(transaction, true).subscribe();", "originalCommit": "f12743f20689f92f7234fcdb78985a2cda3c3e1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxNTAxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r433615017", "bodyText": "These tests are not using the right way to test Project Reactor.\nhttps://projectreactor.io/docs/core/release/reference/#_testing_a_scenario_with_stepverifier", "author": "conniey", "createdAt": "2020-06-02T04:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMTUzNQ=="}], "type": "inlineReview"}, {"oid": "17707ff474adfc0282d24356182a4b9f6ca8228a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17707ff474adfc0282d24356182a4b9f6ca8228a", "message": "Review comments", "committedDate": "2020-06-02T05:11:41Z", "type": "commit"}, {"oid": "43b503a8983071e359e11d5b8efa26f2af5bca19", "url": "https://github.com/Azure/azure-sdk-for-java/commit/43b503a8983071e359e11d5b8efa26f2af5bca19", "message": "Encapsulated transaction in TransactionCoordinator", "committedDate": "2020-06-02T08:50:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0NjMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434046314", "bodyText": "The sink should return an error (sink.error(...)) what I meant was to move all your other logic from ReactorSender (line452...) for processing DeliveryState into here.\nReactorSender\n//@returns the DeliveryState for the associated send operation.\nMono<DeliveryState> send(byte[] amqpMessage, int encodedMessageSize, int messageFormat, DeliveryState dispositionState);\nTransactionCoordinator\n.handle((state, sink) -> {\n  // process delivery state.\n});", "author": "conniey", "createdAt": "2020-06-02T17:23:52Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+import reactor.util.function.Tuples;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.fromCallable(() -> {\n+            final Message message = Proton.message();\n+            Discharge discharge = new Discharge();\n+            discharge.setFail(!isCommit);\n+            discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+            message.setBody(new AmqpValue(discharge));\n+\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize = message.encode(bytes, 0, allocationSize);\n+            Tuple2<byte[], Integer> tuple = Tuples.of(bytes, encodedSize);\n+            return tuple;\n+        })\n+            .flatMap(tuple2 -> sendLink.send(tuple2.getT1(), tuple2.getT2(), DeliveryImpl.DEFAULT_MESSAGE_FORMAT))\n+            .handle((state, sink) -> {\n+                if (!(state instanceof Accepted)) {\n+                    logger.error(\"Transaction [{}] could not be completed, Service Bus status [{}].\",", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0NzAxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434047016", "bodyText": "// Arrange", "author": "conniey", "createdAt": "2020-06-02T17:25:02Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +122,30 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    /**\n+     * Testing that we can send message with transaction.\n+     */\n+    @Test\n+    public void testSendWithTransaction() {\n+        Message message = Proton.message();", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0NzEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434047103", "bodyText": "new line then:\n// Act", "author": "conniey", "createdAt": "2020-06-02T17:25:12Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +122,30 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    /**\n+     * Testing that we can send message with transaction.\n+     */\n+    @Test\n+    public void testSendWithTransaction() {\n+        Message message = Proton.message();\n+        message.setMessageId(\"id\");\n+        message.setBody(new AmqpValue(\"hello\"));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        ReactorSender reactorSender = new ReactorSender(entityPath, sender, handler, reactorProvider, tokenManager,\n+            messageSerializer, Duration.ofSeconds(1), new ExponentialAmqpRetryPolicy(new AmqpRetryOptions()));\n+        ReactorSender spyReactorSender = spy(reactorSender);\n+\n+        doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), any(AmqpTransaction.class));\n+        StepVerifier.create(spyReactorSender.send(message, transaction))", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0NzIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434047216", "bodyText": "// Assert", "author": "conniey", "createdAt": "2020-06-02T17:25:23Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +122,30 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    /**\n+     * Testing that we can send message with transaction.\n+     */\n+    @Test\n+    public void testSendWithTransaction() {\n+        Message message = Proton.message();\n+        message.setMessageId(\"id\");\n+        message.setBody(new AmqpValue(\"hello\"));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        ReactorSender reactorSender = new ReactorSender(entityPath, sender, handler, reactorProvider, tokenManager,\n+            messageSerializer, Duration.ofSeconds(1), new ExponentialAmqpRetryPolicy(new AmqpRetryOptions()));\n+        ReactorSender spyReactorSender = spy(reactorSender);\n+\n+        doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), any(AmqpTransaction.class));\n+        StepVerifier.create(spyReactorSender.send(message, transaction))\n+            .verifyComplete();\n+        StepVerifier.create(spyReactorSender.send(message, transaction))\n+            .verifyComplete();\n+        verify(sender, times(1)).getRemoteMaxMessageSize();", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0ODEzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434048134", "bodyText": "I'm confused what you are actually testing here... Just that it eventually calls the send() overload?", "author": "conniey", "createdAt": "2020-06-02T17:26:43Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +122,30 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    /**\n+     * Testing that we can send message with transaction.\n+     */\n+    @Test\n+    public void testSendWithTransaction() {\n+        Message message = Proton.message();\n+        message.setMessageId(\"id\");\n+        message.setBody(new AmqpValue(\"hello\"));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        ReactorSender reactorSender = new ReactorSender(entityPath, sender, handler, reactorProvider, tokenManager,", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwODIwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435608204", "bodyText": "We're missing tests for using the delivery state on success and not.", "author": "conniey", "createdAt": "2020-06-04T23:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0ODEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwOTEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435609101", "bodyText": "Or that the transactionDeliveryState is set on a delivery.", "author": "conniey", "createdAt": "2020-06-04T23:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0ODEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0ODY5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434048690", "bodyText": "There are no unit tests here that actually test the complex logic in your ReactorSender operation.. (which will eventually moved to TransactionCoordinator)", "author": "conniey", "createdAt": "2020-06-02T17:27:40Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +122,30 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0ODkzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434048932", "bodyText": "nit: empty line.", "author": "conniey", "createdAt": "2020-06-02T17:28:06Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java", "diffHunk": "@@ -225,6 +230,74 @@ void sendMessageIdSet() {\n             .expectError(IllegalArgumentException.class)\n             .verify();\n     }\n+    /**\n+     * Verifies a message is received.\n+     */\n+    @Test\n+    void sendMessageWithTransaction() throws IOException {\n+        // Arrange\n+        // This message was copied from one that was received.\n+        ByteBuffer txnId = ByteBuffer.wrap(\"1\".getBytes());\n+        AmqpTransaction transaction = mock(AmqpTransaction.class);\n+        when(transaction.getTransactionId()).thenReturn(txnId);\n+\n+        final byte[] messageBytes = new byte[]{0, 83, 115, -64, 15, 13, 64, 64, 64, 64, 64, 83, 1, 64, 64, 64, 64, 64,\n+            64, 64, 0, 83, 116, -63, 49, 4, -95, 11, 115, 116, 97, 116, 117, 115, 45, 99, 111, 100, 101, 113, 0, 0, 0,\n+            -54, -95, 18, 115, 116, 97, 116, 117, 115, 45, 100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, -95, 8,\n+            65, 99, 99, 101, 112, 116, 101, 100};\n+        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+            ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n+            ReceiverSettleMode.SECOND);\n+        final UnsignedLong messageId = UnsignedLong.valueOf(1);\n+        final Message message = mock(Message.class);\n+        final int encodedSize = 143;\n+        when(serializer.getSize(message)).thenReturn(150);\n+        when(message.encode(any(), eq(0), anyInt())).thenReturn(encodedSize);\n+\n+        // Creating delivery for sending.\n+        final Delivery deliveryToSend = mock(Delivery.class);\n+        doNothing().when(deliveryToSend).setMessageFormat(anyInt());\n+        doNothing().when(deliveryToSend).disposition(any(TransactionalState.class));\n+        when(sender.delivery(any(byte[].class))).thenReturn(deliveryToSend);\n+", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0OTAyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434049023", "bodyText": "nit: empty line.", "author": "conniey", "createdAt": "2020-06-02T17:28:14Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java", "diffHunk": "@@ -225,6 +230,74 @@ void sendMessageIdSet() {\n             .expectError(IllegalArgumentException.class)\n             .verify();\n     }\n+    /**\n+     * Verifies a message is received.\n+     */\n+    @Test\n+    void sendMessageWithTransaction() throws IOException {\n+        // Arrange\n+        // This message was copied from one that was received.\n+        ByteBuffer txnId = ByteBuffer.wrap(\"1\".getBytes());\n+        AmqpTransaction transaction = mock(AmqpTransaction.class);\n+        when(transaction.getTransactionId()).thenReturn(txnId);\n+\n+        final byte[] messageBytes = new byte[]{0, 83, 115, -64, 15, 13, 64, 64, 64, 64, 64, 83, 1, 64, 64, 64, 64, 64,\n+            64, 64, 0, 83, 116, -63, 49, 4, -95, 11, 115, 116, 97, 116, 117, 115, 45, 99, 111, 100, 101, 113, 0, 0, 0,\n+            -54, -95, 18, 115, 116, 97, 116, 117, 115, 45, 100, 101, 115, 99, 114, 105, 112, 116, 105, 111, 110, -95, 8,\n+            65, 99, 99, 101, 112, 116, 101, 100};\n+        final RequestResponseChannel channel = new RequestResponseChannel(CONNECTION_ID, NAMESPACE, LINK_NAME,\n+            ENTITY_PATH, session, retryOptions, handlerProvider, reactorProvider, serializer, SenderSettleMode.SETTLED,\n+            ReceiverSettleMode.SECOND);\n+        final UnsignedLong messageId = UnsignedLong.valueOf(1);\n+        final Message message = mock(Message.class);\n+        final int encodedSize = 143;\n+        when(serializer.getSize(message)).thenReturn(150);\n+        when(message.encode(any(), eq(0), anyInt())).thenReturn(encodedSize);\n+\n+        // Creating delivery for sending.\n+        final Delivery deliveryToSend = mock(Delivery.class);\n+        doNothing().when(deliveryToSend).setMessageFormat(anyInt());\n+        doNothing().when(deliveryToSend).disposition(any(TransactionalState.class));\n+        when(sender.delivery(any(byte[].class))).thenReturn(deliveryToSend);\n+\n+\n+        // Creating a received message because we decodeDelivery calls implementation details for proton-j.\n+        final Delivery delivery = mock(Delivery.class);\n+        when(delivery.pending()).thenReturn(messageBytes.length);\n+\n+", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0OTI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434049286", "bodyText": "nit: empty line.", "author": "conniey", "createdAt": "2020-06-02T17:28:40Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/RequestResponseChannelTest.java", "diffHunk": "@@ -246,9 +319,16 @@ void sendMessage() throws IOException {\n         when(serializer.getSize(message)).thenReturn(150);\n         when(message.encode(any(), eq(0), anyInt())).thenReturn(encodedSize);\n \n+        // Creating delivery for sending.\n+        final Delivery deliveryToSend = mock(Delivery.class);\n+        doNothing().when(deliveryToSend).setMessageFormat(anyInt());\n+        when(sender.delivery(any(byte[].class))).thenReturn(deliveryToSend);\n+\n         // Creating a received message because we decodeDelivery calls implementation details for proton-j.\n         final Delivery delivery = mock(Delivery.class);\n         when(delivery.pending()).thenReturn(messageBytes.length);\n+", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0OTUyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434049524", "bodyText": "txn -> transaction", "author": "conniey", "createdAt": "2020-06-02T17:29:05Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void testCompleteTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, true))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), anyInt());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        AtomicReference<AmqpTransaction> createdTransaction = new AtomicReference<>();\n+\n+        StepVerifier.create(transactionCoordinator.createTransaction()\n+            .map(txn -> {", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0OTg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434049891", "bodyText": "You should be using assertNext rather than a map and setting it through an atomic reference.", "author": "conniey", "createdAt": "2020-06-02T17:29:45Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void testCompleteTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, true))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), anyInt());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        AtomicReference<AmqpTransaction> createdTransaction = new AtomicReference<>();\n+\n+        StepVerifier.create(transactionCoordinator.createTransaction()\n+            .map(txn -> {", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDIwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434050206", "bodyText": "This should be an assertEquals rather than a true.", "author": "conniey", "createdAt": "2020-06-02T17:30:13Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void testCompleteTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, true))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), anyInt());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        AtomicReference<AmqpTransaction> createdTransaction = new AtomicReference<>();\n+\n+        StepVerifier.create(transactionCoordinator.createTransaction()\n+            .map(txn -> {\n+                createdTransaction.set(txn);\n+                return txn;\n+            }))\n+            .verifyComplete();\n+\n+        Assertions.assertNotNull(createdTransaction.get(), \"Should have got transaction id.\");\n+        Assertions.assertTrue(new String(createdTransaction.get().getTransactionId().array()).equals(transactionId),", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MDY3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434050673", "bodyText": "transactionId -> transaction", "author": "conniey", "createdAt": "2020-06-02T17:30:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -69,17 +70,16 @@ String getLinkName() {\n     }\n \n     Mono<Void> updateDisposition(String lockToken, DispositionStatus dispositionStatus, String deadLetterReason,\n-        String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        String deadLetterErrorDescription, Map<String, Object> propertiesToModify, AmqpTransaction transactionId) {", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MjQ3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434052473", "bodyText": "Instead of creating a new object for every time (AmqpTransaction), why not pass the ServiceBusTransactionContext in here and pass the parameter onto the ServiceManagementNode?.", "author": "conniey", "createdAt": "2020-06-02T17:33:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -871,7 +1100,7 @@ private boolean isManagementToken(String lockToken) {\n \n     private Mono<Void> updateDisposition(MessageLockToken message, DispositionStatus dispositionStatus,\n         String deadLetterReason, String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n-        String sessionId) {\n+        String sessionId, AmqpTransaction transactionId) {", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1MzI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434053277", "bodyText": "Why are you chaining .then()? You use this a lot unnecessarily. Same with the lines below. I think you should understand why we use .then().", "author": "conniey", "createdAt": "2020-06-02T17:35:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/TransactionManagerImpl.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.core.amqp.AmqpSession;\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.ServiceBusTransactionContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Objects;\n+\n+/**\n+ * Implements {@link TransactionManager} which provide utility for transaction API.\n+ */\n+public class TransactionManagerImpl implements TransactionManager {\n+\n+    private final Mono<AmqpSession> session;\n+    private final String fullyQualifiedNamespace;\n+    private final String linkName;\n+    private final ClientLogger logger =  new ClientLogger(TransactionManagerImpl.class);\n+\n+    TransactionManagerImpl(Mono<AmqpSession> session, String fullyQualifiedNamespace, String linkName) {\n+        this.session = Objects.requireNonNull(session, \"'session' cannot be null.\");\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.linkName = Objects.requireNonNull(linkName, \"'linkName' cannot be null.\");\n+\n+    }\n+\n+    @Override\n+    public Mono<ByteBuffer> createTransaction() {\n+        return  session.flatMap(session ->\n+            session.createTransaction()).map(transaction -> transaction.getTransactionId());\n+    }\n+\n+    @Override\n+    public Mono<Void> commitTransaction(ServiceBusTransactionContext transactionContext) {\n+        return session.flatMap(session ->\n+            session.commitTransaction(new AmqpTransaction(transactionContext.getTransactionId()))).then();", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NDMyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434054327", "bodyText": "private", "author": "conniey", "createdAt": "2020-06-02T17:36:53Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    AmqpSendLink sendLink;", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NjUxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434056510", "bodyText": "Why is this mapped in a callable?? It can be synchronous and then pass the values onwards. I don't see why we're creating a Tuple.", "author": "conniey", "createdAt": "2020-06-02T17:40:43Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+import reactor.util.function.Tuple2;\n+import reactor.util.function.Tuples;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        return Mono.fromCallable(() -> {\n+            final Message message = Proton.message();", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NzQxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434057414", "bodyText": "any*() is used a lot. The messageFormat is deterministic. We know it's a specific format. This makes our tests more tightly scoped.", "author": "conniey", "createdAt": "2020-06-02T17:42:09Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @Test\n+    public void testCompleteTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, true))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), anyInt());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final String transactionId = \"1\";\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId.getBytes())));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt());", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NzgzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434057836", "bodyText": "nit: empty line. Same with instances below.", "author": "conniey", "createdAt": "2020-06-02T17:42:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -218,6 +317,28 @@ public void defer(MessageLockToken lockToken, Map<String, Object> propertiesToMo\n         asyncClient.defer(lockToken, propertiesToModify, sessionId).block(operationTimeout);\n     }\n \n+    /**\n+     * Defers a {@link ServiceBusReceivedMessage message} using its lock token with modified message property. This will\n+     * move message into the deferred subqueue.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Message properties to modify.\n+     * @param sessionId Session id of the message to defer. {@code null} if there is no session.\n+     * @param transactionContext in which this operation is taking part in. The transaction should be created first by\n+     * {@link ServiceBusReceiverClient#createTransaction()} or {@link ServiceBusSenderClient#createTransaction()}.\n+     *\n+     * @throws NullPointerException if {@code lockToken} is null.\n+     * @throws UnsupportedOperationException if the receiver was opened in {@link ReceiveMode#RECEIVE_AND_DELETE}\n+     *     mode.\n+     * @throws IllegalArgumentException if {@link MessageLockToken#getLockToken()} returns a null lock token.\n+     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-deferral\">Message deferral</a>\n+     */\n+    public void defer(MessageLockToken lockToken, Map<String, Object> propertiesToModify, String sessionId,\n+        ServiceBusTransactionContext transactionContext) {\n+        asyncClient.defer(lockToken, propertiesToModify, sessionId, transactionContext).block(operationTimeout);\n+", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5Njc2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434296762", "bodyText": "I meant, line 452 onwards to line 463. The only time Mono<DeliveryState> send\u00a0returns is in a success (Accepted/Declared) state.\n\u00a0   1. Why return DeliveryState if you already process it rather than Mono<Void>?\n\u00a0   2. It could be decoupled by returning the DeliveryState as-is in processDeliveredMessage if\n\u00a0   you have an associated DeliveryState (ie. TransactionState) that was passed.\n1. In this case, we could decouple any transaction handling from ReactorSender.\nclass ReactorSender {\n    Mono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, DeliveryState deliveryState) {\n        return validateEndpoint()\n            .then(Mono.create(sink -> sendWork(new RetriableWorkItem(bytes,\n                arrayOffset, messageFormat, sink, timeout, deliveryState)))\n            );\n    }\n\n    private void processDeliveredMessage(Delivery delivery) {\n        final DeliveryState outcome = delivery.getRemoteState();\n        final String deliveryTag = new String(delivery.getTag(), UTF_8);\n\n        logger.verbose(\"entityPath[{}], linkName[{}], deliveryTag[{}]: process delivered message\",\n            entityPath, getLinkName(), deliveryTag);\n\n        final RetriableWorkItem workItem = pendingSendsMap.remove(deliveryTag);\n\n        if (workItem == null) {\n            logger.verbose(\"clientId[{}]. path[{}], linkName[{}], delivery[{}] - mismatch (or send timed out)\",\n                handler.getConnectionId(), entityPath, getLinkName(), deliveryTag);\n            return;\n        } else if (workItem.updatedDeliveryState()) {\n            workItem.success(outcome);\n            return;\n        }\n\n        // All the original content from line 444 without any transaction stuff.\n    }\n}\n\nclass RetriableWorkItem {\n    private final DeliveryState deliveryState;\n\n    boolean updatedDeliveryState() {\n        return deliveryState != null;\n    }\n}\n\nclass TransactionCoordinator {\n    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n        final int payloadSize = messageSerializer.getSize(message);\n        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n\n        final byte[] bytes = new byte[allocationSize];\n        final int encodedSize = message.encode(bytes, 0, allocationSize);\n        final DeliveryState deliveryState = new TransactionalState();\n        deliveryState.setTxnId(new Binary(transaction.getTransactionId().array()));\n\n        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT,deliveryState)\n            .handle((outcome, MonoSink<Void> sink) -> {\n                if (!(outcome instanceof TransactionalState)) {\n                    sink.error(new IllegalArgumentException(\"Expected a TransactionalState, received: \" + outcome));\n                    return;\n                }\n\n                final TransactionalState state = (TransactionalState) outcome;\n                final DeliveryStateType stateType = state.getType();\n                switch (stateType) {\n                    case Accepted:\n                        break;\n                    case Rejected:\n                        break;\n                    case Declared:\n                        break;\n                    default:\n                }\n            });\n    }\n}", "author": "conniey", "createdAt": "2020-06-03T04:09:55Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -411,15 +449,19 @@ private void processDeliveredMessage(Delivery delivery) {\n             return;\n         }\n \n-        if (outcome instanceof Accepted) {\n+        if (outcome instanceof Accepted", "originalCommit": "43b503a8983071e359e11d5b8efa26f2af5bca19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e338204f397726e4190237b925c52368abc6286", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3e338204f397726e4190237b925c52368abc6286", "message": "refactoring and renaming of classed", "committedDate": "2020-06-03T07:57:19Z", "type": "commit"}, {"oid": "b879787b3f6ba491b1f699b78805f18e17d0a525", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b879787b3f6ba491b1f699b78805f18e17d0a525", "message": "Refactoring classes", "committedDate": "2020-06-03T08:23:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5NDY2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434394665", "bodyText": "Add a little more documentation to describe the capabilities of a transaction. This is a public-facing class, so, want to make sure we have enough details in JavaDoc.", "author": "srnagar", "createdAt": "2020-06-03T08:24:56Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Represents transaction.", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5NzQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434397499", "bodyText": "Add javadoc.", "author": "srnagar", "createdAt": "2020-06-03T08:29:30Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Represents transaction.\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;\n+\n+    /**\n+     *\n+     * @param transactionId for this transaction\n+     */\n+    public AmqpTransaction(ByteBuffer transactionId) {\n+        this.transactionId = transactionId;\n+    }\n+\n+    /**\n+     *", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5OTYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434399623", "bodyText": "Why does this return a DeliveryState while the other send overloads don't?", "author": "srnagar", "createdAt": "2020-06-03T08:33:00Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpSendLink.java", "diffHunk": "@@ -24,16 +26,50 @@\n      */\n     Mono<Void> send(Message message);\n \n+    /**\n+     * Batches list of messages given into a single proton-j message that is sent down the wire.\n+     *\n+     * @param messages The list of messages to send to the service.\n+     * @param deliveryState to be sent along with message.\n+     *\n+     * @return A Mono that completes when all the batched messages are successfully transmitted to message broker.\n+     * @throws AmqpException if the serialized contents of {@code messageBatch} exceed the link's capacity for a single\n+     * message.\n+     */\n+    Mono<Void> send(List<Message> messages, DeliveryState deliveryState);\n+\n+    /**\n+     * Sends a single message to the remote endpoint.\n+     *\n+     * @param message Message to send.\n+     * @param deliveryState to be sent along with message.\n+     * @return A Mono that completes when the message has been sent.\n+     * @throws AmqpException if the serialized {@code message} exceed the links capacity for a single message.\n+     */\n+    Mono<Void> send(Message message, DeliveryState deliveryState);\n+\n     /**\n      * Batches the messages given into a single proton-j message that is sent down the wire.\n      *\n      * @param messageBatch The batch of messages to send to the service.\n-     * @return A Mono that completes when all the batched messages are successfully transmitted to Event Hub.\n+     * @return A Mono that completes when all the batched messages are successfully transmitted to the message broker.\n      * @throws AmqpException if the serialized contents of {@code messageBatch} exceed the link's capacity for a single\n      * message.\n      */\n     Mono<Void> send(List<Message> messageBatch);\n \n+    /**\n+     * send the message and return {@link DeliveryState} of this delivery in message broker.\n+     *\n+     * @param bytes to send to message broker\n+     * @param arrayOffset offset of the message.\n+     * @param messageFormat to be set on the message.\n+     * @param deliveryState to be updated on the {@link Delivery}.\n+     *\n+     * @return A completable of {@link DeliveryState} received from Message Broker.\n+     */\n+    Mono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, DeliveryState deliveryState);", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4ODgzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434688838", "bodyText": "When we create  transaction, This is the case where we need to process this DeliveryState in TransactionCoordinator  and  read transactionid from it. We do not want to do this processing in this class and abstracted this in TransactionCoordinator", "author": "hemanttanwar", "createdAt": "2020-06-03T16:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5OTYyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMTg5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434401891", "bodyText": "The ctor already creates an instance of RetryPolicy.  Is there a reason for creating another instance instead of using this.retryPolicy?", "author": "srnagar", "createdAt": "2020-06-03T08:36:55Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorConnection.java", "diffHunk": "@@ -241,7 +241,7 @@ public int getMaxFrameSize() {\n     protected AmqpSession createSession(String sessionName, Session session, SessionHandler handler) {\n         return new ReactorSession(session, handler, sessionName, reactorProvider, handlerProvider,\n             getClaimsBasedSecurityNode(), tokenManagerProvider, messageSerializer,\n-            connectionOptions.getRetry().getTryTimeout());\n+            connectionOptions.getRetry().getTryTimeout(), RetryUtil.getRetryPolicy(connectionOptions.getRetry()));", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMzQ0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434403447", "bodyText": "Can tokenManager be null? If so, how is authorization done?", "author": "srnagar", "createdAt": "2020-06-03T08:39:33Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -125,9 +126,11 @@\n             this.handler.getErrors().subscribe(error -> {\n                 logger.error(\"[{}] Error occurred in sender error handler.\", entityPath, error);\n                 endpointStateSink.error(error);\n-            }),\n+            })\n+        );\n \n-            this.tokenManager.getAuthorizationResults().subscribe(\n+        if (tokenManager != null) {", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4NzM3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434687372", "bodyText": "This is for special Sender link called coordinator which create a transaction in SB and there is no auth for this according to service bus team because auth will be done when user want to use this transaction in messages. And user can not do anything with a transaction alone.", "author": "hemanttanwar", "createdAt": "2020-06-03T16:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwMzQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQwNzQzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434407435", "bodyText": "Commented code can be deleted.", "author": "srnagar", "createdAt": "2020-06-03T08:46:07Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -289,19 +302,39 @@ public void dispose() {\n         tokenManager.close();\n     }\n \n-    Mono<Void> send(byte[] bytes, int arrayOffset, int messageFormat) {\n-        if (hasConnected.get()) {\n-            return Mono.create(sink -> send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout)));\n-        } else {\n-            return RetryUtil.withRetry(\n-                handler.getEndpointStates().takeUntil(state -> state == EndpointState.ACTIVE),\n-                timeout, retry)\n-                .then(Mono.create(sink ->\n-                    send(new RetriableWorkItem(bytes, arrayOffset, messageFormat, sink, timeout))));\n-        }\n+    @Override\n+    public Mono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, DeliveryState deliveryState) {\n+        return validateEndpoint()\n+            .then(Mono.create(sink -> sendWork(new RetriableWorkItem(bytes,\n+                arrayOffset, messageFormat, sink, timeout, deliveryState)))\n+            );\n     }\n \n-    private void send(RetriableWorkItem workItem) {\n+    /*Mono<DeliveryState> send(byte[] bytes, int arrayOffset, int messageFormat, DeliveryState deliveryState) {\n+        return validateEndpoint()\n+            .then(Mono.create(sink -> sendWork(new RetriableWorkItem(bytes,\n+                arrayOffset, messageFormat, sink, timeout, deliveryState)))\n+            );\n+    }*/\n+", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQxNzc3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434417774", "bodyText": "transactionId should not be null. Add a null check here.", "author": "srnagar", "createdAt": "2020-06-03T09:02:46Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+\n+/**\n+ * Represents transaction.\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;\n+\n+    /**\n+     *\n+     * @param transactionId for this transaction\n+     */\n+    public AmqpTransaction(ByteBuffer transactionId) {", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyMDUxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434420517", "bodyText": "Consider naming this method as isDeliveryStateUpdated.", "author": "srnagar", "createdAt": "2020-06-03T09:07:20Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/RetriableWorkItem.java", "diffHunk": "@@ -13,39 +14,54 @@\n  */\n class RetriableWorkItem {\n     private final AtomicInteger retryAttempts = new AtomicInteger();\n-    private final MonoSink<Void> monoSink;\n+    private final MonoSink<DeliveryState> monoSink;\n     private final TimeoutTracker timeoutTracker;\n     private final byte[] amqpMessage;\n     private final int messageFormat;\n     private final int encodedMessageSize;\n+    private final DeliveryState deliveryState;\n \n     private boolean waitingForAck;\n     private Exception lastKnownException;\n \n-    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                      Duration timeout) {\n-        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout, false));\n+    RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState> monoSink,\n+                      Duration timeout, DeliveryState deliveryState) {\n+        this(amqpMessage, encodedMessageSize, messageFormat, monoSink, new TimeoutTracker(timeout,\n+            false), deliveryState);\n     }\n \n-    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<Void> monoSink,\n-                              TimeoutTracker timeout) {\n+    private RetriableWorkItem(byte[] amqpMessage, int encodedMessageSize, int messageFormat, MonoSink<DeliveryState>\n+        monoSink, TimeoutTracker timeout, DeliveryState deliveryState) {\n         this.amqpMessage = amqpMessage;\n         this.encodedMessageSize = encodedMessageSize;\n         this.messageFormat = messageFormat;\n         this.monoSink = monoSink;\n         this.timeoutTracker = timeout;\n+        this.deliveryState = deliveryState;\n     }\n \n     byte[] getMessage() {\n         return amqpMessage;\n     }\n \n+    DeliveryState getDeliveryState() {\n+        return deliveryState;\n+    }\n+\n+    boolean updatedDeliveryState() {", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyODQ1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434428456", "bodyText": "Add a log or throw an exception for default case instead of leaving it blank.", "author": "srnagar", "createdAt": "2020-06-03T09:20:30Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        final Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Accepted)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Accepted, received: \" + outcome));\n+                    return;\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<AmqpTransaction> createTransaction() {\n+        final Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Declared)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Declared, received: \" + outcome));\n+                    return;\n+                }\n+\n+                final Declared state = (Declared) outcome;\n+                final DeliveryState.DeliveryStateType stateType = state.getType();\n+                switch (stateType) {\n+                    case Accepted:\n+                        break;\n+                    case Rejected:\n+                        break;\n+                    case Declared:\n+                        Binary txnId;\n+                        Declared declared = (Declared) outcome;\n+                        txnId = declared.getTxnId();\n+                        logger.verbose(\"Created new TX started: {}\", txnId);\n+                        sink.next(new AmqpTransaction(txnId.asByteBuffer()));\n+                        break;\n+                    default:", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyOTc2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434429769", "bodyText": "Add codesnippets.", "author": "srnagar", "createdAt": "2020-06-03T09:22:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -221,6 +222,28 @@ public String getEntityPath() {\n         return abandon(lockToken, propertiesToModify, receiverOptions.getSessionId());\n     }\n \n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n+     *", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjIyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434442223", "bodyText": "Is there a reason for having this interface instead of an implementation? Will it have more than 1 implementation?", "author": "srnagar", "createdAt": "2020-06-03T09:42:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/TransactionManager.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+import com.azure.messaging.servicebus.ServiceBusTransactionContext;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Provides API to manage transaction on Service Bus namespace.\n+ */\n+public interface TransactionManager {", "originalCommit": "3e338204f397726e4190237b925c52368abc6286", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0de06e855128047690e8ee4d0f00538f11a51b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0de06e855128047690e8ee4d0f00538f11a51b9", "message": "refactor AmqpTransaction in method calls", "committedDate": "2020-06-03T16:22:18Z", "type": "commit"}, {"oid": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "message": "Adding unit test", "committedDate": "2020-06-03T18:31:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2ODYxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434768615", "bodyText": "Objects.requireNotNull returns the object.\nthis.transactionId = Objects.requireNonNull(transactionId, \"'transactionId' cannot be null.\");", "author": "conniey", "createdAt": "2020-06-03T18:25:29Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import com.azure.core.amqp.implementation.TransactionCoordinator;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+/**\n+ * Represents transaction in message broker. {@link TransactionCoordinator} uses this to perform many message broker\n+ * operation as unit of work.\n+ *\n+ * @see TransactionCoordinator\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;\n+\n+    /**\n+     * Creates {@link AmqpTransaction} given {@code transactionId}.\n+     *\n+     * @param transactionId for this transaction\n+     *\n+     * @throws NullPointerException if {@code transactionId} is null.\n+     */\n+    public AmqpTransaction(ByteBuffer transactionId) {\n+        Objects.requireNonNull(transactionId, \"'transactionId' cannot be null.\");\n+\n+        this.transactionId = transactionId;", "originalCommit": "f0de06e855128047690e8ee4d0f00538f11a51b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2ODk3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434768979", "bodyText": "Transaction coordinator is an implementation detail. It shouldn't be mentioned in the public API.", "author": "conniey", "createdAt": "2020-06-03T18:26:02Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import com.azure.core.amqp.implementation.TransactionCoordinator;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+/**\n+ * Represents transaction in message broker. {@link TransactionCoordinator} uses this to perform many message broker", "originalCommit": "f0de06e855128047690e8ee4d0f00538f11a51b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTM3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434769371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Get {@code transactionId} for this transaction.\n          \n          \n            \n                 * Gets the id for this transaction.", "author": "conniey", "createdAt": "2020-06-03T18:26:48Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import com.azure.core.amqp.implementation.TransactionCoordinator;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+/**\n+ * Represents transaction in message broker. {@link TransactionCoordinator} uses this to perform many message broker\n+ * operation as unit of work.\n+ *\n+ * @see TransactionCoordinator\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;\n+\n+    /**\n+     * Creates {@link AmqpTransaction} given {@code transactionId}.\n+     *\n+     * @param transactionId for this transaction\n+     *\n+     * @throws NullPointerException if {@code transactionId} is null.\n+     */\n+    public AmqpTransaction(ByteBuffer transactionId) {\n+        Objects.requireNonNull(transactionId, \"'transactionId' cannot be null.\");\n+\n+        this.transactionId = transactionId;\n+    }\n+\n+    /**\n+     * Get {@code transactionId} for this transaction.", "originalCommit": "f0de06e855128047690e8ee4d0f00538f11a51b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2OTgzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434769831", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return transactionId.\n          \n          \n            \n                 * @return The id for this transaction.", "author": "conniey", "createdAt": "2020-06-03T18:27:37Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/AmqpTransaction.java", "diffHunk": "@@ -0,0 +1,52 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import com.azure.core.amqp.implementation.TransactionCoordinator;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n+\n+/**\n+ * Represents transaction in message broker. {@link TransactionCoordinator} uses this to perform many message broker\n+ * operation as unit of work.\n+ *\n+ * @see TransactionCoordinator\n+ */\n+public class AmqpTransaction {\n+\n+    private final ByteBuffer transactionId;\n+\n+    /**\n+     * Creates {@link AmqpTransaction} given {@code transactionId}.\n+     *\n+     * @param transactionId for this transaction\n+     *\n+     * @throws NullPointerException if {@code transactionId} is null.\n+     */\n+    public AmqpTransaction(ByteBuffer transactionId) {\n+        Objects.requireNonNull(transactionId, \"'transactionId' cannot be null.\");\n+\n+        this.transactionId = transactionId;\n+    }\n+\n+    /**\n+     * Get {@code transactionId} for this transaction.\n+     *\n+     * @return transactionId.", "originalCommit": "f0de06e855128047690e8ee4d0f00538f11a51b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MTE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434771153", "bodyText": "Is this used in production? iirc, we only send a single message, or an amqp message as a batch.", "author": "conniey", "createdAt": "2020-06-03T18:29:54Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/AmqpSendLink.java", "diffHunk": "@@ -24,16 +26,50 @@\n      */\n     Mono<Void> send(Message message);\n \n+    /**\n+     * Batches list of messages given into a single proton-j message that is sent down the wire.\n+     *\n+     * @param messages The list of messages to send to the service.\n+     * @param deliveryState to be sent along with message.\n+     *\n+     * @return A Mono that completes when all the batched messages are successfully transmitted to message broker.\n+     * @throws AmqpException if the serialized contents of {@code messageBatch} exceed the link's capacity for a single\n+     * message.\n+     */\n+    Mono<Void> send(List<Message> messages, DeliveryState deliveryState);", "originalCommit": "f0de06e855128047690e8ee4d0f00538f11a51b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczNDg0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435734841", "bodyText": "sender client does reference this https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java#L266", "author": "hemanttanwar", "createdAt": "2020-06-05T07:21:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3MTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3NzcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434777711", "bodyText": "Why is a lock here? The operation itself is asynchronous. The call returns immediately after setting up the Mono. You can have multiple createCoordinatorSendLink.\nCreating an AtomicReference plus a lock for this doesn't seem like the right approach here.", "author": "conniey", "createdAt": "2020-06-03T18:41:44Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -162,6 +180,117 @@ public Duration getOperationTimeout() {\n         return openTimeout;\n     }\n \n+    /**\n+     *\n+     * @return {@link Mono} of {@link TransactionCoordinator}\n+     */\n+    private Mono<TransactionCoordinator> createTransactionCoordinator() {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        if (transactionCoordinator != null) {\n+            logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(transactionCoordinator);\n+        }\n+\n+        synchronized (coordinatorLock) {", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3ODAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434778035", "bodyText": "Why are we using handle rather than a .map operation?", "author": "conniey", "createdAt": "2020-06-03T18:42:18Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -162,6 +180,117 @@ public Duration getOperationTimeout() {\n         return openTimeout;\n     }\n \n+    /**\n+     *\n+     * @return {@link Mono} of {@link TransactionCoordinator}\n+     */\n+    private Mono<TransactionCoordinator> createTransactionCoordinator() {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        if (transactionCoordinator != null) {\n+            logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(transactionCoordinator);\n+        }\n+\n+        synchronized (coordinatorLock) {\n+            return createCoordinatorSendLink(TRANSACTION_LINK_NAME, openTimeout, retryPolicy)\n+                .handle((amqpLink, sink) -> {", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3OTM5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434779397", "bodyText": "This is going to create multiple instances of TransactionCoordinator. since you have createTransactionCoordinator() for every create, commit, rollback operation you do. I don't think this is what you intended to do; the transactionCoordinator variable is never set.", "author": "conniey", "createdAt": "2020-06-03T18:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3ODAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434780554", "bodyText": "Doesn't complete transaction also have some outcomes it should validate?", "author": "conniey", "createdAt": "2020-06-03T18:46:55Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        final Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Accepted)) {", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434782936", "bodyText": "I think doing these instanceof checks are messy, when there is an enum DeliveryStateType we can use.", "author": "conniey", "createdAt": "2020-06-03T18:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NzA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434797047", "bodyText": "You also need a success scenario for this sink.", "author": "conniey", "createdAt": "2020-06-03T19:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MTEwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434781101", "bodyText": "Declared can be checked using the DeliveryStateType. If it's not this type, it should fall into the default switch/case. I think this way is messy because there can be many different classes.", "author": "conniey", "createdAt": "2020-06-03T18:47:56Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        final Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Accepted)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Accepted, received: \" + outcome));\n+                    return;\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<AmqpTransaction> createTransaction() {\n+        final Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Declared)) {", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MTQ0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434781441", "bodyText": "Do we really need this log message? Also, txtId -> transactionId.", "author": "conniey", "createdAt": "2020-06-03T18:48:33Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        final Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Accepted)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Accepted, received: \" + outcome));\n+                    return;\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<AmqpTransaction> createTransaction() {\n+        final Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Declared)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Declared, received: \" + outcome));\n+                    return;\n+                }\n+\n+                final Declared state = (Declared) outcome;\n+                final DeliveryState.DeliveryStateType stateType = state.getType();\n+                switch (stateType) {\n+                    case Accepted:\n+                        break;\n+                    case Rejected:\n+                        break;\n+                    case Declared:\n+                        Binary txnId;\n+                        Declared declared = (Declared) outcome;\n+                        txnId = declared.getTxnId();\n+                        logger.verbose(\"Created new TX started: {}\", txnId);", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434782041", "bodyText": "Should the default behaviour just be a warning and not an error? the send operation will continue to wait for another delivery state message that will never come and hang an application.", "author": "conniey", "createdAt": "2020-06-03T18:49:41Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {\n+\n+    private final ClientLogger logger = new ClientLogger(TransactionCoordinator.class);\n+\n+    private final AmqpSendLink sendLink;\n+    private final MessageSerializer messageSerializer;\n+\n+    TransactionCoordinator(AmqpSendLink sendLink, MessageSerializer messageSerializer) {\n+        this.sendLink = sendLink;\n+        this.messageSerializer = messageSerializer;\n+    }\n+\n+    /**\n+     * Completes the transaction. All the work in this transaction will either rollback or committed as one unit of\n+     * work.\n+     *\n+     * @param transaction that needs to be completed.\n+     * @param isCommit true for commit and false to rollback this transaction.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<Void> completeTransaction(AmqpTransaction transaction, boolean isCommit) {\n+        final Message message = Proton.message();\n+        Discharge discharge = new Discharge();\n+        discharge.setFail(!isCommit);\n+        discharge.setTxnId(new Binary(transaction.getTransactionId().array()));\n+        message.setBody(new AmqpValue(discharge));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Accepted)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Accepted, received: \" + outcome));\n+                    return;\n+                }\n+            });\n+    }\n+\n+    /**\n+     * Creates the transaction in message broker.\n+     *\n+     * @return a completable {@link Mono} which represent {@link DeliveryState}.\n+     */\n+    Mono<AmqpTransaction> createTransaction() {\n+        final Message message = Proton.message();\n+        Declare declare = new Declare();\n+        message.setBody(new AmqpValue(declare));\n+\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize = payloadSize + MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+        final byte[] bytes = new byte[allocationSize];\n+        final int encodedSize = message.encode(bytes, 0, allocationSize);\n+\n+        return sendLink.send(bytes, encodedSize, DeliveryImpl.DEFAULT_MESSAGE_FORMAT, null)\n+            .handle((outcome, sink) -> {\n+                if (!(outcome instanceof Declared)) {\n+                    sink.error(new IllegalArgumentException(\"Expected a Declared, received: \" + outcome));\n+                    return;\n+                }\n+\n+                final Declared state = (Declared) outcome;\n+                final DeliveryState.DeliveryStateType stateType = state.getType();\n+                switch (stateType) {\n+                    case Accepted:\n+                        break;\n+                    case Rejected:\n+                        break;\n+                    case Declared:\n+                        Binary txnId;\n+                        Declared declared = (Declared) outcome;\n+                        txnId = declared.getTxnId();\n+                        logger.verbose(\"Created new TX started: {}\", txnId);\n+                        sink.next(new AmqpTransaction(txnId.asByteBuffer()));\n+                        break;\n+                    default:\n+                        logger.warning(\"Unknown DeliveryState type: {}\", stateType);", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MjE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434782149", "bodyText": "private static final", "author": "conniey", "createdAt": "2020-06-03T18:49:54Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/AmqpTransactionTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.nio.ByteBuffer;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+/**\n+ * This have test for {@link AmqpTransaction}.\n+ * */\n+public class AmqpTransactionTest {\n+\n+    final private byte[] TRANSACTION_ID = \"1\".getBytes();", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5NjAzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434796030", "bodyText": "Why do we need a linkName parameter? It seems to always be the same name.", "author": "conniey", "createdAt": "2020-06-03T19:15:48Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -162,6 +180,117 @@ public Duration getOperationTimeout() {\n         return openTimeout;\n     }\n \n+    /**\n+     *\n+     * @return {@link Mono} of {@link TransactionCoordinator}\n+     */\n+    private Mono<TransactionCoordinator> createTransactionCoordinator() {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        if (transactionCoordinator != null) {\n+            logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(transactionCoordinator);\n+        }\n+\n+        synchronized (coordinatorLock) {\n+            return createCoordinatorSendLink(TRANSACTION_LINK_NAME, openTimeout, retryPolicy)\n+                .handle((amqpLink, sink) -> {\n+                    logger.info(\"Coordinator[{}]: Creating transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                    final TransactionCoordinator transactionCoordinator = new TransactionCoordinator(amqpLink,\n+                        messageSerializer);\n+                    sink.next(transactionCoordinator);\n+                });\n+        }\n+    }\n+\n+    private Mono<AmqpSendLink> createCoordinatorSendLink(String linkName, Duration timeout, AmqpRetryPolicy retry) {", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5ODE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434798153", "bodyText": "Should scope when we return a mock whenever possible. any*() is very large in scope. (ie. You can scope it to eq(transactionDeliveryState) instead of any(DeliveryState.class) so we don't have false positives in our tests.)", "author": "conniey", "createdAt": "2020-06-03T19:19:59Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -117,6 +124,38 @@ public void testLinkSize() throws IOException {\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n     }\n \n+    /**\n+     * Testing that we can send message with transaction.\n+     */\n+    @Test\n+    public void testSendWithTransaction() {\n+        // Arrange\n+        final String transactionId = \"1\";\n+        Message message = Proton.message();\n+        message.setMessageId(\"id\");\n+        message.setBody(new AmqpValue(\"hello\"));\n+\n+        DeliveryState transactionDeliveryState = getAmqpTransactionState(transactionId);\n+\n+\n+        ReactorSender reactorSender = new ReactorSender(entityPath, sender, handler, reactorProvider, tokenManager,\n+            messageSerializer, Duration.ofSeconds(1), new ExponentialAmqpRetryPolicy(new AmqpRetryOptions()));\n+        ReactorSender spyReactorSender = spy(reactorSender);\n+\n+        doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), any(DeliveryState.class));", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5ODUyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434798525", "bodyText": "Unit tests for creating transactions?", "author": "conniey", "createdAt": "2020-06-03T19:20:42Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSessionTest.java", "diffHunk": "@@ -68,8 +71,11 @@ public void setup() throws IOException {\n         MockReactorHandlerProvider handlerProvider = new MockReactorHandlerProvider(reactorProvider, null, handler, null, null);\n         AzureTokenManagerProvider azureTokenManagerProvider = new AzureTokenManagerProvider(\n             CbsAuthorizationType.SHARED_ACCESS_SIGNATURE, HOST, \"a-test-scope\");\n+        this.retryPolicy = RetryUtil.getRetryPolicy(new AmqpRetryOptions());\n         this.reactorSession = new ReactorSession(session, handler, NAME, reactorProvider, handlerProvider,\n-            Mono.just(cbsNode), azureTokenManagerProvider, serializer, TIMEOUT);\n+            Mono.just(cbsNode), azureTokenManagerProvider, serializer, TIMEOUT, retryPolicy);", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5OTEwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r434799107", "bodyText": "Scope the returns for your mocks.", "author": "conniey", "createdAt": "2020-06-03T19:21:46Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    private AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @MethodSource(\"commitParams\")\n+    @ParameterizedTest\n+    public void testCompleteTransactionRejected(boolean isCommit) {\n+        final Rejected outcome = new Rejected();\n+\n+        final AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), anyInt(), isNull());", "originalCommit": "b5bd10a2db13ef26c1f8f2df9ebbfbca9088c35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4062f1677ca69dcdcfd916abd64b7f76c8cfebea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4062f1677ca69dcdcfd916abd64b7f76c8cfebea", "message": "clean up and  test", "committedDate": "2020-06-03T23:59:16Z", "type": "commit"}, {"oid": "229f9f3645f18c78a27d5d99f7df53af4f370110", "url": "https://github.com/Azure/azure-sdk-for-java/commit/229f9f3645f18c78a27d5d99f7df53af4f370110", "message": " test improvement", "committedDate": "2020-06-04T00:09:35Z", "type": "commit"}, {"oid": "6a32f069666019f0f7585ea4798b06861f2fee5b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6a32f069666019f0f7585ea4798b06861f2fee5b", "message": "Added new AMQP api description in revapi", "committedDate": "2020-06-04T05:51:49Z", "type": "commit"}, {"oid": "ae6d10110df570ea48b72f1d3083bc124aa9648b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ae6d10110df570ea48b72f1d3083bc124aa9648b", "message": " changed smaple", "committedDate": "2020-06-04T17:10:59Z", "type": "commit"}, {"oid": "fdbd57bf4b61fc304aeb7d21472826464119df02", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fdbd57bf4b61fc304aeb7d21472826464119df02", "message": "Added sample and fix revapi chanegs", "committedDate": "2020-06-04T22:40:11Z", "type": "commit"}, {"oid": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/175f3922347b578c32dad59e1bbe949b6de9fb4b", "message": "Added code snippets", "committedDate": "2020-06-04T23:16:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzAzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435607037", "bodyText": "The @override annotations should be here since you are implementing from the interface.\nyour methods should be grouped by visibility. This is public whereas the ones above is private.", "author": "conniey", "createdAt": "2020-06-04T23:30:39Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -162,6 +180,118 @@ public Duration getOperationTimeout() {\n         return openTimeout;\n     }\n \n+    /**\n+     *\n+     * @return {@link Mono} of {@link TransactionCoordinator}\n+     */\n+    private Mono<TransactionCoordinator> createTransactionCoordinator() {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        if (transactionCoordinator != null) {\n+            logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(transactionCoordinator);\n+        }\n+\n+        synchronized (coordinatorLock) {\n+            return createCoordinatorSendLink(openTimeout, retryPolicy)\n+                .handle((amqpLink, sink) -> {\n+                    logger.info(\"Coordinator[{}]: Creating transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                    final TransactionCoordinator transactionCoordinator = new TransactionCoordinator(amqpLink,\n+                        messageSerializer);\n+                    sink.next(transactionCoordinator);\n+                });\n+        }\n+    }\n+\n+    private Mono<AmqpSendLink> createCoordinatorSendLink(Duration timeout, AmqpRetryPolicy retry) {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        final LinkSubscription<AmqpSendLink> existing = coordinator.get();\n+        if (existing != null) {\n+            logger.verbose(\"linkName[{}]: Returning existing coordinator send link.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(existing.getLink());\n+        }\n+\n+        return RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),\n+            timeout, retry)\n+            .then(Mono.<AmqpSendLink>create(sink -> {\n+                try {\n+                    // We have to invoke this in the same thread or else proton-j will not properly link up the created\n+                    // sender because the link names are not unique. Link name == entity path.\n+                    provider.getReactorDispatcher().invoke(() -> {\n+                        LinkSubscription<AmqpSendLink> linkLinkSubscription = getCoordinator(TRANSACTION_LINK_NAME,\n+                            timeout, retry);\n+\n+                        if (coordinator.compareAndSet(null, linkLinkSubscription)) {\n+                            logger.info(\"linkName[{}]: coordinator send link created.\", TRANSACTION_LINK_NAME);\n+                        } else {\n+                            logger.info(\"linkName[{}]: Another coordinator send link exists. Disposing of new one.\",\n+                                TRANSACTION_LINK_NAME);\n+                            linkLinkSubscription.dispose();\n+                        }\n+\n+                        sink.success(coordinator.get().getLink());\n+                    });\n+                } catch (IOException e) {\n+                    sink.error(e);\n+                }\n+            }));\n+    }\n+\n+    /**\n+     * NOTE: Ensure this is invoked using the reactor dispatcher because proton-j is not thread-safe.\n+     */\n+    private LinkSubscription<AmqpSendLink> getCoordinator(String linkName, Duration timeout, AmqpRetryPolicy retry) {\n+\n+        final Sender sender = session.sender(linkName);\n+        sender.setTarget(new Coordinator());\n+\n+        final Source source = new Source();\n+        sender.setSource(source);\n+        sender.setSenderSettleMode(SenderSettleMode.UNSETTLED);\n+\n+        final SendLinkHandler sendLinkHandler = handlerProvider.createSendLinkHandler(\n+            sessionHandler.getConnectionId(), sessionHandler.getHostname(), linkName, linkName);\n+        BaseHandler.setHandler(sender, sendLinkHandler);\n+\n+        sender.open();\n+\n+        final ReactorSender coordinator = new ReactorSender(linkName, sender, sendLinkHandler, provider, null,\n+            messageSerializer, timeout, retry);\n+\n+        final Disposable subscription = coordinator.getEndpointStates().subscribe(state -> { },\n+            error -> {\n+                logger.info(\"linkName[{}]: Error occurred. Removing and disposing coordinator link.\", linkName, error);\n+                removeLink(openSendLinks, linkName);\n+            }, () -> {\n+                logger.info(\"linkName[{}]: Complete. Removing and disposing coordinator link.\", linkName);\n+                removeLink(openSendLinks, linkName);\n+            });\n+        return new LinkSubscription<>(coordinator, subscription);\n+    }\n+\n+    public Mono<AmqpTransaction> createTransaction() {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzEyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435607128", "bodyText": "Does this need to be public?", "author": "conniey", "createdAt": "2020-06-04T23:30:56Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TransactionCoordinator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.Proton;\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.AmqpValue;\n+import org.apache.qpid.proton.amqp.transaction.Declare;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.amqp.transaction.Discharge;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.apache.qpid.proton.message.Message;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.amqp.implementation.ClientConstants.MAX_AMQP_HEADER_SIZE_BYTES;\n+\n+/**\n+ * Encapsulates transaction functions.\n+ */\n+public class TransactionCoordinator {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwODgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435608804", "bodyText": "This could be mocked rather than using a concrete implementation. Also, it is only used once.", "author": "conniey", "createdAt": "2020-06-04T23:33:48Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/ReactorSenderTest.java", "diffHunk": "@@ -168,15 +207,22 @@ public void testLinkSizeSmallerThanMessageSize() {\n             messageSerializer, Duration.ofSeconds(1), new ExponentialAmqpRetryPolicy(new AmqpRetryOptions()));\n         ReactorSender spyReactorSender = spy(reactorSender);\n \n-        doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt());\n+        doReturn(Mono.empty()).when(spyReactorSender).send(any(byte[].class), anyInt(), anyInt(), isNull());\n+\n         StepVerifier.create(spyReactorSender.send(message))\n             .verifyErrorSatisfies(throwable -> {\n                 Assertions.assertTrue(throwable instanceof AmqpException);\n                 Assertions.assertTrue(throwable.getMessage().startsWith(\"Error sending. Size of the payload exceeded \"\n                     + \"maximum message size\"));\n             });\n         verify(sender, times(1)).getRemoteMaxMessageSize();\n-        verify(spyReactorSender, times(0)).send(any(byte[].class), anyInt(), anyInt());\n+        verify(spyReactorSender, times(0)).send(any(byte[].class), anyInt(), anyInt(), isNull());\n+    }\n+\n+    private DeliveryState getAmqpTransactionState(String transactionId) {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMDM2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435610361", "bodyText": "Why protected?\nThere is a ValueSource that supports boolean. https://junit.org/junit5/docs/current/api/org.junit.jupiter.params/org/junit/jupiter/params/provider/ValueSource.html\nParams -> Parameters.", "author": "conniey", "createdAt": "2020-06-04T23:35:44Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    private AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @MethodSource(\"commitParams\")\n+    @ParameterizedTest\n+    public void testCompleteTransactionRejected(boolean isCommit) {\n+        final Rejected outcome = new Rejected();\n+\n+        final AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, isCommit))\n+            .verifyError(IllegalArgumentException.class);\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @MethodSource(\"commitParams\")\n+    @ParameterizedTest\n+    public void testCompleteTransaction(boolean isCommit) {\n+        final Accepted outcome = Accepted.getInstance();\n+\n+        final AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, isCommit))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @Test\n+    public void testCreateTransactionRejected() {\n+        Rejected outcome = new Rejected();\n+\n+        final TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.createTransaction())\n+            .verifyError(IllegalArgumentException.class);\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final Duration shortTimeout = Duration.ofSeconds(5);\n+        final byte[] transactionId = \"1\".getBytes();\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId)));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt(), isNull());\n+\n+        AmqpTransaction actual = transactionCoordinator.createTransaction().block(shortTimeout);\n+\n+        Assertions.assertNotNull(actual);\n+        Assertions.assertArrayEquals(transactionId, actual.getTransactionId().array());\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    protected static Stream<Arguments> commitParams() {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMDU3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435610574", "bodyText": "Use StepVerifier.", "author": "conniey", "createdAt": "2020-06-04T23:36:02Z", "path": "sdk/core/azure-core-amqp/src/test/java/com/azure/core/amqp/implementation/TransactionCoordinatorTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.amqp.implementation;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.isNull;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import com.azure.core.amqp.AmqpTransaction;\n+import java.nio.ByteBuffer;\n+import java.time.Duration;\n+import java.util.stream.Stream;\n+\n+import org.apache.qpid.proton.amqp.Binary;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.transaction.Declared;\n+import org.apache.qpid.proton.engine.impl.DeliveryImpl;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.publisher.Mono;\n+import reactor.test.StepVerifier;\n+\n+/**\n+ * Unit tests for {@link TransactionCoordinator}\n+ */\n+public class TransactionCoordinatorTest {\n+\n+    @Mock\n+    private MessageSerializer messageSerializer;\n+    @Mock\n+    private AmqpSendLink sendLink;\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+    }\n+\n+    @MethodSource(\"commitParams\")\n+    @ParameterizedTest\n+    public void testCompleteTransactionRejected(boolean isCommit) {\n+        final Rejected outcome = new Rejected();\n+\n+        final AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, isCommit))\n+            .verifyError(IllegalArgumentException.class);\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @MethodSource(\"commitParams\")\n+    @ParameterizedTest\n+    public void testCompleteTransaction(boolean isCommit) {\n+        final Accepted outcome = Accepted.getInstance();\n+\n+        final AmqpTransaction transaction = new AmqpTransaction(ByteBuffer.wrap(\"1\".getBytes()));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.completeTransaction(transaction, isCommit))\n+            .verifyComplete();\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @Test\n+    public void testCreateTransactionRejected() {\n+        Rejected outcome = new Rejected();\n+\n+        final TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(outcome)).when(sendLink).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+\n+        StepVerifier.create(transactionCoordinator.createTransaction())\n+            .verifyError(IllegalArgumentException.class);\n+\n+        verify(sendLink, times(1)).send(any(byte[].class), anyInt(), eq(DeliveryImpl.DEFAULT_MESSAGE_FORMAT), isNull());\n+    }\n+\n+    @Test\n+    public void testCreateTransaction() {\n+        final Duration shortTimeout = Duration.ofSeconds(5);\n+        final byte[] transactionId = \"1\".getBytes();\n+        Declared transactionState = new Declared();\n+        transactionState.setTxnId(Binary.create(ByteBuffer.wrap(transactionId)));\n+\n+        TransactionCoordinator transactionCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+\n+        doReturn(Mono.just(transactionState)).when(sendLink).send(any(byte[].class), anyInt(), anyInt(), isNull());\n+\n+        AmqpTransaction actual = transactionCoordinator.createTransaction().block(shortTimeout);", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMjM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435612357", "bodyText": "Use title casing. \"Complete a message with a transaction\"", "author": "conniey", "createdAt": "2020-06-04T23:38:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -221,6 +221,31 @@ public String getEntityPath() {\n         return abandon(lockToken, propertiesToModify, receiverOptions.getSessionId());\n     }\n \n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n+     * <p><strong>Complete a Message with transaction</strong></p>", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxMzA0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435613048", "bodyText": "There should be consistent indentation for javadocs. The throws param in a couple lines below, the continuation is indentation, but several places here, it is not.", "author": "conniey", "createdAt": "2020-06-04T23:39:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -238,7 +263,36 @@ public String getEntityPath() {\n      */\n     public Mono<Void> abandon(MessageLockToken lockToken, Map<String, Object> propertiesToModify, String sessionId) {\n         return updateDisposition(lockToken, DispositionStatus.ABANDONED, null, null,\n-            propertiesToModify, sessionId);\n+            propertiesToModify, sessionId, null);\n+    }\n+    /**\n+     * Abandon a {@link ServiceBusReceivedMessage message} with its lock token and updates the message's properties.\n+     * This will make the message available again for processing. Abandoning a message will increase the delivery count\n+     * on the message.\n+     *\n+     * @param lockToken Lock token of the message.\n+     * @param propertiesToModify Properties to modify on the message.\n+     * @param sessionId Session id of the message to abandon. {@code null} if there is no session.\n+     * @param transactionContext in which this operation is taking part in. The transaction should be created first by\n+     * {@link ServiceBusReceiverAsyncClient#createTransaction()} or", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435616711", "bodyText": "In the case of a transaction, why not just return the link.send(message, deliveryState); and when there isn't one, keep the link.send(message);? Not a fan of accepting null as a normal deliveryState. It would keep the behaviour we want explicit.", "author": "conniey", "createdAt": "2020-06-04T23:43:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -261,9 +347,16 @@ public String getEntityPath() {\n                     parentContext.set(tracerProvider.startSpan(\n                         entityContext.addData(HOST_NAME_KEY, link.getHostname()), ProcessKind.SEND));\n                 }\n+\n+                TransactionalState deliveryState = null;\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {\n+                    deliveryState = new TransactionalState();\n+                    deliveryState.setTxnId(new Binary(transactionContext.getTransactionId().array()));\n+                }", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNjkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435616936", "bodyText": "Keep visible methods together.  Public with public methods, followed by package-private then, private methods, etc.", "author": "conniey", "createdAt": "2020-06-04T23:44:39Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -279,6 +372,31 @@ public String getEntityPath() {\n \n     }\n \n+    /**\n+     * Sends a scheduled message to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param message Message to be sent to the Service Bus Queue.\n+     * @param scheduledEnqueueTime Instant at which the message should appear in the Service Bus queue or topic.\n+     * @param transactionContext to be set on message before sending to Service Bus.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code message}, {@code scheduledEnqueueTime}, {@code transactionContext} or\n+     * {@code transactionContext.transactionID} is {@code null}.\n+     */\n+    public Mono<Long> scheduleMessage(ServiceBusMessage message, Instant scheduledEnqueueTime,", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzAyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435617020", "bodyText": "Same about visibility.", "author": "conniey", "createdAt": "2020-06-04T23:44:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -446,4 +570,57 @@ public void close() {\n             return Collections.emptySet();\n         }\n     }\n+\n+    /**\n+     * Starts a new transaction on Service Bus. The {@link ServiceBusTransactionContext} should be passed along with\n+     * {@link ServiceBusReceivedMessage} or {@link MessageLockToken} to all operations that needs to be in\n+     * this transaction.\n+     *\n+     * @return a new {@link ServiceBusTransactionContext}.\n+     */\n+    public Mono<ServiceBusTransactionContext> createTransaction() {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435617091", "bodyText": "a completable mono?", "author": "conniey", "createdAt": "2020-06-04T23:45:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -446,4 +570,57 @@ public void close() {\n             return Collections.emptySet();\n         }\n     }\n+\n+    /**\n+     * Starts a new transaction on Service Bus. The {@link ServiceBusTransactionContext} should be passed along with\n+     * {@link ServiceBusReceivedMessage} or {@link MessageLockToken} to all operations that needs to be in\n+     * this transaction.\n+     *\n+     * @return a new {@link ServiceBusTransactionContext}.\n+     */\n+    public Mono<ServiceBusTransactionContext> createTransaction() {\n+        if (isDisposed.get()) {\n+            return monoError(logger, new IllegalStateException(\n+                String.format(INVALID_OPERATION_DISPOSED_RECEIVER, \"createTransaction\")));\n+        }\n+\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getTransactionManager())\n+            .flatMap(transactionManager -> transactionManager.createTransaction())\n+            .map(byteBuffer -> new ServiceBusTransactionContext(byteBuffer));\n+    }\n+\n+    /**\n+     * Commits the transaction given {@link ServiceBusTransactionContext}. This will make a call to Service Bus.\n+     *\n+     * @param transactionContext to be committed.\n+     * @return a completable {@link Mono}.", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzg0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435617848", "bodyText": "I remember I had tried to keep the methods grouped by visibility, and then alphabetised.. so if you go to source, you wouldn't have to jump around. The send method should be with all its friends. Same with any o5ther public method you added.", "author": "conniey", "createdAt": "2020-06-04T23:48:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderClient.java", "diffHunk": "@@ -101,6 +101,62 @@ public Long scheduleMessage(ServiceBusMessage message, Instant scheduledEnqueueT\n         return asyncClient.scheduleMessage(message, scheduledEnqueueTime).block(tryTimeout);\n     }\n \n+    /**\n+     * Sends a scheduled message to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time.\n+     *\n+     * @param message Message to be sent to the Service Bus Queue or Topic.\n+     * @param scheduledEnqueueTime Instant at which the message should appear in the Service Bus queue or topic.\n+     * @param transactionContext to be set on message before sending to Service Bus.\n+     *\n+     * @return The sequence number of the scheduled message which can be used to cancel the scheduling of the message.\n+     *\n+     * @throws NullPointerException if {@code message} or {@code scheduledEnqueueTime} is {@code null}.\n+     */\n+    public Long scheduleMessage(ServiceBusMessage message, Instant scheduledEnqueueTime,", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODE4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618180", "bodyText": "This check is repeated many times, you can simplify it by having a boolean before this switch method. final boolean hasTransaction = context != null && ...", "author": "conniey", "createdAt": "2020-06-04T23:49:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -107,11 +111,19 @@ static Instant convertDotNetTicksToInstant(long dotNetTicks) {\n      * @return The corresponding DeliveryState, or null if the disposition status is unknown.\n      */\n     public static DeliveryState getDeliveryState(DispositionStatus dispositionStatus, String deadLetterReason,\n-        String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n+        ServiceBusTransactionContext transactionContext) {\n         final DeliveryState state;\n         switch (dispositionStatus) {\n             case COMPLETED:\n-                state = Accepted.getInstance();\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODM2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618369", "bodyText": "tState = transactionState", "author": "conniey", "createdAt": "2020-06-04T23:50:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -107,11 +111,19 @@ static Instant convertDotNetTicksToInstant(long dotNetTicks) {\n      * @return The corresponding DeliveryState, or null if the disposition status is unknown.\n      */\n     public static DeliveryState getDeliveryState(DispositionStatus dispositionStatus, String deadLetterReason,\n-        String deadLetterErrorDescription, Map<String, Object> propertiesToModify) {\n+        String deadLetterErrorDescription, Map<String, Object> propertiesToModify,\n+        ServiceBusTransactionContext transactionContext) {\n         final DeliveryState state;\n         switch (dispositionStatus) {\n             case COMPLETED:\n-                state = Accepted.getInstance();\n+                if (transactionContext != null && transactionContext.getTransactionId() != null) {\n+                    TransactionalState tState = new TransactionalState();", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODQ3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618472", "bodyText": "Unused import.", "author": "conniey", "createdAt": "2020-06-04T23:50:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusAmqpConnection.java", "diffHunk": "@@ -5,6 +5,7 @@\n \n import com.azure.core.amqp.AmqpConnection;\n import com.azure.core.amqp.AmqpRetryOptions;\n+//import com.azure.core.amqp.implementation.AmqpCoordinatorLink;", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODUyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618522", "bodyText": "nit; emptyline.", "author": "conniey", "createdAt": "2020-06-04T23:50:45Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java", "diffHunk": "@@ -197,6 +198,35 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n             });\n     }\n \n+    @Override\n+    public Mono<TransactionManager> getTransactionManager() {\n+        final String linkName = \"coordinator\";\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"connectionId[%s]: Connection is disposed. Cannot get transaction coordinator instance for '%s'\",\n+                connectionId, linkName))));\n+        }\n+\n+", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODU3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618572", "bodyText": "Why mono.defer?", "author": "conniey", "createdAt": "2020-06-04T23:50:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java", "diffHunk": "@@ -197,6 +198,35 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n             });\n     }\n \n+    @Override\n+    public Mono<TransactionManager> getTransactionManager() {\n+        final String linkName = \"coordinator\";\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"connectionId[%s]: Connection is disposed. Cannot get transaction coordinator instance for '%s'\",\n+                connectionId, linkName))));\n+        }\n+\n+\n+        final TransactionManager existing = transactionManagers.get(linkName);\n+        if (existing != null) {\n+            return Mono.just(existing);\n+        }\n+\n+        return getReactorConnection().then(\n+            Mono.defer(() -> Mono.just(transactionManagers.compute(linkName, (key, current) -> {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4MjgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435682804", "bodyText": "removed it, not using transactionmanager", "author": "hemanttanwar", "createdAt": "2020-06-05T04:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODYyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435618621", "bodyText": "Remove.", "author": "conniey", "createdAt": "2020-06-04T23:51:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorReceiver.java", "diffHunk": "@@ -343,7 +343,11 @@ private void cleanupWorkItems() {\n     }\n \n     private void completeWorkItem(String lockToken, Delivery delivery, MonoSink<Void> sink, Throwable error) {\n-        final boolean isSettled = delivery != null && delivery.remotelySettled();\n+        boolean isSettled = delivery != null && delivery.remotelySettled();\n+        /*if (workItem.getDeliveryState() instanceof  TransactionalState){", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxOTAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435619034", "bodyText": "This only has a single key it can be, why is it managed by a map?", "author": "conniey", "createdAt": "2020-06-04T23:52:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java", "diffHunk": "@@ -197,6 +198,35 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n             });\n     }\n \n+    @Override\n+    public Mono<TransactionManager> getTransactionManager() {\n+        final String linkName = \"coordinator\";", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMDUzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435620538", "bodyText": "I'm looking through the usage of this.. and do we really need a TransactionManager class? This always calls getSession(\"coordinator\"), namespace, \"coordinator\"), then passes any calls onto the session. Why not expose the methods as-is. (ie. createTransaction()) and underneath, keep that \"coordinator\" session. The TransactionManager class isn't managing any transactions.", "author": "conniey", "createdAt": "2020-06-04T23:58:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java", "diffHunk": "@@ -197,6 +198,35 @@ public ServiceBusReactorAmqpConnection(String connectionId, ConnectionOptions co\n             });\n     }\n \n+    @Override\n+    public Mono<TransactionManager> getTransactionManager() {", "originalCommit": "175f3922347b578c32dad59e1bbe949b6de9fb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4MDY4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r435680681", "bodyText": "I was debating it, it provide little bit of abstraction from AmqpSession in client itself but not a big gain any way. I will remove it.", "author": "hemanttanwar", "createdAt": "2020-06-05T04:14:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyMDUzOA=="}], "type": "inlineReview"}, {"oid": "fedfc46101b9088dcdec0c2a8affaf7f6a1e24e4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fedfc46101b9088dcdec0c2a8affaf7f6a1e24e4", "message": "Adding more unit test and refactoring", "committedDate": "2020-06-05T04:52:24Z", "type": "commit"}, {"oid": "d1a1ed7c36ca39de830e80bcd8a296ca3430bbd9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d1a1ed7c36ca39de830e80bcd8a296ca3430bbd9", "message": "more docs, sample, code snippets", "committedDate": "2020-06-05T07:14:55Z", "type": "commit"}, {"oid": "86ccb9af30173c6eb767aa060188ff07d666c215", "url": "https://github.com/Azure/azure-sdk-for-java/commit/86ccb9af30173c6eb767aa060188ff07d666c215", "message": "cleanup", "committedDate": "2020-06-05T09:21:25Z", "type": "commit"}, {"oid": "d84764713985fd851a20552db0494c13f9fc0d34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d84764713985fd851a20552db0494c13f9fc0d34", "message": "added unit test", "committedDate": "2020-06-05T15:48:32Z", "type": "commit"}, {"oid": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2f9ca4a1d4d4258d3853961342e6fabd33325924", "message": "integration test cleanup", "committedDate": "2020-06-05T17:19:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA1OTg4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436059889", "bodyText": "extra semicolon.", "author": "conniey", "createdAt": "2020-06-05T17:25:39Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSender.java", "diffHunk": "@@ -15,10 +15,11 @@\n import org.apache.qpid.proton.amqp.Binary;\n import org.apache.qpid.proton.amqp.Symbol;\n import org.apache.qpid.proton.amqp.UnsignedLong;\n-import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Accepted;;", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MDMyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436060322", "bodyText": "private final -> and move this up with the other final variables.", "author": "conniey", "createdAt": "2020-06-05T17:26:30Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -60,6 +66,11 @@\n     private final ReactorHandlerProvider handlerProvider;\n     private final Mono<ClaimsBasedSecurityNode> cbsNodeSupplier;\n \n+    private final AtomicReference<LinkSubscription<AmqpSendLink>> coordinatorLink = new AtomicReference<>();\n+\n+    private AmqpRetryPolicy retryPolicy;\n+    private AtomicReference<TransactionCoordinator> transactionCoordinator = new AtomicReference<>();", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2MzE3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436063171", "bodyText": "Is this used anywhere? I don't see it.", "author": "conniey", "createdAt": "2020-06-05T17:31:57Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -115,6 +128,10 @@ Session session() {\n         return this.session;\n     }\n \n+    AmqpRetryPolicy getRetryPolicy() {", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTU3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436075577", "bodyText": "You've moved the other methods. Can you alphabetise these too, up there?", "author": "conniey", "createdAt": "2020-06-05T17:55:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderClient.java", "diffHunk": "@@ -152,4 +208,33 @@ public void send(ServiceBusMessageBatch batch) {\n     public void close() {\n         asyncClient.close();\n     }\n+\n+    /**", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5MDAyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436090025", "bodyText": "again moved, I did put friends together, like all send together and other except this one.\nAlthough all the transaction related messages are friend but they can not be ordered since their name are create, commit, rollback. So I decided to take an exception and kept all transaction related API together.", "author": "hemanttanwar", "createdAt": "2020-06-05T18:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTc4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436075781", "bodyText": "You're missing the @throws for these methods.", "author": "conniey", "createdAt": "2020-06-05T17:55:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderClient.java", "diffHunk": "@@ -152,4 +208,33 @@ public void send(ServiceBusMessageBatch batch) {\n     public void close() {\n         asyncClient.close();\n     }\n+\n+    /**\n+     * Starts a new transaction on Service Bus. The {@link ServiceBusTransactionContext} should be passed along with\n+     * {@link ServiceBusReceivedMessage} or {@link MessageLockToken} to all operations that needs to be in\n+     * this transaction.\n+     *\n+     * @return a new {@link ServiceBusTransactionContext}.\n+     */\n+    public ServiceBusTransactionContext createTransaction() {\n+        return asyncClient.createTransaction().block(tryTimeout);\n+    }\n+\n+    /**\n+     * Commits the transaction given {@link ServiceBusTransactionContext}. This will make a call to Service Bus.\n+     *\n+     * @param transactionContext to be committed.", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NTk5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436075993", "bodyText": "There is an @Immutable annotation, iirc.", "author": "conniey", "createdAt": "2020-06-05T17:56:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusTransactionContext.java", "diffHunk": "@@ -0,0 +1,26 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents transaction in service. This object just contains transaction id. Transaction management operations\n+ * like create transaction, rollback and commit operation needs to be done using sender/receiver ServiceBusClients.\n+ */\n+public class ServiceBusTransactionContext {", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NzQ3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436077478", "bodyText": "These three lines of code show up many times. Can we get a messageUtils.getTRansactionState(ByteBuffer or Context ) and consolidate this?", "author": "conniey", "createdAt": "2020-06-05T17:58:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -129,15 +144,29 @@ public static DeliveryState getDeliveryState(DispositionStatus dispositionStatus\n                 error.setInfo(errorInfo);\n                 rejected.setError(error);\n \n-                state = rejected;\n+                if (hasTransaction) {\n+                    TransactionalState transactionalState = new TransactionalState();\n+                    transactionalState.setTxnId(new Binary(transactionContext.getTransactionId().array()));\n+                    transactionalState.setOutcome(rejected);\n+                    state = transactionalState;\n+                } else {\n+                    state = rejected;\n+                }\n                 break;\n             case ABANDONED:\n                 final Modified outcome = new Modified();\n                 if (propertiesToModify != null) {\n                     outcome.setMessageAnnotations(propertiesToModify);\n                 }\n \n-                state = outcome;\n+                if (hasTransaction) {\n+                    TransactionalState transactionalState = new TransactionalState();", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODA3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436078070", "bodyText": "The way we've used transaction here is not reactive. I don't think we want people to have to create an atomic reference every time they create a transaction.", "author": "conniey", "createdAt": "2020-06-05T18:00:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageWithTransactionAsyncSample.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.SignalType;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class ReceiveMessageWithTransactionAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to use transaction API and settle the {@link ServiceBusReceivedMessage}\n+     * as part of a transaction.\n+     *\n+     * @param args Unused arguments to the program.\n+     * @throws InterruptedException If the program is unable to sleep while waiting for the operations to complete.\n+     */\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = \"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n+            + \"SharedAccessKey={key}\";\n+\n+        // Create a receiver.\n+        // \"<<fully-qualified-namespace>>\" will look similar to \"{your-namespace}.servicebus.windows.net\"\n+        // \"<<queue-name>>\" will be the name of the Service Bus queue instance you created\n+        // inside the Service Bus namespace.\n+        ServiceBusClientBuilder builder = new ServiceBusClientBuilder()\n+            .connectionString(connectionString);\n+\n+        // At most, the receiver will automatically renew the message lock until 120 seconds have elapsed.\n+        // By default, after messages are processed, the onus is on users to complete, abandon, defer, or dead-letter the\n+        // message when they are finished with it.\n+\n+        ServiceBusReceiverAsyncClient receiver = builder\n+            .receiver()\n+            .receiveMode(ReceiveMode.PEEK_LOCK)\n+            .queueName(\"<<queue-name>>\")\n+            .maxAutoLockRenewalDuration(Duration.ofSeconds(120))\n+            .buildAsyncClient();\n+\n+        ServiceBusSenderAsyncClient sender = builder.sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        List<ServiceBusMessage> messages = new ArrayList<>();\n+        messages.add(new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8)));\n+        messages.add(new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8)));\n+\n+        // Send some messages.\n+        sender.send(messages).block();\n+\n+        // Hold the transaction.\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // Transaction is actually started in ServiceBus until you perform first operation\n+        // (Example receiver.complete(message, transaction)) with it.\n+        // Create transaction and start receiving messages\n+        Disposable subscription = receiver.createTransaction()\n+            .flatMapMany(transactionContext -> {", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3ODQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436078418", "bodyText": "This callback/method could end long before this completes and the receiver is disposed.", "author": "conniey", "createdAt": "2020-06-05T18:00:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageWithTransactionAsyncSample.java", "diffHunk": "@@ -0,0 +1,108 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.messaging.servicebus.models.ReceiveMode;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.SignalType;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class ReceiveMessageWithTransactionAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to use transaction API and settle the {@link ServiceBusReceivedMessage}\n+     * as part of a transaction.\n+     *\n+     * @param args Unused arguments to the program.\n+     * @throws InterruptedException If the program is unable to sleep while waiting for the operations to complete.\n+     */\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = \"Endpoint={fully-qualified-namespace};SharedAccessKeyName={policy-name};\"\n+            + \"SharedAccessKey={key}\";\n+\n+        // Create a receiver.\n+        // \"<<fully-qualified-namespace>>\" will look similar to \"{your-namespace}.servicebus.windows.net\"\n+        // \"<<queue-name>>\" will be the name of the Service Bus queue instance you created\n+        // inside the Service Bus namespace.\n+        ServiceBusClientBuilder builder = new ServiceBusClientBuilder()\n+            .connectionString(connectionString);\n+\n+        // At most, the receiver will automatically renew the message lock until 120 seconds have elapsed.\n+        // By default, after messages are processed, the onus is on users to complete, abandon, defer, or dead-letter the\n+        // message when they are finished with it.\n+\n+        ServiceBusReceiverAsyncClient receiver = builder\n+            .receiver()\n+            .receiveMode(ReceiveMode.PEEK_LOCK)\n+            .queueName(\"<<queue-name>>\")\n+            .maxAutoLockRenewalDuration(Duration.ofSeconds(120))\n+            .buildAsyncClient();\n+\n+        ServiceBusSenderAsyncClient sender = builder.sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        List<ServiceBusMessage> messages = new ArrayList<>();\n+        messages.add(new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8)));\n+        messages.add(new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8)));\n+\n+        // Send some messages.\n+        sender.send(messages).block();\n+\n+        // Hold the transaction.\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // Transaction is actually started in ServiceBus until you perform first operation\n+        // (Example receiver.complete(message, transaction)) with it.\n+        // Create transaction and start receiving messages\n+        Disposable subscription = receiver.createTransaction()\n+            .flatMapMany(transactionContext -> {\n+                transaction.set(transactionContext);\n+                return receiver.receive();\n+            })\n+            .take(2)\n+            .flatMap(context -> {\n+                boolean messageProcessed = true;\n+                // Process the context and its message here.\n+                // Change the `messageProcessed` according to you business logic and if you are able to process the\n+                // message successfully.\n+\n+                if (messageProcessed) {\n+                    return receiver.complete(context.getMessage(), transaction.get());\n+                } else {\n+                    return receiver.abandon(context.getMessage(), null, transaction.get());\n+                }\n+            })\n+            .doFinally(signal -> {\n+                if (signal == SignalType.ON_COMPLETE) {\n+                    receiver.commitTransaction(transaction.get()).subscribe();", "originalCommit": "2f9ca4a1d4d4258d3853961342e6fabd33325924", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c366e1cd25827d4ce64bb1bfee5c319793013b47", "message": "Review comment", "committedDate": "2020-06-05T18:54:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNjk4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436116988", "bodyText": "linkLinkSubscription?", "author": "conniey", "createdAt": "2020-06-05T19:17:43Z", "path": "sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/ReactorSession.java", "diffHunk": "@@ -225,6 +266,104 @@ public boolean removeLink(String linkName) {\n         return removeLink(openSendLinks, linkName) || removeLink(openReceiveLinks, linkName);\n     }\n \n+    /**\n+     *\n+     * @return {@link Mono} of {@link TransactionCoordinator}\n+     */\n+    private Mono<TransactionCoordinator> createTransactionCoordinator() {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+        TransactionCoordinator existing = transactionCoordinator.get();\n+        if (existing != null) {\n+            logger.verbose(\"Coordinator[{}]: Returning existing transaction coordinator.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(existing);\n+        }\n+\n+        return createCoordinatorSendLink(openTimeout, retryPolicy)\n+            .map(sendLink -> {\n+                TransactionCoordinator newCoordinator = new TransactionCoordinator(sendLink, messageSerializer);\n+                if (transactionCoordinator.compareAndSet(null, newCoordinator)) {\n+                    logger.info(\"Coordinator[{}]: Created transaction coordinator.\", TRANSACTION_LINK_NAME);\n+                } else {\n+                    logger.info(\"linkName[{}]: Another transaction coordinator exists.\", TRANSACTION_LINK_NAME);\n+                }\n+                return transactionCoordinator.get();\n+            });\n+    }\n+\n+    private Mono<AmqpSendLink> createCoordinatorSendLink(Duration timeout, AmqpRetryPolicy retry) {\n+        if (isDisposed()) {\n+            return Mono.error(logger.logExceptionAsError(new IllegalStateException(String.format(\n+                \"Cannot create coordinator send link '%s' from a closed session.\", TRANSACTION_LINK_NAME))));\n+        }\n+\n+        final LinkSubscription<AmqpSendLink> existing = coordinatorLink.get();\n+        if (existing != null) {\n+            logger.verbose(\"linkName[{}]: Returning existing coordinator send link.\", TRANSACTION_LINK_NAME);\n+            return Mono.just(existing.getLink());\n+        }\n+\n+        return RetryUtil.withRetry(\n+            getEndpointStates().takeUntil(state -> state == AmqpEndpointState.ACTIVE),\n+            timeout, retry)\n+            .then(Mono.<AmqpSendLink>create(sink -> {\n+                try {\n+                    // We have to invoke this in the same thread or else proton-j will not properly link up the created\n+                    // sender because the link names are not unique. Link name == entity path.\n+                    provider.getReactorDispatcher().invoke(() -> {\n+                        LinkSubscription<AmqpSendLink> linkLinkSubscription = getCoordinator(TRANSACTION_LINK_NAME,", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNzkwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436117904", "bodyText": "remove en-us from links.", "author": "conniey", "createdAt": "2020-06-05T19:20:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusTransactionContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents transaction in service. This object just contains transaction id. Transaction management operations\n+ * like create transaction, rollback and commit operation needs to be done using sender/receiver ServiceBusClients.\n+ * A transaction times out after 2 minutes. The transaction timer starts when the first operation in the transaction\n+ * starts.\n+ *\n+ * @see <a href=\"https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-transactions#transactions-in-service-bus\">", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODA5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436118094", "bodyText": "Gets the transaction id.", "author": "conniey", "createdAt": "2020-06-05T19:20:27Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusTransactionContext.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.annotation.Immutable;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Represents transaction in service. This object just contains transaction id. Transaction management operations\n+ * like create transaction, rollback and commit operation needs to be done using sender/receiver ServiceBusClients.\n+ * A transaction times out after 2 minutes. The transaction timer starts when the first operation in the transaction\n+ * starts.\n+ *\n+ * @see <a href=\"https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-transactions#transactions-in-service-bus\">\n+ *     Transaction Overciew</a>\n+ *\n+ * @see <a href=\"https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-transactions#timeout\">\n+ *     Transaction Timeout</a>\n+\n+ *\n+ */\n+@Immutable\n+public class ServiceBusTransactionContext {\n+    private final ByteBuffer transactionId;\n+\n+    ServiceBusTransactionContext(ByteBuffer transactionId) {\n+        this.transactionId = transactionId;\n+    }\n+\n+    /**\n+     * Represents the service-side transactionID", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODI5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436118290", "bodyText": "Fix spacing.", "author": "conniey", "createdAt": "2020-06-05T19:20:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -222,4 +247,11 @@ static Throwable toException(ServiceBusErrorCondition errorCondition, String des\n \n         return reorderedBytes;\n     }\n+\n+    private  static TransactionalState getTransactionState(ByteBuffer transactionId, Outcome outcome) {", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436118418", "bodyText": "Why do we need this lock.", "author": "conniey", "createdAt": "2020-06-05T19:21:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusReactorAmqpConnection.java", "diffHunk": "@@ -45,6 +45,7 @@\n      */\n     private final ConcurrentHashMap<String, AmqpSendLink> sendLinks = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<String, ServiceBusManagementNode> managementNodes = new ConcurrentHashMap<>();\n+    private final Object transactionManagerLock = new Object();", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODYxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436118618", "bodyText": "Why is it multiplied by 2.", "author": "conniey", "createdAt": "2020-06-05T19:21:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -48,7 +48,7 @@\n \n public abstract class IntegrationTestBase extends TestBase {\n     protected static final Duration OPERATION_TIMEOUT = Duration.ofSeconds(30);\n-    protected static final Duration TIMEOUT = Duration.ofSeconds(60);\n+    protected static final Duration TIMEOUT = Duration.ofSeconds(60 * 2);", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MTAxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436171011", "bodyText": "left over, removing", "author": "hemanttanwar", "createdAt": "2020-06-05T21:25:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTAwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436119008", "bodyText": "can you add a getBuilder method here so we can consolidate these sections of duplicated code.", "author": "conniey", "createdAt": "2020-06-05T19:22:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -278,13 +311,25 @@ protected ServiceBusReceiverClientBuilder getReceiverBuilder(boolean useCredenti\n     }\n \n     protected ServiceBusSessionReceiverClientBuilder getSessionReceiverBuilder(boolean useCredentials,\n-        MessagingEntityType entityType, Function<ServiceBusClientBuilder, ServiceBusClientBuilder> onBuilderCreate) {\n+        MessagingEntityType entityType, Function<ServiceBusClientBuilder, ServiceBusClientBuilder> onBuilderCreate,\n+        boolean sharedConnection) {\n+\n+        ServiceBusClientBuilder builder;", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTEyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436119124", "bodyText": "Txn -> Transaction", "author": "conniey", "createdAt": "2020-06-05T19:22:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/IntegrationTestBase.java", "diffHunk": "@@ -294,14 +339,36 @@ protected ServiceBusSessionReceiverClientBuilder getSessionReceiverBuilder(boole\n                 assertNotNull(topicName, \"'topicName' cannot be null.\");\n                 assertNotNull(subscriptionName, \"'subscriptionName' cannot be null.\");\n \n-                return onBuilderCreate.apply(getBuilder(useCredentials))\n+                return onBuilderCreate.apply(builder)\n                     .sessionReceiver()\n                     .topicName(topicName).subscriptionName(subscriptionName);\n             default:\n                 throw logger.logExceptionAsError(new IllegalArgumentException(\"Unknown entity type: \" + entityType));\n         }\n     }\n \n+    protected static Stream<Arguments> messagingEntityProviderWithTransaction() {\n+        return Stream.of(\n+            Arguments.of(MessagingEntityType.QUEUE, true),\n+            Arguments.of(MessagingEntityType.SUBSCRIPTION, true),\n+            Arguments.of(MessagingEntityType.QUEUE, false),\n+            Arguments.of(MessagingEntityType.SUBSCRIPTION, false)\n+        );\n+    }\n+\n+    protected static Stream<Arguments> messagingEntityWithSessionsWithTxn() {", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTUyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436119522", "bodyText": "nit: new line.", "author": "conniey", "createdAt": "2020-06-05T19:23:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientTest.java", "diffHunk": "@@ -674,4 +756,13 @@ void cannotRenewMessageLockInSession() {\n             .mapToObj(index -> getMessage(PAYLOAD_BYTES, messageTrackingUUID, map))\n             .collect(Collectors.toList());\n     }\n+    protected static Stream<Arguments> dispositionStatus() {", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMDIyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436120226", "bodyText": "Stepverifier.", "author": "conniey", "createdAt": "2020-06-05T19:25:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -83,6 +89,284 @@ protected void afterTest() {\n         } finally {\n             dispose(receiver, sender, receiveAndDeleteReceiver);\n         }\n+\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction.\n+     */\n+    @Test\n+    void createTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+    /**\n+     * Verifies that we can create multiple transaction using sender and receiver.\n+     */\n+    @Test\n+    void createMultipleTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and complete.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n+        // Arrange\n+        Duration timeout = Duration.ofSeconds(60);\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(OPERATION_TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.complete(receivedMessage, transaction.get()))\n+            .verifyComplete();\n+\n+        receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertMessageEquals(received, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and commit/rollback.\n+     */\n+    @Test\n+    void createAndCompleteTansactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * This specifically test that we can use lockToken. This use case is valid when a message is moved from one\n+     * machine to another machine and user just have access to lock token.\n+     * Verifies that we can complete a message with lock token only with a transaction and rollback.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionWithLockTokenTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        ServiceBusReceiverAsyncClient receiverNonConnectionSharing = getReceiverBuilder(false, entityType,\n+            Function.identity()).buildAsyncClient();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // create a transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        AtomicReference<MessageLockToken> messageLockToken = new AtomicReference<>();\n+\n+        // receive a message and get lock token.\n+        StepVerifier.create(receiver.receive().next()\n+            .map(messageContext -> {\n+                ServiceBusReceivedMessage received =  messageContext.getMessage();\n+                messageLockToken.set(MessageLockToken.fromString(received.getLockToken()));\n+                return messageContext;\n+            }))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, messageId, isSessionEnabled))\n+            .verifyComplete();\n+\n+        // complete the message using lock token only using a receiver which represent a different machine\n+        StepVerifier.create(receiverNonConnectionSharing.complete(messageLockToken.get(), transaction.get()))\n+            .verifyComplete();\n+\n+        // rollback the transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.rollbackTransaction(transaction.get()))\n+            .verifyComplete();\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext receivedContext = receiveAndDeleteReceiver.receive().next().block(TIMEOUT);\n+        assertMessageEquals(receivedContext, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can do following using shared connection.\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. receive and settle with transactionContext.\n+     * 4. commit Rollback this transaction.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")\n+    @ParameterizedTest\n+    void transactionSendReceiveAndSettle(MessagingEntityType entityType, boolean isSessionEnabled,\n+         boolean commitTransaction, DispositionStatus dispositionStatus) {\n+\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled, true);\n+\n+        final String messageId1 = \"1\";\n+        final ServiceBusMessage message1 = getMessage(messageId1, isSessionEnabled);\n+        final String messageId2 = \"2\";\n+        final ServiceBusMessage message2 = getMessage(messageId2, isSessionEnabled);\n+        final String deadLetterReason = \"testing\";\n+        sendMessage(message1).block(TIMEOUT);\n+\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        assertNotNull(transaction.get());\n+\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message2, transaction.get()))\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+        final Mono<Void> operation;\n+        if (DispositionStatus.ABANDONED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.abandon(receivedMessage, null, sessionId, transaction.get());\n+        } else if (DispositionStatus.ABANDONED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.abandon(receivedMessage, null, transaction.get());\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(deadLetterReason);\n+            operation = receiver.deadLetter(receivedMessage, deadLetterOptions, sessionId, transaction.get());\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && !isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(deadLetterReason);\n+            operation = receiver.deadLetter(receivedMessage, deadLetterOptions, transaction.get());\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.complete(receivedMessage, sessionId, transaction.get());\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.complete(receivedMessage, transaction.get());\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.defer(receivedMessage, null, sessionId, transaction.get());\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.defer(receivedMessage, null, transaction.get());\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Disposition status not recognized for this test case: \" + dispositionStatus));\n+        }\n+\n+        StepVerifier.create(operation)\n+            .verifyComplete();\n+\n+        if (commitTransaction) {\n+            StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+                .verifyComplete();\n+        } else {\n+            StepVerifier.create(receiver.rollbackTransaction(transaction.get()))\n+                .verifyComplete();\n+        }\n+    }\n+\n+    /**\n+     * Verifies that we can do following on different clients i.e. sender and receiver.\n+     * 1. create transaction using sender\n+     * 2. receive and complete with transactionContext.\n+     * 3. Commit this transaction using sender.\n+     */\n+    @MethodSource(\"messagingEntityWithSessions\")\n+    @ParameterizedTest\n+    void transactionReceiveCompleteCommitMixClient(MessagingEntityType entityType, boolean isSessionEnabled) {\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled, true);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        assertNotNull(transaction.get());\n+\n+        // Assert & Act\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(TIMEOUT);", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTQ2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436121464", "bodyText": "There is only one operation in here. I'm not sure this is actually testing a transaction.", "author": "conniey", "createdAt": "2020-06-05T19:28:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -83,6 +89,284 @@ protected void afterTest() {\n         } finally {\n             dispose(receiver, sender, receiveAndDeleteReceiver);\n         }\n+\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction.\n+     */\n+    @Test\n+    void createTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+    /**\n+     * Verifies that we can create multiple transaction using sender and receiver.\n+     */\n+    @Test\n+    void createMultipleTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and complete.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n+        // Arrange\n+        Duration timeout = Duration.ofSeconds(60);\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(OPERATION_TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.complete(receivedMessage, transaction.get()))\n+            .verifyComplete();\n+\n+        receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertMessageEquals(received, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and commit/rollback.\n+     */\n+    @Test\n+    void createAndCompleteTansactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * This specifically test that we can use lockToken. This use case is valid when a message is moved from one\n+     * machine to another machine and user just have access to lock token.\n+     * Verifies that we can complete a message with lock token only with a transaction and rollback.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionWithLockTokenTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        ServiceBusReceiverAsyncClient receiverNonConnectionSharing = getReceiverBuilder(false, entityType,\n+            Function.identity()).buildAsyncClient();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // create a transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        AtomicReference<MessageLockToken> messageLockToken = new AtomicReference<>();\n+\n+        // receive a message and get lock token.\n+        StepVerifier.create(receiver.receive().next()\n+            .map(messageContext -> {\n+                ServiceBusReceivedMessage received =  messageContext.getMessage();\n+                messageLockToken.set(MessageLockToken.fromString(received.getLockToken()));\n+                return messageContext;\n+            }))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, messageId, isSessionEnabled))\n+            .verifyComplete();\n+\n+        // complete the message using lock token only using a receiver which represent a different machine\n+        StepVerifier.create(receiverNonConnectionSharing.complete(messageLockToken.get(), transaction.get()))\n+            .verifyComplete();\n+\n+        // rollback the transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.rollbackTransaction(transaction.get()))\n+            .verifyComplete();\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext receivedContext = receiveAndDeleteReceiver.receive().next().block(TIMEOUT);\n+        assertMessageEquals(receivedContext, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can do following using shared connection.\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. receive and settle with transactionContext.\n+     * 4. commit Rollback this transaction.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")\n+    @ParameterizedTest\n+    void transactionSendReceiveAndSettle(MessagingEntityType entityType, boolean isSessionEnabled,\n+         boolean commitTransaction, DispositionStatus dispositionStatus) {\n+\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled, true);\n+\n+        final String messageId1 = \"1\";\n+        final ServiceBusMessage message1 = getMessage(messageId1, isSessionEnabled);\n+        final String messageId2 = \"2\";\n+        final ServiceBusMessage message2 = getMessage(messageId2, isSessionEnabled);\n+        final String deadLetterReason = \"testing\";\n+        sendMessage(message1).block(TIMEOUT);\n+\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        assertNotNull(transaction.get());\n+\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message2, transaction.get()))\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+        final Mono<Void> operation;\n+        if (DispositionStatus.ABANDONED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.abandon(receivedMessage, null, sessionId, transaction.get());\n+        } else if (DispositionStatus.ABANDONED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.abandon(receivedMessage, null, transaction.get());\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(deadLetterReason);\n+            operation = receiver.deadLetter(receivedMessage, deadLetterOptions, sessionId, transaction.get());\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && !isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(deadLetterReason);\n+            operation = receiver.deadLetter(receivedMessage, deadLetterOptions, transaction.get());\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.complete(receivedMessage, sessionId, transaction.get());\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.complete(receivedMessage, transaction.get());\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && isSessionEnabled) {\n+            operation = receiver.defer(receivedMessage, null, sessionId, transaction.get());\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && !isSessionEnabled) {\n+            operation = receiver.defer(receivedMessage, null, transaction.get());\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Disposition status not recognized for this test case: \" + dispositionStatus));\n+        }\n+\n+        StepVerifier.create(operation)\n+            .verifyComplete();\n+\n+        if (commitTransaction) {\n+            StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+                .verifyComplete();\n+        } else {\n+            StepVerifier.create(receiver.rollbackTransaction(transaction.get()))\n+                .verifyComplete();\n+        }\n+    }\n+\n+    /**\n+     * Verifies that we can do following on different clients i.e. sender and receiver.\n+     * 1. create transaction using sender", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436123586", "bodyText": "It overlaps functionality of the previous test method. I think we can just remove this.", "author": "conniey", "createdAt": "2020-06-05T19:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMjg1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436122852", "bodyText": "txn -> transaction.", "author": "conniey", "createdAt": "2020-06-05T19:31:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -83,6 +89,284 @@ protected void afterTest() {\n         } finally {\n             dispose(receiver, sender, receiveAndDeleteReceiver);\n         }\n+\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction.\n+     */\n+    @Test\n+    void createTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+    /**\n+     * Verifies that we can create multiple transaction using sender and receiver.\n+     */\n+    @Test\n+    void createMultipleTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and complete.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n+        // Arrange\n+        Duration timeout = Duration.ofSeconds(60);\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(OPERATION_TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.complete(receivedMessage, transaction.get()))\n+            .verifyComplete();\n+\n+        receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertMessageEquals(received, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and commit/rollback.\n+     */\n+    @Test\n+    void createAndCompleteTansactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * This specifically test that we can use lockToken. This use case is valid when a message is moved from one\n+     * machine to another machine and user just have access to lock token.\n+     * Verifies that we can complete a message with lock token only with a transaction and rollback.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionWithLockTokenTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        ServiceBusReceiverAsyncClient receiverNonConnectionSharing = getReceiverBuilder(false, entityType,\n+            Function.identity()).buildAsyncClient();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // create a transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        AtomicReference<MessageLockToken> messageLockToken = new AtomicReference<>();\n+\n+        // receive a message and get lock token.\n+        StepVerifier.create(receiver.receive().next()\n+            .map(messageContext -> {\n+                ServiceBusReceivedMessage received =  messageContext.getMessage();\n+                messageLockToken.set(MessageLockToken.fromString(received.getLockToken()));\n+                return messageContext;\n+            }))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, messageId, isSessionEnabled))\n+            .verifyComplete();\n+\n+        // complete the message using lock token only using a receiver which represent a different machine\n+        StepVerifier.create(receiverNonConnectionSharing.complete(messageLockToken.get(), transaction.get()))\n+            .verifyComplete();\n+\n+        // rollback the transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.rollbackTransaction(transaction.get()))\n+            .verifyComplete();\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext receivedContext = receiveAndDeleteReceiver.receive().next().block(TIMEOUT);\n+        assertMessageEquals(receivedContext, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can do following using shared connection.\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. receive and settle with transactionContext.\n+     * 4. commit Rollback this transaction.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzE5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436123195", "bodyText": "It's not valuable to test every combination. It makes this exponentially longer to run. Choose a couple.", "author": "conniey", "createdAt": "2020-06-05T19:32:29Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -83,6 +89,284 @@ protected void afterTest() {\n         } finally {\n             dispose(receiver, sender, receiveAndDeleteReceiver);\n         }\n+\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction.\n+     */\n+    @Test\n+    void createTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+    /**\n+     * Verifies that we can create multiple transaction using sender and receiver.\n+     */\n+    @Test\n+    void createMultipleTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and complete.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n+        // Arrange\n+        Duration timeout = Duration.ofSeconds(60);\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(OPERATION_TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.complete(receivedMessage, transaction.get()))\n+            .verifyComplete();\n+\n+        receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertMessageEquals(received, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and commit/rollback.\n+     */\n+    @Test\n+    void createAndCompleteTansactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * This specifically test that we can use lockToken. This use case is valid when a message is moved from one\n+     * machine to another machine and user just have access to lock token.\n+     * Verifies that we can complete a message with lock token only with a transaction and rollback.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionWithLockTokenTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        ServiceBusReceiverAsyncClient receiverNonConnectionSharing = getReceiverBuilder(false, entityType,\n+            Function.identity()).buildAsyncClient();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // create a transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        AtomicReference<MessageLockToken> messageLockToken = new AtomicReference<>();\n+\n+        // receive a message and get lock token.\n+        StepVerifier.create(receiver.receive().next()\n+            .map(messageContext -> {\n+                ServiceBusReceivedMessage received =  messageContext.getMessage();\n+                messageLockToken.set(MessageLockToken.fromString(received.getLockToken()));\n+                return messageContext;\n+            }))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, messageId, isSessionEnabled))\n+            .verifyComplete();\n+\n+        // complete the message using lock token only using a receiver which represent a different machine\n+        StepVerifier.create(receiverNonConnectionSharing.complete(messageLockToken.get(), transaction.get()))\n+            .verifyComplete();\n+\n+        // rollback the transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.rollbackTransaction(transaction.get()))\n+            .verifyComplete();\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext receivedContext = receiveAndDeleteReceiver.receive().next().block(TIMEOUT);\n+        assertMessageEquals(receivedContext, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can do following using shared connection.\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. receive and settle with transactionContext.\n+     * 4. commit Rollback this transaction.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")\n+    @ParameterizedTest\n+    void transactionSendReceiveAndSettle(MessagingEntityType entityType, boolean isSessionEnabled,", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436123754", "bodyText": "commitTransaction.", "author": "conniey", "createdAt": "2020-06-05T19:33:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverClientIntegrationTest.java", "diffHunk": "@@ -189,6 +190,66 @@ void receiveNoMessage(MessagingEntityType entityType, boolean isSessionEnabled)\n         assertEquals(noMessages, messages.stream().count());\n     }\n \n+    /**\n+     * Verifies that we can send, receive one message and settle.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")\n+    @ParameterizedTest\n+    void transactionMessageAndSettle(MessagingEntityType entityType, boolean isSessionEnabled, boolean commitTxn,\n+        DispositionStatus dispositionStatus) {\n+\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        int maxMessages = 1;\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message);\n+\n+        // Act & Assert\n+        final Stream<ServiceBusReceivedMessage> messages = receiver.receive(maxMessages, TIMEOUT)\n+            .stream().map(ServiceBusReceivedMessageContext::getMessage);\n+\n+        final ServiceBusTransactionContext transaction = receiver.createTransaction();\n+\n+        List<ServiceBusReceivedMessage> messageList = messages.collect(Collectors.toList());\n+        assertEquals(maxMessages, messageList.size());\n+\n+        ServiceBusReceivedMessage receivedMessage = messageList.get(0);\n+\n+        if (DispositionStatus.ABANDONED == dispositionStatus && isSessionEnabled) {\n+            receiver.abandon(receivedMessage, null, sessionId, transaction);\n+        } else if (DispositionStatus.ABANDONED == dispositionStatus && !isSessionEnabled) {\n+            receiver.abandon(receivedMessage, null, transaction);\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(\"For testing.\");\n+            receiver.deadLetter(receivedMessage, deadLetterOptions, sessionId, transaction);\n+        } else if (DispositionStatus.SUSPENDED == dispositionStatus && !isSessionEnabled) {\n+            DeadLetterOptions deadLetterOptions = new DeadLetterOptions().setDeadLetterReason(\"For testing.\");\n+            receiver.deadLetter(receivedMessage, deadLetterOptions, transaction);\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && isSessionEnabled) {\n+            receiver.complete(receivedMessage, sessionId, transaction);\n+            messagesPending.decrementAndGet();\n+        } else if (DispositionStatus.COMPLETED == dispositionStatus && !isSessionEnabled) {\n+            receiver.complete(receivedMessage, transaction);\n+            messagesPending.decrementAndGet();\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && isSessionEnabled) {\n+            receiver.defer(receivedMessage, null, sessionId, transaction);\n+        } else if (DispositionStatus.DEFERRED == dispositionStatus && !isSessionEnabled) {\n+            receiver.defer(receivedMessage, null, transaction);\n+        } else {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"Disposition status not recognized for this test case: \" + dispositionStatus));\n+        }\n+\n+        if (commitTxn) {", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436124143", "bodyText": "This block of code is hard to follow same with the sync case below. Can we split this into two test cases, one with sessions and one with not sessions.", "author": "conniey", "createdAt": "2020-06-05T19:34:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -83,6 +89,284 @@ protected void afterTest() {\n         } finally {\n             dispose(receiver, sender, receiveAndDeleteReceiver);\n         }\n+\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction.\n+     */\n+    @Test\n+    void createTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+    /**\n+     * Verifies that we can create multiple transaction using sender and receiver.\n+     */\n+    @Test\n+    void createMultipleTransactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+\n+        StepVerifier.create(sender.createTransaction())\n+            .assertNext(Assertions::assertNotNull)\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and complete.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n+        // Arrange\n+        Duration timeout = Duration.ofSeconds(60);\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(OPERATION_TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.complete(receivedMessage, transaction.get()))\n+            .verifyComplete();\n+\n+        receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n+        assertMessageEquals(received, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can create transaction and commit/rollback.\n+     */\n+    @Test\n+    void createAndCompleteTansactionTest() {\n+        // Arrange\n+        setSenderAndReceiver(MessagingEntityType.QUEUE, false);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        StepVerifier.create(receiver.commitTransaction(transaction.get()))\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * This specifically test that we can use lockToken. This use case is valid when a message is moved from one\n+     * machine to another machine and user just have access to lock token.\n+     * Verifies that we can complete a message with lock token only with a transaction and rollback.\n+     */\n+    @MethodSource(\"messagingEntityProvider\")\n+    @ParameterizedTest\n+    void transactionWithLockTokenTest(MessagingEntityType entityType) {\n+\n+        // Arrange\n+        boolean isSessionEnabled = false;\n+        setSenderAndReceiver(entityType, isSessionEnabled);\n+        ServiceBusReceiverAsyncClient receiverNonConnectionSharing = getReceiverBuilder(false, entityType,\n+            Function.identity()).buildAsyncClient();\n+\n+        final String messageId = UUID.randomUUID().toString();\n+        final ServiceBusMessage message = getMessage(messageId, isSessionEnabled);\n+\n+        sendMessage(message).block(TIMEOUT);\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+\n+        // create a transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+\n+        AtomicReference<MessageLockToken> messageLockToken = new AtomicReference<>();\n+\n+        // receive a message and get lock token.\n+        StepVerifier.create(receiver.receive().next()\n+            .map(messageContext -> {\n+                ServiceBusReceivedMessage received =  messageContext.getMessage();\n+                messageLockToken.set(MessageLockToken.fromString(received.getLockToken()));\n+                return messageContext;\n+            }))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, messageId, isSessionEnabled))\n+            .verifyComplete();\n+\n+        // complete the message using lock token only using a receiver which represent a different machine\n+        StepVerifier.create(receiverNonConnectionSharing.complete(messageLockToken.get(), transaction.get()))\n+            .verifyComplete();\n+\n+        // rollback the transaction.\n+        StepVerifier.create(receiverNonConnectionSharing.rollbackTransaction(transaction.get()))\n+            .verifyComplete();\n+\n+        // read the message back, since it was rolled-back previously.\n+        final ServiceBusReceivedMessageContext receivedContext = receiveAndDeleteReceiver.receive().next().block(TIMEOUT);\n+        assertMessageEquals(receivedContext, messageId, isSessionEnabled);\n+\n+        messagesPending.decrementAndGet();\n+    }\n+\n+    /**\n+     * Verifies that we can do following using shared connection.\n+     * 1. create transaction\n+     * 2. send message  with transactionContext\n+     * 3. receive and settle with transactionContext.\n+     * 4. commit Rollback this transaction.\n+     */\n+    @MethodSource(\"messagingEntityTxnWithSessions\")\n+    @ParameterizedTest\n+    void transactionSendReceiveAndSettle(MessagingEntityType entityType, boolean isSessionEnabled,\n+         boolean commitTransaction, DispositionStatus dispositionStatus) {\n+\n+        // Arrange\n+        setSenderAndReceiver(entityType, isSessionEnabled, true);\n+\n+        final String messageId1 = \"1\";\n+        final ServiceBusMessage message1 = getMessage(messageId1, isSessionEnabled);\n+        final String messageId2 = \"2\";\n+        final ServiceBusMessage message2 = getMessage(messageId2, isSessionEnabled);\n+        final String deadLetterReason = \"testing\";\n+        sendMessage(message1).block(TIMEOUT);\n+\n+\n+        // Assert & Act\n+        AtomicReference<ServiceBusTransactionContext> transaction = new AtomicReference<>();\n+        StepVerifier.create(receiver.createTransaction())\n+            .assertNext(txn -> {\n+                transaction.set(txn);\n+                assertNotNull(transaction);\n+            })\n+            .verifyComplete();\n+        assertNotNull(transaction.get());\n+\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message2, transaction.get()))\n+            .verifyComplete();\n+\n+        final ServiceBusReceivedMessageContext receivedContext = receiver.receive().next().block(TIMEOUT);\n+        assertNotNull(receivedContext);\n+\n+        final ServiceBusReceivedMessage receivedMessage = receivedContext.getMessage();\n+        assertNotNull(receivedMessage);\n+        final Mono<Void> operation;\n+        if (DispositionStatus.ABANDONED == dispositionStatus && isSessionEnabled) {", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDQxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436124413", "bodyText": "This doesn't need to be changed.", "author": "conniey", "createdAt": "2020-06-05T19:35:37Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ServiceBusMessageProcessorTest.java", "diffHunk": "@@ -1,5 +1,6 @@\n // Copyright (c) Microsoft Corporation. All rights reserved.\n // Licensed under the MIT License.\n+", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDc1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436124751", "bodyText": "Create an issue to test that new behaviour for transaction behaviour you added.", "author": "conniey", "createdAt": "2020-06-05T19:36:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/implementation/ManagementChannelTests.java", "diffHunk": "@@ -59,6 +59,7 @@\n import static org.junit.jupiter.api.Assertions.assertNull;", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTk3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436141973", "bodyText": "https://app.zenhub.com/workspaces/azure-sdk-team-5bdca72c4b5806bc2bf0aab2/issues/azure/azure-sdk-for-java/11832", "author": "hemanttanwar", "createdAt": "2020-06-05T20:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNTI2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436125262", "bodyText": "Do you need to capture it? The 336 already returns only when the parameters are equal.", "author": "conniey", "createdAt": "2020-06-05T19:37:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientTest.java", "diffHunk": "@@ -224,6 +322,35 @@ void scheduleMessage() {\n         Assertions.assertEquals(scheduledEnqueueTime, scheduledEnqueueTimeActual);\n     }\n \n+    /**\n+     * Verifies that scheduling a message will result in calling asyncSender.scheduleMessage() with transaction.\n+     */\n+    @Test\n+    void scheduleMessageWithTransaction() {\n+        // Arrange\n+        final ServiceBusMessage testData =\n+            new ServiceBusMessage(TEST_CONTENTS.getBytes(UTF_8));\n+        final Instant scheduledEnqueueTime = Instant.now();\n+        final long sequenceNumber = 1;\n+\n+        when(asyncSender.scheduleMessage(testData, scheduledEnqueueTime, transactionContext)).thenReturn(Mono.just(sequenceNumber));\n+\n+        // Act\n+        sender.scheduleMessage(testData, scheduledEnqueueTime, transactionContext);\n+\n+        // Assert\n+        verify(asyncSender, times(1)).scheduleMessage(testData, scheduledEnqueueTime, transactionContext);\n+        verify(asyncSender).scheduleMessage(singleMessageCaptor.capture(), scheduleMessageCaptor.capture(), transactionCaptor.capture());", "originalCommit": "c366e1cd25827d4ce64bb1bfee5c319793013b47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNTUyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436125525", "bodyText": "Same with ones above.", "author": "conniey", "createdAt": "2020-06-05T19:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNTI2Mg=="}], "type": "inlineReview"}, {"oid": "549c618ab7291458b7b90d8c251004f6c7402386", "url": "https://github.com/Azure/azure-sdk-for-java/commit/549c618ab7291458b7b90d8c251004f6c7402386", "message": "review commenst", "committedDate": "2020-06-05T21:00:10Z", "type": "commit"}, {"oid": "ccec75d2ee48a2db4bd5554f128b1fc25f52b0ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ccec75d2ee48a2db4bd5554f128b1fc25f52b0ee", "message": "review comments", "committedDate": "2020-06-05T21:36:45Z", "type": "commit"}, {"oid": "c28edebeff67643550ef22b8e31a50c9bd6ac87a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c28edebeff67643550ef22b8e31a50c9bd6ac87a", "message": "getting ready merge master", "committedDate": "2020-06-05T21:40:28Z", "type": "commit"}, {"oid": "663dac49d053f1cb7e6d0bb7664a551b68dab004", "url": "https://github.com/Azure/azure-sdk-for-java/commit/663dac49d053f1cb7e6d0bb7664a551b68dab004", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java", "committedDate": "2020-06-05T21:43:35Z", "type": "commit"}, {"oid": "04a6f6e4a783409db83d980036191068a3a699bd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/04a6f6e4a783409db83d980036191068a3a699bd", "message": "merge master into branch", "committedDate": "2020-06-05T21:50:11Z", "type": "commit"}, {"oid": "bd7c7cae5ec5909e04968cea5449df76f7a1d3fb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bd7c7cae5ec5909e04968cea5449df76f7a1d3fb", "message": "minor naming changes", "committedDate": "2020-06-05T21:55:44Z", "type": "commit"}, {"oid": "e98ca727429a8cd204414c5324c5842015844a02", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e98ca727429a8cd204414c5324c5842015844a02", "message": " reshuffle ofder of methods", "committedDate": "2020-06-05T22:13:36Z", "type": "commit"}, {"oid": "6073def0e98f680d267b32a0dc4be3e5d54604b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6073def0e98f680d267b32a0dc4be3e5d54604b9", "message": "Increasing timeout for live  test", "committedDate": "2020-06-06T16:18:25Z", "type": "commit"}, {"oid": "f3c66c872ddd684ffdd671085476cf9bf265ff31", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3c66c872ddd684ffdd671085476cf9bf265ff31", "message": "auto renewlock test disable", "committedDate": "2020-06-06T19:03:51Z", "type": "commit"}, {"oid": "e6842c2aebf369c301b120ac0ffa9db47a23b2b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e6842c2aebf369c301b120ac0ffa9db47a23b2b3", "message": "auto renewlock test disable", "committedDate": "2020-06-06T20:13:09Z", "type": "commit"}, {"oid": "d4cd8c112de0501ced64d1dea87ca162efe6bba9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4cd8c112de0501ced64d1dea87ca162efe6bba9", "message": "Disable transaction live test to see overall the time taken", "committedDate": "2020-06-06T23:35:09Z", "type": "commit"}, {"oid": "c1ec53d4dd69cbe22552e01e345d33a4be4393d9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c1ec53d4dd69cbe22552e01e345d33a4be4393d9", "message": "Disable transaction live test to see overall the time taken", "committedDate": "2020-06-07T00:30:41Z", "type": "commit"}, {"oid": "6cb9cb98eef34606eff5fb888821ba61bd77a2e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6cb9cb98eef34606eff5fb888821ba61bd77a2e2", "message": "Chanegd test to optimize running time", "committedDate": "2020-06-07T04:06:36Z", "type": "commit"}, {"oid": "176691bff45f0586eb5f9703110bb835ccdc1bce", "url": "https://github.com/Azure/azure-sdk-for-java/commit/176691bff45f0586eb5f9703110bb835ccdc1bce", "message": "Adjusting test for timeout", "committedDate": "2020-06-07T06:53:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDYyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436334620", "bodyText": "I hope these comments are cleaned up before you merge your commits.", "author": "conniey", "createdAt": "2020-06-07T07:31:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -146,11 +146,11 @@ void createTransactionAndRollbackMessagesTest(MessagingEntityType entityType) {\n             .verifyComplete();\n \n         receiver.rollbackTransaction(transaction.get()).delaySubscription(Duration.ofSeconds(5)).block(timeout);\n-\n+        logger.verbose(\"!!!! Test rollback done Waiting to receiveAndDeleteReceiver.receive \");\n         // read the message back, since it was rolled-back previously.\n         final ServiceBusReceivedMessageContext received = receiveAndDeleteReceiver.receive().next().block(OPERATION_TIMEOUT);\n         assertMessageEquals(received, messageId, isSessionEnabled);\n-\n+        logger.verbose(\"!!!! Test Done  receiveAndDeleteReceiver.receive \");", "originalCommit": "c1ec53d4dd69cbe22552e01e345d33a4be4393d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM3NTM0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/11305#discussion_r436375340", "bodyText": "Yes will do, I am adjusting live test and testing since it is taking longer time specially when transaction rollback, server does not release lock and we have to wait  longer for it.", "author": "hemanttanwar", "createdAt": "2020-06-07T15:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDYyMA=="}], "type": "inlineReview"}, {"oid": "d88a5acd300763260b03cc5320328b7ade138808", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d88a5acd300763260b03cc5320328b7ade138808", "message": "Adjusting live test to complete sooner", "committedDate": "2020-06-07T15:33:51Z", "type": "commit"}, {"oid": "69132d45e89a35529360fa46b3f08107a1292327", "url": "https://github.com/Azure/azure-sdk-for-java/commit/69132d45e89a35529360fa46b3f08107a1292327", "message": "Adjusting live test to complete sooner", "committedDate": "2020-06-07T15:42:23Z", "type": "commit"}, {"oid": "934528c2a2316df4f16aa9906ecca1e3f9702f5b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/934528c2a2316df4f16aa9906ecca1e3f9702f5b", "message": "Adjusting live test to complete sooner", "committedDate": "2020-06-07T16:27:34Z", "type": "commit"}]}