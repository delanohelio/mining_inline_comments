{"pr_number": 14383, "pr_title": "Azure Search Documents Performance Tests", "pr_createdAt": "2020-08-24T21:08:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14383", "timeline": [{"oid": "9a982cac5d501f629a9d662ea50229d6b5279548", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9a982cac5d501f629a9d662ea50229d6b5279548", "message": "azure-search-documents performance tests for autocomplete, search, suggest, and document indexing", "committedDate": "2020-08-24T21:04:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzMzEyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476633124", "bodyText": "justCurious why delay is added ?", "author": "g2vinay", "createdAt": "2020-08-25T17:52:10Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/core/ServiceTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf.core;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.http.netty.NettyAsyncHttpClientBuilder;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.perf.test.core.PerfStressOptions;\n+import com.azure.perf.test.core.PerfStressTest;\n+import com.azure.search.documents.SearchAsyncClient;\n+import com.azure.search.documents.SearchClient;\n+import com.azure.search.documents.indexes.SearchIndexAsyncClient;\n+import com.azure.search.documents.indexes.SearchIndexClientBuilder;\n+import com.azure.search.documents.indexes.models.IndexDocumentsBatch;\n+import com.azure.search.documents.indexes.models.SearchIndex;\n+import com.azure.search.documents.indexes.models.SearchSuggester;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * Base class for Azure Search performance tests.\n+ */\n+public abstract class ServiceTest<TOptions extends PerfStressOptions> extends PerfStressTest<TOptions> {\n+    private static final String CONFIGURATION_ERROR = \"Configuration %s must be set in either environment variables \"\n+        + \"or system properties.%n\";\n+    private static final String ALLOWED_INDEX_CHARACTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n+    private static final int INDEX_NAME_LENGTH = 24;\n+\n+    protected static final String SUGGESTER_NAME = \"sg\";\n+\n+    protected final SearchClient searchClient;\n+    protected final SearchAsyncClient searchAsyncClient;\n+\n+    private final SearchIndexAsyncClient searchIndexAsyncClient;\n+    private final String indexName;\n+\n+    public ServiceTest(TOptions options) {\n+        super(options);\n+\n+        String searchEndpoint = Configuration.getGlobalConfiguration().get(\"SEARCH_ENDPOINT\");\n+        if (CoreUtils.isNullOrEmpty(searchEndpoint)) {\n+            System.out.printf(CONFIGURATION_ERROR, \"SEARCH_ENDPOINT\");\n+            System.exit(1);\n+        }\n+\n+        String searchApiKey = Configuration.getGlobalConfiguration().get(\"SEARCH_API_KEY\");\n+        if (CoreUtils.isNullOrEmpty(searchApiKey)) {\n+            System.out.printf(CONFIGURATION_ERROR, \"SEARCH_API_KEY\");\n+            System.exit(1);\n+        }\n+\n+        SearchIndexClientBuilder builder = new SearchIndexClientBuilder()\n+            .endpoint(searchEndpoint)\n+            .credential(new AzureKeyCredential(searchApiKey))\n+            .httpClient(new NettyAsyncHttpClientBuilder().build());\n+\n+        this.searchIndexAsyncClient = builder.buildAsyncClient();\n+\n+        Random random = new Random();\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for (int i = 0; i < INDEX_NAME_LENGTH; i++) {\n+            stringBuilder.append(ALLOWED_INDEX_CHARACTERS.charAt(random.nextInt(ALLOWED_INDEX_CHARACTERS.length())));\n+        }\n+\n+        this.indexName = stringBuilder.toString();\n+\n+        this.searchClient = builder.buildClient().getSearchClient(this.indexName);\n+        this.searchAsyncClient = this.searchIndexAsyncClient.getSearchAsyncClient(this.indexName);\n+    }\n+\n+    @Override\n+    public Mono<Void> globalSetupAsync() {\n+        return searchIndexAsyncClient\n+            .createIndex(new SearchIndex(indexName, SearchIndexAsyncClient.buildSearchFields(Hotel.class, null))\n+                .setSuggesters(new SearchSuggester(SUGGESTER_NAME, Arrays.asList(\"Description\", \"HotelName\"))))\n+            .then();\n+    }\n+\n+    @Override\n+    public Mono<Void> globalCleanupAsync() {\n+        return searchIndexAsyncClient.deleteIndex(indexName);\n+    }\n+\n+    protected Mono<Void> populateIndex(int documentCount, String documentSize) {\n+        /*\n+         * Generate the count of documents using the given size. Then, upload the documents in batches of 100, this\n+         * prevents the batch from triggering the services request size limit to fail. Finally, continuously poll the\n+         * index for its document count until it is equal to the count passed.\n+         */\n+        return Mono.defer(() -> {\n+            List<Hotel> hotels = DocumentGenerator.generateHotels(documentCount, DocumentSize.valueOf(documentSize));\n+\n+            return Flux.range(0, (int) Math.ceil(hotels.size() / 100D))\n+                .map(i -> hotels.subList(i * 100, Math.min((i + 1) * 100, hotels.size())))\n+                .flatMap(hotelDocuments -> searchAsyncClient.indexDocuments(new IndexDocumentsBatch<Hotel>()\n+                    .addUploadActions(hotelDocuments)))\n+                .then();\n+        }).then(Mono.defer(() -> searchAsyncClient.getDocumentCount()\n+            .delaySubscription(Duration.ofSeconds(1))", "originalCommit": "9a982cac5d501f629a9d662ea50229d6b5279548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1MDAxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476650013", "bodyText": "Document indexing doesn't always complete instantly, so I don't want to begin testing while it is still running nor do I want to spam the service with a ton of requests.", "author": "alzimmermsft", "createdAt": "2020-08-25T18:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzMzEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NjQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476646429", "bodyText": "The indexName generation logic can be optionally replaced with this.\n this.indexName  =  random.ints(0, ALLOWED_INDEX_CHARACTERS.length())\n            .limit(INDEX_NAME_LENGTH)\n            .collect(StringBuilder::new, ((stringBuilder, value) -> stringBuilder.append(ALLOWED_INDEX_CHARACTERS.charAt(value))), StringBuilder::append)\n            .toString();", "author": "g2vinay", "createdAt": "2020-08-25T18:16:13Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/core/ServiceTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf.core;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.http.netty.NettyAsyncHttpClientBuilder;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.perf.test.core.PerfStressOptions;\n+import com.azure.perf.test.core.PerfStressTest;\n+import com.azure.search.documents.SearchAsyncClient;\n+import com.azure.search.documents.SearchClient;\n+import com.azure.search.documents.indexes.SearchIndexAsyncClient;\n+import com.azure.search.documents.indexes.SearchIndexClientBuilder;\n+import com.azure.search.documents.indexes.models.IndexDocumentsBatch;\n+import com.azure.search.documents.indexes.models.SearchIndex;\n+import com.azure.search.documents.indexes.models.SearchSuggester;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * Base class for Azure Search performance tests.\n+ */\n+public abstract class ServiceTest<TOptions extends PerfStressOptions> extends PerfStressTest<TOptions> {\n+    private static final String CONFIGURATION_ERROR = \"Configuration %s must be set in either environment variables \"\n+        + \"or system properties.%n\";\n+    private static final String ALLOWED_INDEX_CHARACTERS = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n+    private static final int INDEX_NAME_LENGTH = 24;\n+\n+    protected static final String SUGGESTER_NAME = \"sg\";\n+\n+    protected final SearchClient searchClient;\n+    protected final SearchAsyncClient searchAsyncClient;\n+\n+    private final SearchIndexAsyncClient searchIndexAsyncClient;\n+    private final String indexName;\n+\n+    public ServiceTest(TOptions options) {\n+        super(options);\n+\n+        String searchEndpoint = Configuration.getGlobalConfiguration().get(\"SEARCH_ENDPOINT\");\n+        if (CoreUtils.isNullOrEmpty(searchEndpoint)) {\n+            System.out.printf(CONFIGURATION_ERROR, \"SEARCH_ENDPOINT\");\n+            System.exit(1);\n+        }\n+\n+        String searchApiKey = Configuration.getGlobalConfiguration().get(\"SEARCH_API_KEY\");\n+        if (CoreUtils.isNullOrEmpty(searchApiKey)) {\n+            System.out.printf(CONFIGURATION_ERROR, \"SEARCH_API_KEY\");\n+            System.exit(1);\n+        }\n+\n+        SearchIndexClientBuilder builder = new SearchIndexClientBuilder()\n+            .endpoint(searchEndpoint)\n+            .credential(new AzureKeyCredential(searchApiKey))\n+            .httpClient(new NettyAsyncHttpClientBuilder().build());\n+\n+        this.searchIndexAsyncClient = builder.buildAsyncClient();\n+\n+        Random random = new Random();\n+        StringBuilder stringBuilder = new StringBuilder();\n+        for (int i = 0; i < INDEX_NAME_LENGTH; i++) {\n+            stringBuilder.append(ALLOWED_INDEX_CHARACTERS.charAt(random.nextInt(ALLOWED_INDEX_CHARACTERS.length())));\n+        }\n+\n+        this.indexName = stringBuilder.toString();", "originalCommit": "9a982cac5d501f629a9d662ea50229d6b5279548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcyODQwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476728409", "bodyText": "Will do a slight variant on this, using random.ints(long streamSize, int lowerBound, int upperBound).", "author": "alzimmermsft", "createdAt": "2020-08-25T20:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NjQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NzI0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476647245", "bodyText": "Add Test Suffix to the Test Name ?\nTo have them identify as Test classes ?\nWill also make it consistent with the naming pattern in other perf test projects.", "author": "g2vinay", "createdAt": "2020-08-25T18:17:40Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/Autocomplete.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf;\n+\n+import com.azure.search.documents.models.AutocompleteItem;\n+import com.azure.search.perf.core.SearchPerfStressOptions;\n+import com.azure.search.perf.core.ServiceTest;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Performs autocomplete operations.\n+ */\n+public class Autocomplete extends ServiceTest<SearchPerfStressOptions> {", "originalCommit": "9a982cac5d501f629a9d662ea50229d6b5279548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY1MDM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476650344", "bodyText": "Will add Test suffix to all test classes.", "author": "alzimmermsft", "createdAt": "2020-08-25T18:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0NzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476675179", "bodyText": "Do we need some sort of validation that at least one item is received? since .then() just replays a complete/error signal.. is it possible autocomplete returns mono.empty() and this will still pass.", "author": "conniey", "createdAt": "2020-08-25T19:07:30Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/Autocomplete.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf;\n+\n+import com.azure.search.documents.models.AutocompleteItem;\n+import com.azure.search.perf.core.SearchPerfStressOptions;\n+import com.azure.search.perf.core.ServiceTest;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Performs autocomplete operations.\n+ */\n+public class Autocomplete extends ServiceTest<SearchPerfStressOptions> {\n+    public Autocomplete(SearchPerfStressOptions options) {\n+        super(options);\n+    }\n+\n+    @Override\n+    public Mono<Void> globalSetupAsync() {\n+        /*\n+         * First, run the global setup in the super class. That will create the index to be used for performance\n+         * testing. Then populate the index with a given number of documents.\n+         */\n+        return super.globalSetupAsync().then(populateIndex(options.getCount(), options.getDocumentSize()));\n+    }\n+\n+    @Override\n+    public void run() {\n+        searchClient.autocomplete(\"historic\", SUGGESTER_NAME).forEach(AutocompleteItem::getText);\n+    }\n+\n+    @Override\n+    public Mono<Void> runAsync() {\n+        return searchAsyncClient.autocomplete(\"historic\", SUGGESTER_NAME)\n+            .map(AutocompleteItem::getText)\n+            .then();", "originalCommit": "9a982cac5d501f629a9d662ea50229d6b5279548", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjcyNjI5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476726292", "bodyText": "Should be simple to add in validation.", "author": "alzimmermsft", "createdAt": "2020-08-25T20:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY3NTM1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r476675354", "bodyText": "Some validation that we get at least one item?", "author": "conniey", "createdAt": "2020-08-25T19:07:50Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/Autocomplete.java", "diffHunk": "@@ -0,0 +1,39 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf;\n+\n+import com.azure.search.documents.models.AutocompleteItem;\n+import com.azure.search.perf.core.SearchPerfStressOptions;\n+import com.azure.search.perf.core.ServiceTest;\n+import reactor.core.publisher.Mono;\n+\n+/**\n+ * Performs autocomplete operations.\n+ */\n+public class Autocomplete extends ServiceTest<SearchPerfStressOptions> {\n+    public Autocomplete(SearchPerfStressOptions options) {\n+        super(options);\n+    }\n+\n+    @Override\n+    public Mono<Void> globalSetupAsync() {\n+        /*\n+         * First, run the global setup in the super class. That will create the index to be used for performance\n+         * testing. Then populate the index with a given number of documents.\n+         */\n+        return super.globalSetupAsync().then(populateIndex(options.getCount(), options.getDocumentSize()));\n+    }\n+\n+    @Override\n+    public void run() {\n+        searchClient.autocomplete(\"historic\", SUGGESTER_NAME).forEach(AutocompleteItem::getText);", "originalCommit": "9a982cac5d501f629a9d662ea50229d6b5279548", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "54b9ddfd35bc985b70fbfff792d64cecf13f267b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/54b9ddfd35bc985b70fbfff792d64cecf13f267b", "message": "Merge branch 'master' into AzSearch_AddPerformanceTests", "committedDate": "2020-08-25T20:46:06Z", "type": "commit"}, {"oid": "c50e5307f927f32d2883c0bb9c0fede1b3cf6855", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c50e5307f927f32d2883c0bb9c0fede1b3cf6855", "message": "Update performance test names and add validation to tests", "committedDate": "2020-08-25T21:30:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxOTczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r477019734", "bodyText": "just checking,\nDoes the Rest API contract always guarantee a response when response code is 200 ?\nHere and other spots below too.", "author": "g2vinay", "createdAt": "2020-08-26T04:01:48Z", "path": "sdk/search/azure-search-perf/src/main/java/com/azure/search/perf/AutocompleteTest.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.perf;\n+\n+import com.azure.search.perf.core.SearchPerfStressOptions;\n+import com.azure.search.perf.core.ServiceTest;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Performs autocomplete operations.\n+ */\n+public class AutocompleteTest extends ServiceTest<SearchPerfStressOptions> {\n+    public AutocompleteTest(SearchPerfStressOptions options) {\n+        super(options);\n+    }\n+\n+    @Override\n+    public Mono<Void> globalSetupAsync() {\n+        /*\n+         * First, run the global setup in the super class. That will create the index to be used for performance\n+         * testing. Then populate the index with a given number of documents.\n+         */\n+        return super.globalSetupAsync().then(populateIndex(options.getCount(), options.getDocumentSize()));\n+    }\n+\n+    @Override\n+    public void run() {\n+        AtomicInteger count = new AtomicInteger();\n+        searchClient.autocomplete(\"historic\", SUGGESTER_NAME).iterator()\n+            .forEachRemaining(ignored -> count.incrementAndGet());\n+\n+        assert count.get() > 0;\n+    }\n+\n+    @Override\n+    public Mono<Void> runAsync() {\n+        return searchAsyncClient.autocomplete(\"historic\", SUGGESTER_NAME)\n+            .count()", "originalCommit": "c50e5307f927f32d2883c0bb9c0fede1b3cf6855", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0ODkzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14383#discussion_r477448936", "bodyText": "There is never a complete guarantee on the request being successful, for performance tests how should be handle the case were an operation fails? Do we prevent that iteration from being counted in the metrics?", "author": "alzimmermsft", "createdAt": "2020-08-26T16:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAxOTczNA=="}], "type": "inlineReview"}, {"oid": "70576727351dc2b7d75dcdd7d0e202fc555a3a4f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/70576727351dc2b7d75dcdd7d0e202fc555a3a4f", "message": "Merge branch 'master' into AzSearch_AddPerformanceTests", "committedDate": "2020-08-31T17:57:40Z", "type": "commit"}]}