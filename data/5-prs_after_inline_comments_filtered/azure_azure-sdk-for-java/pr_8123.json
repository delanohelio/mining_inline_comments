{"pr_number": 8123, "pr_title": "Adding readMany api that reads many documents at once based on id and\u2026", "pr_createdAt": "2020-02-12T02:48:28Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/8123", "timeline": [{"oid": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "message": "Adding readMany api that reads many documents at once based on id and partitionkey.\nThis avoids queryplan round trip, and does query only required partitions for required elements.", "committedDate": "2020-02-12T02:47:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNzg2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378017865", "bodyText": "does this actually read the collection? or uses collection cache.\nReading collection is expensive and we should be using CollectionCache.", "author": "moderakh", "createdAt": "2020-02-12T03:01:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MDcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378590724", "bodyText": "Moved to using collectioncache", "author": "mbhaskar", "createdAt": "2020-02-13T00:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxNzg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODU5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378018591", "bodyText": "shouldn't this be concurrentHashMap as it is modified on a flatMap?", "author": "moderakh", "createdAt": "2020-02-12T03:05:01Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MTA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378591043", "bodyText": "Did minor refactoring to ensure that these calls are only made once in the flatmap and no other thread is going to write on to this. Also made the rangeQueryMap unmodifiable", "author": "mbhaskar", "createdAt": "2020-02-13T00:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODU5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODgwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378018807", "bodyText": "same about this one too. shouldn't this be thread-safe?", "author": "moderakh", "createdAt": "2020-02-12T03:06:01Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/query/ParallelDocumentQueryExecutionContext.java", "diffHunk": "@@ -96,6 +100,36 @@ private ParallelDocumentQueryExecutionContext(\n         }\n     }\n \n+    public static <T extends Resource> Flux<IDocumentQueryExecutionComponent<T>> createReadManyQueryAsync(\n+        IDocumentQueryClient queryClient,\n+        String collectionResourceId, SqlQuerySpec sqlQuery,\n+        Map<PartitionKeyRange, String> rangeQueryMap,\n+        FeedOptions feedOptions, String collectionRid, String collectionLink, UUID activityId, Class<T> klass,\n+        ResourceType resourceTypeEnum) {\n+        \n+        List<PartitionKeyRange> ranges = new ArrayList<>();", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MTMzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378591334", "bodyText": "It will be modified only inside this flatmap and is called only once.", "author": "mbhaskar", "createdAt": "2020-02-13T00:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAxODgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MDgzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378040835", "bodyText": "String, PartitionKey [](start = 63, length = 20)\n\nParameter order consistency w.r.t. other API's", "author": "kirankumarkolli", "createdAt": "2020-02-12T04:57:07Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, \n+                                                     List<Pair<String, PartitionKey>> itemKeyList){", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2MjIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378662202", "bodyText": "This API is kind of different from the other we have. Still we are sort of consistent", "author": "mbhaskar", "createdAt": "2020-02-13T05:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MDgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTA1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041059", "bodyText": "Is a sync version of this contract also needed?", "author": "kirankumarkolli", "createdAt": "2020-02-12T04:58:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, ", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MjExOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378592118", "bodyText": "At the moment, I added async version, sync wrapper can be added quickly if required.", "author": "mbhaskar", "createdAt": "2020-02-13T00:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2NjExMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378666112", "bodyText": "we added sync version too.", "author": "moderakh", "createdAt": "2020-02-13T06:04:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2NjE4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378666186", "bodyText": "Thanks Mo for adding sync API. We have both sync and async API now.", "author": "mbhaskar", "createdAt": "2020-02-13T06:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTI2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041267", "bodyText": "Is BridgeInernal right place? May be a new targetted contract\nBridgeInternal has lot of other contracts which might get attention.", "author": "kirankumarkolli", "createdAt": "2020-02-12T04:59:28Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -489,4 +491,12 @@ public static void setFeedOptionsMaxItemCount(FeedOptions feedOptions, Integer m\n     public static <T> CosmosContinuablePagedFlux<T> createCosmosContinuablePagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n         return new CosmosContinuablePagedFlux<>(pagedFluxOptionsFluxFunction);\n     }\n+\n+    public static Mono<FeedResponse<Document>> readMany(CosmosAsyncContainer container, ", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MzU3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378043571", "bodyText": "thought on one of these options as the class name where this new method to be added?\n\nReadManyItems.java\nExperimental.java\nSpecialQuery.java\n\nany thought? any suggestion on the class name?", "author": "moderakh", "createdAt": "2020-02-12T05:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MjI0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378592242", "bodyText": "Leaving it in the BridgeInternal until a decision is taken on where it should actually go", "author": "mbhaskar", "createdAt": "2020-02-13T00:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTI2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2MjUwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378662506", "bodyText": "We moved it to ItemOperations", "author": "mbhaskar", "createdAt": "2020-02-13T05:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTg0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378041845", "bodyText": "can we create the template of query using StringBuilder,  and use SqlQuerySpec and SqlParameter for passing id and pk values?\nthat way you don't have to worry about serializing the query and also it is safe against sql query injection attack?", "author": "moderakh", "createdAt": "2020-02-12T05:02:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();\n+                         Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                             .tryLookupAsync(collection\n+                                                                                                                 .getResourceId(),\n+                                                                                                             null,\n+                                                                                                             null);\n+                         return valueHolderMono.flatMap(collectionRoutingMapValueHolder ->{\n+                             CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                             itemKeyList\n+                                 .forEach(stringPartitionKeyPair -> {\n+\n+                                     String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                              .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                  .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                               .getRight()),\n+                                                                                                              collection\n+                                                                                                                  .getPartitionKey());\n+\n+                                     //use routing map to find the partitionKeyRangeId of each effectivePartitionKey\n+\n+\n+                                     PartitionKeyRange range =\n+                                         routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+\n+                                     //group the itemKeyList based on partitionKeyRangeId\n+                                     if (partitionRangeItemKeyMap.get(range) == null) {\n+                                         List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                         list.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, list);\n+                                     } else {\n+                                         List<Pair<String, PartitionKey>> pairs = partitionRangeItemKeyMap.get(range);\n+                                         pairs.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, pairs);\n+                                     }\n+\n+                                 });\n+\n+                             Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                             List<PartitionKeyRange> ranges = new ArrayList<>();\n+                             ranges.addAll(partitionKeyRanges);\n+\n+                             //Create the range query map that contains the query to be run for that partitionkeyrange\n+                             Map<PartitionKeyRange, String> rangeQueryMap;\n+                             rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap, collection.getPartitionKey());\n+\n+                             String sqlQuery = \"this is dummy and only used for creating \" +\n+                                                   \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                             return createReadManyQuery(collectionLink, new SqlQuerySpec(sqlQuery), new FeedOptions(), Document.class,\n+                                                        ResourceType.Document, collection, rangeQueryMap)\n+                                        .collectList() // aggregating the result construct a FeedResponse and aggregate RUs.\n+                                        .map(feedList -> {\n+                                            List<Document> finalList = new ArrayList<>();\n+                                            HashMap<String, String> headers = new HashMap<>();\n+                                            double requestCharge = 0;\n+                                            for (FeedResponse<Document> page : feedList) {\n+                                                requestCharge += page.getRequestCharge();\n+                                                finalList.addAll(page.getResults());\n+                                            }\n+                                            headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n+                                            FeedResponse<Document> frp = BridgeInternal.createFeedResponse(finalList, headers);\n+                                            return frp;\n+                                        });\n+                         });\n+                     }\n+            );\n+      \n+    }\n+\n+    // TODO: This needs refactoring and optimization and betterment and everything\n+    private Map<PartitionKeyRange, String> getRangeQueryMap(\n+        Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap,\n+        PartitionKeyDefinition partitionKeyDefinition) {\n+        //TODO: Optimise this\n+        String partitionKeyPathString = partitionKeyDefinition.getPaths().get(0);\n+        String partitionKeyPath = (new StringBuilder(partitionKeyPathString)).deleteCharAt(0).toString();\n+        \n+        Map<PartitionKeyRange, String> rangeQueryMap = new HashMap<>();\n+        \n+        for (PartitionKeyRange range : partitionRangeItemKeyMap.keySet()) {\n+            StringBuilder queryStringBuilder = new StringBuilder();\n+            queryStringBuilder.append(\"select * from c where \");\n+            List<Pair<String, PartitionKey>> pairsList = partitionRangeItemKeyMap.get(range);\n+            for (Pair p : pairsList) {\n+                queryStringBuilder.append(\"(c.id = \\\"\");", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MjU0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378592547", "bodyText": "Thank you for the suggestion, moved to use  SqlQuerySpec and SqlParameters, looks much cleaner and also helps handle some additional types without heave conversions", "author": "mbhaskar", "createdAt": "2020-02-13T00:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MjM2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378042362", "bodyText": "is this some leftover code? is this needed?", "author": "moderakh", "createdAt": "2020-02-12T05:05:17Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU5MjU3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378592577", "bodyText": "Yup. Deleted", "author": "mbhaskar", "createdAt": "2020-02-13T00:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0MjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NjEyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378046125", "bodyText": "Split handling: Do query layer take care?", "author": "kirankumarkolli", "createdAt": "2020-02-12T05:25:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1332,155 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink) {\n+        \n+        DocumentCollection collection = \n+            this.readCollection(collectionLink, new RequestOptions()).block().getResource();\n+\n+        return this.readCollection(collectionLink, new RequestOptions())\n+            .flatMap(documentCollectionResourceResponse -> {\n+                         Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                             new HashMap<>();\n+                         Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                             .tryLookupAsync(collection\n+                                                                                                                 .getResourceId(),\n+                                                                                                             null,\n+                                                                                                             null);\n+                         return valueHolderMono.flatMap(collectionRoutingMapValueHolder ->{\n+                             CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                             itemKeyList\n+                                 .forEach(stringPartitionKeyPair -> {\n+\n+                                     String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                              .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                  .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                               .getRight()),\n+                                                                                                              collection\n+                                                                                                                  .getPartitionKey());\n+\n+                                     //use routing map to find the partitionKeyRangeId of each effectivePartitionKey\n+\n+\n+                                     PartitionKeyRange range =\n+                                         routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+\n+                                     //group the itemKeyList based on partitionKeyRangeId\n+                                     if (partitionRangeItemKeyMap.get(range) == null) {\n+                                         List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                         list.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, list);\n+                                     } else {\n+                                         List<Pair<String, PartitionKey>> pairs = partitionRangeItemKeyMap.get(range);\n+                                         pairs.add(stringPartitionKeyPair);\n+                                         partitionRangeItemKeyMap.put(range, pairs);\n+                                     }\n+\n+                                 });\n+\n+                             Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                             List<PartitionKeyRange> ranges = new ArrayList<>();\n+                             ranges.addAll(partitionKeyRanges);\n+\n+                             //Create the range query map that contains the query to be run for that partitionkeyrange\n+                             Map<PartitionKeyRange, String> rangeQueryMap;\n+                             rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap, collection.getPartitionKey());\n+\n+                             String sqlQuery = \"this is dummy and only used for creating \" +\n+                                                   \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                             return createReadManyQuery(collectionLink, new SqlQuerySpec(sqlQuery), new FeedOptions(), Document.class,\n+                                                        ResourceType.Document, collection, rangeQueryMap)\n+                                        .collectList() // aggregating the result construct a FeedResponse and aggregate RUs.\n+                                        .map(feedList -> {\n+                                            List<Document> finalList = new ArrayList<>();\n+                                            HashMap<String, String> headers = new HashMap<>();\n+                                            double requestCharge = 0;\n+                                            for (FeedResponse<Document> page : feedList) {\n+                                                requestCharge += page.getRequestCharge();\n+                                                finalList.addAll(page.getResults());\n+                                            }\n+                                            headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double.toString(requestCharge));\n+                                            FeedResponse<Document> frp = BridgeInternal.createFeedResponse(finalList, headers);", "originalCommit": "9c31c8ee58e6f7b751f0ce34456faed8f7e754da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0Njg0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378046847", "bodyText": "DocumentProducer internally/recursively will handle split, if DocumentProducers correctly wired up no additional work for split proofing should be needed.", "author": "moderakh", "createdAt": "2020-02-12T05:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA0NjEyNQ=="}], "type": "inlineReview"}, {"oid": "fce2e2d44869faff18df4cb6a7e5272b4635b80d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fce2e2d44869faff18df4cb6a7e5272b4635b80d", "message": "Addressing PR comments", "committedDate": "2020-02-13T00:31:20Z", "type": "commit"}, {"oid": "0619c734b908500547e62f6af859daf6edeeecc1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0619c734b908500547e62f6af859daf6edeeecc1", "message": "Merge branch 'feature/cosmos/upstream-v4' into mbhaskar/v4/readmany-internalapi\n\n# Conflicts:\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java\n#\tsdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java\n#\tsdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ParallelDocumentQueryTest.java", "committedDate": "2020-02-13T02:25:02Z", "type": "commit"}, {"oid": "7055cff91d00143b3b18f31b7a22aaf748fd09ad", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7055cff91d00143b3b18f31b7a22aaf748fd09ad", "message": "Skipping readMany test in gateway mode", "committedDate": "2020-02-13T02:47:21Z", "type": "commit"}, {"oid": "696d0d5274a91ee699ab8ec4876bdec126b83a52", "url": "https://github.com/Azure/azure-sdk-for-java/commit/696d0d5274a91ee699ab8ec4876bdec126b83a52", "message": "added support for pk = '/id', and added support for nested partition-key path", "committedDate": "2020-02-13T05:08:38Z", "type": "commit"}, {"oid": "a1e1ee4dfc0aafe2c2c8717c479eee19c8a3a68f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a1e1ee4dfc0aafe2c2c8717c479eee19c8a3a68f", "message": "added support for typed based translation to readmany", "committedDate": "2020-02-13T05:31:30Z", "type": "commit"}, {"oid": "0ee589b285036ed42b1494819ddba2e23818f3af", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ee589b285036ed42b1494819ddba2e23818f3af", "message": "moved readmany to ItemOperation", "committedDate": "2020-02-13T05:39:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxODE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378618149", "bodyText": "this only works on simple partition-key-path. I will improve this.", "author": "moderakh", "createdAt": "2020-02-13T02:16:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/RxDocumentClientImpl.java", "diffHunk": "@@ -1328,6 +1334,182 @@ void captureSessionToken(RxDocumentServiceRequest request, RxDocumentServiceResp\n         return queryDocuments(collectionLink, \"SELECT * FROM r\", options);\n     }\n \n+    @Override\n+    public Mono<FeedResponse<Document>> readMany(\n+        List<Pair<String, PartitionKey>> itemKeyList,\n+        String collectionLink, FeedOptions options) {\n+\n+        RxDocumentServiceRequest request = RxDocumentServiceRequest.create(\n+            OperationType.Query,\n+            ResourceType.Document,\n+            collectionLink, null\n+        ); // This should not got to backend\n+        Mono<Utils.ValueHolder<DocumentCollection>> collectionObs = collectionCache.resolveCollectionAsync(request);\n+\n+        return collectionObs\n+                   .flatMap(documentCollectionResourceResponse -> {\n+                                final DocumentCollection collection = documentCollectionResourceResponse.v;\n+                                if (collection == null) {\n+                                    throw new IllegalStateException(\"Collection cannot be null\");\n+                                }\n+\n+                                Mono<Utils.ValueHolder<CollectionRoutingMap>> valueHolderMono = partitionKeyRangeCache\n+                                                                                                    .tryLookupAsync(collection\n+                                                                                                                        .getResourceId(),\n+                                                                                                                    null,\n+                                                                                                                    null);\n+                                return valueHolderMono.flatMap(collectionRoutingMapValueHolder -> {\n+                                    Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap =\n+                                        new HashMap<>();\n+                                    CollectionRoutingMap routingMap = collectionRoutingMapValueHolder.v;\n+                                    if (routingMap == null) {\n+                                        throw new IllegalStateException(\"Failed to get routing map.\");\n+                                    }\n+                                    itemKeyList\n+                                        .forEach(stringPartitionKeyPair -> {\n+\n+                                            String effectivePartitionKeyString = PartitionKeyInternalHelper\n+                                                                                     .getEffectivePartitionKeyString(BridgeInternal\n+                                                                                                                         .getPartitionKeyInternal(stringPartitionKeyPair\n+                                                                                                                                                      .getRight()),\n+                                                                                                                     collection\n+                                                                                                                         .getPartitionKey());\n+\n+                                            //use routing map to find the partitionKeyRangeId of each \n+                                            // effectivePartitionKey\n+                                            PartitionKeyRange range =\n+                                                routingMap.getRangeByEffectivePartitionKey(effectivePartitionKeyString);\n+\n+                                            //group the itemKeyList based on partitionKeyRangeId\n+                                            if (partitionRangeItemKeyMap.get(range) == null) {\n+                                                List<Pair<String, PartitionKey>> list = new ArrayList<>();\n+                                                list.add(stringPartitionKeyPair);\n+                                                partitionRangeItemKeyMap.put(range, list);\n+                                            } else {\n+                                                List<Pair<String, PartitionKey>> pairs =\n+                                                    partitionRangeItemKeyMap.get(range);\n+                                                pairs.add(stringPartitionKeyPair);\n+                                                partitionRangeItemKeyMap.put(range, pairs);\n+                                            }\n+\n+                                        });\n+\n+                                    Set<PartitionKeyRange> partitionKeyRanges = partitionRangeItemKeyMap.keySet();\n+                                    List<PartitionKeyRange> ranges = new ArrayList<>();\n+                                    ranges.addAll(partitionKeyRanges);\n+\n+                                    //Create the range query map that contains the query to be run for that \n+                                    // partitionkeyrange\n+                                    Map<PartitionKeyRange, SqlQuerySpec> rangeQueryMap;\n+                                    rangeQueryMap = getRangeQueryMap(partitionRangeItemKeyMap,\n+                                                                     collection.getPartitionKey());\n+\n+                                    String sqlQuery = \"this is dummy and only used in creating \" +\n+                                                          \"ParallelDocumentQueryExecutioncontext, but not used\";\n+\n+                                    // create the executable query\n+                                    return createReadManyQuery(collectionLink,\n+                                                               new SqlQuerySpec(sqlQuery),\n+                                                               new FeedOptions(),\n+                                                               Document.class,\n+                                                               ResourceType.Document,\n+                                                               collection,\n+                                                               Collections.unmodifiableMap(rangeQueryMap))\n+                                               .collectList() // aggregating the result construct a FeedResponse and \n+                                               // aggregate RUs.\n+                                               .map(feedList -> {\n+                                                   List<Document> finalList = new ArrayList<>();\n+                                                   HashMap<String, String> headers = new HashMap<>();\n+                                                   double requestCharge = 0;\n+                                                   for (FeedResponse<Document> page : feedList) {\n+                                                       requestCharge += page.getRequestCharge();\n+                                                       finalList.addAll(page.getResults());\n+                                                   }\n+                                                   headers.put(HttpConstants.HttpHeaders.REQUEST_CHARGE, Double\n+                                                                                                             .toString(requestCharge));\n+                                                   FeedResponse<Document> frp = BridgeInternal\n+                                                                                    .createFeedResponse(finalList, headers);\n+                                                   return frp;\n+                                               });\n+                                });\n+                            }\n+                   );\n+\n+    }\n+\n+    // TODO: This needs refactoring and optimization and betterment and everything\n+    private Map<PartitionKeyRange, SqlQuerySpec> getRangeQueryMap(\n+        Map<PartitionKeyRange, List<Pair<String, PartitionKey>>> partitionRangeItemKeyMap,\n+        PartitionKeyDefinition partitionKeyDefinition) {\n+        //TODO: Optimise this to include all types of partitionkeydefinitions. ex: c[\"prop1./ab\"][\"key1\"]\n+        String partitionKeyPathString = partitionKeyDefinition.getPaths().get(0);\n+        String partitionKeyPath = (new StringBuilder(partitionKeyPathString)).deleteCharAt(0).toString();\n+\n+        SqlParameterList parameters = new SqlParameterList();\n+        int paramCnt = 0;\n+        Map<PartitionKeyRange, SqlQuerySpec> rangeQueryMap = new HashMap<>();\n+        \n+        for (PartitionKeyRange range : partitionRangeItemKeyMap.keySet()) {\n+            StringBuilder queryStringBuilder = new StringBuilder();\n+            queryStringBuilder.append(\"select * from c where \");\n+            List<Pair<String, PartitionKey>> pairsList = partitionRangeItemKeyMap.get(range);\n+            for (Pair p : pairsList) {\n+                paramCnt++;\n+                queryStringBuilder.append(\"(c.id = \");\n+                queryStringBuilder.append(getCurentParamName(paramCnt));\n+                parameters.add(new SqlParameter(getCurentParamName(paramCnt), p.getLeft()));\n+                paramCnt++;\n+                queryStringBuilder.append(\" and \");\n+                queryStringBuilder.append(\" c.\");\n+                // partition key def\n+                queryStringBuilder.append(partitionKeyPath);", "originalCommit": "fce2e2d44869faff18df4cb6a7e5272b4635b80d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY2MjA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378662085", "bodyText": "I addressed this one myself.", "author": "moderakh", "createdAt": "2020-02-13T05:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYxODE0OQ=="}], "type": "inlineReview"}, {"oid": "b6746cc67f7df9f51b2b12ae002629d097e93bcf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b6746cc67f7df9f51b2b12ae002629d097e93bcf", "message": "added a sync method", "committedDate": "2020-02-13T05:58:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3NzQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378677429", "bodyText": "Nit: No need for this import.", "author": "kushagraThapar", "createdAt": "2020-02-13T06:47:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -26,7 +26,9 @@\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import io.micrometer.core.instrument.MeterRegistry;\n+import org.apache.commons.lang3.tuple.Pair;", "originalCommit": "b6746cc67f7df9f51b2b12ae002629d097e93bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAwNzk3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r379007970", "bodyText": "will fix. ack.", "author": "moderakh", "createdAt": "2020-02-13T17:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3NzQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3ODQ0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378678441", "bodyText": "Do we still need to fix this for gateway ?", "author": "kushagraThapar", "createdAt": "2020-02-13T06:50:58Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/ParallelDocumentQueryTest.java", "diffHunk": "@@ -539,4 +547,44 @@ private void queryWithContinuationTokensAndPageSizes(String query, int[] pageSiz\n \n         return receivedDocuments;\n     }\n+\n+    //TODO: Fix the test for GW mode", "originalCommit": "b6746cc67f7df9f51b2b12ae002629d097e93bcf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY4MDk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/8123#discussion_r378680971", "bodyText": "later this needs to be fixed. for some reason doesn't work now.", "author": "moderakh", "createdAt": "2020-02-13T06:59:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY3ODQ0MQ=="}], "type": "inlineReview"}, {"oid": "7bcdadc249afab82274e8c33ab3290186ed89a54", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7bcdadc249afab82274e8c33ab3290186ed89a54", "message": "fixed parallelism in readMany", "committedDate": "2020-02-13T08:42:00Z", "type": "commit"}]}