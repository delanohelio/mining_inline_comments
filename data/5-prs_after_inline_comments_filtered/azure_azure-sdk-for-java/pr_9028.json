{"pr_number": 9028, "pr_title": "Service Bus track 2 - schedule message and cancel schedule feature", "pr_createdAt": "2020-03-12T17:02:34Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9028", "timeline": [{"oid": "37daa62a07523eb099204e5efef08c915453a933", "url": "https://github.com/Azure/azure-sdk-for-java/commit/37daa62a07523eb099204e5efef08c915453a933", "message": "schedule and cancel schedule feature", "committedDate": "2020-03-12T16:58:56Z", "type": "commit"}, {"oid": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51d07edca12068ac9cafe1a80e58b11e0e831b3a", "message": "fixing some spotbugs and refactoring", "committedDate": "2020-03-12T19:03:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDMyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960321", "bodyText": ".map is sufficient since this is not an asynchronous operation. Also replace usage of System.out with logger", "author": "conniey", "createdAt": "2020-03-12T23:40:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClient.java", "diffHunk": "@@ -217,12 +217,17 @@ public String getEntityName() {\n      *\n      * @throws NullPointerException if {@code message} or {@code scheduledEnqueueTime} is {@code null}.\n      */\n-    public Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime) {\n+    public Mono<Long> scheduleMessage(ServiceBusMessage message, Instant scheduledEnqueueTime) {\n         Objects.requireNonNull(message, \"'message' cannot be null.\");\n         Objects.requireNonNull(scheduledEnqueueTime, \"'scheduledEnqueueTime' cannot be null.\");\n \n-        //TODO (hemanttanwar): Implement session id feature.\n-        return Mono.error(new IllegalStateException(\"Not implemented.\"));\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityName))\n+            .flatMap(x -> x.schedule(message, scheduledEnqueueTime))\n+            .flatMap(scheduleSequenceNumber -> {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDU0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960542", "bodyText": "Should these all go into ManagementConstants? There are two places where these strings live.", "author": "conniey", "createdAt": "2020-03-12T23:40:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -40,17 +52,38 @@\n     public static final String MANAGEMENT_RESULT_LAST_ENQUEUED_TIME_UTC = \"last_enqueued_time_utc\";\n     public static final String MANAGEMENT_RESULT_RUNTIME_INFO_RETRIEVAL_TIME_UTC = \"runtime_info_retrieval_time_utc\";\n     public static final String MANAGEMENT_RESULT_PARTITION_IS_EMPTY = \"is_partition_empty\";\n-\n     // Well-known keys for management plane service requests.\n     private static final String MANAGEMENT_ENTITY_TYPE_KEY = \"type\";\n     private static final String MANAGEMENT_OPERATION_KEY = \"operation\";\n     private static final String MANAGEMENT_SECURITY_TOKEN_KEY = \"security_token\";\n \n+    public static final String REQUEST_RESPONSE_MESSAGES = \"messages\";", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDgwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960807", "bodyText": "Why .flatMapMany? You can use .map.", "author": "conniey", "createdAt": "2020-03-12T23:41:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MDkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391960901", "bodyText": "Is the responseType another class? Why the use of generics?", "author": "conniey", "createdAt": "2020-03-12T23:42:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        return Mono.empty();\n+                    }\n+                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                        + cancelScheduleNumbers,\n+                        new AmqpErrorContext(\"namespace name\")));\n+                })\n+            .then();\n+\n+    }\n+\n+    private Mono<Void>  cbsAuthorizationOnce() {\n+        return Mono.defer(() -> {\n+            if (!cbsBasedTokenManagerCalled.get()) {\n+                return cbsBasedTokenManager\n+                    .authorize()\n+                    .doOnNext(refreshCBSTokenTime -> {\n+                        cbsBasedTokenManagerCalled.set(true);\n+                    })\n+                    .then();\n+            } else {\n+                return Mono.empty();\n+            }\n+        });\n+    }\n+\n+    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n+                                 Class<T> responseType) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTAyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961027", "bodyText": "I don't like the use of Object. I'd prefer it be a strongly typed Map or something similar.", "author": "conniey", "createdAt": "2020-03-12T23:42:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -151,6 +202,113 @@\n             });\n     }\n \n+    private <T> Mono<Void> cancelSchedule( Long[] cancelScheduleNumbers) {\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    HashMap<String, Object> requestBodyMap = new HashMap<>();\n+                    requestBodyMap.put(REQUEST_RESPONSE_SEQUENCE_NUMBERS, cancelScheduleNumbers);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_CANCEL_SCHEDULED_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+\n+                }))\n+                .flatMapMany(responseMessage -> {\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        return Mono.empty();\n+                    }\n+                    return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence  \"\n+                        + cancelScheduleNumbers,\n+                        new AmqpErrorContext(\"namespace name\")));\n+                })\n+            .then();\n+\n+    }\n+\n+    private Mono<Void>  cbsAuthorizationOnce() {\n+        return Mono.defer(() -> {\n+            if (!cbsBasedTokenManagerCalled.get()) {\n+                return cbsBasedTokenManager\n+                    .authorize()\n+                    .doOnNext(refreshCBSTokenTime -> {\n+                        cbsBasedTokenManagerCalled.set(true);\n+                    })\n+                    .then();\n+            } else {\n+                return Mono.empty();\n+            }\n+        });\n+    }\n+\n+    private <T> Flux<T> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,\n+                                 Class<T> responseType) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return cbsAuthorizationOnce()\n+            .then(\n+                channelMono.flatMap(requestResponseChannel -> {\n+                    List<Message> messagesToSchedule = new ArrayList<>();\n+                    messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+                    Map<String, Object> requestBodyMap = new HashMap<>();\n+                    Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+                    for (Message message : messagesToSchedule) {\n+                        HashMap<String, Object> messageEntry = new HashMap<>();\n+                        Pair<byte[], Integer> encodedPair;\n+                        encodedPair = MessageUtils.encodeMessageToOptimalSizeArray(message,\n+                            MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES);\n+\n+                        messageEntry.put(REQUEST_RESPONSE_MESSAGE, new Binary(encodedPair.getFirstItem(),\n+                            0, encodedPair.getSecondItem()));\n+                        messageEntry.put(REQUEST_RESPONSE_MESSAGE_ID, message.getMessageId());\n+                        messageList.add(messageEntry);\n+                    }\n+                    requestBodyMap.put(REQUEST_RESPONSE_MESSAGES, messageList);\n+\n+                    Message requestMessage = createRequestMessageFromValueBody(\n+                        REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION, requestBodyMap,\n+                        MessageUtils.adjustServerTimeout(DEFAULT_REQUEST_RESPONSE_TIMEOUT));\n+                    return requestResponseChannel.sendWithAck(requestMessage);\n+                })\n+            )\n+             .map(responseMessage -> {\n+\n+                    int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+                    List<T> sequenceNumbers = null;\n+                    if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n+                            .getBody()).getValue();\n+                        Object seqNumberListObj = responseBody.get(REQUEST_RESPONSE_SEQUENCE_NUMBERS);\n+\n+                        if (seqNumberListObj instanceof  long[]){\n+                            @SuppressWarnings(\"unchecked\")\n+                            List<T> seqNumbers  = (List<T>)Arrays.stream((long[])seqNumberListObj)\n+                                .boxed().collect(Collectors.toList());\n+                            sequenceNumbers = seqNumbers;\n+                        }\n+                    }\n+                    return sequenceNumbers;\n+                })\n+         .flatMapMany(Flux::fromIterable);\n+    }\n+\n+    private Message createRequestMessageFromValueBody(String operation, Object valueBody, Duration timeout) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961156", "bodyText": "iirc, this logic exists elsewhere.", "author": "conniey", "createdAt": "2020-03-12T23:43:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/MessageUtils.java", "diffHunk": "@@ -71,4 +98,195 @@ public static UUID convertDotNetBytesToUUID(byte[] dotNetBytes) {\n         long leastSignificantBits = buffer.getLong();\n         return new UUID(mostSignificantBits, leastSignificantBits);\n     }\n+\n+\n+\n+    private static int getPayloadSize(Message msg) {", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391962357", "bodyText": "check the serializer class.", "author": "conniey", "createdAt": "2020-03-12T23:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961197", "bodyText": "Why a pair?", "author": "conniey", "createdAt": "2020-03-12T23:43:28Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/Pair.java", "diffHunk": "@@ -0,0 +1,66 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus.implementation;\n+\n+/**", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTYzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391961633", "bodyText": "In your usage of it, it feels like you can infer the size from the length of the bytes.", "author": "conniey", "createdAt": "2020-03-12T23:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk2MjE4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r391962184", "bodyText": "Its more specific you to create a mock of the message and then if the managementNode gets a schedule call with that instance to return the number. any() should be used in the case when the parameter can be variable things or its not specific to the test case you are checking.", "author": "conniey", "createdAt": "2020-03-12T23:47:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -185,4 +194,31 @@ void sendSingleMessage() {\n         final Message message = singleMessageCaptor.getValue();\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n+\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned =10;\n+\n+        when(managementNode.schedule(any(ServiceBusMessage.class), any(Instant.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(mock(ServiceBusMessage.class), mock(Instant.class)))", "originalCommit": "51d07edca12068ac9cafe1a80e58b11e0e831b3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "45ae563d18b949418c4c2e8349ff66e67c2d4998", "url": "https://github.com/Azure/azure-sdk-for-java/commit/45ae563d18b949418c4c2e8349ff66e67c2d4998", "message": " schedule and cancelschedule message", "committedDate": "2020-03-30T00:06:36Z", "type": "commit"}, {"oid": "00d2a0c7af4b0fac2cdd31a54f85be04c17e9527", "url": "https://github.com/Azure/azure-sdk-for-java/commit/00d2a0c7af4b0fac2cdd31a54f85be04c17e9527", "message": "ongoing changes", "committedDate": "2020-03-30T16:54:38Z", "type": "commit"}, {"oid": "f702b08e3c07df60f4835ad5cfee61f11ad6a6f9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f702b08e3c07df60f4835ad5cfee61f11ad6a6f9", "message": "more chanegs", "committedDate": "2020-03-30T19:35:49Z", "type": "commit"}, {"oid": "d5a3f6a66fc52839ed286fbf96e669f25f28ebcd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d5a3f6a66fc52839ed286fbf96e669f25f28ebcd", "message": " checkstyle changes", "committedDate": "2020-03-31T03:48:52Z", "type": "commit"}, {"oid": "a0060414b3a3e284aa44ee63403089ba8a4cc7d6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0060414b3a3e284aa44ee63403089ba8a4cc7d6", "message": "Fixed test", "committedDate": "2020-03-31T04:59:57Z", "type": "commit"}, {"oid": "84d8ab500f8773ba97e6c193d3a932befd1c9213", "url": "https://github.com/Azure/azure-sdk-for-java/commit/84d8ab500f8773ba97e6c193d3a932befd1c9213", "message": "Rolling back builder", "committedDate": "2020-03-31T17:41:08Z", "type": "commit"}, {"oid": "f5fa721037261b55de710a52910bc357e886fa58", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5fa721037261b55de710a52910bc357e886fa58", "message": "merge master", "committedDate": "2020-03-31T18:28:07Z", "type": "commit"}, {"oid": "6c4ffb32918d1945487a6498d8a1f39781e1a970", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6c4ffb32918d1945487a6498d8a1f39781e1a970", "message": "Fixing test", "committedDate": "2020-03-31T18:45:37Z", "type": "commit"}, {"oid": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "message": "java doc and renaming constants", "committedDate": "2020-03-31T19:49:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401177512", "bodyText": "nit: unnecessary empty line.", "author": "conniey", "createdAt": "2020-03-31T19:58:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,34 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3NzY2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401177669", "bodyText": "nit: unnecessary new line", "author": "conniey", "createdAt": "2020-03-31T19:58:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,34 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+\n+        if (amqpMessage.getBody() instanceof AmqpValue) {\n+            AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n+            if (amqpValue.getValue() instanceof  Map) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) amqpValue.getValue();\n+                Object expirationListObj = responseBody.get(SEQUENCE_NUMBERS);\n+\n+                if (expirationListObj instanceof long[]) {\n+                    return Arrays.stream((long[]) expirationListObj)\n+                        .boxed()\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+        }\n+        return Collections.emptyList();\n+    }\n+\n+", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODA4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401178081", "bodyText": "cancelScheduledMessage", "author": "conniey", "createdAt": "2020-03-31T19:59:44Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -101,6 +116,23 @@\n             .next();\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelSchedule(long sequenceNumber) {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3ODc4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401178789", "bodyText": "This doesn't need to be a method, it is only used in one place. Roll it up into the calling method.", "author": "conniey", "createdAt": "2020-03-31T20:01:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE3OTM3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401179370", "bodyText": "You may need to reformat your code. There are double spaces where there shouldn't be.", "author": "conniey", "createdAt": "2020-03-31T20:02:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence \"\n+                + Arrays.toString(cancelScheduleNumbers), getErrorContext()));\n+\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401180255", "bodyText": "Use monoError(logger, exception). It also logs the message. In addition to places you also return a mono error.", "author": "conniey", "createdAt": "2020-03-31T20:03:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();\n+        messagesToSchedule.add(messageSerializer.serialize(messageToSchedule));\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        for (Message message : messagesToSchedule) {\n+            final int payloadSize = messageSerializer.getSize(message);\n+            final int allocationSize =\n+                Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+            final byte[] bytes = new byte[allocationSize];\n+\n+            int encodedSize;\n+            try {\n+                encodedSize = message.encode(bytes, 0, allocationSize);\n+            } catch (BufferOverflowException exception) {\n+                final String errorMessage =\n+                    String.format(Locale.US,\n+                        \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                        maxMessageSize / 1024);\n+                throw logger.logExceptionAsWarning(new AmqpException(false,\n+                    AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+            }\n+\n+            HashMap<String, Object> messageEntry = new HashMap<>();\n+\n+            messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+            messageEntry.put(MESSAGE_ID, message.getMessageId());\n+            messageList.add(messageEntry);\n+        }\n+        requestBodyMap.put(MESSAGES, messageList);\n+\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    private Mono<Void> cancelSchedule(Long[] cancelScheduleNumbers) {\n+        return  isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS, cancelScheduleNumbers)));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode ==  AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel schedule message with sequence \"\n+                + Arrays.toString(cancelScheduleNumbers), getErrorContext()));\n+\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime) {\n+\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION, channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap;\n+            requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"Could not schedule message.\",", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDk0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401180940", "bodyText": "I should have noticed it before, put the private renewMessageLock method into the public one. It is only used in one place. It saves another stack call.", "author": "conniey", "createdAt": "2020-03-31T20:05:00Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMwNzc0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401307741", "bodyText": "I was thinking of when we have to renew multiple lock Token in one go and need to expose that API,  this would be helpful.\nBut for now I have changed this like you said.", "author": "hemanttanwar", "createdAt": "2020-04-01T01:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDM5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401184391", "bodyText": "Why are you creating a list and iterating through it for a single message?\nYou aren't taking into account the size of the send link. It is not always \"MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES\".\nThis doesn't need to be a method. It is only used in a single place.\nDocument that the logic is from ReactorSender, so if we bug fix one place, it can also be done in another.", "author": "conniey", "createdAt": "2020-03-31T20:11:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +348,95 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule) {\n+        int maxMessageSize = MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES;\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        List<Message> messagesToSchedule = new ArrayList<>();", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2MTg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401261890", "bodyText": "A separate method will keep scheduleMessage succinct and readable. I can merge them together if you still want.", "author": "hemanttanwar", "createdAt": "2020-03-31T22:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDg3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401184877", "bodyText": "This should be from the send link, not receive link.", "author": "conniey", "createdAt": "2020-03-31T20:11:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java", "diffHunk": "@@ -34,4 +37,12 @@\n     static final String ASSOCIATED_LINK_NAME_KEY = \"associated-link-name\";\n     static final String SEQUENCE_NUMBERS = \"sequence-numbers\";\n     static final String RECEIVER_SETTLE_MODE = \"receiver-settle-mode\";\n+    static final String MESSAGES = \"messages\";\n+    static final String MESSAGE = \"message\";\n+    static final String MESSAGE_ID = \"message-id\";\n+\n+\n+    // TODO(Hemant) :This value should be read from Receive Link (Currently using track 1 default value)\n+    static final int MAX_MESSAGE_LENGTH_SENDER_LINK_BYTES = 1024 * 1024;", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NTUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401185515", "bodyText": "This is different than the one in azure-core-amqp's ClientConstants.", "author": "conniey", "createdAt": "2020-03-31T20:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NDg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NjE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401186140", "bodyText": "<<queue-name>> for constency.", "author": "conniey", "createdAt": "2020-03-31T20:14:07Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name\")", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4NzYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401187609", "bodyText": "The variable creations like Instant.now.plus.. and Duration.ofSeconds(enqeueDe...) are a part of your \"Arrange\" section. The Act part is usually, \"I set up all my things, now let me invoke it.\"", "author": "conniey", "createdAt": "2020-03-31T20:16:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,47 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 2;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4ODAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401188035", "bodyText": "Scheduling a message isn't part of the scenario. Do that as part of your // Arrange.", "author": "conniey", "createdAt": "2020-03-31T20:17:30Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,47 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 2;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))\n+            .delaySubscription(Duration.ofSeconds(enqueDelayInSec + 1))\n+            .thenMany(receiver.receive().take(1)))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        int enqueDelayInSec = 3;\n+        // Assert & Act\n+        StepVerifier.create(sender.scheduleMessage(message, Instant.now().plusSeconds(enqueDelayInSec))", "originalCommit": "78d0ec0a5e3ed4b8aa5af510b0ec0884b2681ed6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5ecbd6092f758b8b11790f9f355df8349ef75b97", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ecbd6092f758b8b11790f9f355df8349ef75b97", "message": "Review comments", "committedDate": "2020-04-01T01:28:07Z", "type": "commit"}, {"oid": "1c2bd1ab5979ae1c47eba67c480fb735f35e5b76", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c2bd1ab5979ae1c47eba67c480fb735f35e5b76", "message": "Review comments", "committedDate": "2020-04-01T01:35:57Z", "type": "commit"}, {"oid": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47b5ea234acabd851dabb9fd32657b00e1b42a3a", "message": "Review comments", "committedDate": "2020-04-01T01:48:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxNzk0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401317946", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (amqpValue.getValue() instanceof  Map) {\n          \n          \n            \n                        if (amqpValue.getValue() instanceof Map) {", "author": "conniey", "createdAt": "2020-04-01T02:17:03Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -191,12 +192,32 @@ public int getSize(Message amqpMessage) {\n             return (List<T>) deserializeListOfMessages(message);\n         } else if (clazz == Instant.class) {\n             return (List<T>) deserializeListOfInstant(message);\n+        } else if (clazz == Long.class) {\n+            return (List<T>) deserializeListOfLong(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Long> deserializeListOfLong(Message amqpMessage) {\n+        if (amqpMessage.getBody() instanceof AmqpValue) {\n+            AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n+            if (amqpValue.getValue() instanceof  Map) {", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxODkzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401318938", "bodyText": "Don't think this needs to be its own function. It's only used once. Same with your helper method to create a message. Functions are pieces of code that can be reused.", "author": "conniey", "createdAt": "2020-04-01T02:20:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +334,98 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    private Flux<Long> scheduleMessage(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime,", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTQwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319403", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime,  int maxSendLinkSize);\n          \n          \n            \n                Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime, int maxSendLinkSize);", "author": "conniey", "createdAt": "2020-04-01T02:22:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementNode.java", "diffHunk": "@@ -39,6 +40,28 @@\n      */\n     Mono<ServiceBusReceivedMessage> peek(long fromSequenceNumber);\n \n+    /**\n+     * Sends a scheduled message to the Azure Service Bus entity this sender is connected to. A scheduled message is\n+     * enqueued and made available to receivers only at the scheduled enqueue time. This is an asynchronous method\n+     * returning a CompletableFuture which completes when the message is sent to the entity. The CompletableFuture,\n+     * on completion, returns the sequence number of the scheduled message which can be used to cancel the scheduling\n+     * of the message.\n+     *\n+     * @param message The message to be sent to the entity.\n+     * @param scheduledEnqueueTime The {@link Instant} at which the message should be enqueued in the entity.\n+     * @return The sequence number representing the pending send, which returns the sequence number of\n+      * the scheduled message. This sequence number can be used to cancel the scheduling of the message.\n+     */\n+    Mono<Long> schedule(ServiceBusMessage message, Instant scheduledEnqueueTime,  int maxSendLinkSize);", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319499", "bodyText": "nit: empty line. Same with the one below. there's an extra empty line.", "author": "conniey", "createdAt": "2020-04-01T02:23:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);\n+            });\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTczNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319737", "bodyText": "Tests should be in the test folder.", "author": "conniey", "createdAt": "2020-04-01T02:23:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,146 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sending message async.\n+ */\n+public class MessageSendAsyncSample {\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void sendMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<queue-name>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello world!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while\n+        // sending the message.\n+\n+        senderAsyncClient.send(message).subscribe();\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+    }\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     */\n+    @Test\n+    public void scheduleMessage() {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<<queue-name>>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);\n+            });\n+\n+        // Subscribe is not a blocking call so we sleep here so the program does not end while finishing\n+        // the operation.\n+        try {\n+            Thread.sleep(Duration.ofSeconds(20).toMillis());\n+        } catch (InterruptedException ignored) {\n+        }\n+\n+    }\n+\n+\n+    /**\n+     * Main method to invoke this demo on how to cancle a scheduled  message to an Azure Service Bus.\n+     */\n+    @Test", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTg4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319883", "bodyText": "Why delaySubscription vs Mono.delay(duration).then(cancelSubscription)?", "author": "conniey", "createdAt": "2020-04-01T02:24:33Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,53 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);\n+        Duration delayDuration = Duration.ofSeconds(3);\n+        Long sequenceNumber = sender.scheduleMessage(message, scheduledEnqueueTime).block();\n+\n+        sender.cancelScheduledMessage(sequenceNumber.longValue())\n+            .delaySubscription(delayDuration)", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxOTk1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401319953", "bodyText": "consistency: use final for the rest of them", "author": "conniey", "createdAt": "2020-04-01T02:24:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,53 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320104", "bodyText": "by default the mock runnable does nothing.", "author": "conniey", "createdAt": "2020-04-01T02:25:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -113,8 +123,15 @@ void setup() {\n         connectionProcessor = Mono.fromCallable(() -> connection).repeat(10).subscribeWith(\n             new ServiceBusConnectionProcessor(connectionOptions.getFullyQualifiedNamespace(),\n                 connectionOptions.getRetry()));\n-        sender = new ServiceBusSenderAsyncClient(ENTITY_NAME, connectionProcessor, retryOptions,\n-            tracerProvider, messageSerializer, onClientClose);\n+\n+        sender = new ServiceBusSenderAsyncClient(ENTITY_NAME, MessagingEntityType.QUEUE, connectionProcessor,\n+            retryOptions, tracerProvider, messageSerializer, onClientClose);\n+\n+        when(connection.getManagementNode(anyString(), any(MessagingEntityType.class)))\n+            .thenReturn(just(managementNode));\n+\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(ServiceBusSenderAsyncClient.MAX_MESSAGE_LENGTH_BYTES));\n+        doNothing().when(onClientClose).run();", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMzNzQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401337401", "bodyText": "It was throwing NPE in test when it was invoked by client.", "author": "hemanttanwar", "createdAt": "2020-04-01T03:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDIwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320209", "bodyText": "Should you verify that the management node operation was called?", "author": "conniey", "createdAt": "2020-04-01T02:25:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -290,6 +307,33 @@ void sendSingleMessage() {\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n \n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+\n+        when(managementNode.schedule(eq(message), any(Instant.class), any(Integer.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(message, mock(Instant.class)))\n+            .expectNext(sequenceNumberReturned)\n+            .verifyComplete();\n+    }\n+\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+\n+        when(managementNode.cancelScheduledMessage(eq(sequenceNumberReturned)))\n+            .thenReturn(Mono.empty());\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.cancelScheduledMessage(sequenceNumberReturned))\n+            .verifyComplete();\n+    }", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMyMDI4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401320282", "bodyText": "Did you mean to change code in this library?", "author": "conniey", "createdAt": "2020-04-01T02:26:03Z", "path": "sdk/servicebus/microsoft-azure-servicebus/src/test/java/com/microsoft/azure/servicebus/TestCommons.java", "diffHunk": "@@ -94,7 +93,7 @@ private static void testBasicReceiveAndDeleteWithBinaryData(IMessageSender sende\n         receivedMessage = receiver.receive(SHORT_WAIT_TIME);\n         Assert.assertNull(\"Message received again\", receivedMessage);\n     }\n-    \n+", "originalCommit": "47b5ea234acabd851dabb9fd32657b00e1b42a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1fc26e9b76b99ee6ba7ce84abe48401f434454cc", "message": "review comment", "committedDate": "2020-04-01T05:05:48Z", "type": "commit"}, {"oid": "4604222d206dfdff1da92e147d551fc7d264de11", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4604222d206dfdff1da92e147d551fc7d264de11", "message": "review comment", "committedDate": "2020-04-01T05:10:11Z", "type": "commit"}, {"oid": "d169489a504dc592de4321be520c789d149ed249", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d169489a504dc592de4321be520c789d149ed249", "message": "review comment", "committedDate": "2020-04-01T05:12:43Z", "type": "commit"}, {"oid": "b3438321825719351486bfd02c540a8c271e0a20", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b3438321825719351486bfd02c540a8c271e0a20", "message": " rollback track 1 test change", "committedDate": "2020-04-01T05:21:53Z", "type": "commit"}, {"oid": "f3cde12beef84973db44eb1e88c60d263bc41208", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f3cde12beef84973db44eb1e88c60d263bc41208", "message": " rollback track 1 test change", "committedDate": "2020-04-01T05:25:06Z", "type": "commit"}, {"oid": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "message": "revert back", "committedDate": "2020-04-01T05:28:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401720318", "bodyText": "You already have access to the list here, why not return the first item in the list as a mono rather than wrapping it in a flux from iterable and only choosing one item from it?", "author": "conniey", "createdAt": "2020-04-01T15:49:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -289,7 +297,8 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n             }\n \n             return Flux.fromIterable(messageSerializer.deserializeList(responseMessage, Instant.class));", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMDY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401720678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /***\n          \n          \n            \n                /**", "author": "conniey", "createdAt": "2020-04-01T15:49:50Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401722607", "bodyText": "When .thenMany versus .then? You aren't returning a stream of items, just a Mono.", "author": "conniey", "createdAt": "2020-04-01T15:52:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjkzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401722934", "bodyText": "Why .thenMany? Same comment as above.", "author": "conniey", "createdAt": "2020-04-01T15:53:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +325,102 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /***\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Long> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMzYwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401723605", "bodyText": "You only take the first item from the list.. I'd just return it as a mono instead of wrapping it in a flux.", "author": "conniey", "createdAt": "2020-04-01T15:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyMjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNDc0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401724740", "bodyText": "These printed messages should be cleaned up in both samples.", "author": "conniey", "createdAt": "2020-04-01T15:55:26Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))\n+            .subscribe(aLong -> {\n+                System.out.println(\"!! After schedule message  sequence : \" + aLong);", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTA2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725062", "bodyText": "Update the documentation to describe that schedule operation?", "author": "conniey", "createdAt": "2020-04-01T15:55:53Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTM0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725342", "bodyText": "Why not .plusSeconds(60) or plusMinute(1)?", "author": "conniey", "createdAt": "2020-04-01T15:56:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageScheduleAsyncSample.java", "diffHunk": "@@ -0,0 +1,54 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to schedule {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageScheduleAsyncSample {\n+\n+    /**\n+     * Main method to invoke this demo on how to send a message to an Azure Service Bus.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main(String[] args) {\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Go to \"Shared access policies\"\n+        // 3. Copy the connection string for the \"RootManageSharedAccessKey\" policy.\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\");\n+\n+        // Instantiate a client that will be used to call the service.\n+        ServiceBusSenderAsyncClient senderAsyncClient = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .sender()\n+            .queueName(\"<< QUEUE NAME >>\")\n+            .buildAsyncClient();\n+\n+        // Create an message to send.\n+        ServiceBusMessage message = new ServiceBusMessage(\"Hello World!!\".getBytes(UTF_8));\n+\n+        // Send that message. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n+        // message has been delivered to the Service Bus. It completes with an error if an exception occurred while sending\n+        // the message.\n+\n+        senderAsyncClient.scheduleMessage(message, Instant.now().plusSeconds(1 * 60L))", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MzQ1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401743451", "bodyText": "I did not see plusMinute() API .", "author": "hemanttanwar", "createdAt": "2020-04-01T16:22:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401725613", "bodyText": "I thought you added this sample in another PR.", "author": "conniey", "createdAt": "2020-04-01T15:56:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/MessageSendAsyncSample.java", "diffHunk": "@@ -0,0 +1,50 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Sample demonstrates how to send {@link ServiceBusMessage} to an Azure Service Bus queue or topic.\n+ */\n+public class MessageSendAsyncSample {", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401744680", "bodyText": "Another PR I just had an update to it .", "author": "hemanttanwar", "createdAt": "2020-04-01T16:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDc2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401800761", "bodyText": "This sample exists almost exactly: https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/SendMessageAsyncSample.java", "author": "conniey", "createdAt": "2020-04-01T17:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNjQ3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401726473", "bodyText": "use client logger.", "author": "conniey", "createdAt": "2020-04-01T15:57:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -110,6 +110,57 @@ void peekMessage() {\n             .verifyComplete();\n     }\n \n+    /**\n+     * Verifies that we can schedule and peek a message.\n+     */\n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n+\n+        sender.scheduleMessage(message, scheduledEnqueueTime)\n+            .delaySubscription(Duration.ofSeconds(3))\n+            .block();\n+\n+        // Assert & Act\n+        StepVerifier.create(receiver.receive().take(1))\n+            .assertNext(receivedMessage -> {\n+                Assertions.assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n+                Assertions.assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n+                Assertions.assertEquals(messageId, receivedMessage.getProperties().get(MESSAGE_TRACKING_ID));\n+            })\n+            .verifyComplete();\n+    }\n+\n+    /**\n+     * Verifies that we can cancel a scheduled message.\n+     */\n+    @Test\n+    void cancelScheduleMessage() {\n+        // Arrange\n+        final String messageId = UUID.randomUUID().toString();\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final Instant scheduledEnqueueTime = Instant.now().plusSeconds(10);\n+        final Duration delayDuration = Duration.ofSeconds(3);\n+\n+        final Long sequenceNumber = sender.scheduleMessage(message, scheduledEnqueueTime).block();\n+        System.out.println(\"Scheduled the message, sequence number: \" + sequenceNumber);", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcyNzU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401727575", "bodyText": "I could have been more clear, the verification of management node operation should be here as well.", "author": "conniey", "createdAt": "2020-04-01T15:59:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderAsyncClientTest.java", "diffHunk": "@@ -290,6 +307,37 @@ void sendSingleMessage() {\n         Assertions.assertEquals(Section.SectionType.Data, message.getBody().getType());\n     }\n \n+    @Test\n+    void scheduleMessage() {\n+        // Arrange\n+        long sequenceNumberReturned = 10;\n+        Instant instant = mock(Instant.class);\n+\n+        when(connection.createSendLink(eq(ENTITY_NAME), eq(ENTITY_NAME), any(AmqpRetryOptions.class)))\n+            .thenReturn(Mono.just(sendLink));\n+        when(sendLink.getLinkSize()).thenReturn(Mono.just(MAX_MESSAGE_LENGTH_BYTES));\n+        when(managementNode.schedule(eq(message), eq(instant), any(Integer.class)))\n+            .thenReturn(just(sequenceNumberReturned));\n+\n+        // Act & Assert\n+        StepVerifier.create(sender.scheduleMessage(message, instant))\n+            .expectNext(sequenceNumberReturned)\n+            .verifyComplete();\n+    }", "originalCommit": "5667f3c60ea9e73e4ab1472d0fcfac44fc2a8afc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ab538c3640b0d6ddd6eb4785b313624e765f715d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ab538c3640b0d6ddd6eb4785b313624e765f715d", "message": " continue  changes", "committedDate": "2020-04-01T16:43:14Z", "type": "commit"}, {"oid": "7dba46e6e09ee421149bf58130c1e4144cefc7a4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7dba46e6e09ee421149bf58130c1e4144cefc7a4", "message": "changes in management channel", "committedDate": "2020-04-01T17:30:11Z", "type": "commit"}, {"oid": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99420905173fdbb7ec0afab54f7daa17c72c1eaf", "message": "changes in management channel", "committedDate": "2020-04-01T17:35:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5OTQ2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401799469", "bodyText": "Nothing is this code is async, you can use .map.", "author": "conniey", "createdAt": "2020-04-01T17:49:51Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -272,23 +277,33 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n-    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n-\n-        return  isAuthorized(PEEK_OPERATION).thenMany(createRequestResponse.flatMap(channel -> {\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(UUID lockToken) {\n+        return  isAuthorized(PEEK_OPERATION).then(createRequestResponse.flatMap(channel -> {\n \n             Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n                 channel.getReceiveLinkName());\n \n-            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, renewLockList)));\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS_KEY, new UUID[]{lockToken})));\n             return channel.sendWithAck(requestMessage);\n-        }).flatMapMany(responseMessage -> {\n+        }).flatMap(responseMessage -> {", "originalCommit": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDA1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9028#discussion_r401800050", "bodyText": "Similar to my first comment above. This can be .map rather than .flatMap.", "author": "conniey", "createdAt": "2020-04-01T17:50:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -316,10 +331,108 @@ private Message createManagementMessage(String operation, String linkName) {\n         return message;\n     }\n \n+    /**\n+     * Create a Amqp key, value map to be used to create Amqp mesage for scheduling purpose.\n+     *\n+     * @param messageToSchedule The message which needs to be scheduled.\n+     * @param maxMessageSize The maximum size allowed on send link.\n+     *\n+     * @return Map of key and value in Amqp format.\n+     * @throws AmqpException When payload exceeded maximum message allowed size.\n+     */\n+    private Map<String, Object> createScheduleMessgeAmqpValue(ServiceBusMessage messageToSchedule, int maxMessageSize) {\n+\n+        Message message = messageSerializer.serialize(messageToSchedule);\n+\n+        // The maxsize allowed logic is from ReactorSender, this logic should be kept in sync.\n+        final int payloadSize = messageSerializer.getSize(message);\n+        final int allocationSize =\n+            Math.min(payloadSize + MAX_MESSAGING_AMQP_HEADER_SIZE_BYTES, maxMessageSize);\n+        final byte[] bytes = new byte[allocationSize];\n+\n+        int encodedSize;\n+        try {\n+            encodedSize = message.encode(bytes, 0, allocationSize);\n+        } catch (BufferOverflowException exception) {\n+            final String errorMessage =\n+                String.format(Locale.US,\n+                    \"Error sending. Size of the payload exceeded maximum message size: %s kb\",\n+                    maxMessageSize / 1024);\n+            throw logger.logExceptionAsWarning(new AmqpException(false,\n+                AmqpErrorCondition.LINK_PAYLOAD_SIZE_EXCEEDED, errorMessage, exception, getErrorContext()));\n+        }\n+        HashMap<String, Object> messageEntry = new HashMap<>();\n+        messageEntry.put(MESSAGE, new Binary(bytes, 0, encodedSize));\n+        messageEntry.put(MESSAGE_ID, message.getMessageId());\n+\n+        Collection<HashMap<String, Object>> messageList = new LinkedList<>();\n+        messageList.add(messageEntry);\n+\n+        Map<String, Object> requestBodyMap = new HashMap<>();\n+        requestBodyMap.put(MESSAGES, messageList);\n+        return requestBodyMap;\n+    }\n+\n     private AmqpErrorContext getErrorContext() {\n         return new SessionErrorContext(fullyQualifiedNamespace, entityPath);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Void> cancelScheduledMessage(long sequenceNumber) {\n+        return isAuthorized(CANCEL_SCHEDULED_MESSAGE_OPERATION).then(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(CANCEL_SCHEDULED_MESSAGE_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(SEQUENCE_NUMBERS,\n+                new Long[]{sequenceNumber})));\n+            return channel.sendWithAck(requestMessage);\n+        }).map(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+\n+            if (statusCode == AmqpResponseCode.OK.getValue()) {\n+                return Mono.empty();\n+            }\n+            return Mono.error(new AmqpException(false, \"Could not cancel scheduled message with sequence number \"\n+                + sequenceNumber, getErrorContext()));\n+        })).then();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Long> schedule(ServiceBusMessage messageToSchedule, Instant scheduledEnqueueTime, int maxSendLinkSize) {\n+        messageToSchedule.setScheduledEnqueueTime(scheduledEnqueueTime);\n+        return  isAuthorized(SCHEDULE_MESSAGE_OPERATION).then(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(SCHEDULE_MESSAGE_OPERATION, channel.getReceiveLinkName());\n+            Map<String, Object> requestBodyMap = createScheduleMessgeAmqpValue(messageToSchedule, maxSendLinkSize);\n+\n+            requestMessage.setBody(new AmqpValue(requestBodyMap));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMap(responseMessage -> {", "originalCommit": "99420905173fdbb7ec0afab54f7daa17c72c1eaf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "916fa7038bf66e8260ef7d9273717678a59e625c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/916fa7038bf66e8260ef7d9273717678a59e625c", "message": "Continue the work", "committedDate": "2020-04-01T19:34:53Z", "type": "commit"}, {"oid": "f08a809ac505b14fa2ab845d68172db866c8c80c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f08a809ac505b14fa2ab845d68172db866c8c80c", "message": "change continue", "committedDate": "2020-04-01T21:08:56Z", "type": "commit"}, {"oid": "452eaee0162b5e169673304698035edf18a4d01a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/452eaee0162b5e169673304698035edf18a4d01a", "message": "review comments", "committedDate": "2020-04-02T05:08:04Z", "type": "commit"}]}