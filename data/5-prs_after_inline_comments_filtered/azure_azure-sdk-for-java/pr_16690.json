{"pr_number": 16690, "pr_title": "Add ServiceBus Session Receiver Client", "pr_createdAt": "2020-10-22T17:01:21Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16690", "timeline": [{"oid": "aee166331fc10f91ff86edab8f8a56e511b79d68", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aee166331fc10f91ff86edab8f8a56e511b79d68", "message": "Add ServiceBus Session Receiver Client", "committedDate": "2020-10-22T05:38:38Z", "type": "commit"}, {"oid": "094f9eda935666aff2ec2f73c8f3c28cfe96b9d8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/094f9eda935666aff2ec2f73c8f3c28cfe96b9d8", "message": "Merge branch 'master' into sb_session_receiver", "committedDate": "2020-10-22T18:04:24Z", "type": "commit"}, {"oid": "b4aeb731aed3cddfaca7b8bf0a3b2561db053fc3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b4aeb731aed3cddfaca7b8bf0a3b2561db053fc3", "message": "More small fixes after merging from master", "committedDate": "2020-10-22T18:06:10Z", "type": "commit"}, {"oid": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7d7ab16c4d121d234e81e247d038516c6676cc4", "message": "More small fixes after merging from master", "committedDate": "2020-10-22T23:56:18Z", "type": "commit"}, {"oid": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d9af703b7660949d41fb7405fd4ac2963d9a4042", "message": "create an unnamed session manager for getReceiverClient", "committedDate": "2020-10-23T00:39:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY2Mjg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r510662862", "bodyText": "The term 'link' is less known to user, it is AMQP  term, we should avoid it. The user should know that they are getting lock to the session.\nAcquires lock for next available session and ....", "author": "hemanttanwar", "createdAt": "2020-10-23T06:31:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgxOTg1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513819859", "bodyText": "Updated", "author": "YijunXieMS", "createdAt": "2020-10-28T23:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY2Mjg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MDA1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r510670056", "bodyText": "When client calls acceptNextSession :  it should go to service bus and get a lock to any session and if client do not do receiveMessages() on it, the session is locked, no one else can get it.  Can you try that ?   getActiveLink() returns  a Mono and until a user subscribe to it, it will not create link.", "author": "hemanttanwar", "createdAt": "2020-10-23T06:49:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMDM4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513820383", "bodyText": "According to our discussion discussion offline, we give the user a Mono so they have full control.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MDA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3Nzc3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r510677778", "bodyText": "Once user have accepted a session, their receiver is locked to one session (named or unnamed) . And if they call receiver.receiveMessages() two times parallelly , what should happen ? There will be two subscriber receiving from same link. These two subscriber will get duplicated messages. We can check in dotnet, if they are throwing exception while one subscriber is receiving and do not allow second receiveMessages () ?", "author": "hemanttanwar", "createdAt": "2020-10-23T07:07:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionManager.java", "diffHunk": "@@ -247,7 +256,10 @@ private AmqpErrorContext getErrorContext() {\n      * @return A Mono that completes when an unnamed session becomes available.\n      * @throws AmqpException if the session manager is already disposed.\n      */\n-    private Mono<ServiceBusReceiveLink> getActiveLink() {\n+    Mono<ServiceBusReceiveLink> getActiveLink() {\n+        if (this.receiveLink != null) {\n+            return Mono.just(this.receiveLink);", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyODcyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513828724", "bodyText": "According to our offline discussion, we give the user full control over how many times they subscribe. But we return the same Flux instance if they call the async receiveMessages() twice.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3Nzc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0ODIyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511148224", "bodyText": "Should we?", "author": "conniey", "createdAt": "2020-10-23T20:47:46Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -1119,4 +1123,16 @@ private String getLinkName(String sessionId) {\n             return existing != null ? existing.getLinkName() : null;\n         }\n     }\n+\n+    //TODO: discuss whether we should disallow session id call on peek, receiveDeferred.", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MzEwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511153102", "bodyText": "No, we don't allow peeking into a session that is not owned by this client.", "author": "srnagar", "createdAt": "2020-10-23T21:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0ODIyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMDY3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513820679", "bodyText": "latest update: removed these sessionId-related APIs because ServiceBusReceiverClient doesn't support multi-session any more.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0ODIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0ODgxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511148813", "bodyText": "nit: consistent use of final.", "author": "conniey", "createdAt": "2020-10-23T20:49:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyODgwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513828807", "bodyText": "Updated.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:51:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0ODgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0OTI3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511149271", "bodyText": "nit: consistent use of final.", "author": "conniey", "createdAt": "2020-10-23T20:50:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMDc1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513820756", "bodyText": "Good catch. Fixed", "author": "YijunXieMS", "createdAt": "2020-10-28T23:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0OTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0OTc2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511149768", "bodyText": "Can use map instead of .thenReturn", "author": "conniey", "createdAt": "2020-10-23T20:51:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+            receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+        final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions);\n+\n+        return sessionSpecificManager.getActiveLink().thenReturn(new ServiceBusReceiverAsyncClient(", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMDgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513820834", "bodyText": "Updated", "author": "YijunXieMS", "createdAt": "2020-10-28T23:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0OTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511150035", "bodyText": "This looks exactly the same as the lines above, can we condense this into a private method?", "author": "conniey", "createdAt": "2020-10-23T20:52:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+            receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+        final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions);\n+\n+        return sessionSpecificManager.getActiveLink().thenReturn(new ServiceBusReceiverAsyncClient(\n+            fullyQualifiedNamespace, entityPath, entityType, newReceiverOptions, connectionProcessor,\n+            ServiceBusConstants.OPERATION_TIMEOUT, tracerProvider, messageSerializer, onClientClose,\n+            sessionSpecificManager));\n+    }\n+\n+    /**\n+     * Create a {@link ServiceBusReceiverAsyncClient} that processes at most {@code maxConcurrentSessions} sessions.\n+     *\n+     * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+     *\n+     * @return The {@link ServiceBusReceiverAsyncClient} object that will be used to receive messages.\n+     * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+     */\n+    public ServiceBusReceiverAsyncClient getReceiverClient(int maxConcurrentSessions) {\n+        if (maxConcurrentSessions < 1) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Maximum number of concurrent sessions must be positive.\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMTA1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513821054", "bodyText": "It's actually slightly different. Anyway this getReceiverClient has been removed", "author": "YijunXieMS", "createdAt": "2020-10-28T23:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDE0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511150143", "bodyText": "Is this idempotent? If we call close multiple times, what happens.", "author": "conniey", "createdAt": "2020-10-23T20:52:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+            receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+        final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions);\n+\n+        return sessionSpecificManager.getActiveLink().thenReturn(new ServiceBusReceiverAsyncClient(\n+            fullyQualifiedNamespace, entityPath, entityType, newReceiverOptions, connectionProcessor,\n+            ServiceBusConstants.OPERATION_TIMEOUT, tracerProvider, messageSerializer, onClientClose,\n+            sessionSpecificManager));\n+    }\n+\n+    /**\n+     * Create a {@link ServiceBusReceiverAsyncClient} that processes at most {@code maxConcurrentSessions} sessions.\n+     *\n+     * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+     *\n+     * @return The {@link ServiceBusReceiverAsyncClient} object that will be used to receive messages.\n+     * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+     */\n+    public ServiceBusReceiverAsyncClient getReceiverClient(int maxConcurrentSessions) {\n+        if (maxConcurrentSessions < 1) {\n+            throw logger.logExceptionAsError(\n+                new IllegalArgumentException(\"Maximum number of concurrent sessions must be positive.\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+            receiverOptions.getPrefetchCount(), null, maxConcurrentSessions,\n+            receiverOptions.getMaxLockRenewDuration());\n+        ServiceBusSessionManager newSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions);\n+        return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+            entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+            tracerProvider, messageSerializer, onClientClose, newSessionManager);\n+    }\n+\n+    @Override\n+    public void close() {\n+        this.onClientClose.run();", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyOTE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513829172", "bodyText": "This calls the ServiceBusClientBuilder's close() method.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDQyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511150427", "bodyText": "Add documentation about what it throws if there is no session to accept. Same with async one.", "author": "conniey", "createdAt": "2020-10-23T20:53:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverClient implements AutoCloseable {\n+    private final ServiceBusSessionReceiverAsyncClient sessionAsyncClient;\n+    private final Duration operationTimeout;\n+\n+    ServiceBusSessionReceiverClient(ServiceBusSessionReceiverAsyncClient asyncClient, Duration operationTimeout) {\n+        this.sessionAsyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverClient} that is tied to the available session.", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1MzgxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514053812", "bodyText": "Added", "author": "YijunXieMS", "createdAt": "2020-10-29T07:33:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDYyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511150620", "bodyText": "Add documentation about what the mono throws if there is no session to accept or this is locked. Same with other overload.", "author": "conniey", "createdAt": "2020-10-23T20:53:54Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1MzcxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514053717", "bodyText": "Added", "author": "YijunXieMS", "createdAt": "2020-10-29T07:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDk4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511150985", "bodyText": "Where are the unit tests for Session receiver?", "author": "conniey", "createdAt": "2020-10-23T20:54:49Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSessionManagerTest.java", "diffHunk": "@@ -155,7 +155,7 @@ void afterEach(TestInfo testInfo) {\n     @Test", "originalCommit": "d9af703b7660949d41fb7405fd4ac2963d9a4042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMjkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513822905", "bodyText": "Added unit test for ServiceBusSessionReceiverAsyncClient and ServiceBusSessionReceiverClient.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200085", "bodyText": "I guess this is now resolved. So, you might want to update this.", "author": "srnagar", "createdAt": "2020-10-23T23:49:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -1119,4 +1123,16 @@ private String getLinkName(String sessionId) {\n             return existing != null ? existing.getLinkName() : null;\n         }\n     }\n+\n+    //TODO: discuss whether we should disallow session id call on peek, receiveDeferred.\n+//    private Mono<Boolean> validateSession(String sessionId) {\n+//        String optionSessionId = receiverOptions.getSessionId();\n+//        if (optionSessionId != null && !optionSessionId.equals(sessionId)) {\n+//            return monoError(logger, new IllegalArgumentException(String.format(\n+//                \"This receiver client is tied to session %s. It can't be used for another %s.\",\n+//                optionSessionId, sessionId)));\n+//        } else {\n+//            return Mono.just(true);\n+//        }\n+//    }", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMzExMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513823113", "bodyText": "Removed this part according to latest requirement.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDIxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200210", "bodyText": "Make this final.", "author": "srnagar", "createdAt": "2020-10-23T23:50:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMzIwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513823201", "bodyText": "Done", "author": "YijunXieMS", "createdAt": "2020-10-28T23:34:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDI2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200262", "bodyText": "Update javadoc.", "author": "srnagar", "createdAt": "2020-10-23T23:50:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDQ2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200468", "bodyText": "Add documentation to specify what happens if the requested sessionId is not available.", "author": "srnagar", "createdAt": "2020-10-23T23:51:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1MzM3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514053379", "bodyText": "Added a description", "author": "YijunXieMS", "createdAt": "2020-10-29T07:32:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDcxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200717", "bodyText": "This API can be hidden for now until we decide that this is required. We can consider adding this post GA.", "author": "srnagar", "createdAt": "2020-10-23T23:53:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n+        }\n+        ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+            receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+        final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions);\n+\n+        return sessionSpecificManager.getActiveLink().thenReturn(new ServiceBusReceiverAsyncClient(\n+            fullyQualifiedNamespace, entityPath, entityType, newReceiverOptions, connectionProcessor,\n+            ServiceBusConstants.OPERATION_TIMEOUT, tracerProvider, messageSerializer, onClientClose,\n+            sessionSpecificManager));\n+    }\n+\n+    /**\n+     * Create a {@link ServiceBusReceiverAsyncClient} that processes at most {@code maxConcurrentSessions} sessions.\n+     *\n+     * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+     *\n+     * @return The {@link ServiceBusReceiverAsyncClient} object that will be used to receive messages.\n+     * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+     */\n+    public ServiceBusReceiverAsyncClient getReceiverClient(int maxConcurrentSessions) {", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyMzY3MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513823670", "bodyText": "Removed it.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200795", "bodyText": "Update javadoc.", "author": "srnagar", "createdAt": "2020-10-23T23:53:39Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverClient} instances.", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511200823", "bodyText": "Make this final.", "author": "srnagar", "createdAt": "2020-10-23T23:53:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverClient implements AutoCloseable {", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1MzQ5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514053495", "bodyText": "Updated", "author": "YijunXieMS", "createdAt": "2020-10-29T07:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMDgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTAxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511201011", "bodyText": "Why do we need operationTimeout as ctor arg. We can include this in the accept*Session APIs.", "author": "srnagar", "createdAt": "2020-10-23T23:54:47Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverClient implements AutoCloseable {\n+    private final ServiceBusSessionReceiverAsyncClient sessionAsyncClient;\n+    private final Duration operationTimeout;\n+\n+    ServiceBusSessionReceiverClient(ServiceBusSessionReceiverAsyncClient asyncClient, Duration operationTimeout) {\n+        this.sessionAsyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDE1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824153", "bodyText": "According to our latest offline discussion, we'll keep this operationTimeout on client.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTIxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511201216", "bodyText": "This can be now removed because the processor can be created from the builder.", "author": "srnagar", "createdAt": "2020-10-23T23:55:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,68 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverClient implements AutoCloseable {\n+    private final ServiceBusSessionReceiverAsyncClient sessionAsyncClient;\n+    private final Duration operationTimeout;\n+\n+    ServiceBusSessionReceiverClient(ServiceBusSessionReceiverAsyncClient asyncClient, Duration operationTimeout) {\n+        this.sessionAsyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverClient} that is tied to the available session.\n+     */\n+    public ServiceBusReceiverClient acceptNextSession() {\n+        return sessionAsyncClient.acceptNextSession()\n+            .map(asyncClient -> new ServiceBusReceiverClient(asyncClient, operationTimeout))\n+            .block(operationTimeout);\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public ServiceBusReceiverClient acceptSession(String sessionId) {\n+        return sessionAsyncClient.acceptSession(sessionId)\n+            .map(asyncClient -> new ServiceBusReceiverClient(asyncClient, operationTimeout))\n+            .block(operationTimeout);\n+    }\n+\n+    /**\n+     * Create a {@link ServiceBusReceiverClient} that processes at most {@code maxConcurrentSessions} sessions.\n+     *\n+     * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n+     *\n+     * @return The {@link ServiceBusReceiverClient} object that will be used to receive messages.\n+     * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n+     */\n+    public ServiceBusReceiverClient getReceiverClient(int maxConcurrentSessions) {", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDI0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824242", "bodyText": "Remvoed", "author": "YijunXieMS", "createdAt": "2020-10-28T23:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTUxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511201518", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));\n          \n          \n            \n                        return monoError(logger, new IllegalArgumentException(\"sessionId cannot be null or empty\"));", "author": "srnagar", "createdAt": "2020-10-23T23:57:22Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {\n+            return monoError(logger, new IllegalArgumentException(\"sessionId can not be null or empty\"));", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDM5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824393", "bodyText": "Fixed", "author": "YijunXieMS", "createdAt": "2020-10-28T23:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTg1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r511201855", "bodyText": "Java guidelines specify that if the input is null for an expected non-null value, then we must throw NPE. If the input is invalid, then we should use IllegalArgumentException.", "author": "srnagar", "createdAt": "2020-10-23T23:59:11Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,124 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * The builder that creates session-related {@link ServiceBusReceiverAsyncClient} instances.\n+ * Use {@link #acceptSession(String)} to create a {@link ServiceBusReceiverAsyncClient} that is tied to a known specific\n+ * session id.\n+ * Use {@link #acceptNextSession()} to create a {@link ServiceBusReceiverAsyncClient} that is tied to an unknown\n+ * available session.\n+ * Use {@link #getReceiverClient(int)} to create a {@link ServiceBusReceiverAsyncClient} that\n+ * process events from up to maxConcurrentSessions number of sessions.\n+ */\n+public class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType,\n+            connectionProcessor, tracerProvider,\n+            messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from that session.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), sessionId, null, receiverOptions.getMaxLockRenewDuration());\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, onClientClose, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Create a link for the \"sessionId\" and use the link to create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws IllegalArgumentException if {@code sessionId} is null or empty.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        if (CoreUtils.isNullOrEmpty(sessionId)) {", "originalCommit": "b7d7ab16c4d121d234e81e247d038516c6676cc4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDQ4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824486", "bodyText": "Updated to throw separate errors.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTIwMTg1NQ=="}], "type": "inlineReview"}, {"oid": "f59e84f58b26ee516ed71b62add29e268c47dec8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f59e84f58b26ee516ed71b62add29e268c47dec8", "message": "Update code review comment", "committedDate": "2020-10-27T23:35:04Z", "type": "commit"}, {"oid": "8b063c35984eccb8401a477cd3ef390c0ece2cd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8b063c35984eccb8401a477cd3ef390c0ece2cd4", "message": "Add test case for ServiceBusSessionReceiverAsyncClient and -Client", "committedDate": "2020-10-28T03:47:12Z", "type": "commit"}, {"oid": "a9a7a0ee1d4f6f800a121ed46e8246353acf8dd5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a9a7a0ee1d4f6f800a121ed46e8246353acf8dd5", "message": "Merge branch 'master' into sb_session_receiver", "committedDate": "2020-10-28T05:08:22Z", "type": "commit"}, {"oid": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "message": "Fix merge problems and tests", "committedDate": "2020-10-28T06:50:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxOTk5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513219994", "bodyText": "If this client is tied to a single session only, then why do we even need to have the sessionId in the method args?", "author": "srnagar", "createdAt": "2020-10-28T07:07:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -638,6 +655,11 @@ public String getEntityPath() {\n      * @return A deferred message with the matching {@code sequenceNumber}.\n      */\n     public Mono<ServiceBusReceivedMessage> receiveDeferredMessage(long sequenceNumber, String sessionId) {", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDcwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824705", "bodyText": "Removed these session related APIs", "author": "YijunXieMS", "createdAt": "2020-10-28T23:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxOTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyMDQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513220418", "bodyText": "Do we have a tracking GH issue for this task?", "author": "srnagar", "createdAt": "2020-10-28T07:08:42Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -53,6 +53,14 @@\n         this.operationTimeout = Objects.requireNonNull(operationTimeout, \"'operationTimeout' cannot be null.\");\n     }\n \n+    // TODO: ServiceBusReceiverClient will remove the above constructor that accepts operationTimeout.\n+    //  This one is added because ServiceBusSessionReceiverClient need this constructor right now.\n+    //  this.operationTimeout won't be needed after timeout is moved to methods.\n+    ServiceBusReceiverClient(ServiceBusReceiverAsyncClient asyncClient) {\n+        this.asyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+        this.operationTimeout = Duration.ofDays(10000); // TODO: remove after moving timeout to methods.", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNDg2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513824862", "bodyText": "This has been removed.", "author": "YijunXieMS", "createdAt": "2020-10-28T23:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIyMDQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0MjY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513242672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n          \n          \n            \n             *        Use {@link #acceptNextSession()} to acquire the lock of the next available session", "author": "srnagar", "createdAt": "2020-10-28T08:00:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0NDkyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514044920", "bodyText": "Fixed.", "author": "YijunXieMS", "createdAt": "2020-10-29T07:14:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0MjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0NDQ5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513244494", "bodyText": "None of these validations are required if we remove the sessionId param from all these methods. A client is tied to a single session only.", "author": "srnagar", "createdAt": "2020-10-28T08:03:48Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -390,6 +386,11 @@ public String getEntityPath() {\n         }\n \n         if (sessionManager != null) {\n+            if (validateSessionId(sessionId)) {\n+                return monoError(logger, new IllegalArgumentException(String.format(\n+                    \"This receiver client is tied to session %s. It can't be used for another session(%s).\",\n+                    receiverOptions.getSessionId(), sessionId)));", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgyNTYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513825630", "bodyText": "Removed", "author": "YijunXieMS", "createdAt": "2020-10-28T23:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0NDQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MDEyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513270120", "bodyText": "nit: Closing paragraph tag </p> appears twice.", "author": "srnagar", "createdAt": "2020-10-28T08:49:18Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public final class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType, connectionProcessor,\n+            tracerProvider, messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Acquires a session lock for the next available session and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>Accept next available session</p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+     * </p>", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0Mzg0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514043847", "bodyText": "Fixed", "author": "YijunXieMS", "createdAt": "2020-10-29T07:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MTkwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513271905", "bodyText": "AmqpException can be thrown for many reasons - not just when the session is locked by another receiver. So, you can make this generic and mention that if there was an error while accepting the session.", "author": "srnagar", "createdAt": "2020-10-28T08:52:12Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public final class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType, connectionProcessor,\n+            tracerProvider, messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Acquires a session lock for the next available session and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>Accept next available session</p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+     * </p>\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                final ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), receiverOptions.getMaxLockRenewDuration(),\n+                    receiverOptions.isAutoLockRenewEnabled(), sessionId, null);\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, () -> { }, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Acquires a session lock for {@code sessionId} and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+     * </p>\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws NullPointerException if {@code sessionId} is null.\n+     * @throws IllegalArgumentException if {@code sessionId} is empty.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     * @throws com.azure.core.amqp.exception.AmqpException if the session has been locked by another session receiver.", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MzAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513273028", "bodyText": "Add @ServiceMethod annotation for all public APIs", "author": "srnagar", "createdAt": "2020-10-28T08:54:01Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public final class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType, connectionProcessor,\n+            tracerProvider, messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Acquires a session lock for the next available session and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>Accept next available session</p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+     * </p>\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0NDQ0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514044443", "bodyText": "Added to ServiceBusSessionReceiverAsyncClient and ServiceBusSessionReceiverClient.", "author": "YijunXieMS", "createdAt": "2020-10-29T07:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MzAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MzE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513273154", "bodyText": "Add @ServiceClient annotation to both sync and async clients.", "author": "srnagar", "createdAt": "2020-10-28T08:54:14Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public final class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA1MzkxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514053912", "bodyText": "Added", "author": "YijunXieMS", "createdAt": "2020-10-29T07:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3MzE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NTA0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513275046", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n          \n          \n            \n             *        Use {@link #acceptNextSession()} to acquire the lock of the next available session", "author": "srnagar", "createdAt": "2020-10-28T08:57:13Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0NDc3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514044776", "bodyText": "Good catch. Fixed", "author": "YijunXieMS", "createdAt": "2020-10-29T07:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NTA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NTc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513275791", "bodyText": "What happens if timeout is Duration.ZERO? Also, if the timeout is larger than the retry timeout what happens? I don't think any code change is required but we just need to document both these cases.", "author": "srnagar", "createdAt": "2020-10-28T08:58:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverClient.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public class ServiceBusSessionReceiverClient implements AutoCloseable {\n+    private final ServiceBusSessionReceiverAsyncClient sessionAsyncClient;\n+\n+    ServiceBusSessionReceiverClient(ServiceBusSessionReceiverAsyncClient asyncClient) {\n+        this.sessionAsyncClient = Objects.requireNonNull(asyncClient, \"'asyncClient' cannot be null.\");\n+    }\n+\n+    /**\n+     * Acquires a session lock for the next available session and create a {@link ServiceBusReceiverClient}\n+     * to receive messages from the session. It will wait if no session is available.\n+     * <p>Accept next available session</p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusreceiverclient.instantiation#nextsession}\n+     * </p>\n+     * @return A {@link ServiceBusReceiverClient} that is tied to the available session.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     */\n+    public ServiceBusReceiverClient acceptNextSession() {\n+        return sessionAsyncClient.acceptNextSession()\n+            .map(asyncClient -> new ServiceBusReceiverClient(asyncClient))\n+            .block();\n+    }\n+\n+    /**\n+     * Create a link for the next available session and use the link to create a {@link ServiceBusReceiverClient}\n+     * to receive messages from that session.\n+     * @param timeout the call is cancelled after this duration.\n+     * @return A {@link ServiceBusReceiverClient} that is tied to the available session.\n+     * @throws IllegalStateException if the operation times out.\n+     */\n+    public ServiceBusReceiverClient acceptNextSession(Duration timeout) {", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NzU3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513277573", "bodyText": "Don't throw NPE here. Return monoError(logger, new NPE()) instead.", "author": "srnagar", "createdAt": "2020-10-28T09:01:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusSessionReceiverAsyncClient.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.implementation.MessageSerializer;\n+import com.azure.core.amqp.implementation.TracerProvider;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.messaging.servicebus.implementation.MessagingEntityType;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConnectionProcessor;\n+import com.azure.messaging.servicebus.implementation.ServiceBusConstants;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.Objects;\n+\n+import static com.azure.core.util.FluxUtil.monoError;\n+\n+/**\n+ * This session receiver client is used to acquire session locks from a queue or topic and create\n+ * {@link ServiceBusReceiverAsyncClient} instances that are tied to the locked sessions.\n+ * <ul>\n+ *     <li>\n+ *         Use {@link #acceptSession(String)} to acquire the lock of a session if you know the session id.\n+ *         <p>\n+ *         {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+ *         </p>\n+ *    </li>\n+ *    <li>\n+ *        Use {@link #acceptNextSession()} to acquire the lock of the next availabe session\n+ *        without specifying the session id.\n+ *        <p>\n+ *        {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+ *        </p>\n+ *    </li>\n+ * </ul>\n+ *\n+ */\n+public final class ServiceBusSessionReceiverAsyncClient implements AutoCloseable {\n+    private final String fullyQualifiedNamespace;\n+    private final String entityPath;\n+    private final MessagingEntityType entityType;\n+    private final ReceiverOptions receiverOptions;\n+    private final ServiceBusConnectionProcessor connectionProcessor;\n+    private final TracerProvider tracerProvider;\n+    private final MessageSerializer messageSerializer;\n+    private final Runnable onClientClose;\n+    private final ServiceBusSessionManager unNamedSessionManager;  // for acceptNextSession()\n+    private final ClientLogger logger = new ClientLogger(ServiceBusSessionReceiverAsyncClient.class);\n+\n+    ServiceBusSessionReceiverAsyncClient(String fullyQualifiedNamespace, String entityPath,\n+        MessagingEntityType entityType, ReceiverOptions receiverOptions,\n+        ServiceBusConnectionProcessor connectionProcessor, TracerProvider tracerProvider,\n+        MessageSerializer messageSerializer, Runnable onClientClose) {\n+        this.fullyQualifiedNamespace = Objects.requireNonNull(fullyQualifiedNamespace,\n+            \"'fullyQualifiedNamespace' cannot be null.\");\n+        this.entityPath = Objects.requireNonNull(entityPath, \"'entityPath' cannot be null.\");\n+        this.entityType = Objects.requireNonNull(entityType, \"'entityType' cannot be null.\");\n+        this.receiverOptions = Objects.requireNonNull(receiverOptions, \"'receiveOptions cannot be null.'\");\n+        this.connectionProcessor = Objects.requireNonNull(connectionProcessor, \"'connectionProcessor' cannot be null.\");\n+        this.tracerProvider = Objects.requireNonNull(tracerProvider, \"'tracerProvider' cannot be null.\");\n+        this.messageSerializer = Objects.requireNonNull(messageSerializer, \"'messageSerializer' cannot be null.\");\n+        this.onClientClose = Objects.requireNonNull(onClientClose, \"'onClientClose' cannot be null.\");\n+        this.unNamedSessionManager = new ServiceBusSessionManager(entityPath, entityType, connectionProcessor,\n+            tracerProvider, messageSerializer, receiverOptions);\n+    }\n+\n+    /**\n+     * Acquires a session lock for the next available session and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>Accept next available session</p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#nextsession}\n+     * </p>\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the available session.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptNextSession() {\n+        return unNamedSessionManager.getActiveLink().flatMap(receiveLink -> receiveLink.getSessionId()\n+            .map(sessionId -> {\n+                final ReceiverOptions newReceiverOptions = new ReceiverOptions(receiverOptions.getReceiveMode(),\n+                    receiverOptions.getPrefetchCount(), receiverOptions.getMaxLockRenewDuration(),\n+                    receiverOptions.isAutoLockRenewEnabled(), sessionId, null);\n+                final ServiceBusSessionManager sessionSpecificManager = new ServiceBusSessionManager(entityPath,\n+                    entityType, connectionProcessor, tracerProvider, messageSerializer, newReceiverOptions,\n+                    receiveLink);\n+                return new ServiceBusReceiverAsyncClient(fullyQualifiedNamespace, entityPath,\n+                    entityType, newReceiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n+                    tracerProvider, messageSerializer, () -> { }, sessionSpecificManager);\n+            }));\n+    }\n+\n+    /**\n+     * Acquires a session lock for {@code sessionId} and create a {@link ServiceBusReceiverAsyncClient}\n+     * to receive messages from the session.\n+     * <p>\n+     * {@codesnippet com.azure.messaging.servicebus.servicebusasyncreceiverclient.instantiation#sessionId}\n+     * </p>\n+     * @param sessionId The session Id.\n+     * @return A {@link ServiceBusReceiverAsyncClient} that is tied to the specified session.\n+     * @throws NullPointerException if {@code sessionId} is null.\n+     * @throws IllegalArgumentException if {@code sessionId} is empty.\n+     * @throws UnsupportedOperationException if the queue or topic subscription is not session-enabled.\n+     * @throws com.azure.core.amqp.exception.AmqpException if the session has been locked by another session receiver.\n+     */\n+    public Mono<ServiceBusReceiverAsyncClient> acceptSession(String sessionId) {\n+        sessionId = Objects.requireNonNull(sessionId, \"'sessionId' cannot be null\");", "originalCommit": "2c2c7ae7296bef5de9472f65c9310dcd32c87b3c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk5ODkzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r513998938", "bodyText": "Updated", "author": "YijunXieMS", "createdAt": "2020-10-29T05:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI3NzU3Mw=="}], "type": "inlineReview"}, {"oid": "464d533a943d63b75d8e0931f48846aa10da25fd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/464d533a943d63b75d8e0931f48846aa10da25fd", "message": "Use ServiceBusClientBuilder's retryPolicy timeout", "committedDate": "2020-10-28T20:58:48Z", "type": "commit"}, {"oid": "27580ca03571a5d37c1db182a9c7fdd71c9cebe3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27580ca03571a5d37c1db182a9c7fdd71c9cebe3", "message": "Remove/hide receiver methods that have param sessionId", "committedDate": "2020-10-28T22:56:38Z", "type": "commit"}, {"oid": "30266e1dbe9af39fbb3d55a3f9478dbd1e5911c9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30266e1dbe9af39fbb3d55a3f9478dbd1e5911c9", "message": "Small fixes", "committedDate": "2020-10-29T05:31:33Z", "type": "commit"}, {"oid": "4eb8093ac1d21eb7f87130becfdffa3e472ff03f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4eb8093ac1d21eb7f87130becfdffa3e472ff03f", "message": "Remove INVALID_LOCK_TOKEN_STRING", "committedDate": "2020-10-29T06:02:09Z", "type": "commit"}, {"oid": "60d0b5282beb89005ff11ad4796c8cd73a4a36f7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/60d0b5282beb89005ff11ad4796c8cd73a4a36f7", "message": "Fix unnamesession test", "committedDate": "2020-10-29T06:35:47Z", "type": "commit"}, {"oid": "600f60ffa7ee0d7acc3c259a9dac78c0e4067f95", "url": "https://github.com/Azure/azure-sdk-for-java/commit/600f60ffa7ee0d7acc3c259a9dac78c0e4067f95", "message": "cannot acquire lock wording adjustment", "committedDate": "2020-10-29T06:38:13Z", "type": "commit"}, {"oid": "22308ddad7055229082aae6e30588856f3d97339", "url": "https://github.com/Azure/azure-sdk-for-java/commit/22308ddad7055229082aae6e30588856f3d97339", "message": "Add maxLockRenewal to fix test", "committedDate": "2020-10-29T07:11:53Z", "type": "commit"}, {"oid": "925d7b8b19688527c2e8699c20a1cd56b8770bb3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/925d7b8b19688527c2e8699c20a1cd56b8770bb3", "message": "Add @ServiceClient annotation", "committedDate": "2020-10-29T07:23:28Z", "type": "commit"}, {"oid": "b08e95df5b54b6a89c1ee1b54cb7f39ca05198f0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b08e95df5b54b6a89c1ee1b54cb7f39ca05198f0", "message": "Adjust readme sample code lines", "committedDate": "2020-10-29T18:36:01Z", "type": "commit"}, {"oid": "c86c5fc5abc8ddca59fda0e2cb0387e007a36aeb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c86c5fc5abc8ddca59fda0e2cb0387e007a36aeb", "message": "Supress @ServiceClient check for methods acceptNextSession and acceptSession", "committedDate": "2020-10-29T18:36:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNjc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514516795", "bodyText": "Make this package-private instead since this method will be used by the processor.", "author": "srnagar", "createdAt": "2020-10-29T19:37:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -666,24 +664,6 @@ public ServiceBusSessionReceiverClientBuilder maxAutoLockRenewDuration(Duration\n             return this;\n         }\n \n-        /**\n-         * Enables session processing roll-over by processing at most {@code maxConcurrentSessions}.\n-         *\n-         * @param maxConcurrentSessions Maximum number of concurrent sessions to process at any given time.\n-         *\n-         * @return The modified {@link ServiceBusSessionReceiverClientBuilder} object.\n-         * @throws IllegalArgumentException if {@code maxConcurrentSessions} is less than 1.\n-         */\n-        public ServiceBusSessionReceiverClientBuilder maxConcurrentSessions(int maxConcurrentSessions) {", "originalCommit": "c86c5fc5abc8ddca59fda0e2cb0387e007a36aeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDYyNzIwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514627203", "bodyText": "Added back for message processor", "author": "YijunXieMS", "createdAt": "2020-10-29T23:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNjc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNzMyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514517325", "bodyText": "All of this will be required for the session processor. Keep this code and make this available only for the processor.", "author": "srnagar", "createdAt": "2020-10-29T19:38:19Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -822,34 +791,11 @@ private ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAll\n \n             final ServiceBusConnectionProcessor connectionProcessor = getOrCreateConnectionProcessor(messageSerializer);\n             final ReceiverOptions receiverOptions = new ReceiverOptions(receiveMode, prefetchCount,\n-                maxAutoLockRenewDuration, enableAutoComplete, sessionId, isRollingSessionReceiver(),\n-                maxConcurrentSessions);\n-\n-            final ServiceBusSessionManager sessionManager = new ServiceBusSessionManager(entityPath, entityType,\n-                connectionProcessor, tracerProvider, messageSerializer, receiverOptions);\n-\n-            return new ServiceBusReceiverAsyncClient(connectionProcessor.getFullyQualifiedNamespace(), entityPath,\n-                entityType, receiverOptions, connectionProcessor, ServiceBusConstants.OPERATION_TIMEOUT,\n-                tracerProvider, messageSerializer, ServiceBusClientBuilder.this::onClientClose, sessionManager);\n-        }\n-\n-        /**\n-         * This is a rolling session receiver only if maxConcurrentSessions is > 0 AND sessionId is null or empty. If\n-         * there is a sessionId, this is going to be a single, named session receiver.\n-         *\n-         * @return {@code true} if this is an unnamed rolling session receiver; {@code false} otherwise.\n-         */\n-        private boolean isRollingSessionReceiver() {\n-            if (maxConcurrentSessions == null) {\n-                return false;\n-            }\n-\n-            if (maxConcurrentSessions < 1) {\n-                throw logger.logExceptionAsError(\n-                    new IllegalArgumentException(\"Maximum number of concurrent sessions must be positive.\"));\n-            }\n+                maxAutoLockRenewDuration, enableAutoComplete, null, null);\n \n-            return CoreUtils.isNullOrEmpty(sessionId);", "originalCommit": "c86c5fc5abc8ddca59fda0e2cb0387e007a36aeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDU5OTczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514599736", "bodyText": "I added maxConcurrentSessions back at package level but keep isRollingSessionReceiver deleted from the builder because ReceiverOptions.isRollingSessionReceiver() can be inferred from it's own properties.", "author": "YijunXieMS", "createdAt": "2020-10-29T22:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxNzMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUxOTM3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514519371", "bodyText": "For the async client, we just hid these overloads by making them package-private. In sync client, we are deleting these overloads. We should be consistent by either deleting in both clients or hiding it in both clients.", "author": "srnagar", "createdAt": "2020-10-29T19:42:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverClient.java", "diffHunk": "@@ -260,20 +244,6 @@ public ServiceBusReceivedMessage peekMessageAt(long sequenceNumber) {\n         return asyncClient.peekMessageAt(sequenceNumber).block(operationTimeout);\n     }\n \n-    /**\n-     * Starting from the given sequence number, reads next the active message without changing the state of the receiver\n-     * or the message source.\n-     *\n-     * @param sequenceNumber The sequence number from where to read the message.\n-     * @param sessionId Session id of the message to peek from. {@code null} if there is no session.\n-     *\n-     * @return A peeked {@link ServiceBusReceivedMessage}.\n-     * @see <a href=\"https://docs.microsoft.com/azure/service-bus-messaging/message-browsing\">Message browsing</a>\n-     */\n-    public ServiceBusReceivedMessage peekMessageAt(long sequenceNumber, String sessionId) {", "originalCommit": "c86c5fc5abc8ddca59fda0e2cb0387e007a36aeb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ef3d9d52103833b8ae914b463bd928ce5b1fdb34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ef3d9d52103833b8ae914b463bd928ce5b1fdb34", "message": "Add back maxConcurrentSessions to ServiceBusSessionReceiverBuilder at package level", "committedDate": "2020-10-29T22:14:51Z", "type": "commit"}, {"oid": "c13f2809ef3ffd5cf3d86fec7ac81ff969da1e47", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c13f2809ef3ffd5cf3d86fec7ac81ff969da1e47", "message": "Remove </p> from javadoc", "committedDate": "2020-10-29T23:29:26Z", "type": "commit"}, {"oid": "e7177900c0688f105b99540bffe42d0282495828", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7177900c0688f105b99540bffe42d0282495828", "message": "Restore some session related code but hide with package level", "committedDate": "2020-10-29T23:31:29Z", "type": "commit"}, {"oid": "110fcb7c857eda89f222660867d03e009d13a812", "url": "https://github.com/Azure/azure-sdk-for-java/commit/110fcb7c857eda89f222660867d03e009d13a812", "message": "Update sync ServiceBusReceiverClientTest", "committedDate": "2020-10-30T03:36:16Z", "type": "commit"}, {"oid": "d5147930745172c145805102ede773b6e93e478a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d5147930745172c145805102ede773b6e93e478a", "message": "Try fix javadoc ci problem", "committedDate": "2020-10-30T08:21:42Z", "type": "commit"}, {"oid": "36c8c95a2d0c929c73c7604b24fc3db176e97db2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36c8c95a2d0c929c73c7604b24fc3db176e97db2", "message": "Try fix javadoc ci problem", "committedDate": "2020-10-30T08:32:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NTkxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514895919", "bodyText": "Processor will never build a sync client. So, this method can be removed.", "author": "srnagar", "createdAt": "2020-10-30T06:32:40Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -797,11 +784,11 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n-        public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());\n+        ServiceBusReceiverClient buildClientForProcessor() {\n+            return new ServiceBusReceiverClient(buildAsyncClientForProcessor(false), retryOptions.getTryTimeout());\n         }", "originalCommit": "110fcb7c857eda89f222660867d03e009d13a812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5NjE1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514896154", "bodyText": "Since the async client built for processor will always have autoComplete enabled, the boolean param is redundant and can be removed.", "author": "srnagar", "createdAt": "2020-10-30T06:33:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -797,11 +784,11 @@ public ServiceBusReceiverAsyncClient buildAsyncClient() {\n          * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n          *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n-        public ServiceBusReceiverClient buildClient() {\n-            return new ServiceBusReceiverClient(buildAsyncClient(false), retryOptions.getTryTimeout());\n+        ServiceBusReceiverClient buildClientForProcessor() {\n+            return new ServiceBusReceiverClient(buildAsyncClientForProcessor(false), retryOptions.getTryTimeout());\n         }\n \n-        private ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAllowed) {\n+        private ServiceBusReceiverAsyncClient buildAsyncClientForProcessor(boolean isAutoCompleteAllowed) {", "originalCommit": "110fcb7c857eda89f222660867d03e009d13a812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk0OTQ4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16690#discussion_r514949489", "bodyText": "This timeout is for a single attempt, right? If the user has set retry policy to 3 attempts, will this not wait for the 2nd attempt after the first attempt fails due to timeout?", "author": "srnagar", "createdAt": "2020-10-30T08:52:15Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -834,22 +821,66 @@ private ServiceBusReceiverAsyncClient buildAsyncClient(boolean isAutoCompleteAll\n         }\n \n         /**\n-         * This is a rolling session receiver only if maxConcurrentSessions is > 0 AND sessionId is null or empty. If\n-         * there is a sessionId, this is going to be a single, named session receiver.\n+         * Creates an <b>asynchronous</b>, <b>session-aware</b> Service Bus receiver responsible for reading {@link\n+         * ServiceBusMessage messages} from a specific queue or topic.\n+         *\n+         * @return An new {@link ServiceBusSessionReceiverAsyncClient} that receives messages from a queue or topic.\n+         * @throws IllegalStateException if {@link #queueName(String) queueName} or {@link #topicName(String)\n+         *     topicName} are not set or, both of these fields are set. It is also thrown if the Service Bus {@link\n+         *     #connectionString(String) connectionString} contains an {@code EntityPath} that does not match one set in\n+         *     {@link #queueName(String) queueName} or {@link #topicName(String) topicName}. Lastly, if a {@link\n+         *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n+         * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n+         *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n+         */\n+        public ServiceBusSessionReceiverAsyncClient buildAsyncClient() {\n+            return buildAsyncClient(true);\n+        }\n+\n+        /**\n+         * Creates a <b>synchronous</b>, <b>session-aware</b> Service Bus receiver responsible for reading {@link\n+         * ServiceBusMessage messages} from a specific queue or topic.\n          *\n-         * @return {@code true} if this is an unnamed rolling session receiver; {@code false} otherwise.\n+         * @return An new {@link ServiceBusReceiverClient} that receives messages from a queue or topic.\n+         * @throws IllegalStateException if {@link #queueName(String) queueName} or {@link #topicName(String)\n+         *     topicName} are not set or, both of these fields are set. It is also thrown if the Service Bus {@link\n+         *     #connectionString(String) connectionString} contains an {@code EntityPath} that does not match one set in\n+         *     {@link #queueName(String) queueName} or {@link #topicName(String) topicName}. Lastly, if a {@link\n+         *     #topicName(String) topicName} is set, but {@link #subscriptionName(String) subscriptionName} is not.\n+         * @throws IllegalArgumentException Queue or topic name are not set via {@link #queueName(String)\n+         *     queueName()} or {@link #topicName(String) topicName()}, respectively.\n          */\n-        private boolean isRollingSessionReceiver() {\n-            if (maxConcurrentSessions == null) {\n-                return false;\n+        public ServiceBusSessionReceiverClient buildClient() {\n+            return new ServiceBusSessionReceiverClient(buildAsyncClient(false),\n+                retryOptions.getTryTimeout());", "originalCommit": "110fcb7c857eda89f222660867d03e009d13a812", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}