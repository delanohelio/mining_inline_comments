{"pr_number": 15925, "pr_title": "Creating composed models in FormRecognizer", "pr_createdAt": "2020-10-05T08:03:22Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15925", "timeline": [{"oid": "2d43d9a217da64ab61411be628e1350b930219f7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2d43d9a217da64ab61411be628e1350b930219f7", "message": "add initial tests", "committedDate": "2020-10-06T08:35:33Z", "type": "forcePushed"}, {"oid": "bc4fb8d0a4efef3e3845632ed34d62d30189de5e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bc4fb8d0a4efef3e3845632ed34d62d30189de5e", "message": "update test rescordings", "committedDate": "2020-10-07T20:40:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3NTA3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501375076", "bodyText": "@maririos suggested removing any length constraints from the public docs", "author": "kristapratico", "createdAt": "2020-10-07T23:56:17Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CreateComposedModelOptions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Fluent;\n+\n+import java.time.Duration;\n+\n+/**\n+ * The configurable options to pass when creating a composed model.\n+ */\n+@Fluent\n+public final class CreateComposedModelOptions {\n+    private static final Duration DEFAULT_POLL_INTERVAL = Duration.ofSeconds(5);\n+    private String modelDisplayName;\n+    private Duration pollInterval = DEFAULT_POLL_INTERVAL;\n+\n+    /**\n+     * Get the optional model name defined by the user. (max length: 1024).", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501384242", "bodyText": "you won't find a modelName for composed submodels since the service doesn't return this in the train result", "author": "kristapratico", "createdAt": "2020-10-08T00:31:02Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/CustomModelTransforms.java", "diffHunk": "@@ -67,42 +71,139 @@ static CustomFormModel toCustomFormModel(Model modelResponse) {\n             modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n         }\n \n+\n         List<CustomFormSubmodel> subModelList = new ArrayList<>();\n-        String formType = \"form-\";\n-        // unlabeled model\n+        String formType = \"custom:\";\n         if (modelResponse.getKeys() != null) {\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n-                forEachWithIndex(clusterFields, (index, eachField) -> {\n-                    String fieldName = \"field-\" + index;\n-                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n-                });\n-                subModelList.add(new CustomFormSubmodel(\n-                    null,\n-                    fieldMap,\n-                    formType + clusterKey));\n-            });\n+            // unlabeled model\n+            subModelList = getUnlabeledSubmodels(modelResponse.getKeys().getClusters(), modelId, formType);\n         } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n             // labeled model\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getTrainResult().getFields()\n-                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n-                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n-                        formFieldsReport.getAccuracy())));\n-            subModelList.add(new CustomFormSubmodel(\n-                modelResponse.getTrainResult().getAverageModelAccuracy(),\n-                fieldMap,\n-                formType + modelInfo.getModelId()));\n+            if (modelInfo.getModelName() != null) {\n+                formType = formType + modelInfo.getModelName();\n+            } else {\n+                formType = formType + modelInfo.getModelId();\n+            }\n+            subModelList = getLabeledSubmodels(modelResponse, modelId, formType);\n+        } else if (!CoreUtils.isNullOrEmpty(modelResponse.getComposedTrainResults())) {\n+            // composed model\n+            subModelList = getComposedSubmodels(modelResponse);\n+            trainingDocumentInfoList = new ArrayList<>();\n+            for (int i = 0; i < modelResponse.getComposedTrainResults().size(); i++) {\n+                final TrainResult composedTrainResultItem = modelResponse.getComposedTrainResults().get(i);\n+                final List<TrainingDocumentInfo> trainingDocumentSubModelList\n+                    = composedTrainResultItem.getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem ->\n+                        new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                            TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                            trainingDocumentItem.getPages(),\n+                            transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .peek(trainingDocumentInfo ->\n+                        PrivateFieldAccessHelper.set(trainingDocumentInfo,\n+                            \"modelId\",\n+                            composedTrainResultItem.getModelId().toString()))\n+                    .collect(Collectors.toList());\n+                trainingDocumentInfoList.addAll(trainingDocumentSubModelList);\n+            }\n         }\n \n-        return new CustomFormModel(\n+        CustomFormModel customFormModel = new CustomFormModel(\n             modelInfo.getModelId().toString(),\n             CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n             modelInfo.getCreatedDateTime(),\n             modelInfo.getLastUpdatedDateTime(),\n             subModelList,\n             modelErrors,\n             trainingDocumentInfoList);\n+\n+        if (modelInfo.getAttributes() != null) {\n+            CustomModelProperties customModelProperties = new CustomModelProperties();\n+            PrivateFieldAccessHelper.set(customModelProperties, \"isComposed\",\n+                modelInfo.getAttributes().isComposed());\n+            PrivateFieldAccessHelper.set(customFormModel, \"customModelProperties\",\n+                customModelProperties);\n+            if (modelInfo.getAttributes().isComposed()) {\n+                PrivateFieldAccessHelper.set(customFormModel, \"trainingDocuments\",\n+                    trainingDocumentInfoList);\n+            }\n+        }\n+        if (modelInfo.getModelName() != null) {\n+            PrivateFieldAccessHelper.set(customFormModel, \"modelDisplayName\",\n+                modelInfo.getModelName());\n+        }\n+        return customFormModel;\n+    }\n+\n+    /** Creates a submodel list from composed models service data **/\n+    private static List<CustomFormSubmodel> getComposedSubmodels(Model modelResponse) {\n+        List<CustomFormSubmodel> subModelList = new ArrayList<>();\n+        for (TrainResult composedTrainResultItem : modelResponse.getComposedTrainResults()) {\n+            String formType = \"custom:\";\n+            if (modelResponse.getModelInfo().getModelName() != null) {", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQyMzcyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501423729", "bodyText": "So for CustomFormSubmodel.formType,\nIf unlabeled, we keep it as form-{clusterId} (SDK defined)\nIf composed, always, custom:{modelId}  irrespective if modelName is present or not?\nIf labeled, since we only ever have one submodel, if modelName attr present then formType = custom:{modelName}?", "author": "samvaity", "createdAt": "2020-10-08T03:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3MTQ1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501771453", "bodyText": "I recommend you add a test and that way you can verify that what you are doing matches what the service returns. i.e in .NET => https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/formrecognizer/Azure.AI.FormRecognizer/tests/FormTrainingClient/FormTrainingClientLiveTests.cs#L111\nAlso, here is a table I did with the conversions that might help:\n\n\n\nlabeled\ncomposed\ndisplayname\nvalue\n\n\n\n\nno\nno\nno\nform-{clusterkey}\n\n\nno\nno\nyes\nform-{clusterkey}\n\n\nyes\nno\nyes\ncustom:{displayName}\n\n\nyes\nno\nno\ncustom:{modelId}\n\n\nyes\nyes\nno\ncustom:{displayName} - of specific submodel\n\n\nyes\nyes\nyes\ncustom:{displayName} - of specific submodel", "author": "maririos", "createdAt": "2020-10-08T14:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyMTAzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501821031", "bodyText": "should value for the last two rows be changed to custom:{modelID}? If they are indicating the submodel form_type then we don't have that display name info. Ignore me if it's indicating the RecognizedForm.form_type.", "author": "kristapratico", "createdAt": "2020-10-08T15:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk5MDk3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r502990978", "bodyText": "@kristapratico The submodel.formType and recognizedForm.formType, should be the same. So when a modelName is present on the labeled model (for last two rows) it should be custom: {displayName}, like here.", "author": "samvaity", "createdAt": "2020-10-12T00:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM3NjI0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r503376242", "bodyText": "Looked at the test, and agree that labeled models should have model names in form_type if present. But if enumerating the submodels on a composed model, those submodels will not have a form_type with a model_name since that info is not returned in the train result.", "author": "kristapratico", "createdAt": "2020-10-12T15:34:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM1NjY0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504356645", "bodyText": "updated", "author": "samvaity", "createdAt": "2020-10-14T02:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NDI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4Njk0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501386941", "bodyText": "Is this setting formType to \"custom:{cluster-id}\"? I think we are leaving unsupervised untouched so it should remain \"form-{cluster-id}\".\nUnsupervised doesn't return docType or docTypeConfidence so this field was something we created/set in the SDK. I don't see a reason to alter it from what we returned in the GA version of the library.", "author": "kristapratico", "createdAt": "2020-10-08T00:41:21Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/CustomModelTransforms.java", "diffHunk": "@@ -67,42 +71,139 @@ static CustomFormModel toCustomFormModel(Model modelResponse) {\n             modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n         }\n \n+\n         List<CustomFormSubmodel> subModelList = new ArrayList<>();\n-        String formType = \"form-\";\n-        // unlabeled model\n+        String formType = \"custom:\";\n         if (modelResponse.getKeys() != null) {\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n-                forEachWithIndex(clusterFields, (index, eachField) -> {\n-                    String fieldName = \"field-\" + index;\n-                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n-                });\n-                subModelList.add(new CustomFormSubmodel(\n-                    null,\n-                    fieldMap,\n-                    formType + clusterKey));\n-            });\n+            // unlabeled model\n+            subModelList = getUnlabeledSubmodels(modelResponse.getKeys().getClusters(), modelId, formType);\n         } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n             // labeled model\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getTrainResult().getFields()\n-                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n-                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n-                        formFieldsReport.getAccuracy())));\n-            subModelList.add(new CustomFormSubmodel(\n-                modelResponse.getTrainResult().getAverageModelAccuracy(),\n-                fieldMap,\n-                formType + modelInfo.getModelId()));\n+            if (modelInfo.getModelName() != null) {\n+                formType = formType + modelInfo.getModelName();\n+            } else {\n+                formType = formType + modelInfo.getModelId();\n+            }\n+            subModelList = getLabeledSubmodels(modelResponse, modelId, formType);\n+        } else if (!CoreUtils.isNullOrEmpty(modelResponse.getComposedTrainResults())) {\n+            // composed model\n+            subModelList = getComposedSubmodels(modelResponse);\n+            trainingDocumentInfoList = new ArrayList<>();\n+            for (int i = 0; i < modelResponse.getComposedTrainResults().size(); i++) {\n+                final TrainResult composedTrainResultItem = modelResponse.getComposedTrainResults().get(i);\n+                final List<TrainingDocumentInfo> trainingDocumentSubModelList\n+                    = composedTrainResultItem.getTrainingDocuments().stream()\n+                    .map(trainingDocumentItem ->\n+                        new TrainingDocumentInfo(trainingDocumentItem.getDocumentName(),\n+                            TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n+                            trainingDocumentItem.getPages(),\n+                            transformTrainingErrors(trainingDocumentItem.getErrors())))\n+                    .peek(trainingDocumentInfo ->\n+                        PrivateFieldAccessHelper.set(trainingDocumentInfo,\n+                            \"modelId\",\n+                            composedTrainResultItem.getModelId().toString()))\n+                    .collect(Collectors.toList());\n+                trainingDocumentInfoList.addAll(trainingDocumentSubModelList);\n+            }\n         }\n \n-        return new CustomFormModel(\n+        CustomFormModel customFormModel = new CustomFormModel(\n             modelInfo.getModelId().toString(),\n             CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n             modelInfo.getCreatedDateTime(),\n             modelInfo.getLastUpdatedDateTime(),\n             subModelList,\n             modelErrors,\n             trainingDocumentInfoList);\n+\n+        if (modelInfo.getAttributes() != null) {\n+            CustomModelProperties customModelProperties = new CustomModelProperties();\n+            PrivateFieldAccessHelper.set(customModelProperties, \"isComposed\",\n+                modelInfo.getAttributes().isComposed());\n+            PrivateFieldAccessHelper.set(customFormModel, \"customModelProperties\",\n+                customModelProperties);\n+            if (modelInfo.getAttributes().isComposed()) {\n+                PrivateFieldAccessHelper.set(customFormModel, \"trainingDocuments\",\n+                    trainingDocumentInfoList);\n+            }\n+        }\n+        if (modelInfo.getModelName() != null) {\n+            PrivateFieldAccessHelper.set(customFormModel, \"modelDisplayName\",\n+                modelInfo.getModelName());\n+        }\n+        return customFormModel;\n+    }\n+\n+    /** Creates a submodel list from composed models service data **/\n+    private static List<CustomFormSubmodel> getComposedSubmodels(Model modelResponse) {\n+        List<CustomFormSubmodel> subModelList = new ArrayList<>();\n+        for (TrainResult composedTrainResultItem : modelResponse.getComposedTrainResults()) {\n+            String formType = \"custom:\";\n+            if (modelResponse.getModelInfo().getModelName() != null) {\n+                formType = formType + modelResponse.getModelInfo().getModelName();\n+            } else {\n+                formType = formType + composedTrainResultItem.getModelId().toString();\n+            }\n+            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+            composedTrainResultItem.getFields()\n+                .forEach(formFieldsReport -> fieldMap.put(\n+                    formFieldsReport.getFieldName(),\n+                    new CustomFormModelField(\n+                        null,\n+                        formFieldsReport.getFieldName(),\n+                        formFieldsReport.getAccuracy())));\n+\n+            CustomFormSubmodel customFormSubmodel =\n+                new CustomFormSubmodel(\n+                    composedTrainResultItem.getAverageModelAccuracy(),\n+                    fieldMap,\n+                    formType);\n+            PrivateFieldAccessHelper.set(customFormSubmodel, \"modelId\",\n+                composedTrainResultItem.getModelId().toString());\n+            subModelList.add(customFormSubmodel);\n+        }\n+        return subModelList;\n+    }\n+\n+    /** Creates a submodel list from labeled models service data **/\n+    private static List<CustomFormSubmodel> getLabeledSubmodels(Model modelResponse, String modelId, String formType) {\n+        Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+        List<CustomFormSubmodel> subModelList = new ArrayList<>();\n+        modelResponse.getTrainResult().getFields()\n+            .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n+                new CustomFormModelField(null,\n+                    formFieldsReport.getFieldName(),\n+                    formFieldsReport.getAccuracy())));\n+\n+        CustomFormSubmodel customFormSubmodel =\n+            new CustomFormSubmodel(\n+                modelResponse.getTrainResult().getAverageModelAccuracy(),\n+                fieldMap,\n+                formType);\n+        PrivateFieldAccessHelper.set(customFormSubmodel, \"modelId\", modelId);\n+        subModelList.add(customFormSubmodel);\n+        return subModelList;\n+    }\n+\n+    /** Creates a submodel list from unlabeled models service data **/\n+    private static List<CustomFormSubmodel> getUnlabeledSubmodels(Map<String, List<String>> modelResponseClusters,\n+        String modelId, String formType) {\n+        List<CustomFormSubmodel> subModelList = new ArrayList<>();\n+        modelResponseClusters\n+            .forEach((clusterKey, clusterFields) -> {\n+                Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n+                forEachWithIndex(clusterFields, (index, eachField) -> {\n+                    String fieldName = \"field-\" + index;\n+                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n+                });\n+                CustomFormSubmodel customFormSubmodel = new CustomFormSubmodel(\n+                    null,\n+                    fieldMap,\n+                    formType + clusterKey);", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NzIzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501387239", "bodyText": "I think?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * or has been cancelled. The completed operation returns the copied model {@link CustomFormModel}.\n          \n          \n            \n                 * or has been cancelled. The completed operation returns the composed model {@link CustomFormModel}.", "author": "kristapratico", "createdAt": "2020-10-08T00:42:33Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/FormTrainingAsyncClient.java", "diffHunk": "@@ -470,6 +476,91 @@ String getEndpoint() {\n         }\n     }\n \n+    /**\n+     * Create a composed model from the provided list of existing models in the account.\n+     *\n+     * <p>This operations fails if the list consists of an invalid, non-existing model Id or duplicate Ids.\n+     * This operation is currently only supported for custom models trained using labels.\n+     * </p>\n+     *\n+     * <p>The service does not support cancellation of the long running operation and returns with an\n+     * error message indicating absence of cancellation support.</p>\n+     *\n+     * <p><strong>Code sample</strong></p>\n+     * {@codesnippet com.azure.ai.formrecognizer.training.FormTrainingAsyncClient.beginCreateComposedModel#list}\n+     *\n+     * @param modelIds The list of models Ids to form the composed model.\n+     *\n+     * @return A {@link PollerFlux} that polls the create composed model operation until it has completed, has failed,\n+     * or has been cancelled. The completed operation returns the copied model {@link CustomFormModel}.", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NzQ0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501387440", "bodyText": "weird formatting here", "author": "kristapratico", "createdAt": "2020-10-08T00:43:24Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/FormTrainingAsyncClient.java", "diffHunk": "@@ -643,15 +734,18 @@ String getEndpoint() {\n \n     private Function<PollingContext<FormRecognizerOperationResult>, Mono<FormRecognizerOperationResult>>\n         getTrainingActivationOperation(\n-        String trainingFilesUrl, boolean includeSubfolders, String filePrefix, boolean useTrainingLabels,\n-        Context context) {\n+        String trainingFilesUrl, boolean useTrainingLabels, boolean includeSubfolders, String filePrefix,\n+        String modelDisplayName, Context context) {\n         return (pollingContext) -> {\n             try {\n                 Objects.requireNonNull(trainingFilesUrl, \"'trainingFilesUrl' cannot be null.\");\n                 TrainSourceFilter trainSourceFilter = new TrainSourceFilter().setIncludeSubFolders(includeSubfolders)\n                     .setPrefix(filePrefix);\n-                TrainRequest serviceTrainRequest = new TrainRequest().setSource(trainingFilesUrl).\n-                    setSourceFilter(trainSourceFilter).setUseLabelFile(useTrainingLabels);\n+                TrainRequest serviceTrainRequest = new TrainRequest()\n+                    .setSource(trainingFilesUrl).\n+                    setSourceFilter(trainSourceFilter)", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4NzYzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501387631", "bodyText": "CustomFormModelProperties?", "author": "kristapratico", "createdAt": "2020-10-08T00:44:05Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/models/CustomFormModel.java", "diffHunk": "@@ -52,6 +50,10 @@\n      */\n     private final List<TrainingDocumentInfo> trainingDocuments;\n \n+    private String modelDisplayName;\n+\n+    private CustomModelProperties customModelProperties;", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM4ODAxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r501388011", "bodyText": "possibly include the training document's modelID here since it is relevant for composed model", "author": "kristapratico", "createdAt": "2020-10-08T00:45:26Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/CreateComposedModel.java", "diffHunk": "@@ -0,0 +1,94 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.CreateComposedModelOptions;\n+import com.azure.ai.formrecognizer.models.FormRecognizerOperationResult;\n+import com.azure.ai.formrecognizer.training.FormTrainingClient;\n+import com.azure.ai.formrecognizer.training.FormTrainingClientBuilder;\n+import com.azure.ai.formrecognizer.training.models.CustomFormModel;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.polling.SyncPoller;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+\n+/**\n+ * Sample for creating a custom composed model.\n+ * <p>\n+ *     This is useful when you have trained different models and want to aggregate a group of\n+ *     them into a single model that you (or a user) could use to recognize a form. When doing\n+ *     so, you can let the service decide which model more accurately represents the form to\n+ *     recognize, instead of manually trying each trained model against the form and selecting\n+ *     the most accurate one.\n+ * </p>\n+ */\n+public class CreateComposedModel {\n+\n+    /**\n+     * Main method to invoke this demo.\n+     *\n+     * @param args Unused. Arguments to the program.\n+     */\n+    public static void main(final String[] args) {\n+        // Instantiate a source client which has the model that we want to copy.\n+        FormTrainingClient client = new FormTrainingClientBuilder()\n+            .credential(new AzureKeyCredential(\"{key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildClient();\n+\n+        // Train custom model\n+        String model1TrainingFiles = \"{SAS_URL_of_your_container_in_blob_storage_for_model_1}\";\n+        // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> model1Poller = client.beginTraining(model1TrainingFiles, true);\n+\n+        // Train custom model\n+        String model2TrainingFiles = \"{SAS_URL_of_your_container_in_blob_storage_for_model_2}\";\n+        // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> model2Poller = client.beginTraining(model2TrainingFiles, true);\n+\n+        String labeledModelId1 = model1Poller.getFinalResult().getModelId();\n+        String labeledModelId2 = model2Poller.getFinalResult().getModelId();\n+\n+        final CustomFormModel customFormModel\n+            = client.beginCreateComposedModel(Arrays.asList(labeledModelId1, labeledModelId2),\n+            new CreateComposedModelOptions()\n+                .setModelDisplayName(\"my composed model name\")\n+                .setPollInterval(Duration.ofSeconds(5)),\n+            Context.NONE)\n+            .getFinalResult();\n+\n+        System.out.printf(\"Model Id: %s%n\", customFormModel.getModelId());\n+        System.out.printf(\"Model Status: %s%n\", customFormModel.getModelStatus());\n+        System.out.printf(\"Model display name: %s%n\", customFormModel.getModelDisplayName());\n+        System.out.printf(\"Is this a composed model: %s%n\",\n+            customFormModel.getCustomModelProperties().isComposed());\n+        System.out.printf(\"Composed model creation started on: \", customFormModel.getTrainingStartedOn());\n+        System.out.printf(\"Composed model creation completed on: \", customFormModel.getTrainingCompletedOn());\n+\n+        System.out.println(\"Recognized Fields:\");\n+        customFormModel.getSubmodels().forEach(customFormSubmodel -> {\n+            System.out.printf(\"The subModel with form type %s has accuracy: %.2f%n\",\n+                customFormSubmodel.getFormType(), customFormSubmodel.getAccuracy());\n+            customFormSubmodel.getFields().forEach((label, customFormModelField) ->\n+                System.out.printf(\"The model found field '%s' to have name: %s with an accuracy: %.2f%n\",\n+                    label, customFormModelField.getName(), customFormModelField.getAccuracy()));\n+        });\n+        System.out.println();\n+\n+        customFormModel.getTrainingDocuments().forEach(trainingDocumentInfo -> {\n+            System.out.printf(\"Document name: %s%n\", trainingDocumentInfo.getName());", "originalCommit": "f90e98012c042179bbedec11b77614b62088d2e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0ff4b46af2e4d8a86c7e85244fb79899580cdd6c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0ff4b46af2e4d8a86c7e85244fb79899580cdd6c", "message": "add tests", "committedDate": "2020-10-12T00:42:14Z", "type": "forcePushed"}, {"oid": "28552d4a30ee1f35f523b70c1ac6422c072a1181", "url": "https://github.com/Azure/azure-sdk-for-java/commit/28552d4a30ee1f35f523b70c1ac6422c072a1181", "message": "update impl for compose models", "committedDate": "2020-10-12T00:45:09Z", "type": "commit"}, {"oid": "aacae89c0971bc779f7ba9e072f3d98e8456804b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aacae89c0971bc779f7ba9e072f3d98e8456804b", "message": "add initial tests", "committedDate": "2020-10-12T00:45:13Z", "type": "commit"}, {"oid": "190ad6bdf3c2c3fe4dc2975aa1c83d1bf0a3ae17", "url": "https://github.com/Azure/azure-sdk-for-java/commit/190ad6bdf3c2c3fe4dc2975aa1c83d1bf0a3ae17", "message": "add more tests", "committedDate": "2020-10-12T00:45:18Z", "type": "commit"}, {"oid": "f8ae360c28303a720695ec71687a37da4ea4ca49", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8ae360c28303a720695ec71687a37da4ea4ca49", "message": "update test rescordings", "committedDate": "2020-10-12T00:45:23Z", "type": "commit"}, {"oid": "782e3db662421b11f0039ef6f91257fd58d92695", "url": "https://github.com/Azure/azure-sdk-for-java/commit/782e3db662421b11f0039ef6f91257fd58d92695", "message": "updating training options", "committedDate": "2020-10-12T00:45:29Z", "type": "commit"}, {"oid": "9ad5f6f62bbeb76dc234b348c0583ac2551d0e73", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9ad5f6f62bbeb76dc234b348c0583ac2551d0e73", "message": "review comments", "committedDate": "2020-10-12T00:45:33Z", "type": "commit"}, {"oid": "4babbf45d2ec70029b274411b009711a0c982612", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4babbf45d2ec70029b274411b009711a0c982612", "message": "checkstyle", "committedDate": "2020-10-12T00:45:37Z", "type": "commit"}, {"oid": "897e2ce0d282fbfbc5ae59e08c1ab7469ec491f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/897e2ce0d282fbfbc5ae59e08c1ab7469ec491f1", "message": "add tests", "committedDate": "2020-10-12T00:45:41Z", "type": "commit"}, {"oid": "897e2ce0d282fbfbc5ae59e08c1ab7469ec491f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/897e2ce0d282fbfbc5ae59e08c1ab7469ec491f1", "message": "add tests", "committedDate": "2020-10-12T00:45:41Z", "type": "forcePushed"}, {"oid": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4c92a92c08846cefa99f25730e8fa5903ea51fad", "message": "update tests", "committedDate": "2020-10-14T02:28:33Z", "type": "commit"}, {"oid": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4c92a92c08846cefa99f25730e8fa5903ea51fad", "message": "update tests", "committedDate": "2020-10-14T02:28:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkzNjg2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504936867", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return the modelDisplayName.\n          \n          \n            \n                 * @return the modelName.", "author": "kristapratico", "createdAt": "2020-10-14T19:58:25Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/CreateComposedModelOptions.java", "diffHunk": "@@ -0,0 +1,62 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer.models;\n+\n+import com.azure.core.annotation.Fluent;\n+\n+import java.time.Duration;\n+\n+/**\n+ * The configurable options to pass when creating a composed model.\n+ */\n+@Fluent\n+public final class CreateComposedModelOptions {\n+    private static final Duration DEFAULT_POLL_INTERVAL = Duration.ofSeconds(5);\n+    private String modelName;\n+    private Duration pollInterval = DEFAULT_POLL_INTERVAL;\n+\n+    /**\n+     * Get the optional model name defined by the user.\n+     *\n+     * @return the modelDisplayName.", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NDYyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504944629", "bodyText": "should modelDisplayName be modelName? I see it used in some places, so not sure.", "author": "kristapratico", "createdAt": "2020-10-14T20:12:48Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/FormTrainingAsyncClient.java", "diffHunk": "@@ -643,17 +734,22 @@ String getEndpoint() {\n \n     private Function<PollingContext<FormRecognizerOperationResult>, Mono<FormRecognizerOperationResult>>\n         getTrainingActivationOperation(\n-        String trainingFilesUrl, boolean includeSubfolders, String filePrefix, boolean useTrainingLabels,\n-        Context context) {\n+        String trainingFilesUrl, boolean useTrainingLabels, boolean includeSubfolders, String filePrefix,\n+        String modelDisplayName, Context context) {", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk0NzA0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504947046", "bodyText": "remove max length", "author": "kristapratico", "createdAt": "2020-10-14T20:17:34Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/models/TrainingOptions.java", "diffHunk": "@@ -60,4 +61,25 @@ public TrainingOptions setPollInterval(final Duration pollInterval) {\n         this.pollInterval = pollInterval == null ? DEFAULT_POLL_INTERVAL : pollInterval;\n         return this;\n     }\n+\n+    /**\n+     * Get the optional model name defined by the user. (max length: 1024).\n+     *\n+     * @return the modelDisplayName.\n+     */\n+    public String getModelName() {\n+        return modelName;\n+    }\n+\n+    /**\n+     * Set the optional model name defined by the user. (max length: 1024).", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1MDgxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504950815", "bodyText": "might be good to show printing the modelId of the submodel here", "author": "kristapratico", "createdAt": "2020-10-14T20:24:39Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/CreateComposedModel.java", "diffHunk": "@@ -0,0 +1,96 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.ai.formrecognizer;\n+\n+import com.azure.ai.formrecognizer.models.CreateComposedModelOptions;\n+import com.azure.ai.formrecognizer.models.FormRecognizerOperationResult;\n+import com.azure.ai.formrecognizer.training.FormTrainingClient;\n+import com.azure.ai.formrecognizer.training.FormTrainingClientBuilder;\n+import com.azure.ai.formrecognizer.training.models.CustomFormModel;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.polling.SyncPoller;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+\n+/**\n+ * Sample for creating a custom composed model.\n+ * <p>\n+ *     This is useful when you have trained different models and want to aggregate a group of\n+ *     them into a single model that you (or a user) could use to recognize a form. When doing\n+ *     so, you can let the service decide which model more accurately represents the form to\n+ *     recognize, instead of manually trying each trained model against the form and selecting\n+ *     the most accurate one.\n+ * </p>\n+ */\n+public class CreateComposedModel {\n+\n+    /**\n+     * Main method to invoke this demo.\n+     *\n+     * @param args Unused. Arguments to the program.\n+     */\n+    public static void main(final String[] args) {\n+        // Instantiate a source client which has the model that we want to copy.\n+        FormTrainingClient client = new FormTrainingClientBuilder()\n+            .credential(new AzureKeyCredential(\"{key}\"))\n+            .endpoint(\"https://{endpoint}.cognitiveservices.azure.com/\")\n+            .buildClient();\n+\n+        // Train custom model\n+        String model1TrainingFiles = \"{SAS_URL_of_your_container_in_blob_storage_for_model_1}\";\n+        // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> model1Poller = client.beginTraining(model1TrainingFiles, true);\n+\n+        // Train custom model\n+        String model2TrainingFiles = \"{SAS_URL_of_your_container_in_blob_storage_for_model_2}\";\n+        // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> model2Poller = client.beginTraining(model2TrainingFiles, true);\n+\n+        String labeledModelId1 = model1Poller.getFinalResult().getModelId();\n+        String labeledModelId2 = model2Poller.getFinalResult().getModelId();\n+\n+        final CustomFormModel customFormModel\n+            = client.beginCreateComposedModel(Arrays.asList(labeledModelId1, labeledModelId2),\n+            new CreateComposedModelOptions()\n+                .setModelName(\"my composed model name\")\n+                .setPollInterval(Duration.ofSeconds(5)),\n+            Context.NONE)\n+            .getFinalResult();\n+\n+        System.out.printf(\"Model Id: %s%n\", customFormModel.getModelId());\n+        System.out.printf(\"Model Status: %s%n\", customFormModel.getModelStatus());\n+        System.out.printf(\"Model display name: %s%n\", customFormModel.getModelName());\n+        System.out.printf(\"Is this a composed model: %s%n\",\n+            customFormModel.getCustomModelProperties().isComposed());\n+        System.out.printf(\"Composed model creation started on: \", customFormModel.getTrainingStartedOn());\n+        System.out.printf(\"Composed model creation completed on: \", customFormModel.getTrainingCompletedOn());\n+\n+        System.out.println(\"Recognized Fields:\");\n+        customFormModel.getSubmodels().forEach(customFormSubmodel -> {\n+            System.out.printf(\"The subModel with form type %s has accuracy: %.2f%n\",", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1MTcxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504951718", "bodyText": "since we're just calling beginTraining here, maybe we should name the model \"model trained with labels\"?", "author": "kristapratico", "createdAt": "2020-10-14T20:26:16Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainModelWithLabels.java", "diffHunk": "@@ -36,13 +38,18 @@ public static void main(String[] args) {\n         // Train custom model\n         String trainingFilesUrl = \"{SAS_URL_of_your_container_in_blob_storage}\";\n         // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n-        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller = client.beginTraining(trainingFilesUrl, true);\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller\n+            = client.beginTraining(trainingFilesUrl,\n+            true,\n+            new TrainingOptions().setModelName(\"composed model name\"),", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1MTkzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504951930", "bodyText": "same here, \"model trained without labels\"?", "author": "kristapratico", "createdAt": "2020-10-14T20:26:41Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainModelWithoutLabels.java", "diffHunk": "@@ -35,13 +37,18 @@ public static void main(String[] args) {\n         // Train custom model\n         String trainingFilesUrl = \"{SAS_URL_of_your_container_in_blob_storage}\";\n         // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n-        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller = client.beginTraining(trainingFilesUrl, false);\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller\n+            = client.beginTraining(trainingFilesUrl,\n+            false,\n+            new TrainingOptions().setModelName(\"composed model name\"),", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1MjEwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504952106", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    System.out.printf(\"Model display name: %s%n\", customFormModel.getModelName());\n          \n          \n            \n                    System.out.printf(\"Model name: %s%n\", customFormModel.getModelName());", "author": "kristapratico", "createdAt": "2020-10-14T20:27:02Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/samples/java/com/azure/ai/formrecognizer/TrainModelWithoutLabels.java", "diffHunk": "@@ -35,13 +37,18 @@ public static void main(String[] args) {\n         // Train custom model\n         String trainingFilesUrl = \"{SAS_URL_of_your_container_in_blob_storage}\";\n         // The shared access signature (SAS) Url of your Azure Blob Storage container with your forms.\n-        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller = client.beginTraining(trainingFilesUrl, false);\n+        SyncPoller<FormRecognizerOperationResult, CustomFormModel> trainingPoller\n+            = client.beginTraining(trainingFilesUrl,\n+            false,\n+            new TrainingOptions().setModelName(\"composed model name\"),\n+            Context.NONE);\n \n         CustomFormModel customFormModel = trainingPoller.getFinalResult();\n \n         // Model Info\n         System.out.printf(\"Model Id: %s%n\", customFormModel.getModelId());\n         System.out.printf(\"Model Status: %s%n\", customFormModel.getModelStatus());\n+        System.out.printf(\"Model display name: %s%n\", customFormModel.getModelName());", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDk1MjQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r504952426", "bodyText": "calling delete model twice here", "author": "kristapratico", "createdAt": "2020-10-14T20:27:42Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/test/java/com/azure/ai/formrecognizer/FormRecognizerClientTest.java", "diffHunk": "@@ -1023,4 +1028,303 @@ public void recognizeCustomFormDamagedPdf(HttpClient httpClient,\n                     errorResponseException.getErrorInformation().get(0).getErrorCode());\n             }));\n     }\n+\n+    /**\n+     * Verifies recognized form type when labeled model used for recognition and model name is provided by user.\n+     */\n+    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)\n+    @MethodSource(\"com.azure.ai.formrecognizer.TestUtils#getTestParameters\")\n+    public void checkRecognizeFormTypeLabeledWithModelName(\n+        HttpClient httpClient, FormRecognizerServiceVersion serviceVersion) {\n+        final FormTrainingClient formTrainingClient = getFormTrainingClient(httpClient, serviceVersion);\n+        dataRunner((data, dataLength) -> {\n+            beginTrainingLabeledRunner((trainingFilesUrl, useTrainingLabels) -> {\n+                SyncPoller<FormRecognizerOperationResult, CustomFormModel> syncPoller\n+                    = formTrainingClient.beginTraining(trainingFilesUrl,\n+                    useTrainingLabels,\n+                    new TrainingOptions().setPollInterval(durationTestMode).setModelName(\"model1\"),\n+                    Context.NONE);\n+                syncPoller.waitForCompletion();\n+                CustomFormModel createdModel = syncPoller.getFinalResult();\n+\n+                FormRecognizerClient formRecognizerClient = getFormTrainingClient(httpClient, serviceVersion)\n+                    .getFormRecognizerClient();\n+                SyncPoller<FormRecognizerOperationResult, List<RecognizedForm>> syncPoller1\n+                    = formRecognizerClient.beginRecognizeCustomForms(\n+                    createdModel.getModelId(),\n+                    data,\n+                    dataLength,\n+                    new RecognizeCustomFormsOptions()\n+                        .setContentType(FormContentType.IMAGE_JPEG).setPollInterval(durationTestMode),\n+                    Context.NONE);\n+                syncPoller1.waitForCompletion();\n+                final RecognizedForm recognizedForm = syncPoller1.getFinalResult().stream().findFirst().get();\n+                assertEquals(\"custom:model1\", recognizedForm.getFormType());\n+                assertNotNull(recognizedForm.getFormTypeConfidence());\n+\n+                // check formtype set on submodel\n+                final CustomFormSubmodel submodel = createdModel.getSubmodels().get(0);\n+                assertEquals(\"custom:model1\", submodel.getFormType());\n+                formTrainingClient.deleteModel(createdModel.getModelId());\n+            });\n+        }, FORM_JPG);\n+    }\n+\n+    /**\n+     * Verifies recognized form type when labeled model used for recognition and model name is not provided by user.\n+     */\n+    @ParameterizedTest(name = DISPLAY_NAME_WITH_ARGUMENTS)\n+    @MethodSource(\"com.azure.ai.formrecognizer.TestUtils#getTestParameters\")\n+    public void checkRecognizedFormTypeLabeledModel(\n+        HttpClient httpClient, FormRecognizerServiceVersion serviceVersion) {\n+        final FormTrainingClient formTrainingClient = getFormTrainingClient(httpClient, serviceVersion);\n+        dataRunner((data, dataLength) -> {\n+            beginTrainingLabeledRunner((trainingFilesUrl, useTrainingLabels) -> {\n+                SyncPoller<FormRecognizerOperationResult, CustomFormModel> syncPoller\n+                    = formTrainingClient.beginTraining(trainingFilesUrl,\n+                    useTrainingLabels,\n+                    new TrainingOptions().setPollInterval(durationTestMode),\n+                    Context.NONE);\n+                syncPoller.waitForCompletion();\n+                CustomFormModel createdModel = syncPoller.getFinalResult();\n+\n+                FormRecognizerClient formRecognizerClient = getFormTrainingClient(httpClient, serviceVersion)\n+                    .getFormRecognizerClient();\n+                SyncPoller<FormRecognizerOperationResult, List<RecognizedForm>> syncPoller1\n+                    = formRecognizerClient.beginRecognizeCustomForms(\n+                    createdModel.getModelId(),\n+                    data,\n+                    dataLength,\n+                    new RecognizeCustomFormsOptions()\n+                        .setContentType(FormContentType.IMAGE_JPEG).setPollInterval(durationTestMode),\n+                    Context.NONE);\n+                syncPoller1.waitForCompletion();\n+                final RecognizedForm recognizedForm = syncPoller1.getFinalResult().stream().findFirst().get();\n+                assertEquals(\"custom:\" + createdModel.getModelId(), recognizedForm.getFormType());\n+                assertNotNull(recognizedForm.getFormTypeConfidence());\n+\n+                // check formtype set on submodel\n+                final CustomFormSubmodel submodel = createdModel.getSubmodels().get(0);\n+                assertEquals(\"custom:\" + createdModel.getModelId(), submodel.getFormType());\n+                formTrainingClient.deleteModel(createdModel.getModelId());\n+\n+                formTrainingClient.deleteModel(createdModel.getModelId());", "originalCommit": "4c92a92c08846cefa99f25730e8fa5903ea51fad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d3d022652d7b7becc65f9ed4fb3e33b720e06b19", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d3d022652d7b7becc65f9ed4fb3e33b720e06b19", "message": "remove display name refs and update samples", "committedDate": "2020-10-14T22:32:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5MTg5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505091894", "bodyText": "Does Java has nullable types? we set this type as Float? in .NET.\nI also think the docstring could be something similar to: https://github.com/Azure/azure-sdk-for-net/blob/master/sdk/formrecognizer/Azure.AI.FormRecognizer/src/RecognizedForm.cs#L82\nto help the user", "author": "maririos", "createdAt": "2020-10-15T00:14:58Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/models/RecognizedForm.java", "diffHunk": "@@ -90,4 +90,23 @@ public FormPageRange getPageRange() {\n     public List<FormPage> getPages() {\n         return this.pages;\n     }\n+\n+    /**\n+     * Get the confidence of the form type identified by the model.\n+     *\n+     * @return the formTypeConfidence value.\n+     */\n+    public Float getFormTypeConfidence() {", "originalCommit": "d3d022652d7b7becc65f9ed4fb3e33b720e06b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyMzE5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505723195", "bodyText": "Float is the nullable type, the other is float which would have been non-nullable. And here since the service may not send this back kept it as nullable.\nI will update the javadocs to say something similar", "author": "samvaity", "createdAt": "2020-10-15T17:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5MTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505094041", "bodyText": "what happens if the service doesn't return the attributes?\ni.e. for a model trained without labels, the service won't return this.\nWill the user be able to ask if model.properties.isComposed ?", "author": "maririos", "createdAt": "2020-10-15T00:22:15Z", "path": "sdk/formrecognizer/azure-ai-formrecognizer/src/main/java/com/azure/ai/formrecognizer/training/CustomModelTransforms.java", "diffHunk": "@@ -54,55 +57,147 @@ static CustomFormModel toCustomFormModel(Model modelResponse) {\n \n         List<TrainingDocumentInfo> trainingDocumentInfoList = null;\n         List<FormRecognizerError> modelErrors = null;\n+        final String modelId = modelInfo.getModelId().toString();\n \n+        // get document info for unlabeled and labeled models\n         if (modelResponse.getTrainResult() != null) {\n-            trainingDocumentInfoList =\n-                modelResponse.getTrainResult().getTrainingDocuments().stream()\n-                    .map(trainingDocumentItem -> new TrainingDocumentInfo(\n-                        trainingDocumentItem.getDocumentName(),\n-                        TrainingStatus.fromString(trainingDocumentItem.getStatus().toString()),\n-                        trainingDocumentItem.getPages(),\n-                        transformTrainingErrors(trainingDocumentItem.getErrors())))\n-                    .collect(Collectors.toList());\n+            trainingDocumentInfoList\n+                = getTrainingDocumentList(modelResponse.getTrainResult().getTrainingDocuments(), modelId);\n             modelErrors = transformTrainingErrors(modelResponse.getTrainResult().getErrors());\n         }\n \n-        List<CustomFormSubmodel> subModelList = new ArrayList<>();\n-        String formType = \"form-\";\n-        // unlabeled model\n+        List<CustomFormSubmodel> subModelList = null;\n         if (modelResponse.getKeys() != null) {\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getKeys().getClusters().forEach((clusterKey, clusterFields) -> {\n-                forEachWithIndex(clusterFields, (index, eachField) -> {\n-                    String fieldName = \"field-\" + index;\n-                    fieldMap.put(fieldName, new CustomFormModelField(eachField, fieldName, null));\n-                });\n-                subModelList.add(new CustomFormSubmodel(\n-                    null,\n-                    fieldMap,\n-                    formType + clusterKey));\n-            });\n+            // unlabeled model, read from page results\n+            subModelList = getUnlabeledSubmodels(modelResponse.getKeys().getClusters(), modelId);\n         } else if (modelResponse.getTrainResult() != null && modelResponse.getTrainResult().getFields() != null) {\n             // labeled model\n-            Map<String, CustomFormModelField> fieldMap = new TreeMap<>();\n-            modelResponse.getTrainResult().getFields()\n-                .forEach(formFieldsReport -> fieldMap.put(formFieldsReport.getFieldName(),\n-                    new CustomFormModelField(null, formFieldsReport.getFieldName(),\n-                        formFieldsReport.getAccuracy())));\n-            subModelList.add(new CustomFormSubmodel(\n-                modelResponse.getTrainResult().getAverageModelAccuracy(),\n-                fieldMap,\n-                formType + modelInfo.getModelId()));\n+            String formType = \"custom:\";\n+            if (modelInfo.getModelName() != null) {\n+                formType = formType + modelInfo.getModelName();\n+            } else {\n+                formType = formType + modelInfo.getModelId();\n+            }\n+            subModelList = getLabeledSubmodels(modelResponse, modelId, formType);\n+        } else if (!CoreUtils.isNullOrEmpty(modelResponse.getComposedTrainResults())) {\n+            // composed model\n+            subModelList = getComposedSubmodels(modelResponse);\n+            trainingDocumentInfoList = new ArrayList<>();\n+            for (TrainResult composedTrainResultItem : modelResponse.getComposedTrainResults()) {\n+                final List<TrainingDocumentInfo> trainingDocumentSubModelList\n+                    = getTrainingDocumentList(composedTrainResultItem.getTrainingDocuments(),\n+                    composedTrainResultItem.getModelId().toString());\n+                trainingDocumentInfoList.addAll(trainingDocumentSubModelList);\n+            }\n         }\n \n-        return new CustomFormModel(\n+        CustomFormModel customFormModel = new CustomFormModel(\n             modelInfo.getModelId().toString(),\n             CustomFormModelStatus.fromString(modelInfo.getStatus().toString()),\n             modelInfo.getCreatedDateTime(),\n             modelInfo.getLastUpdatedDateTime(),\n             subModelList,\n             modelErrors,\n             trainingDocumentInfoList);\n+\n+        if (modelInfo.getAttributes() != null) {", "originalCommit": "d3d022652d7b7becc65f9ed4fb3e33b720e06b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcyNjE4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505726185", "bodyText": "No, in the case of model trained without labels, the model.properties would be null and so the user won't be able to drill down further to the isComposed property.", "author": "samvaity", "createdAt": "2020-10-15T17:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzA3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505823077", "bodyText": "It will be better for the user to have a consistent experience when looking into the CustomFormModel independent of model trained with labels or not. If the user has a list of models and wants to see if they are composed or not they will have to first check if Properties are null and if not then check if isComposed == true.\nIt will be better for the SDK to always initialized Properties with isComposed=false so that the user can always count on Properties being present and therefore just as isComposed.", "author": "maririos", "createdAt": "2020-10-15T20:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyMzE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505823179", "bodyText": "We are doing this in .NET and Python", "author": "maririos", "createdAt": "2020-10-15T20:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg0MjgxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505842813", "bodyText": "I think it's a general pattern we have used in Java libraries to keep properties as null rather than using some kind of defaulting.\nAlso, to think about it wouldn't isComposed=false mean that the model is not composed but isComposed/properties as null would mean it cannot have such a property which is the case for \"models trained without labels\".\nI don't think isComposed=false is particularly true for models trained without labels. null and false would mean different things following Java standards.", "author": "samvaity", "createdAt": "2020-10-15T20:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3Nzc3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505877771", "bodyText": "This might be language specific then. In .NET we avoid null as much as possible as it breaks the flow for customers.\nI still think you should initialize it, otherwise you are saying that Properties only applied for models with labels.\ni.e. if in the future the service adds a new property that applies for both models with and without labels, you are going to have to initialize Properties and assigne isComposed to false. This will already brake customers that are assuming that Properties are only for models with labels.", "author": "maririos", "createdAt": "2020-10-15T21:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg5MTM4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505891387", "bodyText": "if in the future the service adds a new property that applies for both models with and without labels, you are going to have to initialize Properties and assigne isComposed to false.\n\nNot true. In that case, too, the properties would have to be assigned but isComposed should only be assigned with what's returned from the service (true/null/false).\nDefaulting when service doesn't return values could be a considerable overhead for client libraries.  For instance, when the service adds additional 5-6 properties, we would be defaulting them all in case of .NET approach?", "author": "samvaity", "createdAt": "2020-10-15T22:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwMjcwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505902709", "bodyText": "So should Properties be assigned now? will it be confusing if later properties is never null?\nIt depends on the property, so we default case by case. Currently we do default to false for isComposed", "author": "maririos", "createdAt": "2020-10-15T22:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwNDQ5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15925#discussion_r505904499", "bodyText": "Asked the service => https://teams.microsoft.com/l/message/19:88f2d9dea2344075b5d4bc34d82a3d1c@thread.skype/1602801673358?tenantId=72f988bf-86f1-41af-91ab-2d7cd011db47&groupId=3e17dcb0-4257-4a30-b843-77f47f1d4121&parentMessageId=1602801673358&teamName=Azure%20SDK&channelName=Service%20-%20Form%20Recognizer&createdTime=1602801673358", "author": "maririos", "createdAt": "2020-10-15T22:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTA5NDA0MQ=="}], "type": "inlineReview"}]}