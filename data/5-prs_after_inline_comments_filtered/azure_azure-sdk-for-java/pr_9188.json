{"pr_number": 9188, "pr_title": "Persistence token cache for Mac & Linux with new MSAL ext", "pr_createdAt": "2020-03-18T07:29:11Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9188", "timeline": [{"oid": "898a02f16e1a727d50d3dfb6bba976d26949162e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/898a02f16e1a727d50d3dfb6bba976d26949162e", "message": "Depend on msal persistence extension", "committedDate": "2020-03-17T00:11:30Z", "type": "commit"}, {"oid": "132c01a578726cf3c8227a80e6bc38ba34171470", "url": "https://github.com/Azure/azure-sdk-for-java/commit/132c01a578726cf3c8227a80e6bc38ba34171470", "message": "Initial draft of shared token cache for Mac and Linux", "committedDate": "2020-03-18T07:27:29Z", "type": "commit"}, {"oid": "3c034433635405cd77f8f5dd3a03f504e645a6e8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3c034433635405cd77f8f5dd3a03f504e645a6e8", "message": "Clean up", "committedDate": "2020-03-18T07:31:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE1MDk1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r394150956", "bodyText": "Keychain service & account names are consistent with Python ext at https://github.com/AzureAD/microsoft-authentication-extensions-for-python/blob/71b5301cb8c4768a9f439bde20750d448062944c/msal_extensions/token_cache.py#L141 and this test in .NET ext: https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/blob/85c1e8ec283b940b1cc34eae44ac37fa645738ff/tests/Microsoft.Identity.Client.Extensions.Msal.UnitTests/MsalCacheStorageTests.cs", "author": "jianghaolu", "createdAt": "2020-03-18T07:34:19Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DefaultAzureCredential.java", "diffHunk": "@@ -23,6 +27,18 @@\n  */\n @Immutable\n public final class DefaultAzureCredential extends ChainedTokenCredential {\n+    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final Path DEFAULT_CACHE_DIRECTORY = Platform.isWindows() ?\n+            Paths.get(System.getProperty(\"user.home\"), \"AppData\", \"Local\", \".IdentityService\", \"msal.cache\") :\n+            Paths.get(System.getProperty(\"user.home\"),\".IdentityService\", \"msal.cache\");\n+    private static final String DEFAULT_KEYCHAIN_SERVICE = \"Microsoft.Developer.IdentityService\";", "originalCommit": "3c034433635405cd77f8f5dd3a03f504e645a6e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE1MTMxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r394151318", "bodyText": "This is consistent with Visual Studio: https://github.com/microsoft/Git-Credential-Manager-Core/blob/master/src/shared/Microsoft.Git.CredentialManager/Authentication/MicrosoftAuthentication.cs#L228", "author": "jianghaolu", "createdAt": "2020-03-18T07:35:17Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DefaultAzureCredential.java", "diffHunk": "@@ -23,6 +27,18 @@\n  */\n @Immutable\n public final class DefaultAzureCredential extends ChainedTokenCredential {\n+    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final Path DEFAULT_CACHE_DIRECTORY = Platform.isWindows() ?\n+            Paths.get(System.getProperty(\"user.home\"), \"AppData\", \"Local\", \".IdentityService\", \"msal.cache\") :", "originalCommit": "3c034433635405cd77f8f5dd3a03f504e645a6e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE1MTUwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r394151504", "bodyText": "This is invented by me - open for discussion", "author": "jianghaolu", "createdAt": "2020-03-18T07:35:43Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DefaultAzureCredential.java", "diffHunk": "@@ -23,6 +27,18 @@\n  */\n @Immutable\n public final class DefaultAzureCredential extends ChainedTokenCredential {\n+    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final Path DEFAULT_CACHE_DIRECTORY = Platform.isWindows() ?\n+            Paths.get(System.getProperty(\"user.home\"), \"AppData\", \"Local\", \".IdentityService\", \"msal.cache\") :\n+            Paths.get(System.getProperty(\"user.home\"),\".IdentityService\", \"msal.cache\");", "originalCommit": "3c034433635405cd77f8f5dd3a03f504e645a6e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDE1MTczNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r394151735", "bodyText": "Line 39 and 40 are also from the test https://github.com/AzureAD/microsoft-authentication-extensions-for-dotnet/blob/85c1e8ec283b940b1cc34eae44ac37fa645738ff/tests/Microsoft.Identity.Client.Extensions.Msal.UnitTests/MsalCacheStorageTests.cs", "author": "jianghaolu", "createdAt": "2020-03-18T07:36:15Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DefaultAzureCredential.java", "diffHunk": "@@ -23,6 +27,18 @@\n  */\n @Immutable\n public final class DefaultAzureCredential extends ChainedTokenCredential {\n+    private static final String DEFAULT_CACHE_FILE_NAME = \"msal.cache\";\n+    private static final Path DEFAULT_CACHE_DIRECTORY = Platform.isWindows() ?\n+            Paths.get(System.getProperty(\"user.home\"), \"AppData\", \"Local\", \".IdentityService\", \"msal.cache\") :\n+            Paths.get(System.getProperty(\"user.home\"),\".IdentityService\", \"msal.cache\");\n+    private static final String DEFAULT_KEYCHAIN_SERVICE = \"Microsoft.Developer.IdentityService\";\n+    private static final String DEFAULT_KEYCHAIN_ACCOUNT = \"MSALCache\";\n+    private static final String DEFAULT_KEYRING_NAME = \"default\";\n+    private static final KeyRingItemSchema DEFAULT_KEYRING_SCHEMA = KeyRingItemSchema.GENERIC_SECRET;\n+    private static final String DEFAULT_KEYRING_ITEM_NAME = DEFAULT_KEYCHAIN_ACCOUNT;\n+    private static final String DEFAULT_KEYRING_ATTR_NAME = \"MsalClientID\";", "originalCommit": "3c034433635405cd77f8f5dd3a03f504e645a6e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "49acab7e6a50a2cbf902b3fb78565792d34b260a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49acab7e6a50a2cbf902b3fb78565792d34b260a", "message": "Add msal ext to module-info", "committedDate": "2020-03-18T21:18:46Z", "type": "commit"}, {"oid": "f50d8b7e12ea6e7b535b025192c678a7732bc26e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f50d8b7e12ea6e7b535b025192c678a7732bc26e", "message": "Wrap MSAL error and fix module-info", "committedDate": "2020-03-18T22:40:05Z", "type": "commit"}, {"oid": "4e4c467657ae1143afcb456d0d1faca0df7adc09", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e4c467657ae1143afcb456d0d1faca0df7adc09", "message": "checkstyle", "committedDate": "2020-03-18T23:13:23Z", "type": "commit"}, {"oid": "fca0133afb51e296ab1ea63dfcc02fcb37ff4935", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fca0133afb51e296ab1ea63dfcc02fcb37ff4935", "message": "Fix spotbugs and naming", "committedDate": "2020-03-18T23:37:50Z", "type": "commit"}, {"oid": "571b44c4cb9ed408cea69de5e323ee9206224834", "url": "https://github.com/Azure/azure-sdk-for-java/commit/571b44c4cb9ed408cea69de5e323ee9206224834", "message": "Fix default azure credential test", "committedDate": "2020-03-23T21:20:30Z", "type": "commit"}, {"oid": "e2c5dc36599d20d8277d47228ac94d6d6d8af086", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2c5dc36599d20d8277d47228ac94d6d6d8af086", "message": "Add initial perf test", "committedDate": "2020-04-01T19:36:11Z", "type": "commit"}, {"oid": "dd341e7d557ee525145f9f7b881c07709ee0d85e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dd341e7d557ee525145f9f7b881c07709ee0d85e", "message": "more perf testing work", "committedDate": "2020-04-03T21:20:52Z", "type": "commit"}, {"oid": "7cba579bc24e6d656a48be916760d4d3a7f16f30", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7cba579bc24e6d656a48be916760d4d3a7f16f30", "message": "Move default to identity client options", "committedDate": "2020-04-06T23:25:10Z", "type": "commit"}, {"oid": "600fc6b4af77373b5bb1e56bc9e73e8329eed72c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/600fc6b4af77373b5bb1e56bc9e73e8329eed72c", "message": "Fix array access in identity client options", "committedDate": "2020-04-07T01:43:34Z", "type": "commit"}, {"oid": "1c53b243c38cee41ccd8aa2a6a07319124fbb39e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1c53b243c38cee41ccd8aa2a6a07319124fbb39e", "message": "Fix libsecret on Windows", "committedDate": "2020-04-07T06:49:50Z", "type": "commit"}, {"oid": "3539779b9c632bd28823c2e9752989a3517c184e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3539779b9c632bd28823c2e9752989a3517c184e", "message": "Remove shared token cache configurations", "committedDate": "2020-04-07T21:59:45Z", "type": "commit"}, {"oid": "80bb671f72a12fa4058efde35f03a5f0fca6d304", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80bb671f72a12fa4058efde35f03a5f0fca6d304", "message": "Clean up", "committedDate": "2020-04-07T22:04:37Z", "type": "commit"}, {"oid": "b28941119a5df60ed5f687f59fdd733988c56179", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b28941119a5df60ed5f687f59fdd733988c56179", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence-perf", "committedDate": "2020-04-07T22:19:28Z", "type": "commit"}, {"oid": "a83c9ab0df31f2a9b17efbdee519ca2c03671917", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a83c9ab0df31f2a9b17efbdee519ca2c03671917", "message": "Fix tests", "committedDate": "2020-04-07T23:16:30Z", "type": "commit"}, {"oid": "52e11f6e41c1d0908b4a5af476326f99611b72db", "url": "https://github.com/Azure/azure-sdk-for-java/commit/52e11f6e41c1d0908b4a5af476326f99611b72db", "message": "Fix versions", "committedDate": "2020-04-07T23:21:08Z", "type": "commit"}, {"oid": "5a79873983b33434529421634dc46231450f44dc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5a79873983b33434529421634dc46231450f44dc", "message": "Fix versions", "committedDate": "2020-04-07T23:37:49Z", "type": "commit"}, {"oid": "bfcf3b3302fcce9049223909adc90bd233b901b7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bfcf3b3302fcce9049223909adc90bd233b901b7", "message": "Add version again", "committedDate": "2020-04-08T00:03:24Z", "type": "commit"}, {"oid": "3660848340c4b749d9aa07eb91e4022ad3aab0f6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3660848340c4b749d9aa07eb91e4022ad3aab0f6", "message": "Lazy initialize pub client", "committedDate": "2020-04-08T20:53:44Z", "type": "commit"}, {"oid": "8c5606a4e0968a9bece6c96b4ea612089d18fa94", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8c5606a4e0968a9bece6c96b4ea612089d18fa94", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence-perf", "committedDate": "2020-04-08T21:05:25Z", "type": "commit"}, {"oid": "435a4f25db9eb59dcad9c6deb5853b17836a1565", "url": "https://github.com/Azure/azure-sdk-for-java/commit/435a4f25db9eb59dcad9c6deb5853b17836a1565", "message": "Defer Mono.fromFuture()", "committedDate": "2020-04-08T21:25:24Z", "type": "commit"}, {"oid": "4ad8ef8bbcaececf6ce2ba6855631111601aaec0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4ad8ef8bbcaececf6ce2ba6855631111601aaec0", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence-perf", "committedDate": "2020-04-08T22:05:15Z", "type": "commit"}, {"oid": "5ac9807992e1983c20ba5b684a67b174b439629d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5ac9807992e1983c20ba5b684a67b174b439629d", "message": "Checkstyle", "committedDate": "2020-04-08T22:11:25Z", "type": "commit"}, {"oid": "0b48bbb94412070d81f71d096262f9204911cb32", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0b48bbb94412070d81f71d096262f9204911cb32", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence-perf", "committedDate": "2020-04-13T22:50:03Z", "type": "commit"}, {"oid": "f8245f0ddd25be0bac8b2859827a67e4cf08b2bb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8245f0ddd25be0bac8b2859827a67e4cf08b2bb", "message": "Fix in perf test", "committedDate": "2020-04-14T18:37:01Z", "type": "commit"}, {"oid": "e8d572a807ecb35cd78d0fb8516f2b2cee3ce12f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e8d572a807ecb35cd78d0fb8516f2b2cee3ce12f", "message": "Merge branch 'persistence' of github.com:jianghaolu/azure-sdk-for-java into persistence-perf", "committedDate": "2020-04-14T18:41:16Z", "type": "commit"}, {"oid": "ed6b0137e88e994d19dabf75263dd001404da094", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed6b0137e88e994d19dabf75263dd001404da094", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence", "committedDate": "2020-04-20T21:59:37Z", "type": "commit"}, {"oid": "1472726a6612a02a1fd330071c1aaad23a903a5b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1472726a6612a02a1fd330071c1aaad23a903a5b", "message": "Does not throw except SharedTokenCacheCredential", "committedDate": "2020-04-21T07:15:18Z", "type": "commit"}, {"oid": "1cc825445fa02cfa045a30e07ce3a61a575965cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1cc825445fa02cfa045a30e07ce3a61a575965cc", "message": "Fix merge error", "committedDate": "2020-04-21T18:15:47Z", "type": "commit"}, {"oid": "6b1e50d109738ef602e5c0370617d420d503fdd9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b1e50d109738ef602e5c0370617d420d503fdd9", "message": "x-include-update", "committedDate": "2020-04-21T21:59:58Z", "type": "commit"}, {"oid": "3a16cadc09e7e61a66ef9bdcc1e4c8baab99a0ec", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a16cadc09e7e61a66ef9bdcc1e4c8baab99a0ec", "message": "Minor change in public client creation", "committedDate": "2020-04-22T05:46:47Z", "type": "commit"}, {"oid": "db0eb379f701bf774bb710128c34afca682da12a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/db0eb379f701bf774bb710128c34afca682da12a", "message": "Checkstyle", "committedDate": "2020-04-22T06:39:13Z", "type": "commit"}, {"oid": "775568f00d9d8b942c670b74412c0e0112a6d15b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/775568f00d9d8b942c670b74412c0e0112a6d15b", "message": "Revert persistent cache demo", "committedDate": "2020-04-22T06:52:05Z", "type": "commit"}, {"oid": "006b191ee58398d9114cdab3625bd1a87ce36726", "url": "https://github.com/Azure/azure-sdk-for-java/commit/006b191ee58398d9114cdab3625bd1a87ce36726", "message": "Align Linux default settings with MSAL.NET tests", "committedDate": "2020-04-22T07:26:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MzY0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r413993646", "bodyText": "nit: to be consistent with the rest of the javadoc change this to\n@return An updated instance of this builder with useUnprotectedFileOnLinux set as specified.", "author": "srnagar", "createdAt": "2020-04-23T17:38:43Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/AadCredentialBuilderBase.java", "diffHunk": "@@ -70,4 +70,31 @@ public T executorService(ExecutorService executorService) {\n         this.identityClientOptions.setExecutorService(executorService);\n         return (T) this;\n     }\n+\n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param useUnprotectedFileOnLinux whether to use an unprotected file for cache storage.\n+     *\n+     * @return The updated T object.", "originalCommit": "006b191ee58398d9114cdab3625bd1a87ce36726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDE4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414014186", "bodyText": "Updated", "author": "jianghaolu", "createdAt": "2020-04-23T18:08:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MzgzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r413993837", "bodyText": "same as above", "author": "srnagar", "createdAt": "2020-04-23T17:39:00Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/AadCredentialBuilderBase.java", "diffHunk": "@@ -70,4 +70,31 @@ public T executorService(ExecutorService executorService) {\n         this.identityClientOptions.setExecutorService(executorService);\n         return (T) this;\n     }\n+\n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param useUnprotectedFileOnLinux whether to use an unprotected file for cache storage.\n+     *\n+     * @return The updated T object.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T useUnprotectedTokenCacheFileOnLinux(boolean useUnprotectedFileOnLinux) {\n+        this.identityClientOptions.setUseUnprotectedTokenCacheFileOnLinux(useUnprotectedFileOnLinux);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Disable using the shared token cache.\n+     *\n+     * @param disabled whether to disable using the shared token cache.\n+     *\n+     * @return The updated identity client options.", "originalCommit": "006b191ee58398d9114cdab3625bd1a87ce36726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDI1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414014252", "bodyText": "Updated", "author": "jianghaolu", "createdAt": "2020-04-23T18:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5MzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NDkwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r413994907", "bodyText": "Since the javadoc mentions that this is an expandable enum, should this class extend from ExpandableStringEnum?", "author": "srnagar", "createdAt": "2020-04-23T17:40:37Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/KeyringItemSchema.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.identity;\n+\n+/**\n+ * An expandable enum for types of item schema in a Keyring.\n+ */\n+public final class KeyringItemSchema {", "originalCommit": "006b191ee58398d9114cdab3625bd1a87ce36726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAxNDM3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414014378", "bodyText": "Changed to extend from ExpandableStringEnum", "author": "jianghaolu", "createdAt": "2020-04-23T18:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NDkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODk4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r413998986", "bodyText": "Use log instead of e.printStackTrace()", "author": "srnagar", "createdAt": "2020-04-23T17:46:30Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +529,86 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId + \"/\";\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorResume(t -> Mono.error(new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t)))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (accounts.size() == 0) {\n+                        if (username == null) {\n+                            return Mono.error(new CredentialUnavailableException(\"No accounts were discovered in the \"\n+                                    + \"shared token cache. To fix, authenticate through tooling supporting azure \"\n+                                    + \"developer sign on.\"));\n+                        } else {\n+                            return Mono.error(new CredentialUnavailableException(String.format(\"User account '%s' was \"\n+                                    + \"not found in the shared token cache. Discovered Accounts: [ '%s' ]\", username,\n+                                    set.stream().map(IAccount::username).distinct()\n+                                            .collect(Collectors.joining(\", \")))));\n+                        }\n+                    } else if (accounts.size() > 1) {\n+                        if (username == null) {\n+                            return Mono.error(new CredentialUnavailableException(\"Multiple accounts were discovered \"\n+                                    + \"in the shared token cache. To fix, set the AZURE_USERNAME and AZURE_TENANT_ID \"\n+                                    + \"environment variable to the preferred username, or specify it when \"\n+                                    + \"constructing SharedTokenCacheCredential.\"));\n+                        } else {\n+                            return Mono.error(new CredentialUnavailableException(\"Multiple entries for the user \"\n+                                    + \"account \" + username + \" were found in the shared token cache. This is not \"\n+                                    + \"currently supported by the SharedTokenCacheCredential.\"));\n+                        }\n+                    } else {\n+                        requestedAccount = accounts.values().iterator().next();\n+                    }\n+\n+                    // if it does, then request the token\n+                    SilentParameters params = SilentParameters.builder(\n+                            new HashSet<>(request.getScopes()), requestedAccount)\n+                            .authorityUrl(authorityUrl)\n+                            .build();\n+\n+                    SilentParameters forceParams = SilentParameters.builder(\n+                            new HashSet<>(request.getScopes()), requestedAccount)\n+                            .authorityUrl(authorityUrl)\n+                            .forceRefresh(true)\n+                            .build();\n+\n+                    CompletableFuture<IAuthenticationResult> future;\n+                    try {\n+                        future = getPublicClientApplication(false).acquireTokenSilently(params);\n+                        return Mono.fromFuture(() -> future).map(result ->\n+                                    new MsalToken(result, options))\n+                                .filter(t -> !t.isExpired())\n+                                .switchIfEmpty(Mono.defer(() -> Mono.fromFuture(() -> {\n+                                        try {\n+                                            return getPublicClientApplication(false).acquireTokenSilently(forceParams);\n+                                        } catch (MalformedURLException e) {\n+                                            throw logger.logExceptionAsWarning(new RuntimeException(e));\n+                                        }\n+                                    }\n+                                ).map(result -> new MsalToken(result, options))));\n+                    } catch (MalformedURLException e) {\n+                        e.printStackTrace();", "originalCommit": "006b191ee58398d9114cdab3625bd1a87ce36726", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5MTc2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414091767", "bodyText": "Updated.", "author": "jianghaolu", "createdAt": "2020-04-23T20:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5ODk4Ng=="}], "type": "inlineReview"}, {"oid": "eb9c6150b09493f5f45eebe6e563b428401edf51", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb9c6150b09493f5f45eebe6e563b428401edf51", "message": "Fix readme and use expandable enum", "committedDate": "2020-04-23T18:07:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDk1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414104957", "bodyText": "I think that persistence of the token cache should be opt-in rather than opt out. Also I'm not sure we can put this on the base builder for all credentials, for instance what does it mean to create a SharedTokenCachceCredential with the shared token cache disabled.", "author": "schaabs", "createdAt": "2020-04-23T20:34:16Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/AadCredentialBuilderBase.java", "diffHunk": "@@ -70,4 +70,31 @@ public T executorService(ExecutorService executorService) {\n         this.identityClientOptions.setExecutorService(executorService);\n         return (T) this;\n     }\n+\n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param useUnprotectedFileOnLinux whether to use an unprotected file for cache storage.\n+     *\n+     * @return An updated instance of this builder with the unprotected token cache setting set as specified.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T useUnprotectedTokenCacheFileOnLinux(boolean useUnprotectedFileOnLinux) {\n+        this.identityClientOptions.setUseUnprotectedTokenCacheFileOnLinux(useUnprotectedFileOnLinux);\n+        return (T) this;\n+    }\n+\n+    /**\n+     * Disable using the shared token cache.\n+     *\n+     * @param disabled whether to disable using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache disabled specified.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public T disableSharedTokenCache(boolean disabled) {", "originalCommit": "eb9c6150b09493f5f45eebe6e563b428401edf51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExNTU0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414115549", "bodyText": "For SharedTokenCacheCredential, yes you can disable shared token cache, but assuming no one will do this does save us a ton of duplicate code.", "author": "jianghaolu", "createdAt": "2020-04-23T20:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2NTMwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414165307", "bodyText": "ManagedIdentityCredential and DefaultAzureCredential inherit from CredentialBuilderBase, so they will not inherit this setter currently.", "author": "g2vinay", "createdAt": "2020-04-23T22:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNDk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNjgzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414106838", "bodyText": "Is this meant to be part of the public API? I'd prefer to keep these details internal.", "author": "schaabs", "createdAt": "2020-04-23T20:37:21Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/KeyringItemSchema.java", "diffHunk": "@@ -0,0 +1,20 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.identity;\n+\n+import com.azure.core.util.ExpandableStringEnum;\n+\n+/**\n+ * An expandable enum for types of item schema in a Keyring.\n+ */\n+\n+public final class KeyringItemSchema extends ExpandableStringEnum<KeyringItemSchema> {", "originalCommit": "eb9c6150b09493f5f45eebe6e563b428401edf51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDExMzM4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414113380", "bodyText": "Good catch - It was made public to allow configurations - but since for now we are not allowing users to configure it I'll hide it.", "author": "jianghaolu", "createdAt": "2020-04-23T20:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEwNjgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2MzExNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r414163116", "bodyText": "do we need them to be static ?", "author": "g2vinay", "createdAt": "2020-04-23T22:22:26Z", "path": "sdk/identity/azure-identity-perf/src/main/java/com/azure/identity/perf/core/ServiceTest.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.identity.perf.core;\n+\n+import com.azure.core.credential.TokenRequestContext;\n+import com.azure.identity.InteractiveBrowserCredential;\n+import com.azure.identity.InteractiveBrowserCredentialBuilder;\n+import com.azure.perf.test.core.PerfStressOptions;\n+import com.azure.perf.test.core.PerfStressTest;\n+import reactor.core.publisher.Mono;\n+\n+public abstract class ServiceTest<TOptions extends PerfStressOptions> extends PerfStressTest<TOptions> {\n+    protected static final String CLI_CLIENT_ID = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\";", "originalCommit": "eb9c6150b09493f5f45eebe6e563b428401edf51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA4OTA2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417089065", "bodyText": "I'm simply defining it as a constant: https://stackoverflow.com/questions/9639007/defining-constant-string-in-java", "author": "jianghaolu", "createdAt": "2020-04-29T06:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE2MzExNg=="}], "type": "inlineReview"}, {"oid": "abfbea9b13903775212825c1fd6c261b690e5d2e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abfbea9b13903775212825c1fd6c261b690e5d2e", "message": "Merge branch 'persistence' of github.com:jianghaolu/azure-sdk-for-java into persistence", "committedDate": "2020-04-25T20:09:08Z", "type": "commit"}, {"oid": "233ce5cb67766680997b09cd944cda342f92a1c0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/233ce5cb67766680997b09cd944cda342f92a1c0", "message": "Disable shared token cache by default", "committedDate": "2020-04-29T06:24:47Z", "type": "commit"}, {"oid": "a0b1725bcf66d5d879ba8a764e1281886193b101", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0b1725bcf66d5d879ba8a764e1281886193b101", "message": "Allow enabling on select builders", "committedDate": "2020-04-29T06:44:29Z", "type": "commit"}, {"oid": "77c8a593e6b0ca17b71912361e2ff2c99f83cb99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/77c8a593e6b0ca17b71912361e2ff2c99f83cb99", "message": "Wrap exceptions in ClientAuthenticationExceptions when Msal fails", "committedDate": "2020-04-29T07:18:41Z", "type": "commit"}, {"oid": "7c7045cdf0860adb8c52b562390ea12d167a1ffe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7c7045cdf0860adb8c52b562390ea12d167a1ffe", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence", "committedDate": "2020-04-29T07:23:48Z", "type": "commit"}, {"oid": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed8e7223daf3df49e337c1e163a56ab9459cdb52", "message": "Address spotbugs", "committedDate": "2020-04-29T07:46:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MTAxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417461012", "bodyText": "Is this exception message meant to be the same as the one above?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:47:26Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -144,7 +153,22 @@\n             if (options.getExecutorService() != null) {\n                 publicClientApplicationBuilder.executorService(options.getExecutorService());\n             }\n+            if (options.isSharedTokenCacheEnabled()) {\n+                try {\n+                    publicClientApplicationBuilder.setTokenCacheAccessAspect(\n+                            new PersistenceTokenCacheAccessAspect(options.getPersistenceSettings()));\n+                } catch (Throwable t) {\n+                    if (sharedTokenCacheCredential) {\n+                        throw logger.logExceptionAsError(new CredentialUnavailableException(\n+                            \"Shared token cache is unavailable in this environment.\", t));\n+                    } else {\n+                        throw logger.logExceptionAsError(new ClientAuthenticationException(\n+                            \"Shared token cache is unavailable in this environment.\", null, t));", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwMjE4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417602182", "bodyText": "They are indeed the same - just wrapping in different exceptions to be handled differently downstream.", "author": "jianghaolu", "createdAt": "2020-04-29T20:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MTAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjYxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417462616", "bodyText": "Should this be onErrorMap? This logic looks to be more of an error mapping than an alternate resume from an exception given this will propagate an error.", "author": "alzimmermsft", "createdAt": "2020-04-29T16:49:53Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with username \"", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MTc0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417581745", "bodyText": "Yes - I'm not aware of this operator, changing them now", "author": "jianghaolu", "createdAt": "2020-04-29T20:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2MjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417464162", "bodyText": "Do we ever want this future to be cancellable? If yes, we will need to add a doFinally operator that will check for cancelled to cancel the future.", "author": "alzimmermsft", "createdAt": "2020-04-29T16:52:02Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwMTk3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417601977", "bodyText": "Synced offline - due to the small cost of the getToken() call we will skip the hassle to cancel the future here", "author": "jianghaolu", "createdAt": "2020-04-29T20:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5NzI5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418497296", "bodyText": "acquireToken here will most likely make an HttpRequest, would this normally be cancellable in other service clients? If so we should probably do the same here.", "author": "schaabs", "createdAt": "2020-05-01T10:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODgyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418778825", "bodyText": "As discussed, there's nothing much to gain to chain doOnCancel signal to CompletableFuture, as it gets triggered right away and not when subscribed to.", "author": "g2vinay", "createdAt": "2020-05-01T23:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDQ5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417464496", "bodyText": "The defer isn't needed here.", "author": "alzimmermsft", "createdAt": "2020-04-29T16:52:30Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with username \"\n+                + \"and password\", null, t))).map(ar -> new MsalToken(ar, options));\n     }\n \n     /**\n      * Asynchronously acquire a token from the currently logged in client.\n      *\n      * @param request the details of the token request\n+     * @param account the account used to login to acquire the last token\n      * @return a Publisher that emits an AccessToken\n      */\n-    public Mono<MsalToken> authenticateWithUserRefreshToken(TokenRequestContext request, MsalToken msalToken) {\n+    public Mono<MsalToken> authenticateWithMsalAccount(TokenRequestContext request, IAccount account) {\n         SilentParameters parameters;\n-        if (msalToken.getAccount() != null) {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), msalToken.getAccount()).build();\n+        SilentParameters forceParameters;\n+        if (account != null) {\n+            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account)\n+                    .forceRefresh(true).build();\n         } else {\n             parameters = SilentParameters.builder(new HashSet<>(request.getScopes())).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes())).forceRefresh(true).build();\n         }\n         return Mono.defer(() -> {\n             try {\n-                return Mono.fromFuture(publicClientApplication.acquireTokenSilently(parameters))\n-                        .map(ar -> new MsalToken(ar, options));\n+                return Mono.fromFuture(getPublicClientApplication(false).acquireTokenSilently(parameters))\n+                        .map(ar -> new MsalToken(ar, options))\n+                        .filter(t -> !t.isExpired())\n+                        .switchIfEmpty(Mono.defer(() -> Mono.fromFuture(() -> {", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MjMwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417582308", "bodyText": "Removed.", "author": "jianghaolu", "createdAt": "2020-04-29T20:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDg5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417464899", "bodyText": "Should this use a future supplier as below?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:53:06Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with username \"\n+                + \"and password\", null, t))).map(ar -> new MsalToken(ar, options));\n     }\n \n     /**\n      * Asynchronously acquire a token from the currently logged in client.\n      *\n      * @param request the details of the token request\n+     * @param account the account used to login to acquire the last token\n      * @return a Publisher that emits an AccessToken\n      */\n-    public Mono<MsalToken> authenticateWithUserRefreshToken(TokenRequestContext request, MsalToken msalToken) {\n+    public Mono<MsalToken> authenticateWithMsalAccount(TokenRequestContext request, IAccount account) {\n         SilentParameters parameters;\n-        if (msalToken.getAccount() != null) {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), msalToken.getAccount()).build();\n+        SilentParameters forceParameters;\n+        if (account != null) {\n+            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account)\n+                    .forceRefresh(true).build();\n         } else {\n             parameters = SilentParameters.builder(new HashSet<>(request.getScopes())).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes())).forceRefresh(true).build();\n         }\n         return Mono.defer(() -> {\n             try {\n-                return Mono.fromFuture(publicClientApplication.acquireTokenSilently(parameters))\n-                        .map(ar -> new MsalToken(ar, options));\n+                return Mono.fromFuture(getPublicClientApplication(false).acquireTokenSilently(parameters))", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4MjY1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417582654", "bodyText": "Yeah we should", "author": "jianghaolu", "createdAt": "2020-04-29T20:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NjA5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417466091", "bodyText": "Does account here have to be non-null? If it can be null, could the if/else block be merged to always pass account?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:54:48Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with username \"\n+                + \"and password\", null, t))).map(ar -> new MsalToken(ar, options));\n     }\n \n     /**\n      * Asynchronously acquire a token from the currently logged in client.\n      *\n      * @param request the details of the token request\n+     * @param account the account used to login to acquire the last token\n      * @return a Publisher that emits an AccessToken\n      */\n-    public Mono<MsalToken> authenticateWithUserRefreshToken(TokenRequestContext request, MsalToken msalToken) {\n+    public Mono<MsalToken> authenticateWithMsalAccount(TokenRequestContext request, IAccount account) {\n         SilentParameters parameters;\n-        if (msalToken.getAccount() != null) {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), msalToken.getAccount()).build();\n+        SilentParameters forceParameters;\n+        if (account != null) {\n+            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account).build();", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4NjcxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417586711", "bodyText": "Unfortunately in the first builder overload the account is required to be non-null.", "author": "jianghaolu", "createdAt": "2020-04-29T20:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU4Njk1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417586950", "bodyText": "But it does seem like I can add account afterwards", "author": "jianghaolu", "createdAt": "2020-04-29T20:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NjA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwMTYwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417601603", "bodyText": "Reorganized a little bit to avoid creating 2 parameters upfront", "author": "jianghaolu", "createdAt": "2020-04-29T20:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NjcwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417466704", "bodyText": "Need to use Exceptions.propagate here.", "author": "alzimmermsft", "createdAt": "2020-04-29T16:55:43Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,29 +404,44 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with username \"\n+                + \"and password\", null, t))).map(ar -> new MsalToken(ar, options));\n     }\n \n     /**\n      * Asynchronously acquire a token from the currently logged in client.\n      *\n      * @param request the details of the token request\n+     * @param account the account used to login to acquire the last token\n      * @return a Publisher that emits an AccessToken\n      */\n-    public Mono<MsalToken> authenticateWithUserRefreshToken(TokenRequestContext request, MsalToken msalToken) {\n+    public Mono<MsalToken> authenticateWithMsalAccount(TokenRequestContext request, IAccount account) {\n         SilentParameters parameters;\n-        if (msalToken.getAccount() != null) {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), msalToken.getAccount()).build();\n+        SilentParameters forceParameters;\n+        if (account != null) {\n+            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes()), account)\n+                    .forceRefresh(true).build();\n         } else {\n             parameters = SilentParameters.builder(new HashSet<>(request.getScopes())).build();\n+            forceParameters = SilentParameters.builder(new HashSet<>(request.getScopes())).forceRefresh(true).build();\n         }\n         return Mono.defer(() -> {\n             try {\n-                return Mono.fromFuture(publicClientApplication.acquireTokenSilently(parameters))\n-                        .map(ar -> new MsalToken(ar, options));\n+                return Mono.fromFuture(getPublicClientApplication(false).acquireTokenSilently(parameters))\n+                        .map(ar -> new MsalToken(ar, options))\n+                        .filter(t -> !t.isExpired())\n+                        .switchIfEmpty(Mono.defer(() -> Mono.fromFuture(() -> {\n+                                try {\n+                                    return getPublicClientApplication(false).acquireTokenSilently(forceParameters);\n+                                } catch (MalformedURLException e) {\n+                                    throw logger.logExceptionAsWarning(new RuntimeException(e));", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzE4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417467188", "bodyText": "onErrorMap?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:56:19Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -425,8 +464,9 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             DeviceCodeFlowParameters parameters = DeviceCodeFlowParameters.builder(new HashSet<>(request.getScopes()),\n                 dc -> deviceCodeConsumer.accept(new DeviceCodeInfo(dc.userCode(), dc.deviceCode(),\n                     dc.verificationUri(), OffsetDateTime.now().plusSeconds(dc.expiresIn()), dc.message()))).build();\n-            return publicClientApplication.acquireToken(parameters);\n-        }).map(ar -> new MsalToken(ar, options));\n+            return getPublicClientApplication(false).acquireToken(parameters);\n+        }).onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with device code\",", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzI4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417467289", "bodyText": "onErrorMap?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:56:30Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -439,11 +479,12 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithAuthorizationCode(TokenRequestContext request, String authorizationCode,\n                                                              URI redirectUrl) {\n-        return Mono.fromFuture(() -> publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             AuthorizationCodeParameters.builder(authorizationCode, redirectUrl)\n                 .scopes(new HashSet<>(request.getScopes()))\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorResume(t -> Mono.error(new ClientAuthenticationException(\"Failed to acquire token with \"", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NzQ5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r417467494", "bodyText": "onErrorMap?", "author": "alzimmermsft", "createdAt": "2020-04-29T16:56:48Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +531,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorResume(t -> Mono.error(new CredentialUnavailableException(", "originalCommit": "ed8e7223daf3df49e337c1e163a56ab9459cdb52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "09718dd9d337c865b7073d84002a6a496e6de77e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/09718dd9d337c865b7073d84002a6a496e6de77e", "message": "Clean up and address Alan's review", "committedDate": "2020-04-29T20:26:53Z", "type": "commit"}, {"oid": "806539a60aa9bf92793a100eafbb62f414a1b60e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/806539a60aa9bf92793a100eafbb62f414a1b60e", "message": "Merge error message", "committedDate": "2020-04-29T20:30:05Z", "type": "commit"}, {"oid": "066d41336c054bd7290070387a5ed46d7f157152", "url": "https://github.com/Azure/azure-sdk-for-java/commit/066d41336c054bd7290070387a5ed46d7f157152", "message": "CI says IdentityClient doesn't compile", "committedDate": "2020-04-29T20:50:09Z", "type": "commit"}, {"oid": "6cc8c1b60735420762714373444870c50eaed310", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6cc8c1b60735420762714373444870c50eaed310", "message": "Checkstyle: indentation", "committedDate": "2020-04-29T23:37:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MTkxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418261916", "bodyText": "This logic here and below was updated before. Please get the one from master.", "author": "g2vinay", "createdAt": "2020-04-30T20:13:29Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +530,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorMap(t -> new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (accounts.size() == 0) {", "originalCommit": "6cc8c1b60735420762714373444870c50eaed310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MjM3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418262376", "bodyText": "Error messages and checks were changed here and below.  get the ones from master.\nThis one is PII exposure.", "author": "g2vinay", "createdAt": "2020-04-30T20:14:18Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +530,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorMap(t -> new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (accounts.size() == 0) {\n+                        if (username == null) {\n+                            return Mono.error(new CredentialUnavailableException(\"No accounts were discovered in the \"\n+                                    + \"shared token cache. To fix, authenticate through tooling supporting azure \"\n+                                    + \"developer sign on.\"));\n+                        } else {\n+                            return Mono.error(new CredentialUnavailableException(String.format(\"User account '%s' was \"\n+                                    + \"not found in the shared token cache. Discovered Accounts: [ '%s' ]\", username,", "originalCommit": "6cc8c1b60735420762714373444870c50eaed310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDczMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418294733", "bodyText": "Thanks! I lost the update during the merge.", "author": "jianghaolu", "createdAt": "2020-04-30T21:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MjM3Ng=="}], "type": "inlineReview"}, {"oid": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d5c466269fe95ea6a729b15cca402cef4fbe0c49", "message": "Update shared token cache look up with master", "committedDate": "2020-04-30T21:27:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MjgzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418352832", "bodyText": "Would you want this to resume on an error and return an empty Mono? I'd expect the error to be propagated downstream and allow downstream subscribers to do with that error what they will. In  globalSetupAsync this is call is chained with .then(), so it would hide the error.\nThere are similar instances in other credentials below.", "author": "conniey", "createdAt": "2020-04-30T23:55:19Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DeviceCodeCredential.java", "diffHunk": "@@ -51,7 +51,7 @@\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n         return Mono.defer(() -> {\n             if (cachedToken.get() != null) {\n-                return identityClient.authenticateWithUserRefreshToken(request, cachedToken.get())\n+                return identityClient.authenticateWithMsalAccount(request, cachedToken.get().getAccount())\n                     .onErrorResume(t -> Mono.empty());", "originalCommit": "6cc8c1b60735420762714373444870c50eaed310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NTIyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418355228", "bodyText": "Yeah it should be probably be handled downstream - it's out of the scope of this PR but I can see if it can be done with minimal footprint", "author": "jianghaolu", "createdAt": "2020-05-01T00:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1MjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NTA4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418355087", "bodyText": "Since you're using futures, it may be easier to follow using:\nvar completableFuture = new CompletableFuture<MsalToken>();\ncompletableFuture.completeExceptionally(logger.logExceptionAsError(Exceptions.propagate(e));\nreturn completableFuture;", "author": "conniey", "createdAt": "2020-05-01T00:03:35Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -380,33 +403,47 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n      */\n     public Mono<MsalToken> authenticateWithUsernamePassword(TokenRequestContext request,\n                                                             String username, String password) {\n-        return Mono.fromFuture(publicClientApplication.acquireToken(\n+        return Mono.fromFuture(() -> getPublicClientApplication(false).acquireToken(\n             UserNamePasswordParameters.builder(new HashSet<>(request.getScopes()), username, password.toCharArray())\n                 .build()))\n-            .map(ar -> new MsalToken(ar, options));\n+            .onErrorMap(t -> new ClientAuthenticationException(\"Failed to acquire token with username and password\",\n+                null, t)).map(ar -> new MsalToken(ar, options));\n     }\n \n     /**\n      * Asynchronously acquire a token from the currently logged in client.\n      *\n      * @param request the details of the token request\n+     * @param account the account used to login to acquire the last token\n      * @return a Publisher that emits an AccessToken\n      */\n-    public Mono<MsalToken> authenticateWithUserRefreshToken(TokenRequestContext request, MsalToken msalToken) {\n-        SilentParameters parameters;\n-        if (msalToken.getAccount() != null) {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes()), msalToken.getAccount()).build();\n-        } else {\n-            parameters = SilentParameters.builder(new HashSet<>(request.getScopes())).build();\n-        }\n-        return Mono.defer(() -> {\n+    public Mono<MsalToken> authenticateWithMsalAccount(TokenRequestContext request, IAccount account) {\n+        return Mono.defer(() -> Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder parametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes()));\n+            if (account != null) {\n+                parametersBuilder = parametersBuilder.account(account);\n+            }\n             try {\n-                return Mono.fromFuture(publicClientApplication.acquireTokenSilently(parameters))\n-                        .map(ar -> new MsalToken(ar, options));\n+                return getPublicClientApplication(false)\n+                    .acquireTokenSilently(parametersBuilder.build());\n             } catch (MalformedURLException e) {\n-                return Mono.error(e);\n+                throw logger.logExceptionAsError(Exceptions.propagate(e));\n             }\n-        });\n+        }).map(ar -> new MsalToken(ar, options))\n+        .filter(t -> !t.isExpired())\n+        .switchIfEmpty(Mono.fromFuture(() -> {\n+            SilentParameters.SilentParametersBuilder forceParametersBuilder = SilentParameters.builder(\n+                new HashSet<>(request.getScopes())).forceRefresh(true);\n+            if (account != null) {\n+                forceParametersBuilder = forceParametersBuilder.account(account);\n+            }\n+            try {\n+                return getPublicClientApplication(false).acquireTokenSilently(forceParametersBuilder.build());\n+            } catch (MalformedURLException e) {\n+                throw logger.logExceptionAsError(Exceptions.propagate(e));", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1OTA1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418459051", "bodyText": "Thanks Connie for the tip but in this code the exception is thrown from creating the future, not from executing it.", "author": "jianghaolu", "createdAt": "2020-05-01T08:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NTkxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418355919", "bodyText": "nit: set.isEmpty()", "author": "conniey", "createdAt": "2020-05-01T00:06:37Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +529,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorMap(t -> new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (set.size() == 0) {", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NjA2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418356063", "bodyText": "Should we use return FluxUtils.monoError(logger, new ....)? Or is it preferable not to log it", "author": "conniey", "createdAt": "2020-05-01T00:07:14Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +529,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorMap(t -> new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (set.size() == 0) {\n+                        return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential \"", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1OTI4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418459284", "bodyText": "We talked to Jonathan and since this IdentityClient isn't used directly by customers and we have downstream credentials to do the logging - we shouldn't log here.", "author": "jianghaolu", "createdAt": "2020-05-01T08:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NjA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM1NjIxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418356213", "bodyText": "nit: Same with .isEmpty() here. But I won't lose sleep. :)", "author": "conniey", "createdAt": "2020-05-01T00:07:46Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -490,6 +529,56 @@ private HttpPipeline setupPipeline(HttpClient httpClient) {\n             });\n     }\n \n+    /**\n+     * Gets token from shared token cache\n+     * */\n+    public Mono<AccessToken> authenticateWithSharedTokenCache(TokenRequestContext request, String username) {\n+        // find if the Public Client app with the requested username exists\n+        return Mono.fromFuture(() -> getPublicClientApplication(true).getAccounts())\n+                .onErrorMap(t -> new CredentialUnavailableException(\n+                        \"Cannot get accounts from token cache. Error: \" + t.getMessage(), t))\n+                .flatMap(set -> {\n+                    IAccount requestedAccount;\n+                    Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n+\n+                    for (IAccount cached : set) {\n+                        if (username == null || username.equals(cached.username())) {\n+                            if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n+                                accounts.put(cached.homeAccountId(), cached);\n+                            }\n+                        }\n+                    }\n+\n+                    if (set.size() == 0) {\n+                        return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential \"\n+                                + \"authentication unavailable. No accounts were found in the cache.\"));\n+                    }\n+\n+                    if (CoreUtils.isNullOrEmpty(username)) {\n+                        return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential \"\n+                                + \"authentication unavailable. Multiple accounts were found in the cache. Use \"\n+                                + \"username and tenant id to disambiguate.\"));\n+                    }\n+\n+                    if (accounts.size() != 1) {\n+                        if (accounts.size() == 0) {", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQyMjc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418422772", "bodyText": "providedfor -> provided for", "author": "conniey", "createdAt": "2020-05-01T05:28:43Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -109,8 +113,14 @@\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n         this.options = options;\n-        if (clientId == null) {\n-            this.publicClientApplication = null;\n+    }\n+\n+    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n+        if (publicClientApplication != null) {\n+            return publicClientApplication;\n+        } else if (clientId == null) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\n+                \"A non-null value for client ID must be providedfor user authentication.\"));", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQyMzY1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418423650", "bodyText": "These tests could be using StepVerifier rather than block.\n// Arrange\nvar context = new TokenRequestContext().addScopes(\"https://vault.azure.net/.default\");\n\n// Act & Assert\nStepVerifier.create(client.authenticateWithMsalAccount(context, token.getAccount()))\n    .assertNext(token -> {\n        assertNotNull(token.getToken());\n        assertNotNull(token.getExpiresAt());\n    })\n    .verifyComplete();", "author": "conniey", "createdAt": "2020-05-01T05:32:57Z", "path": "sdk/identity/azure-identity/src/test/java/com/azure/identity/implementation/IdentityClientIntegrationTests.java", "diffHunk": "@@ -51,7 +51,7 @@ public void deviceCodeCanGetToken() {\n         Assert.assertNotNull(token.getToken());\n         Assert.assertNotNull(token.getExpiresAt());\n         Assert.assertFalse(token.isExpired());\n-        token = client.authenticateWithUserRefreshToken(new TokenRequestContext().addScopes(\"https://vault.azure.net/.default\"), token).block();\n+        token = client.authenticateWithMsalAccount(new TokenRequestContext().addScopes(\"https://vault.azure.net/.default\"), token.getAccount()).block();", "originalCommit": "d5c466269fe95ea6a729b15cca402cef4fbe0c49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2MDI5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418460296", "bodyText": "This is out of scope - if this PR stays open next week I can fix these. But for now I'm planning to get some sleep and enjoy my day off \ud83d\ude38", "author": "jianghaolu", "createdAt": "2020-05-01T08:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQyMzY1MA=="}], "type": "inlineReview"}, {"oid": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0bf3f76bb45b910ff5bd7bdca807110665c1df44", "message": "Address Connie's feedback", "committedDate": "2020-05-01T08:26:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MjA3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418492072", "bodyText": "In .NET and python we named this option EnablePersistentCache.", "author": "schaabs", "createdAt": "2020-05-01T10:26:53Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/DeviceCodeCredentialBuilder.java", "diffHunk": "@@ -29,6 +29,31 @@ public DeviceCodeCredentialBuilder challengeConsumer(\n         return this;\n     }\n \n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param allowUnencryptedCache whether to use an unprotected file for cache storage.\n+     *\n+     * @return An updated instance of this builder with the unprotected token cache setting set as specified.\n+     */\n+    public DeviceCodeCredentialBuilder allowUnencryptedCache(boolean allowUnencryptedCache) {\n+        this.identityClientOptions.allowUnencryptedCache(allowUnencryptedCache);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.\n+     */\n+    public DeviceCodeCredentialBuilder enableSharedTokenCache(boolean enabled) {", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjM3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418776376", "bodyText": "updated", "author": "g2vinay", "createdAt": "2020-05-01T23:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MjA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MjEyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418492123", "bodyText": "Same comment about EnablePersistentCache", "author": "schaabs", "createdAt": "2020-05-01T10:27:08Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/InteractiveBrowserCredentialBuilder.java", "diffHunk": "@@ -27,6 +27,31 @@ public InteractiveBrowserCredentialBuilder port(int port) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param allowUnencryptedCache whether to use an unprotected file for cache storage.\n+     *\n+     * @return An updated instance of this builder with the unprotected token cache setting set as specified.\n+     */\n+    public InteractiveBrowserCredentialBuilder allowUnencryptedCache(boolean allowUnencryptedCache) {\n+        this.identityClientOptions.allowUnencryptedCache(allowUnencryptedCache);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.\n+     */\n+    public InteractiveBrowserCredentialBuilder enableSharedTokenCache(boolean enabled) {", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjM5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418776397", "bodyText": "updated", "author": "g2vinay", "createdAt": "2020-05-01T23:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5MjEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5NTQyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418495426", "bodyText": "This method is called from numerous methods on the IdentityClient some which pass sharedTokenCacheCredential as true and some as false. Whichever calls this method first will cache the publicClientApplication and then all subsequent calls will effectively ignore the sharedTokenCacheCredential parameter. I'm guessing this doesn't matter in practice because certain credentials only call certain methods, and each credential has it's own instance of IdentityClient, and IdentityClient is internal. However, this makes the functionality of this class and the classes that use it interdependent in a non-obvious way which could easily be overlooked if we try to make optimizations like sharing an instance of IdentityClient. I think we should consider refactoring this.", "author": "schaabs", "createdAt": "2020-05-01T10:40:18Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -109,8 +113,14 @@\n         this.tenantId = tenantId;\n         this.clientId = clientId;\n         this.options = options;\n-        if (clientId == null) {\n-            this.publicClientApplication = null;\n+    }\n+\n+    private PublicClientApplication getPublicClientApplication(boolean sharedTokenCacheCredential) {\n+        if (publicClientApplication != null) {\n+            return publicClientApplication;", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODUxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418778512", "bodyText": "Opened an issue #10675", "author": "g2vinay", "createdAt": "2020-05-01T23:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5NTQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyMDM4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418920383", "bodyText": "This method is only called once per IdentityClient and there's exactly one IdentityClient instance per credential.\nYes it can have nicer designs, as something we can do for #10675", "author": "jianghaolu", "createdAt": "2020-05-02T06:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5NTQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5OTkwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418499902", "bodyText": "This is not thread safe. If two clients using the same credential call get token at the same time it's possible that multiple threads attempt to initialize publicClientApplication at the same time. In this case they might each get different instances and any tokens cached on any instances other than the final one will be lost.", "author": "schaabs", "createdAt": "2020-05-01T10:59:06Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/implementation/IdentityClient.java", "diffHunk": "@@ -144,7 +154,21 @@\n             if (options.getExecutorService() != null) {\n                 publicClientApplicationBuilder.executorService(options.getExecutorService());\n             }\n+            if (options.isSharedTokenCacheEnabled()) {\n+                try {\n+                    publicClientApplicationBuilder.setTokenCacheAccessAspect(\n+                            new PersistenceTokenCacheAccessAspect(options.getPersistenceSettings()));\n+                } catch (Throwable t) {\n+                    String message = \"Shared token cache is unavailable in this environment.\";\n+                    if (sharedTokenCacheCredential) {\n+                        throw logger.logExceptionAsError(new CredentialUnavailableException(message, t));\n+                    } else {\n+                        throw logger.logExceptionAsError(new ClientAuthenticationException(message, null, t));\n+                    }\n+                }\n+            }\n             this.publicClientApplication = publicClientApplicationBuilder.build();", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3ODUwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418778504", "bodyText": "Opened an issue #10675", "author": "g2vinay", "createdAt": "2020-05-01T23:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5OTkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyMDMyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418920329", "bodyText": "Resolving as separate issues opened", "author": "jianghaolu", "createdAt": "2020-05-02T06:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ5OTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDYzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418500639", "bodyText": "authenticateWithSharedTokenCache searches the shared token cache for an account each time. Shouldn't the account be saved off after the first time this method is called so that authenticateWithMsalAccount can be called instead?", "author": "schaabs", "createdAt": "2020-05-01T11:02:27Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/SharedTokenCacheCredential.java", "diffHunk": "@@ -63,92 +51,18 @@\n         } else {\n             this.tenantId = tenantId;\n         }\n-        this.options = identityClientOptions;\n+        this.identityClient = new IdentityClientBuilder()\n+                .tenantId(this.tenantId)\n+                .clientId(this.clientId)\n+                .identityClientOptions(identityClientOptions)\n+                .build();\n     }\n \n     /**\n      * Gets token from shared token cache\n      * */\n     @Override\n     public Mono<AccessToken> getToken(TokenRequestContext request) {\n-        String authorityUrl = options.getAuthorityHost().replaceAll(\"/+$\", \"\") + \"/\" + tenantId + \"/\";\n-        // Initialize here so that the constructor doesn't throw\n-        if (pubClient == null) {\n-            try {\n-                PersistentTokenCacheAccessAspect accessAspect = new PersistentTokenCacheAccessAspect();\n-                PublicClientApplication.Builder applicationBuilder =  PublicClientApplication.builder(this.clientId);\n-                if (options.getExecutorService() != null) {\n-                    applicationBuilder.executorService(options.getExecutorService());\n-                }\n-\n-                pubClient = applicationBuilder\n-                    .authority(authorityUrl)\n-                    .setTokenCacheAccessAspect(accessAspect)\n-                    .build();\n-            } catch (Exception e) {\n-                return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential authentication \"\n-                                                                         + \"unavailable.\" +  e.getMessage(), e));\n-            }\n-        }\n-\n-        // find if the Public Client app with the requested username exists\n-        return Mono.fromFuture(pubClient.getAccounts())\n-            .flatMap(set -> {\n-                IAccount requestedAccount;\n-                Map<String, IAccount> accounts = new HashMap<>(); // home account id -> account\n-\n-                for (IAccount cached : set) {\n-                    if (username == null || username.equals(cached.username())) {\n-                        if (!accounts.containsKey(cached.homeAccountId())) { // only put the first one\n-                            accounts.put(cached.homeAccountId(), cached);\n-                        }\n-                    }\n-                }\n-\n-                if (set.size() == 0) {\n-                    return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential authentication \"\n-                             + \"unavailable. No accounts were found in the cache.\"));\n-                }\n-\n-                if (CoreUtils.isNullOrEmpty(username)) {\n-                    return Mono.error(new CredentialUnavailableException(\"SharedTokenCacheCredential authentication \"\n-                             + \"unavailable. Multiple accounts were found in the cache. Use username and tenant id \"\n-                             + \"to disambiguate.\"));\n-                }\n-\n-                if (accounts.size() != 1) {\n-                    if (accounts.size() == 0) {\n-                        return Mono.error(new CredentialUnavailableException(\n-                            String.format(\"SharedTokenCacheCredential authentication \"\n-                             + \"unavailable. No account matching the specified username %s was found in \"\n-                             + \"the cache.\", username)));\n-                    } else {\n-                        return Mono.error(new CredentialUnavailableException(String.format(\"SharedTokenCacheCredential\"\n-                             + \" authentication unavailable. Multiple accounts matching the specified username %s were \"\n-                             + \"found in the cache.\", username)));\n-                    }\n-                }\n-\n-                requestedAccount = accounts.values().iterator().next();\n-\n-\n-                // if it does, then request the token\n-                SilentParameters params = SilentParameters.builder(\n-                        new HashSet<>(request.getScopes()), requestedAccount)\n-                    .authorityUrl(authorityUrl)\n-                    .build();\n-\n-                CompletableFuture<IAuthenticationResult> future;\n-                try {\n-                    future = pubClient.acquireTokenSilently(params);\n-                    return Mono.fromFuture(() -> future).map(result ->\n-                        new AccessToken(result.accessToken(),\n-                            result.expiresOnDate().toInstant().atOffset(ZoneOffset.UTC)));\n-\n-                } catch (MalformedURLException e) {\n-                    e.printStackTrace();\n-                    return Mono.error(new RuntimeException(\"Token was not found\"));\n-                }\n-            });\n+        return identityClient.authenticateWithSharedTokenCache(request, username);", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjU2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418776566", "bodyText": "added the logic.", "author": "g2vinay", "createdAt": "2020-05-01T23:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTM2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418501368", "bodyText": "We hadn't added the ability to use the shared token cache to the UsernamePasswordCredential in .NET and Python yet. I'm not totally against it, but I think it adds limited value since UsernamePasswordCredential has no user interaction.", "author": "schaabs", "createdAt": "2020-05-01T11:05:27Z", "path": "sdk/identity/azure-identity/src/main/java/com/azure/identity/UsernamePasswordCredentialBuilder.java", "diffHunk": "@@ -36,6 +36,31 @@ public UsernamePasswordCredentialBuilder password(String password) {\n         return this;\n     }\n \n+    /**\n+     * Sets whether to use an unprotected file specified by <code>cacheFileLocation()</code> instead of\n+     * Gnome keyring on Linux. This is false by default.\n+     *\n+     * @param allowUnencryptedCache whether to use an unprotected file for cache storage.\n+     *\n+     * @return An updated instance of this builder with the unprotected token cache setting set as specified.\n+     */\n+    public UsernamePasswordCredentialBuilder allowUnencryptedCache(boolean allowUnencryptedCache) {\n+        this.identityClientOptions.allowUnencryptedCache(allowUnencryptedCache);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets whether to enable using the shared token cache. This is disabled by default.\n+     *\n+     * @param enabled whether to enabled using the shared token cache.\n+     *\n+     * @return An updated instance of this builder with if the shared token cache enabled specified.\n+     */\n+    public UsernamePasswordCredentialBuilder enableSharedTokenCache(boolean enabled) {", "originalCommit": "0bf3f76bb45b910ff5bd7bdca807110665c1df44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3NjYzMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9188#discussion_r418776630", "bodyText": "we'll be keeping it for preview, as discussed.", "author": "g2vinay", "createdAt": "2020-05-01T23:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTM2OA=="}], "type": "inlineReview"}, {"oid": "b337b9393669c0a558f3b7b09cba50882e44efb7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b337b9393669c0a558f3b7b09cba50882e44efb7", "message": "address feedback", "committedDate": "2020-05-01T23:18:48Z", "type": "commit"}, {"oid": "4e1d1a01c892bb0df03cb9eea274a0dcb7692cc3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4e1d1a01c892bb0df03cb9eea274a0dcb7692cc3", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence", "committedDate": "2020-05-03T00:47:34Z", "type": "commit"}, {"oid": "5b4e8786b95af3894842e96b655472206e2fbc8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5b4e8786b95af3894842e96b655472206e2fbc8c", "message": "Merge branch 'master' of github.com:Azure/azure-sdk-for-java into persistence", "committedDate": "2020-05-04T18:34:02Z", "type": "commit"}, {"oid": "25d2a63d58710d4196006095b59ce3f455efa7e4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/25d2a63d58710d4196006095b59ce3f455efa7e4", "message": "Fix shared token cache and error handling", "committedDate": "2020-05-04T20:53:33Z", "type": "commit"}, {"oid": "e3a405d368d8d04df222e99b69e80f84f140100d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e3a405d368d8d04df222e99b69e80f84f140100d", "message": "Use getPublicClientApplication()", "committedDate": "2020-05-04T21:14:44Z", "type": "commit"}, {"oid": "3dff1f3437575f1e9581bd42fde3c9fa9c6947df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3dff1f3437575f1e9581bd42fde3c9fa9c6947df", "message": "Undo changes in key vault", "committedDate": "2020-05-04T21:18:02Z", "type": "commit"}]}