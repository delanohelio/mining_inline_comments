{"pr_number": 2901, "pr_title": "Add ItemRequires Constraint", "pr_createdAt": "2020-07-07T07:22:50Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2901", "timeline": [{"oid": "0a9fda4ffc40fdddc1a5fee3ea5b61884b5a654b", "url": "https://github.com/OpenRefine/OpenRefine/commit/0a9fda4ffc40fdddc1a5fee3ea5b61884b5a654b", "message": "Add ItemRequires Constraint\n\nImplemented Item requires constraint as part of #2354", "committedDate": "2020-07-07T05:20:10Z", "type": "commit"}, {"oid": "a368cfe12e7857b8ee9f30377d28326faf9a545c", "url": "https://github.com/OpenRefine/OpenRefine/commit/a368cfe12e7857b8ee9f30377d28326faf9a545c", "message": "done with implementation of ItemRequiresScrutinizer Class", "committedDate": "2020-07-07T07:23:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczODU1Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452738556", "bodyText": "Isn't it possible to simplify this code by pulling the if (update.isNew()) inside, just when the QAWarning is generated? I think this only affects the type of warning you emit, so that should get rid of a lot of duplicated code.", "author": "wetneb", "createdAt": "2020-07-10T09:41:33Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItem_type = \"item-requires-certain-other-statement\";\n+    public static final String existingItem_type = \"item-should-have-certain-other-statement\";\n+    public static String ITEM_REQUIRES_CONSTRAINT_QID = \"Q21503247\";\n+    public static String ITEM_REQUIRES_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ItemRequiresConstraint {\n+        final PropertyIdValue itemRequiresPid;\n+        final List<Value> itemList;\n+\n+        ItemRequiresConstraint(Statement statement) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue pid = null;\n+            this.itemList = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(ITEM_REQUIRES_PROPERTY_PID)){\n+                        pid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        this.itemList.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            this.itemRequiresPid = pid;\n+        }\n+    }\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Set<Value>> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()) {\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            Set<Value> values;\n+            if (value != null) {\n+                if (propertyIdValueValueMap.containsKey(pid)) {\n+                    values = propertyIdValueValueMap.get(pid);\n+                } else {\n+                    values = new HashSet<>();\n+                }\n+                values.add(value);\n+                propertyIdValueValueMap.put(pid, values);\n+            }\n+        }\n+\n+        if (update.isNew()) {", "originalCommit": "e10d9ad9fc6079528ba59ea84addf8df59621b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczODk4NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452738985", "bodyText": "Let's stick to camelCase and not mix it with underscores.", "author": "wetneb", "createdAt": "2020-07-10T09:42:23Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItem_type = \"item-requires-certain-other-statement\";", "originalCommit": "e10d9ad9fc6079528ba59ea84addf8df59621b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjczOTUxOQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452739519", "bodyText": "It would be good to have a test for constraint violations on new items, too.", "author": "wetneb", "createdAt": "2020-07-10T09:43:26Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizerTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.ConstraintFetcher;\n+import org.openrefine.wikidata.testing.TestingData;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.openrefine.wikidata.updates.ItemUpdateBuilder;\n+import org.testng.annotations.Test;\n+import org.wikidata.wdtk.datamodel.helpers.Datamodel;\n+import org.wikidata.wdtk.datamodel.implementation.StatementImpl;\n+import org.wikidata.wdtk.datamodel.interfaces.ItemIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+import org.wikidata.wdtk.datamodel.interfaces.ValueSnak;\n+\n+import java.util.List;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_OF_PROPERTY_CONSTRAINT_PID;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_REQUIRES_CONSTRAINT_QID;\n+import static org.openrefine.wikidata.qa.scrutinizers.ItemRequiresScrutinizer.ITEM_REQUIRES_PROPERTY_PID;\n+\n+public class ItemRequiresScrutinizerTest extends ScrutinizerTest {\n+\n+    public static PropertyIdValue propertyIdValue = Datamodel.makeWikidataPropertyIdValue(\"P157\");\n+    public static ItemIdValue itemValue = Datamodel.makeWikidataItemIdValue(\"Q3187975\");\n+    public static ItemIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(ITEM_REQUIRES_CONSTRAINT_QID);\n+    public static PropertyIdValue propertyParameterPID = Datamodel.makeWikidataPropertyIdValue(ITEM_REQUIRES_PROPERTY_PID);\n+    public static PropertyIdValue propertyParameterValue = Datamodel.makeWikidataPropertyIdValue(\"P1196\");\n+    public static PropertyIdValue itemParameterPID = Datamodel.makeWikidataPropertyIdValue(ITEM_OF_PROPERTY_CONSTRAINT_PID);\n+    public static Value requiredValue = Datamodel.makeWikidataItemIdValue(\"Q149086\");\n+\n+    @Override\n+    public EditScrutinizer getScrutinizer() {\n+        return new ItemRequiresScrutinizer();\n+    }\n+\n+    @Test\n+    public void testTrigger() {\n+        ItemIdValue idA = TestingData.existingId;\n+        Snak mainSnak = Datamodel.makeValueSnak(propertyIdValue, itemValue);\n+        Statement statement = new StatementImpl(\"P157\", mainSnak, idA);\n+        ItemUpdate updateA = new ItemUpdateBuilder(idA).addStatement(statement).build();\n+\n+        Snak qualifierSnak1 = Datamodel.makeValueSnak(propertyParameterPID, propertyParameterValue);\n+        Snak qualifierSnak2 = Datamodel.makeValueSnak(itemParameterPID, requiredValue);\n+        List<SnakGroup> constraintQualifiers = makeSnakGroupList(qualifierSnak1, qualifierSnak2);\n+        List<Statement> constraintDefinitions = constraintParameterStatementList(entityIdValue, constraintQualifiers);\n+\n+        ConstraintFetcher fetcher = mock(ConstraintFetcher.class);\n+        when(fetcher.getConstraintsByType(propertyIdValue, ITEM_REQUIRES_CONSTRAINT_QID)).thenReturn(constraintDefinitions);\n+        setFetcher(fetcher);\n+\n+        scrutinize(updateA);\n+        assertWarningsRaised(ItemRequiresScrutinizer.existingItem_type);", "originalCommit": "e10d9ad9fc6079528ba59ea84addf8df59621b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMDQzNA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452810434", "bodyText": "The severity should also be adapted depending on whether the the update.isNew() or not", "author": "wetneb", "createdAt": "2020-07-10T12:25:34Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class ItemRequiresScrutinizer extends EditScrutinizer {\n+\n+    public static final String newItemType = \"item-requires-certain-other-statement\";\n+    public static final String existingItemType = \"item-should-have-certain-other-statement\";\n+    public static String ITEM_REQUIRES_CONSTRAINT_QID = \"Q21503247\";\n+    public static String ITEM_REQUIRES_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ItemRequiresConstraint {\n+        final PropertyIdValue itemRequiresPid;\n+        final List<Value> itemList;\n+\n+        ItemRequiresConstraint(Statement statement) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue pid = null;\n+            this.itemList = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(ITEM_REQUIRES_PROPERTY_PID)){\n+                        pid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        this.itemList.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            this.itemRequiresPid = pid;\n+        }\n+    }\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Set<Value>> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()) {\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            Set<Value> values;\n+            if (value != null) {\n+                if (propertyIdValueValueMap.containsKey(pid)) {\n+                    values = propertyIdValueValueMap.get(pid);\n+                } else {\n+                    values = new HashSet<>();\n+                }\n+                values.add(value);\n+                propertyIdValueValueMap.put(pid, values);\n+            }\n+        }\n+\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n+            List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n+            for (Statement statement : constraintDefinitions) {\n+                ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n+                PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n+                List<Value> itemList = constraint.itemList;\n+                if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {\n+                    QAWarning issue = new QAWarning(update.isNew() ? newItemType : existingItemType, propertyId.getId() + itemRequiresPid.getId(), QAWarning.Severity.WARNING, 1);", "originalCommit": "ae26863db88ad4c1ddbc91725d72477b8dd3271d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMjQ3OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452812479", "bodyText": "Sorry, missed by me.", "author": "darecoder", "createdAt": "2020-07-10T12:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxMDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452821832", "bodyText": "If I am not wrong, the two branches of this if { } else if {} are identical, so you could deduplicate the code with an OR (||) in your first if. But because of that, I\u00a0am wondering if the else if branch should not be different: we probably want to display a different message for such a violation. If property A requires property B with a list of allowed values, and we have a violation in the else if branch here, we should say that although there is indeed a statement with property B, it does not have one of the allowed values, hence the violation. That probably means having 4 different violation messages for this constraint in total!", "author": "wetneb", "createdAt": "2020-07-10T12:49:17Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ItemRequiresScrutinizer.java", "diffHunk": "@@ -62,27 +63,26 @@ public void scrutinize(ItemUpdate update) {\n             }\n         }\n \n-        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+        for (PropertyIdValue propertyId : propertyIdValueValueMap.keySet()) {\n             List<Statement> constraintDefinitions = _fetcher.getConstraintsByType(propertyId, ITEM_REQUIRES_CONSTRAINT_QID);\n             for (Statement statement : constraintDefinitions) {\n                 ItemRequiresConstraint constraint = new ItemRequiresConstraint(statement);\n                 PropertyIdValue itemRequiresPid = constraint.itemRequiresPid;\n                 List<Value> itemList = constraint.itemList;\n                 if (!propertyIdValueValueMap.containsKey(itemRequiresPid)) {", "originalCommit": "c5e0c0228201994ab82fcc86dbff3ccb3e2aa0a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMjQxMw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452832413", "bodyText": "I'm not having a clear idea about this, how can we have 4 different violation messages?\nProperty A requires property B with a set of allowed values, then the violations will be:\n\nIt doesn't have property B, then we don't have to check about the values\nIt does have property B but it doesn't have the required value.\n\nCan you specific the other two?", "author": "darecoder", "createdAt": "2020-07-10T13:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjg1NDY1NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2901#discussion_r452854655", "bodyText": "Sure:\n\nIt doesn't have property B, and we don't have to check about the values. And the item where the constraint is found already exists.\nIt does have property B but it doesn't have the required value. And the item where the constraint is found already exists.\nIt doesn't have property B, and we don't have to check about the values. And the item where the constraint is found is new.\nIt does have property B but it doesn't have the required value. And the item where the constraint is found is new.", "author": "wetneb", "createdAt": "2020-07-10T13:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgyMTgzMg=="}], "type": "inlineReview"}, {"oid": "671242b20451fdfc367412a9b65e5b7536a688d5", "url": "https://github.com/OpenRefine/OpenRefine/commit/671242b20451fdfc367412a9b65e5b7536a688d5", "message": "Test class added with suitable test cases", "committedDate": "2020-07-10T16:47:53Z", "type": "commit"}]}