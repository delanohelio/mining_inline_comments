{"pr_number": 2661, "pr_title": "OAuth support for Wikidata extension", "pr_createdAt": "2020-06-01T01:07:55Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2661", "timeline": [{"oid": "f719f667c4d0682333541501aefa261fe5e753a4", "url": "https://github.com/OpenRefine/OpenRefine/commit/f719f667c4d0682333541501aefa261fe5e753a4", "message": "initial commit", "committedDate": "2020-06-02T14:18:54Z", "type": "forcePushed"}, {"oid": "29a757dc57d0cc4b246eac004f9edf2729a26881", "url": "https://github.com/OpenRefine/OpenRefine/commit/29a757dc57d0cc4b246eac004f9edf2729a26881", "message": "Added support for Multi-value Constraint in Wikidata extension (#2629)", "committedDate": "2020-05-31T13:24:51Z", "type": "forcePushed"}, {"oid": "0aee0954d1b4e5dfb4d166e82781c1f2d7ee5bbe", "url": "https://github.com/OpenRefine/OpenRefine/commit/0aee0954d1b4e5dfb4d166e82781c1f2d7ee5bbe", "message": "finish the prototype", "committedDate": "2020-06-02T15:12:36Z", "type": "commit"}, {"oid": "de080e60e804dd98189551e31c973b5a84bf1ec7", "url": "https://github.com/OpenRefine/OpenRefine/commit/de080e60e804dd98189551e31c973b5a84bf1ec7", "message": "improve the prototype & add tests", "committedDate": "2020-06-03T14:59:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDY2Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r434180663", "bodyText": "This module already has a Logger defined, so you can use something like logger.debug() here and then you can turn it on/off via the logging levels rather than have to worry about continually added and removing println()s", "author": "tfmorris", "createdAt": "2020-06-02T21:17:28Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/editing/ConnectionManager.java", "diffHunk": "@@ -168,4 +203,12 @@ protected BasicApiConnection createNewConnection() {\n         conn.setReadTimeout(READ_TIMEOUT);\n         return conn;\n     }\n+\n+    public String getAuthorizationUrl() throws InterruptedException, ExecutionException, IOException {\n+        System.out.println(\"Fetching the Request Token...\");", "originalCommit": "0aee0954d1b4e5dfb4d166e82781c1f2d7ee5bbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NjA2Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r435746067", "bodyText": "Thanks for the review. I'll try using logger.debug() in later developing.", "author": "afkbrb", "createdAt": "2020-06-05T07:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE4MDY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY3ODY2MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r435678661", "bodyText": "Is this an OpenRefine bug or Wikidata Toolkit bug?", "author": "tfmorris", "createdAt": "2020-06-05T04:05:30Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/commands/AuthorizeCommand.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openrefine.wikidata.commands;\n+\n+import com.google.refine.commands.Command;\n+import org.openrefine.wikidata.editing.ConnectionManager;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Command for redirecting the user to the authorization page.\n+ */\n+public class AuthorizeCommand extends Command {\n+\n+    @Override\n+    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n+        ConnectionManager manager = ConnectionManager.getInstance();\n+        try {\n+            if (manager.supportOAuth()) {\n+                String remember = request.getParameter(\"remember-credentials\");\n+                manager.setRememberCredentials(\"on\".equals(remember));\n+                String authorizationUrl = manager.getAuthorizationUrl();\n+                response.sendRedirect(authorizationUrl);\n+            } else {\n+                throw new IllegalStateException(\"You must configure Wikidata OAuth client id/secret in refine.ini \" +\n+                        \"in order to use OAuth to login\");\n+            }\n+        } catch (Exception e) {\n+            // TODO: use respondWithErrorPage after fixing its relative path bug", "originalCommit": "de080e60e804dd98189551e31c973b5a84bf1ec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NTE4NA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r435745184", "bodyText": "OpenRefine bug. Reported at #2678", "author": "afkbrb", "createdAt": "2020-06-05T07:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY3ODY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY3ODg1Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r435678853", "bodyText": "This probably should be an error code or something which gets interpretted on the front end so that we can take advantage of the i18n support there.", "author": "tfmorris", "createdAt": "2020-06-05T04:06:24Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/commands/AuthorizeCommand.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.openrefine.wikidata.commands;\n+\n+import com.google.refine.commands.Command;\n+import org.openrefine.wikidata.editing.ConnectionManager;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+/**\n+ * Command for redirecting the user to the authorization page.\n+ */\n+public class AuthorizeCommand extends Command {\n+\n+    @Override\n+    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n+        ConnectionManager manager = ConnectionManager.getInstance();\n+        try {\n+            if (manager.supportOAuth()) {\n+                String remember = request.getParameter(\"remember-credentials\");\n+                manager.setRememberCredentials(\"on\".equals(remember));\n+                String authorizationUrl = manager.getAuthorizationUrl();\n+                response.sendRedirect(authorizationUrl);\n+            } else {\n+                throw new IllegalStateException(\"You must configure Wikidata OAuth client id/secret in refine.ini \" +", "originalCommit": "de080e60e804dd98189551e31c973b5a84bf1ec7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de080e60e804dd98189551e31c973b5a84bf1ec7", "url": "https://github.com/OpenRefine/OpenRefine/commit/de080e60e804dd98189551e31c973b5a84bf1ec7", "message": "improve the prototype & add tests", "committedDate": "2020-06-03T14:59:03Z", "type": "forcePushed"}, {"oid": "9b74c5de8825bf569a9c7e759a556e36a11aed11", "url": "https://github.com/OpenRefine/OpenRefine/commit/9b74c5de8825bf569a9c7e759a556e36a11aed11", "message": "finish the prototype", "committedDate": "2020-06-07T01:06:15Z", "type": "commit"}, {"oid": "2c1ccad08904bc5c0d1167f0a16c9d51b9398d61", "url": "https://github.com/OpenRefine/OpenRefine/commit/2c1ccad08904bc5c0d1167f0a16c9d51b9398d61", "message": "improve the prototype & add tests", "committedDate": "2020-06-07T01:06:15Z", "type": "commit"}, {"oid": "0e285af4d21f92a253caa8e5f26af1fddf548543", "url": "https://github.com/OpenRefine/OpenRefine/commit/0e285af4d21f92a253caa8e5f26af1fddf548543", "message": "Merge branch 'wikidata-extension-oauth' of github.com:afkbrb/OpenRefine into wikidata-extension-oauth", "committedDate": "2020-06-07T01:07:02Z", "type": "commit"}, {"oid": "fe9350aa6ae629e857523f6791e48d0fb9ea1748", "url": "https://github.com/OpenRefine/OpenRefine/commit/fe9350aa6ae629e857523f6791e48d0fb9ea1748", "message": "finish owner-only consumer support", "committedDate": "2020-06-12T07:16:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MDMwMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r439840301", "bodyText": "For people upgrading from previous versions, should we try to delete any existing preference setting stored at this key? That would ensure we clean up credentials stored in plain text there.", "author": "wetneb", "createdAt": "2020-06-14T15:21:39Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/editing/ConnectionManager.java", "diffHunk": "@@ -23,114 +23,100 @@\n  ******************************************************************************/\n package org.openrefine.wikidata.editing;\n \n-import java.io.IOException;\n-\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.wikidata.wdtk.wikibaseapi.ApiConnection;\n import org.wikidata.wdtk.wikibaseapi.BasicApiConnection;\n import org.wikidata.wdtk.wikibaseapi.LoginFailedException;\n+import org.wikidata.wdtk.wikibaseapi.OAuthApiConnection;\n import org.wikidata.wdtk.wikibaseapi.apierrors.MediaWikiApiErrorException;\n \n-import com.fasterxml.jackson.databind.node.ArrayNode;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n-import com.google.refine.ProjectManager;\n-import com.google.refine.preference.PreferenceStore;\n-import com.google.refine.util.ParsingUtilities;\n+import java.io.IOException;\n \n /**\n- * Manages a connection to Wikidata, with login credentials stored in the\n- * preferences.\n- * \n- * Ideally, we should store only the cookies and not the password. But\n- * Wikidata-Toolkit does not allow for that as cookies are kept private.\n- * \n- * This class is also hard-coded for Wikidata: generalization to other Wikibase\n- * instances should be feasible though.\n- * \n+ * Manages a connection to Wikidata.\n+ * <p>\n+ * The connection can be either {@link BasicApiConnection} or {@link OAuthApiConnection}.\n+ * <p>\n+ * This class is also hard-coded for Wikidata,\n+ * it will be generalized to other Wikibase instances soon.\n+ *\n  * @author Antonin Delpeuch\n+ * @author Lu Liu\n  */\n \n public class ConnectionManager {\n-    \n-    final static Logger logger = LoggerFactory.getLogger(\"connection_mananger\");\n \n-    public static final String PREFERENCE_STORE_KEY = \"wikidata_credentials\";", "originalCommit": "fe9350aa6ae629e857523f6791e48d0fb9ea1748", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MDU0OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r439840549", "bodyText": "Instead of storing the password as cookie, could we store Wikidata's cookie as a cookie ourselves? That should let us restore the connection later on, without storing the user's password at all.", "author": "wetneb", "createdAt": "2020-06-14T15:24:17Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/commands/LoginCommand.java", "diffHunk": "@@ -23,61 +23,177 @@\n  ******************************************************************************/\n package org.openrefine.wikidata.commands;\n \n-import java.io.IOException;\n-import java.io.Writer;\n+import com.google.refine.commands.Command;\n+import org.openrefine.wikidata.editing.ConnectionManager;\n \n import javax.servlet.ServletException;\n+import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n \n-import org.openrefine.wikidata.editing.ConnectionManager;\n-\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.google.refine.commands.Command;\n-import com.google.refine.util.ParsingUtilities;\n+import static org.apache.commons.lang.StringUtils.isBlank;\n+import static org.apache.commons.lang.StringUtils.isNotBlank;\n \n+/**\n+ * Handles login.\n+ * <p>\n+ * Both logging in with username/password or owner-only consumer are supported.\n+ * <p>\n+ * This command also manages cookies of login credentials.\n+ */\n public class LoginCommand extends Command {\n \n+    static final String USERNAME = \"wb-username\";\n+    static final String PASSWORD = \"wb-password\";\n+\n+    static final String CONSUMER_TOKEN = \"wb-consumer-token\";\n+    static final String CONSUMER_SECRET = \"wb-consumer-secret\";\n+    static final String ACCESS_TOKEN = \"wb-access-token\";\n+    static final String ACCESS_SECRET = \"wb-access-secret\";\n+\n     @Override\n     public void doPost(HttpServletRequest request, HttpServletResponse response)\n             throws ServletException, IOException {\n-    \tif(!hasValidCSRFToken(request)) {\n-    \t\trespondCSRFError(response);\n-    \t\treturn;\n-    \t}\n-    \trespond(request, response);\n-    }\n-    \n-    protected void respond(HttpServletRequest request, HttpServletResponse response)\n-    \tthrows ServletException, IOException {\n-        String username = request.getParameter(\"wb-username\");\n-        String password = request.getParameter(\"wb-password\");\n-        String remember = request.getParameter(\"remember-credentials\");\n+        if (!hasValidCSRFToken(request)) {\n+            respondCSRFError(response);\n+            return;\n+        }\n+\n         ConnectionManager manager = ConnectionManager.getInstance();\n-        if (username != null && password != null) {\n-            manager.login(username, password, \"on\".equals(remember));\n-        } else if (\"true\".equals(request.getParameter(\"logout\"))) {\n+\n+        if (\"true\".equals(request.getParameter(\"logout\"))) {\n             manager.logout();\n+            removeUsernamePasswordCookies(response);\n+            removeOwnOnlyConsumerCookies(response);\n+            respond(request, response);\n+            return; // return directly\n+        }\n+\n+        boolean remember = \"on\".equals(request.getParameter(\"remember-credentials\"));\n+\n+        Cookie[] cookies = request.getCookies();\n+\n+        // Credentials from parameters have higher priority than those from cookies.\n+        String username = request.getParameter(USERNAME);\n+        String password = request.getParameter(PASSWORD);\n+\n+        if (isBlank(username) || isBlank(password)) {\n+            for (Cookie cookie : cookies) {\n+                String value = cookie.getValue();\n+                switch (cookie.getName()) {\n+                    case USERNAME:\n+                        username = value;\n+                        break;\n+                    case PASSWORD:\n+                        password = value;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+            if (isNotBlank(username) && isNotBlank(password)) {\n+                // If the credentials are read from cookies, we must remember it.\n+                remember = true;\n+            }\n         }\n-        response.setCharacterEncoding(\"UTF-8\");\n-        response.setHeader(\"Content-Type\", \"application/json\");\n-\n-        Writer w = response.getWriter();\n-        JsonGenerator writer = ParsingUtilities.mapper.getFactory().createGenerator(w);\n-\n-        writer.writeStartObject();\n-        writer.writeBooleanField(\"logged_in\", manager.isLoggedIn());\n-        writer.writeStringField(\"username\", manager.getUsername());\n-        writer.writeEndObject();\n-        writer.flush();\n-        writer.close();\n-        w.flush();\n-        w.close();\n+\n+        String consumerToken = request.getParameter(CONSUMER_TOKEN);\n+        String consumerSecret = request.getParameter(CONSUMER_SECRET);\n+        String accessToken = request.getParameter(ACCESS_TOKEN);\n+        String accessSecret = request.getParameter(ACCESS_SECRET);\n+\n+        if (isBlank(consumerToken)|| isBlank(consumerSecret) || isBlank(accessToken) || isBlank(accessSecret)) {\n+            for (Cookie cookie : cookies) {\n+                String value = cookie.getValue();\n+                switch (cookie.getName()) {\n+                    case CONSUMER_TOKEN:\n+                        consumerToken = value;\n+                        break;\n+                    case CONSUMER_SECRET:\n+                        consumerSecret = value;\n+                        break;\n+                    case ACCESS_TOKEN:\n+                        accessToken = value;\n+                        break;\n+                    case ACCESS_SECRET:\n+                        accessSecret = value;\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+            if (isNotBlank(consumerToken) && isNotBlank(consumerSecret) && isNotBlank(accessToken) && isNotBlank(accessSecret)) {\n+                remember = true;\n+            }\n+        }\n+\n+        if (isNotBlank(username) && isNotBlank(password)) {\n+            manager.login(username, password);\n+            // Once logged in with new credentials,\n+            // the old credentials in cookies should be cleared.\n+            if (manager.getConnection() != null && remember) {\n+                setCookie(response, USERNAME, username);\n+                setCookie(response, PASSWORD, password);", "originalCommit": "fe9350aa6ae629e857523f6791e48d0fb9ea1748", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg5ODI3Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r439898273", "bodyText": "Good idea! This is helpful for logging in with password, but for the owner-only consumer, we still need to store the credentials in cookies.", "author": "afkbrb", "createdAt": "2020-06-15T02:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0MDU0OQ=="}], "type": "inlineReview"}, {"oid": "da7e8370eeb515eb442226282c4b53b317cc429f", "url": "https://github.com/OpenRefine/OpenRefine/commit/da7e8370eeb515eb442226282c4b53b317cc429f", "message": "remove unnecessary 'href=\"javascript:void(0)\"' of <a> tags", "committedDate": "2020-06-15T02:02:32Z", "type": "commit"}, {"oid": "85d8337fd731f53fb156a8e2ffe82a7f9b4a680d", "url": "https://github.com/OpenRefine/OpenRefine/commit/85d8337fd731f53fb156a8e2ffe82a7f9b4a680d", "message": "swap explaining messages", "committedDate": "2020-06-15T02:03:22Z", "type": "commit"}, {"oid": "08f37a98c85bd120d79718511aa69dfb2ae384d7", "url": "https://github.com/OpenRefine/OpenRefine/commit/08f37a98c85bd120d79718511aa69dfb2ae384d7", "message": "store Wikidata's cookies instead of password in cookies", "committedDate": "2020-06-15T10:39:01Z", "type": "commit"}, {"oid": "c2a40a95786099585f701e6a2909a29e496bc862", "url": "https://github.com/OpenRefine/OpenRefine/commit/c2a40a95786099585f701e6a2909a29e496bc862", "message": "update \"Remember me\" titles", "committedDate": "2020-06-15T10:49:20Z", "type": "commit"}, {"oid": "9726ed1444992a04c3902c14bb97abe7a8884628", "url": "https://github.com/OpenRefine/OpenRefine/commit/9726ed1444992a04c3902c14bb97abe7a8884628", "message": "Switch to own WDTK snapshot", "committedDate": "2020-06-15T12:32:48Z", "type": "commit"}, {"oid": "cd76df0b293f5b27664d8641134efd96e86d8eb3", "url": "https://github.com/OpenRefine/OpenRefine/commit/cd76df0b293f5b27664d8641134efd96e86d8eb3", "message": "Enable snapshot repository explicitly in root pom", "committedDate": "2020-06-15T12:57:00Z", "type": "commit"}, {"oid": "8fd384f04410da02c12136b6f8a2d9e79770bdf2", "url": "https://github.com/OpenRefine/OpenRefine/commit/8fd384f04410da02c12136b6f8a2d9e79770bdf2", "message": "typo", "committedDate": "2020-06-15T14:59:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNjQyOA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r440536428", "bodyText": "Is this message displayed to the user? It looks like it just gets put into the server log.", "author": "tfmorris", "createdAt": "2020-06-16T01:35:36Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/commands/ConnectionManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\n+ * MIT License\n+ *\n+ * Copyright (c) 2018 Antonin Delpeuch\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ ******************************************************************************/\n+package org.openrefine.wikidata.commands;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.refine.ProjectManager;\n+import com.google.refine.preference.PreferenceStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wikidata.wdtk.wikibaseapi.ApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.BasicApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.LoginFailedException;\n+import org.wikidata.wdtk.wikibaseapi.OAuthApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.apierrors.MediaWikiApiErrorException;\n+\n+import javax.servlet.http.Cookie;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Manages a connection to Wikidata.\n+ * <p>\n+ * The connection can be either {@link BasicApiConnection} or {@link OAuthApiConnection}.\n+ * <p>\n+ * This class is also hard-coded for Wikidata,\n+ * it will be generalized to other Wikibase instances soon.\n+ *\n+ * @author Antonin Delpeuch\n+ * @author Lu Liu\n+ */\n+\n+public class ConnectionManager {\n+\n+    final static Logger logger = LoggerFactory.getLogger(\"connection_manager\");\n+\n+    /**\n+     * We used this key to read/write credentials from/to preferences in the past, which is insecure.\n+     * Now this key is kept only to delete those credentials in the preferences.\n+     */\n+    public static final String PREFERENCE_STORE_KEY = \"wikidata_credentials\";\n+\n+    public static final int CONNECT_TIMEOUT = 5000;\n+    public static final int READ_TIMEOUT = 10000;\n+\n+    /**\n+     * For now, this class is hard-coded for Wikidata.\n+     * <p>\n+     * It will be generalized to work against other Wikibase instances in the future.\n+     */\n+    private static final String WIKIBASE_API_ENDPOINT = ApiConnection.URL_WIKIDATA_API;\n+\n+    /**\n+     * The single {@link ApiConnection} instance managed by {@link ConnectionManager}.\n+     * <p>\n+     * Currently, only one connection is supported at the same time.\n+     */\n+    private ApiConnection connection;\n+\n+    private static final ConnectionManager instance = new ConnectionManager();\n+\n+    public static ConnectionManager getInstance() {\n+        return instance;\n+    }\n+\n+    private ConnectionManager() {\n+        PreferenceStore prefStore = ProjectManager.singleton.getPreferenceStore();\n+        // remove credentials stored in the preferences\n+        prefStore.put(PREFERENCE_STORE_KEY, null);\n+    }\n+\n+    /**\n+     * Logs in to the Wikibase instance, using username/password.\n+     * <p>\n+     * If failed to login, the connection will be set to null.\n+     *\n+     * @param username the username to log in with\n+     * @param password the password to log in with\n+     * @return true if logged in successfully, false otherwise\n+     */\n+    public boolean login(String username, String password) {\n+        connection = new BasicApiConnection(WIKIBASE_API_ENDPOINT);\n+        setupConnection(connection);\n+        try {\n+            ((BasicApiConnection) connection).login(username, password);\n+            return true;\n+        } catch (LoginFailedException e) {\n+            logger.error(e.getMessage());\n+            connection = null;\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Logs in to the Wikibase instance, using owner-only consumer.\n+     * <p>\n+     * If failed to login, the connection will be set to null.\n+     *\n+     * @param consumerToken  consumer token of an owner-only consumer\n+     * @param consumerSecret consumer secret of an owner-only consumer\n+     * @param accessToken    access token of an owner-only consumer\n+     * @param accessSecret   access secret of an owner-only consumer\n+     * @return true if logged in successfully, false otherwise\n+     */\n+    public boolean login(String consumerToken, String consumerSecret,\n+                         String accessToken, String accessSecret) {\n+        connection = new OAuthApiConnection(WIKIBASE_API_ENDPOINT,\n+                consumerToken, consumerSecret,\n+                accessToken, accessSecret);\n+        setupConnection(connection);\n+        try {\n+            // check if the credentials are valid\n+            connection.checkCredentials();\n+            return true;\n+        } catch (IOException | MediaWikiApiErrorException e) {\n+            logger.error(e.getMessage());", "originalCommit": "8fd384f04410da02c12136b6f8a2d9e79770bdf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTg2OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r442605869", "bodyText": "Yes, only in server log. If the login fails, the frontend can know by checking the response and then asks the user to try again.", "author": "afkbrb", "createdAt": "2020-06-19T03:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzNjQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU0MTg4OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2661#discussion_r440541889", "bodyText": "This seems like it might be too short, but I guess we can find out when users test.", "author": "tfmorris", "createdAt": "2020-06-16T01:55:46Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/commands/ConnectionManager.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*******************************************************************************\n+ * MIT License\n+ *\n+ * Copyright (c) 2018 Antonin Delpeuch\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ ******************************************************************************/\n+package org.openrefine.wikidata.commands;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.refine.ProjectManager;\n+import com.google.refine.preference.PreferenceStore;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wikidata.wdtk.wikibaseapi.ApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.BasicApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.LoginFailedException;\n+import org.wikidata.wdtk.wikibaseapi.OAuthApiConnection;\n+import org.wikidata.wdtk.wikibaseapi.apierrors.MediaWikiApiErrorException;\n+\n+import javax.servlet.http.Cookie;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Manages a connection to Wikidata.\n+ * <p>\n+ * The connection can be either {@link BasicApiConnection} or {@link OAuthApiConnection}.\n+ * <p>\n+ * This class is also hard-coded for Wikidata,\n+ * it will be generalized to other Wikibase instances soon.\n+ *\n+ * @author Antonin Delpeuch\n+ * @author Lu Liu\n+ */\n+\n+public class ConnectionManager {\n+\n+    final static Logger logger = LoggerFactory.getLogger(\"connection_manager\");\n+\n+    /**\n+     * We used this key to read/write credentials from/to preferences in the past, which is insecure.\n+     * Now this key is kept only to delete those credentials in the preferences.\n+     */\n+    public static final String PREFERENCE_STORE_KEY = \"wikidata_credentials\";\n+\n+    public static final int CONNECT_TIMEOUT = 5000;", "originalCommit": "8fd384f04410da02c12136b6f8a2d9e79770bdf2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}