{"pr_number": 2693, "pr_title": "New implementation for Conflicts-With Scrutinizer", "pr_createdAt": "2020-06-11T05:39:17Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2693", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MjUzNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442672535", "bodyText": "One way to make this slightly more concise is to use Collections.singletonList which creates a list with a single element.", "author": "wetneb", "createdAt": "2020-06-19T07:16:20Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -211,10 +218,42 @@ public boolean hasDiffWithinRange(PropertyIdValue pid) {\n         return true;\n     }\n \n-    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n-        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n-        List<Value> items = Arrays.asList(conflictingStatementValue, null);\n-        propertyIdValueListMap.put(conflictingStatementPid, items);\n-        return propertyIdValueListMap;\n+    @Override\n+    public Stream<Statement> getConstraintsByType(PropertyIdValue pid, String qid) {\n+        EntityIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(\"Q21502838\");\n+        PropertyIdValue propertyIdValue = Datamodel.makeWikidataPropertyIdValue(\"P2302\");\n+        Snak snak = Datamodel.makeValueSnak(propertyIdValue,entityIdValue);\n+\n+        PropertyIdValue property = Datamodel.makeWikidataPropertyIdValue(\"P2306\");\n+        Value propertyValue = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+        Snak snak1 = Datamodel.makeValueSnak(property,propertyValue);\n+        List<Snak> group1 = new ArrayList<>();\n+        group1.add(snak1);", "originalCommit": "a50fac1878eab162c1518c23df86837a5523f385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MjgyNA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442672824", "bodyText": "When you have more than one element, you can use Arrays.asList(first, second) to construct the list in a more concise way.", "author": "wetneb", "createdAt": "2020-06-19T07:17:00Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -211,10 +218,42 @@ public boolean hasDiffWithinRange(PropertyIdValue pid) {\n         return true;\n     }\n \n-    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n-        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n-        List<Value> items = Arrays.asList(conflictingStatementValue, null);\n-        propertyIdValueListMap.put(conflictingStatementPid, items);\n-        return propertyIdValueListMap;\n+    @Override\n+    public Stream<Statement> getConstraintsByType(PropertyIdValue pid, String qid) {\n+        EntityIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(\"Q21502838\");\n+        PropertyIdValue propertyIdValue = Datamodel.makeWikidataPropertyIdValue(\"P2302\");\n+        Snak snak = Datamodel.makeValueSnak(propertyIdValue,entityIdValue);\n+\n+        PropertyIdValue property = Datamodel.makeWikidataPropertyIdValue(\"P2306\");\n+        Value propertyValue = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+        Snak snak1 = Datamodel.makeValueSnak(property,propertyValue);\n+        List<Snak> group1 = new ArrayList<>();\n+        group1.add(snak1);\n+\n+        PropertyIdValue item = Datamodel.makeWikidataPropertyIdValue(\"P2305\");\n+        Value itemValue = Datamodel.makeWikidataItemIdValue(\"Q5\");\n+        Snak snak2 = Datamodel.makeValueSnak(item,itemValue);\n+        List<Snak> group2 = new ArrayList<>();\n+        group2.add(snak2);\n+\n+        SnakGroup snakGroup1 = Datamodel.makeSnakGroup(group1);\n+        SnakGroup snakGroup2 = Datamodel.makeSnakGroup(group2);\n+\n+        List<SnakGroup> list = new ArrayList<>();\n+        list.add(snakGroup1);\n+        list.add(snakGroup2);", "originalCommit": "a50fac1878eab162c1518c23df86837a5523f385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MzI5Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442673296", "bodyText": "It might be worth ensuring that the statement id uses the same property id as the claim (\"P2302\" instead of \"P50\"), because there are plans to validate statement ids in forthcoming versions of WDTK.", "author": "wetneb", "createdAt": "2020-06-19T07:18:08Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -211,10 +218,42 @@ public boolean hasDiffWithinRange(PropertyIdValue pid) {\n         return true;\n     }\n \n-    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n-        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n-        List<Value> items = Arrays.asList(conflictingStatementValue, null);\n-        propertyIdValueListMap.put(conflictingStatementPid, items);\n-        return propertyIdValueListMap;\n+    @Override\n+    public Stream<Statement> getConstraintsByType(PropertyIdValue pid, String qid) {\n+        EntityIdValue entityIdValue = Datamodel.makeWikidataItemIdValue(\"Q21502838\");\n+        PropertyIdValue propertyIdValue = Datamodel.makeWikidataPropertyIdValue(\"P2302\");\n+        Snak snak = Datamodel.makeValueSnak(propertyIdValue,entityIdValue);\n+\n+        PropertyIdValue property = Datamodel.makeWikidataPropertyIdValue(\"P2306\");\n+        Value propertyValue = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+        Snak snak1 = Datamodel.makeValueSnak(property,propertyValue);\n+        List<Snak> group1 = new ArrayList<>();\n+        group1.add(snak1);\n+\n+        PropertyIdValue item = Datamodel.makeWikidataPropertyIdValue(\"P2305\");\n+        Value itemValue = Datamodel.makeWikidataItemIdValue(\"Q5\");\n+        Snak snak2 = Datamodel.makeValueSnak(item,itemValue);\n+        List<Snak> group2 = new ArrayList<>();\n+        group2.add(snak2);\n+\n+        SnakGroup snakGroup1 = Datamodel.makeSnakGroup(group1);\n+        SnakGroup snakGroup2 = Datamodel.makeSnakGroup(group2);\n+\n+        List<SnakGroup> list = new ArrayList<>();\n+        list.add(snakGroup1);\n+        list.add(snakGroup2);\n+        Claim claim = Datamodel.makeClaim(entityIdValue,snak, list);\n+\n+        Reference reference = Datamodel.makeReference(list);\n+        List<Reference> referenceList = new ArrayList<>();\n+        referenceList.add(reference);\n+\n+        Statement statement = Datamodel.makeStatement(claim,referenceList, StatementRank.NORMAL, \"P50$77BD7FE4-C051-4776-855C-543F0CE697D0\");", "originalCommit": "a50fac1878eab162c1518c23df86837a5523f385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3Mzk5Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442673992", "bodyText": "I would inline the setParams method (pull its contents into the constructor and delete the method), because we do not expect to have to change the constraint definition after constructing it. In general, when we can make immutable classes, it is a good idea to build them as such (so you could also mark the two fields above as final).", "author": "wetneb", "createdAt": "2020-06-19T07:19:48Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -3,18 +3,50 @@\n import org.openrefine.wikidata.qa.QAWarning;\n import org.openrefine.wikidata.updates.ItemUpdate;\n import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n import org.wikidata.wdtk.datamodel.interfaces.Statement;\n import org.wikidata.wdtk.datamodel.interfaces.Value;\n \n-import java.util.Set;\n-import java.util.Map;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class ConflictsWithScrutinizer extends EditScrutinizer {\n \n     public static final String type = \"having-conflicts-with-statements\";\n+    public static String CONFLICTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICTS_WITH_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ConflictsWithConstraint {\n+        PropertyIdValue conflictingPid;\n+        List<Value> itemList;\n+\n+        ConflictsWithConstraint(Statement statement) {\n+            this.setParams(statement);", "originalCommit": "a50fac1878eab162c1518c23df86837a5523f385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5MzMxMg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442693312", "bodyText": "We should remove this print.", "author": "wetneb", "createdAt": "2020-06-19T08:00:54Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -3,18 +3,48 @@\n import org.openrefine.wikidata.qa.QAWarning;\n import org.openrefine.wikidata.updates.ItemUpdate;\n import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Snak;\n+import org.wikidata.wdtk.datamodel.interfaces.SnakGroup;\n import org.wikidata.wdtk.datamodel.interfaces.Statement;\n import org.wikidata.wdtk.datamodel.interfaces.Value;\n \n-import java.util.Set;\n-import java.util.Map;\n+import java.util.ArrayList;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n public class ConflictsWithScrutinizer extends EditScrutinizer {\n \n     public static final String type = \"having-conflicts-with-statements\";\n+    public static String CONFLICTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICTS_WITH_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n+\n+    class ConflictsWithConstraint {\n+        final PropertyIdValue conflictingPid;\n+        final List<Value> itemList;\n+\n+        ConflictsWithConstraint(Statement statement) {\n+            System.out.println(statement.getStatementId());", "originalCommit": "50113e365e95eaced6cec5d1defd9fe697194ffd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NDMyNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442694327", "bodyText": "What happens when the statement does not contain the necessary qualifiers to extract constraint parameters? For instance, a conflicts with constraint without any parameter? We should make sure such declarations are ignored. This will be easier to test with once we migrate to proper mocking, because you will be able to control more easily the return value of getConstraintsByType in each test.", "author": "wetneb", "createdAt": "2020-06-19T08:02:54Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -36,25 +66,29 @@ public void scrutinize(ItemUpdate update) {\n         }\n \n         for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n-            Map<PropertyIdValue, List<Value>> conflictingPropertyMap = _fetcher.getParamConflictsWith(propertyId);\n-            for (PropertyIdValue conflictingPid : conflictingPropertyMap.keySet()) {\n-                if (propertyIdValueValueMap.containsKey(conflictingPid) && raiseWarning(propertyIdValueValueMap, conflictingPid, conflictingPropertyMap)) {\n+            List<Statement> statementList = _fetcher.getConstraintsByType(propertyId, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+            for (Statement statement : statementList) {\n+                ConflictsWithConstraint constraint = new ConflictsWithConstraint(statement);", "originalCommit": "50113e365e95eaced6cec5d1defd9fe697194ffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NzE0MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442697140", "bodyText": "For now, In that case conflictingPid will be null and propertyIdValueValueMap.containsKey(conflictingPid) this will return false and the if condition will not execute in that case. Is it fine for now or it needs some changes?", "author": "darecoder", "createdAt": "2020-06-19T08:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NDMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5ODMzOA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442698338", "bodyText": "Let's just try to remember to add a test for it once we have proper mocking in place :)", "author": "wetneb", "createdAt": "2020-06-19T08:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NDMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5ODU3MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2693#discussion_r442698570", "bodyText": "Sure!", "author": "darecoder", "createdAt": "2020-06-19T08:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5NDMyNw=="}], "type": "inlineReview"}, {"oid": "b0ee96601b4ee26d347ba2ae0d8eb044d34294a7", "url": "https://github.com/OpenRefine/OpenRefine/commit/b0ee96601b4ee26d347ba2ae0d8eb044d34294a7", "message": "New implementation for Conflicts-With Scrutinizer\n\npart of #2354", "committedDate": "2020-06-19T08:09:30Z", "type": "commit"}]}