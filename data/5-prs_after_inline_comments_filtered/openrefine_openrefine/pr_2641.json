{"pr_number": 2641, "pr_title": "Add conflicts-with constraint", "pr_createdAt": "2020-05-25T16:10:46Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2641", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTg5Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430071897", "bodyText": "Datamodel.makeWikidataItemIdValue(\"P31\") is incorrect, you are trying to create an ItemIdValue with a property identifier.", "author": "wetneb", "createdAt": "2020-05-25T20:52:49Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -59,6 +60,11 @@\n     \n     public static PropertyIdValue propertyOnlyPid = Datamodel.makeWikidataPropertyIdValue(\"P372\");\n \n+    public static PropertyIdValue conflictsWithPid = Datamodel.makeWikidataPropertyIdValue(\"P50\");\n+    public static PropertyIdValue pidConflictingStatement = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"P31\");", "originalCommit": "058d0775ef0ba1c44981ce2c788836cfeab735cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430215519", "bodyText": "If this returns a list of PropertyIdValues, the return type should probably reflect that, no? I would use List<PropertyIdValue> instead of List<Value>.", "author": "wetneb", "createdAt": "2020-05-26T07:41:47Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzY0Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432877642", "bodyText": "I did that so I can make use of findValues method else we have to create a new method doing nearly same thing.", "author": "darecoder", "createdAt": "2020-05-30T18:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODc1OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432878759", "bodyText": "I think it is better to have a clean signature for an interface: you can convert the values with a map (from the streaming API).", "author": "wetneb", "createdAt": "2020-05-30T18:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNjA3MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430216070", "bodyText": "Typo: CONFLICSTS should be CONFLICTS", "author": "wetneb", "createdAt": "2020-05-26T07:42:51Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -96,7 +86,10 @@\n     public static String ALLOWED_ENTITY_TYPES_QID = \"Q52004125\";\n     public static String ALLOWED_ITEM_TYPE_QID = \"Q29934200\";\n     public static String ALLOWED_ENTITY_TYPES_PID = \"P2305\";\n-    \n+\n+    public static String CONFLICSTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICSTS_WITH_PROPERTY_PID = \"P2306\";", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNzQzNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430217435", "bodyText": "This method seems redundant to me: if a property does not conflict with any other, we could just represent that by getConflictsWithProperties returning an empty list.", "author": "wetneb", "createdAt": "2020-05-26T07:45:21Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getItemwithConflicts (PropertyIdValue pid);\n+\n+    /**\n+     * Is this property expected to have conflicts-with any other property/properties?\n+     */\n+    boolean hasConflictsWith(PropertyIdValue propertyId);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjU0Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432836542", "bodyText": "Style: no space between the method name and the opening parenthesis, one space between the closing parenthesis and the opening curly brace.", "author": "wetneb", "createdAt": "2020-05-30T12:12:06Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -340,4 +333,47 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getConflictsWithProperties (PropertyIdValue pid){", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNzkwNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432837907", "bodyText": "Okay, I'll do the changes.", "author": "darecoder", "createdAt": "2020-05-30T12:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432836641", "bodyText": "Didn't we agree that we needed two parameters here: the property on which the constraint is defined, and the property it conflicts with?", "author": "wetneb", "createdAt": "2020-05-30T12:13:20Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getItemwithConflicts (PropertyIdValue pid);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNzg3Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432837876", "bodyText": "That's what I want to discuss with you, that If we are following wikibase quality constraints implementation so I guess they have used the same kind of implementation, they are fetching the item list at once and then checking that if the conflicting property is having a value from that list. https://github.com/wikimedia/mediawiki-extensions-WikibaseQualityConstraints/blob/master/src/ConstraintCheck/Checker/ConflictsWithChecker.php#L119-L139", "author": "darecoder", "createdAt": "2020-05-30T12:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTI4OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432839289", "bodyText": "Their architecture is quite different from what we have here: yes they fetch items in a single go, but in this context they are already looking at a single constraint definition anyway. We should make sure examples like https://www.wikidata.org/wiki/Property:P4013 are handled correctly.", "author": "wetneb", "createdAt": "2020-05-30T12:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTMyNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432839326", "bodyText": "Happy to discuss that at our next meeting on tuesday if that helps :)", "author": "wetneb", "createdAt": "2020-05-30T12:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA4ODc4MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434088781", "bodyText": "@wetneb: I have made the changes proposed, still finding an issue. When there are multiple issues to be reported for conflicts with constraint only the one is reported at once. I have checked that the raiseWarning method is returning true for all the possible issues but still the issues are not flagged in the issues tab. Please help. Thank you.", "author": "darecoder", "createdAt": "2020-06-02T18:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcyMA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432949720", "bodyText": "Because you are using getSingleConstraint here, this means that for properties with multiple conflicts-with constraints, you will only check the first one.", "author": "wetneb", "createdAt": "2020-05-31T13:54:43Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -340,4 +333,40 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICTS_WITH_CONSTRAINT_QID);", "originalCommit": "9e85f9851beca8b56253b80f2b8cb18f95ce0345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTYxNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432955617", "bodyText": "Okay, let me try the alternatives. Thanks for the review. :)", "author": "darecoder", "createdAt": "2020-05-31T15:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MDE3NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434390175", "bodyText": "Should be Map<PropertyIdValue, List<Value>>", "author": "wetneb", "createdAt": "2020-06-03T08:17:32Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434391211", "bodyText": "We need to check to check what happens with no value and some value snaks.", "author": "wetneb", "createdAt": "2020-06-03T08:19:17Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()){\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NDgwOA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434744808", "bodyText": "In the case of NoValueSnak & SomeValueSnak, it will make a call to the method implemented in SnakImpl which will return null. So, I guess it will not create any issues. If it is an issue, please let me know, I'll use some other way to implement the functionality.", "author": "darecoder", "createdAt": "2020-06-03T17:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzY2Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257662", "bodyText": "That is fine then! It would be worth adding a test case with a NoValueSnak to demonstrate that, perhaps?", "author": "wetneb", "createdAt": "2020-06-06T10:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MjAzNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434392035", "bodyText": "You will have an NPE here if the candidate conflicting value is a NoValueSnak.", "author": "wetneb", "createdAt": "2020-06-03T08:20:44Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()){\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            propertyIdValueValueMap.put(pid, value);\n+        }\n+\n+        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+            List<PropertyIdValue> conflictingProperties = _fetcher.getConflictsWithProperties(propertyId);\n+            if (conflictingProperties != null){\n+                for (PropertyIdValue conflictingPid : conflictingProperties) {\n+                    if (propertyIdValueValueMap.containsKey(conflictingPid) && raiseWarning(propertyId, propertyIdValueValueMap, conflictingPid)) {\n+                        QAWarning issue = new QAWarning(type, propertyId.getId(), QAWarning.Severity.WARNING, 1);\n+                        issue.setProperty(\"property_entity\", propertyId);\n+                        issue.setProperty(\"added_property_entity\", conflictingPid);\n+                        issue.setProperty(\"example_entity\", update.getItemId());\n+                        addIssue(issue);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean raiseWarning(PropertyIdValue propertyId, Map<PropertyIdValue, Value> propertyIdValueValueMap, PropertyIdValue conflictingPid) {\n+        List<Value> conflictingValues = _fetcher.getItemWithConflicts(propertyId, conflictingPid);\n+        if (conflictingValues == null){\n+            return true;\n+        }\n+\n+        if (propertyIdValueValueMap.containsKey(conflictingPid)){\n+            for (Value value : conflictingValues) {\n+                if (propertyIdValueValueMap.get(conflictingPid).equals(value)){", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257551", "bodyText": "Two things: it is better to avoid referring to PropertyIdValueImpl, you can just use PropertyIdValue which is the interface. Also, this type check is actually redundant with the equality check afterwards. You should just be able to do conflictingPid.equals(snak.getValue()) (since you know conflictingPid is not null and its equals method will only return true for instances of PropertyIdValue).", "author": "wetneb", "createdAt": "2020-06-06T10:29:53Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -337,4 +342,57 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> conflictsWithProperties = new ArrayList<>();\n+        for(Statement statement : statementList){\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            if (specs != null) {\n+                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+            }\n+        }\n+\n+        if (!conflictsWithProperties.isEmpty()) {\n+            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> itemList = new ArrayList<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            boolean flag = false;\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){", "originalCommit": "0457785a0882b8610f761d3cc4c0997151d8d1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI2OTM0Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436269347", "bodyText": "Changing PropertyIdValueImpl to PropertyIdValue sounds good to me but removing that check will not be good I guess. Because I have used that as in case of Snaks we get both Property and Item so we have to update flag value only in case when we get Property as Snak. So, in the 1st if condition it will work but in 2nd else if part it will not work as expected.", "author": "darecoder", "createdAt": "2020-06-06T13:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzE4Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273187", "bodyText": "Can you give me an example of a case where snak.getValue().equals(conflictingPid) evaluates to true but snak.getValue() instanceof PropertyIdValue does not?", "author": "wetneb", "createdAt": "2020-06-06T14:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzUyNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273527", "bodyText": "As I mentioned, it will work for sure but in the 2nd else if condition snak.getValue() instanceof PropertyIdValue && !snak.getValue().equals(conflictingPid)  if we remove the check to check the instance class then there might be the case that it belongs to ItemIdValue and it will make get executed as this will be true in that case !snak.getValue().equals(conflictingPid).", "author": "darecoder", "createdAt": "2020-06-06T14:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzgyMw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273823", "bodyText": "If snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)", "author": "wetneb", "createdAt": "2020-06-06T14:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDI1Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436274257", "bodyText": "I feel we both are looking at the issue differently.\n\nIf snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)\n\nI do agree with your explanation, that's why I'm saying it. If it evaluates to false for other ItemIdValue the ! at the starting !snak.getValue().equals(conflictingPid) will make it true and it will get executed which I don't want for now. I have tried to remove the instanceof comparison but it didn't worked as expected. If you are insisting I'll try it once again for sure.", "author": "darecoder", "createdAt": "2020-06-06T14:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDgxMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436274811", "bodyText": "Could you explain what you mean by \"it didn't worked as expected\"? Perhaps the best thing to do in this case is to put a breakpoint on this if and use the debugger to find out what is happening here exactly :)", "author": "wetneb", "createdAt": "2020-06-06T14:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTYxNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436275616", "bodyText": "Because I want the 2nd else if condition to execute only when the case is: it is not an ItemIdValue, it is a PropertyIdValue but its value is not equal to the conflictingPid. But when I remove the instanceof check from it, the condition executes even for ItemIdValue as expected according to your explanation.\n\nIf snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)\n\nBut I want to it to execute for PropertyIdValue only when its value isn't equal to conflictingPid.\nChanging the order of conditions after removing the instanceof check might work. I'm testing it currently.", "author": "darecoder", "createdAt": "2020-06-06T15:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTU0Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436279543", "bodyText": "But I want to it to execute for PropertyIdValue only when its value isn't equal to conflictingPid.\n\nYes but that is not how you should do it: you should look at the property of the snak, not the type of its values (because there could potentially be some other parameter which would also have the same type of values). So: remove all instanceof checks and use snak.getProperty() to know what sort of parameter you are handling.", "author": "wetneb", "createdAt": "2020-06-06T15:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTk5Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436279993", "bodyText": "I have removed the instanceof checks. Is it okay now?\nOr I need to change  snak.getValue().equals(conflictingPid)  to snak.getPropertyId().equals(conflictingPid) ?", "author": "darecoder", "createdAt": "2020-06-06T16:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDAwNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436290005", "bodyText": "It is much better! Now I guess we still have the issue that you are relying on the order of the qualifiers (you expect the property first, and then the items, but there is no reason why they should necessarily appear in this order).", "author": "wetneb", "createdAt": "2020-06-06T18:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDY3OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436290679", "bodyText": "I tried a lot of properties having conflicts-with constraint and observed this pattern, hence proceeded with this implementation. I won't say testes all of them but some of them. The item values don't seem to have anything that relates it to the conflicting Pid I guess. What else I should do? Any suggestions?", "author": "darecoder", "createdAt": "2020-06-06T18:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MTA3Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436291072", "bodyText": "I would do as follows:\n\ncreate a variable to store the conflicting pid and a list of conflicting values\nloop over all qualifier snaks (as you are doing)\n\nif the property of the snak is the one that specifies the conflicting pid, then set the conflicting pid to the qualifier value\nif the property of the snak is the one that specifies the conflicting values, then add the value to the list of conflicting values", "author": "wetneb", "createdAt": "2020-06-06T18:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5ODUwNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436298506", "bodyText": "Hope, I correctly understand what you tried to explain. :)", "author": "darecoder", "createdAt": "2020-06-06T20:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU2MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257561", "bodyText": "Same here.", "author": "wetneb", "createdAt": "2020-06-06T10:30:04Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -337,4 +342,57 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> conflictsWithProperties = new ArrayList<>();\n+        for(Statement statement : statementList){\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            if (specs != null) {\n+                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+            }\n+        }\n+\n+        if (!conflictsWithProperties.isEmpty()) {\n+            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> itemList = new ArrayList<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            boolean flag = false;\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){\n+                        flag = true;\n+                    } else if (snak.getValue() instanceof PropertyIdValueImpl && !snak.getValue().equals(conflictingPid)) {", "originalCommit": "0457785a0882b8610f761d3cc4c0997151d8d1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTA1Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436275053", "bodyText": "Here, instead of relying on the PropertyIdValue type of the snak value, you should rather rely on the snak.getProperty()'s value.", "author": "wetneb", "createdAt": "2020-06-06T14:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU2MQ=="}], "type": "inlineReview"}, {"oid": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "url": "https://github.com/OpenRefine/OpenRefine/commit/3aa6e2dd6807111e843169c3b3acd88801e7314f", "message": "Added conflicts-with constraints\n\nImplemented conflicts-with scrutinizer as part of #2354", "committedDate": "2020-06-06T20:33:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg4NA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437673884", "bodyText": "This looks like a missed merge conflict", "author": "tfmorris", "createdAt": "2020-06-09T19:41:32Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -142,6 +144,7 @@\n     boolean usableOnItems(PropertyIdValue pid);\n \n     /**\n+<<<<<<< HEAD", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTQ1MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437729450", "bodyText": "whoops, thanks for catching that!", "author": "wetneb", "createdAt": "2020-06-09T21:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NDY5NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437674695", "bodyText": "Did your IDE do this without you asking? Can you configure a higher limit for wild card imports and/or review the diff to make sure unnecessary changes aren't included?", "author": "tfmorris", "createdAt": "2020-06-09T19:43:03Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -28,9 +28,7 @@\n import org.wikidata.wdtk.datamodel.implementation.QuantityValueImpl;\n import org.wikidata.wdtk.datamodel.interfaces.*;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDkxNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437844917", "bodyText": "Yes, it got updated on its own by the IDE. Sorry, I'll take care of it next time onwards for sure. For now, I'll create a PR resolving all the flaws. Thanks for the review. :)", "author": "darecoder", "createdAt": "2020-06-10T03:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3OTUyMg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437679522", "bodyText": "This appears to duplicate ALLOWED_ENTITY_TYPES_PID just above.", "author": "tfmorris", "createdAt": "2020-06-09T19:52:13Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -94,7 +92,10 @@\n     public static String ALLOWED_ENTITY_TYPES_QID = \"Q52004125\";\n     public static String ALLOWED_ITEM_TYPE_QID = \"Q29934200\";\n     public static String ALLOWED_ENTITY_TYPES_PID = \"P2305\";\n-    \n+\n+    public static String CONFLICTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICTS_WITH_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczMDI5Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437730292", "bodyText": "While these happen to have the same value for Wikidata, it might not be true of all Wikibase instances (these constants should become user-configurable once we add proper Wikibase support). That being said the name of the constant could probably be adapted to reflect that it is specifically for that constraint.", "author": "wetneb", "createdAt": "2020-06-09T21:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3OTUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MDYyNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437680626", "bodyText": "I recognize Q5, but the rest would have to look up. For the benefit of future readers, it might be nice to give them mnemonic variable names or to put the string values in constants.", "author": "tfmorris", "createdAt": "2020-06-09T19:54:26Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -66,6 +69,11 @@\n     public static QuantityValue minValuePid = Datamodel.makeQuantityValue(new BigDecimal(0));\n     public static QuantityValue maxValuePid = Datamodel.makeQuantityValue(new BigDecimal(150));\n \n+    public static PropertyIdValue conflictsWithPid = Datamodel.makeWikidataPropertyIdValue(\"P50\");\n+    public static PropertyIdValue pidConflictingStatement = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"Q5\");\n+    public static Value conflictsWithValue = Datamodel.makeWikidataItemIdValue(\"Q36322\");", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}