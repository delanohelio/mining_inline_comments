{"pr_number": 2406, "pr_title": "[ISSUE #690] Support batch msgs in dledger mode", "pr_createdAt": "2020-11-08T10:39:03Z", "pr_url": "https://github.com/apache/rocketmq/pull/2406", "timeline": [{"oid": "d16878663ef56d05efc138c2d41d186e9118f033", "url": "https://github.com/apache/rocketmq/commit/d16878663ef56d05efc138c2d41d186e9118f033", "message": "implement issue-690", "committedDate": "2020-11-07T08:32:14Z", "type": "commit"}, {"oid": "a6d4affa0ff54997dfb6d0561320cd9c18490a17", "url": "https://github.com/apache/rocketmq/commit/a6d4affa0ff54997dfb6d0561320cd9c18490a17", "message": "implement issue 690", "committedDate": "2020-11-08T05:20:32Z", "type": "commit"}, {"oid": "9a7893bdb95761cb51ba02f9e8fffaefedbc2c4d", "url": "https://github.com/apache/rocketmq/commit/9a7893bdb95761cb51ba02f9e8fffaefedbc2c4d", "message": "add unit test", "committedDate": "2020-11-08T09:52:09Z", "type": "commit"}, {"oid": "d638e5ffdb94f0957da36253eb971990ded68ea6", "url": "https://github.com/apache/rocketmq/commit/d638e5ffdb94f0957da36253eb971990ded68ea6", "message": "fix version", "committedDate": "2020-11-08T10:38:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxOTYxMg==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519519612", "bodyText": "When sending batch messages, worteOffset is the offset of the first message, but this is the offset of the last message, so the unit test fails.", "author": "RongtongJin", "createdAt": "2020-11-09T02:19:18Z", "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            for (long pos : dledgerFuture.getPositions()) {\n+                wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }\n+            elapsedTimeInLock = this.defaultMessageStore.getSystemClock().now() - beginTimeInDledgerLock;\n+            appendResult = new AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, encodeResult.totalMsgLen,\n+                    msgIdBuilder.toString(), System.currentTimeMillis(), queueOffset, elapsedTimeInLock);\n+            DLedgerCommitLog.this.topicQueueTable.put(encodeResult.queueOffsetKey, queueOffset + msgNum);", "originalCommit": "d638e5ffdb94f0957da36253eb971990ded68ea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzODE3Mg==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520638172", "bodyText": "Good job!", "author": "TerrellChen", "createdAt": "2020-11-10T15:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUxOTYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMDM3Mw==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519520373", "bodyText": "Write code as this:\nboolean isFirstOffset = true;\n            for (long pos : dledgerFuture.getPositions()) {\n                if(isFirstOffset) {\n                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n                    isFirstOffset = false;\n                }\n                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n                if (msgIdBuilder.length() > 0) {\n                    msgIdBuilder.append(',').append(msgId);\n                } else {\n                    msgIdBuilder.append(msgId);\n                }\n                msgNum++;\n            }\nOr do you have a better solution\uff1f", "author": "RongtongJin", "createdAt": "2020-11-09T02:22:42Z", "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            for (long pos : dledgerFuture.getPositions()) {\n+                wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "originalCommit": "d638e5ffdb94f0957da36253eb971990ded68ea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzOTMwNA==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520639304", "bodyText": "LGTM!", "author": "TerrellChen", "createdAt": "2020-11-10T15:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMDM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMTU5OA==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r519521598", "bodyText": "Removing [DEBUG_CTR] will be better.", "author": "RongtongJin", "createdAt": "2020-11-09T02:28:25Z", "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,122 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"[DEBUG_CTR] handleAppend return false due to error code {}\", dledgerFuture.get().getCode());", "originalCommit": "d638e5ffdb94f0957da36253eb971990ded68ea6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzOTc2MQ==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520639761", "bodyText": "My fault!", "author": "TerrellChen", "createdAt": "2020-11-10T15:13:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyMTU5OA=="}], "type": "inlineReview"}, {"oid": "08c9b0110d0b6e32a3c7ce741d3296f337700430", "url": "https://github.com/apache/rocketmq/commit/08c9b0110d0b6e32a3c7ce741d3296f337700430", "message": "fix wroteOffset;update version;polish", "committedDate": "2020-11-10T15:15:02Z", "type": "commit"}, {"oid": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "url": "https://github.com/apache/rocketmq/commit/6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "message": "polish", "committedDate": "2020-11-10T15:43:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTczNg==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520945736", "bodyText": "This is my fault. The code will cause the writeOffset of the following message not to be updated, so as to get the wrong msgId. We need to fix it and ensure that the writeOffset of the first message is returned to the user.", "author": "RongtongJin", "createdAt": "2020-11-10T23:45:09Z", "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -609,7 +735,122 @@ public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n \n     @Override\n     public CompletableFuture<PutMessageResult> asyncPutMessages(MessageExtBatch messageExtBatch) {\n-        return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null));\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status)));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"HandleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return CompletableFuture.completedFuture(new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR)));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            boolean isFirstOffset = true;\n+            for (long pos : dledgerFuture.getPositions()) {\n+                if (isFirstOffset) {\n+                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                    isFirstOffset = false;\n+                }\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "originalCommit": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5NDM4Mw==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r522194383", "bodyText": "fixed", "author": "TerrellChen", "createdAt": "2020-11-12T15:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTk5MQ==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r520945991", "bodyText": "Same as below", "author": "RongtongJin", "createdAt": "2020-11-10T23:45:51Z", "path": "store/src/main/java/org/apache/rocketmq/store/dledger/DLedgerCommitLog.java", "diffHunk": "@@ -507,7 +513,127 @@ public PutMessageResult putMessage(final MessageExtBrokerInner msg) {\n \n     @Override\n     public PutMessageResult putMessages(final MessageExtBatch messageExtBatch) {\n-        return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        final int tranType = MessageSysFlag.getTransactionValue(messageExtBatch.getSysFlag());\n+\n+        if (tranType != MessageSysFlag.TRANSACTION_NOT_TYPE) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+        if (messageExtBatch.getDelayTimeLevel() > 0) {\n+            return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, null);\n+        }\n+\n+        // Set the storage time\n+        messageExtBatch.setStoreTimestamp(System.currentTimeMillis());\n+\n+        StoreStatsService storeStatsService = this.defaultMessageStore.getStoreStatsService();\n+\n+        InetSocketAddress bornSocketAddress = (InetSocketAddress) messageExtBatch.getBornHost();\n+        if (bornSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setBornHostV6Flag();\n+        }\n+\n+        InetSocketAddress storeSocketAddress = (InetSocketAddress) messageExtBatch.getStoreHost();\n+        if (storeSocketAddress.getAddress() instanceof Inet6Address) {\n+            messageExtBatch.setStoreHostAddressV6Flag();\n+        }\n+\n+        // Back to Results\n+        AppendMessageResult appendResult;\n+        BatchAppendFuture<AppendEntryResponse> dledgerFuture;\n+        EncodeResult encodeResult;\n+\n+        putMessageLock.lock(); //spin or ReentrantLock ,depending on store config\n+        msgIdBuilder.setLength(0);\n+        long elapsedTimeInLock;\n+        long queueOffset;\n+        long msgNum = 0;\n+        try {\n+            beginTimeInDledgerLock = this.defaultMessageStore.getSystemClock().now();\n+            encodeResult = this.messageSerializer.serialize(messageExtBatch);\n+            queueOffset = topicQueueTable.get(encodeResult.queueOffsetKey);\n+            if (encodeResult.status != AppendMessageStatus.PUT_OK) {\n+                return new PutMessageResult(PutMessageStatus.MESSAGE_ILLEGAL, new AppendMessageResult(encodeResult\n+                        .status));\n+            }\n+            BatchAppendEntryRequest request = new BatchAppendEntryRequest();\n+            request.setGroup(dLedgerConfig.getGroup());\n+            request.setRemoteId(dLedgerServer.getMemberState().getSelfId());\n+            request.setBatchMsgs(encodeResult.batchData);\n+            dledgerFuture = (BatchAppendFuture<AppendEntryResponse>) dLedgerServer.handleAppend(request);\n+            if (dledgerFuture.getPos() == -1) {\n+                log.warn(\"HandleAppend return false due to error code {}\", dledgerFuture.get().getCode());\n+                return new PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, new AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));\n+            }\n+            long wroteOffset = 0;\n+\n+            int msgIdLength = (messageExtBatch.getSysFlag() & MessageSysFlag.STOREHOSTADDRESS_V6_FLAG) == 0 ? 4 + 4 + 8 : 16 + 4 + 8;\n+            ByteBuffer buffer = ByteBuffer.allocate(msgIdLength);\n+\n+            boolean isFirstOffset = true;\n+            for (long pos : dledgerFuture.getPositions()) {\n+                if (isFirstOffset) {\n+                    wroteOffset = pos + DLedgerEntry.BODY_OFFSET;\n+                    isFirstOffset = false;\n+                }\n+                String msgId = MessageDecoder.createMessageId(buffer, messageExtBatch.getStoreHostBytes(), wroteOffset);\n+                if (msgIdBuilder.length() > 0) {\n+                    msgIdBuilder.append(',').append(msgId);\n+                } else {\n+                    msgIdBuilder.append(msgId);\n+                }\n+                msgNum++;\n+            }", "originalCommit": "6e7488353dc2c35b6fba097da1b5c28ced7d2a61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjE5NDQzMA==", "url": "https://github.com/apache/rocketmq/pull/2406#discussion_r522194430", "bodyText": "fixed", "author": "TerrellChen", "createdAt": "2020-11-12T15:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk0NTk5MQ=="}], "type": "inlineReview"}, {"oid": "1adcb5c00e9c759ce029438ac183f19e5b241854", "url": "https://github.com/apache/rocketmq/commit/1adcb5c00e9c759ce029438ac183f19e5b241854", "message": "Merge branch 'develop' of github.com:apache/rocketmq into issue_690", "committedDate": "2020-11-12T14:35:14Z", "type": "commit"}, {"oid": "37798914b2ca712844e49f3986626dcffbfb89b5", "url": "https://github.com/apache/rocketmq/commit/37798914b2ca712844e49f3986626dcffbfb89b5", "message": "fix wrong wroteOffset of AppendMessageResult", "committedDate": "2020-11-12T15:26:47Z", "type": "commit"}, {"oid": "4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661", "url": "https://github.com/apache/rocketmq/commit/4dbf7d6c9f8a05763d5202f8151b5ffa5bb32661", "message": "move serialization out of lock in async method", "committedDate": "2020-11-12T15:29:36Z", "type": "commit"}]}