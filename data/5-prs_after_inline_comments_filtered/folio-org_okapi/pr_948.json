{"pr_number": 948, "pr_title": "OKAPI-866 OOM bulk upload", "pr_createdAt": "2020-06-30T12:13:23Z", "pr_url": "https://github.com/folio-org/okapi/pull/948", "timeline": [{"oid": "44df7ba64df1759f5e791039b00397d7f621a316", "url": "https://github.com/folio-org/okapi/commit/44df7ba64df1759f5e791039b00397d7f621a316", "message": "Tests for OKAPI-866", "committedDate": "2020-06-29T16:00:05Z", "type": "commit"}, {"oid": "e73c46e2781ffcbd6decf21cf042f0a8235f3c2f", "url": "https://github.com/folio-org/okapi/commit/e73c46e2781ffcbd6decf21cf042f0a8235f3c2f", "message": "Use HttpClientRequest.write with handler\n\nThat is much much faster and uses no memory.", "committedDate": "2020-06-29T19:00:20Z", "type": "commit"}, {"oid": "10ea0614ea383d38d6b65ff3d674cda467072549", "url": "https://github.com/folio-org/okapi/commit/10ea0614ea383d38d6b65ff3d674cda467072549", "message": "Pause stream until write is complete", "committedDate": "2020-06-30T12:02:01Z", "type": "commit"}, {"oid": "f709f9cabd0a146cbc6aab102bf2f30b925eba17", "url": "https://github.com/folio-org/okapi/commit/f709f9cabd0a146cbc6aab102bf2f30b925eba17", "message": "Ease a bit on testing", "committedDate": "2020-06-30T12:09:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMjcyNA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447732724", "bodyText": "If r can handle less data per second than ctx.response() the data in r's queue will grow until out of memory.", "author": "julianladisch", "createdAt": "2020-06-30T14:34:59Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "originalCommit": "f709f9cabd0a146cbc6aab102bf2f30b925eba17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzY0OQ==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783649", "bodyText": "More theoretical than practical. But I'll change and resume when all writes are done.", "author": "adamdickmeiss", "createdAt": "2020-06-30T15:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczMjcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDE1MA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447734150", "bodyText": "If r can handle less data per second than clientRequest the data in r's queue will grow until out of memory.", "author": "julianladisch", "createdAt": "2020-06-30T14:36:51Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -798,7 +799,8 @@ private void proxyRequestResponse(Iterator<ModuleInstance> it,\n       stream.handler(data -> {\n         pc.trace(\"proxyRequestResponse request chunk '\"\n             + data.toString() + \"'\");\n-        clientRequest.write(data);\n+        stream.pause();\n+        clientRequest.write(data, comp -> stream.resume());\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);", "originalCommit": "f709f9cabd0a146cbc6aab102bf2f30b925eba17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzU0MA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783540", "bodyText": "More theoretical than practical. But I'll change and resume when all writes are done.", "author": "adamdickmeiss", "createdAt": "2020-06-30T15:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDc2NQ==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447734765", "bodyText": "res should be renamed to stream or readStream", "author": "julianladisch", "createdAt": "2020-06-30T14:37:42Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();", "originalCommit": "f709f9cabd0a146cbc6aab102bf2f30b925eba17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4Mzg0MA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447783840", "bodyText": "Shouldn't be a problem.", "author": "adamdickmeiss", "createdAt": "2020-06-30T15:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzczNDc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447818803", "bodyText": "write(Buffer, Handler) does NOT wait if the queue is full. It calls the Handler after appending Buffer to the queue regardless of the queue status.\nThe documenation\n\nhttps://vertx.io/docs/apidocs/io/vertx/core/streams/WriteStream.html\nhttps://vertx.io/docs/vertx-core/java/#streams\n\nexplains to call writeQueueFull() to get a signal about a full queue.\nYou probably need to implement\n\nhttps://vertx.io/docs/apidocs/io/vertx/core/streams/Pump.html\nhttps://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/streams/impl/PipeImpl.java\n\nwith one ReadStream and multiple WriteStreams.", "author": "julianladisch", "createdAt": "2020-06-30T16:29:30Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -592,7 +592,8 @@ private void proxyResponseImmediate(ProxyContext pc, ReadStream<Buffer> res,\n         for (HttpClientRequest r : clientRequestList) {\n           r.write(data);\n         }\n-        ctx.response().write(data);\n+        res.pause();\n+        ctx.response().write(data, end -> res.resume());", "originalCommit": "f709f9cabd0a146cbc6aab102bf2f30b925eba17", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzOTY3MA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447839670", "bodyText": "write(Buffer data, Handler<AsyncResult> handler)\nSame as write(Buffer) but with an handler called when the operation completes\nand and FWIW, Hongwei sees no memory issues.", "author": "adamdickmeiss", "createdAt": "2020-06-30T17:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0ODE4OA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447848188", "bodyText": "I can try to make a solution that does not use write with handler, but with writeQueueFull and drainHandler.", "author": "adamdickmeiss", "createdAt": "2020-06-30T17:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDExOA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447870118", "bodyText": "OK.. Now in place.. More complicated than before.. And as far as I can see results are similar, memory wise. Hongwei, you'll have to test this one.", "author": "adamdickmeiss", "createdAt": "2020-06-30T17:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5NDk4NA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447894984", "bodyText": "Tested. Still works.", "author": "hjiebsco", "createdAt": "2020-06-30T18:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzODkzMg==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r447938932", "bodyText": "package tmp;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.junit5.VertxExtension;\nimport io.vertx.junit5.VertxTestContext;\n\n@ExtendWith(VertxExtension.class)\nclass StreamTest {\n  String chunk = StringUtils.repeat(\"chunk \", 20000);\n\n  void writeChunk(int i, HttpClientRequest request) {\n    request.write(chunk, res -> writeChunk(i+1, request));\n    System.out.println(i + \" \" + request.writeQueueFull() + \" \");\n  }\n\n  @Test()\n  void test(Vertx vertx, VertxTestContext vtc) {\n    vertx\n    .createHttpServer()\n    .requestHandler(req -> {\n      req.pause();\n      // don't fetch the data\n    })\n    .listen(8888, server -> {\n      HttpClientRequest request = vertx\n      .createHttpClient()\n      .post(8888, \"localhost\", \"/\")\n      .setChunked(true)\n      .handler(handler -> {});\n      writeChunk(1, request);\n    });\n  }\n}\npackage tmp;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport io.vertx.core.Vertx;\nimport io.vertx.core.http.HttpClientRequest;\nimport io.vertx.junit5.VertxExtension;\nimport io.vertx.junit5.VertxTestContext;\n\n@ExtendWith(VertxExtension.class)\nclass StreamTest {\n  String chunk = StringUtils.repeat(\"chunk \", 20000);\n\n  void writeChunk(int i, HttpClientRequest request) {\n    request.write(chunk, res -> writeChunk(i+1, request));\n    System.out.println(i + \" \" + request.writeQueueFull() + \" \");\n  }\n\n  @Test()\n  void test(Vertx vertx, VertxTestContext vtc) {\n    vertx\n    .createHttpServer()\n    .requestHandler(req -> {\n      req.pause();\n      // don't fetch the data\n    })\n    .listen(8888, server -> {\n      HttpClientRequest request = vertx\n      .createHttpClient()\n      .post(8888, \"localhost\", \"/\")\n      .setChunked(true)\n      .handler(handler -> {});\n      writeChunk(1, request);\n    });\n  }\n}\n\nOutput:\n1 false \n2 true \n3 true \n4 true \n...", "author": "julianladisch", "createdAt": "2020-06-30T19:49:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxODgwMw=="}], "type": "inlineReview"}, {"oid": "e764987fd8ea29d190b40de2f29f8cee7e54182e", "url": "https://github.com/folio-org/okapi/commit/e764987fd8ea29d190b40de2f29f8cee7e54182e", "message": "Wait on logging HTTP clients too to be ready", "committedDate": "2020-06-30T16:52:32Z", "type": "commit"}, {"oid": "70876fcafb2470ed7bed26d93fae9236caba22b8", "url": "https://github.com/folio-org/okapi/commit/70876fcafb2470ed7bed26d93fae9236caba22b8", "message": "Merge remote-tracking branch 'origin/master' into OKAPI-866-oom-bulk-upload", "committedDate": "2020-06-30T16:52:50Z", "type": "commit"}, {"oid": "40bbaa5c3d54df15340e4a25b198c1d308edcbdb", "url": "https://github.com/folio-org/okapi/commit/40bbaa5c3d54df15340e4a25b198c1d308edcbdb", "message": "Solution with writeQueueFull and drainHandler", "committedDate": "2020-06-30T17:46:00Z", "type": "commit"}, {"oid": "a72c80cda6d9115c5db34687255f3ad2b5e824b3", "url": "https://github.com/folio-org/okapi/commit/a72c80cda6d9115c5db34687255f3ad2b5e824b3", "message": "Bail out", "committedDate": "2020-06-30T18:22:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMDc1Nw==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448020757", "bodyText": "List<HttpClientRequest> can be changed to List<? extends WriteStream<Buffer>>", "author": "julianladisch", "createdAt": "2020-06-30T22:46:42Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,57 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {", "originalCommit": "a72c80cda6d9115c5db34687255f3ad2b5e824b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTQyNA==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448021424", "bodyText": "Instead of handling mainWriteStream and logWriteStreams separately they should be combined into one array or list.", "author": "julianladisch", "createdAt": "2020-06-30T22:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzY3OQ==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448023679", "bodyText": "This won't work in all cases.\nA WriteStream will always call the drainHandler, even if ProxyService missed the time period where the WriteStream queue was full.\nHow about a pauseAndResume method:\nfor each WriteStream\n  if not full\n    set drainHandler to null\n  else\n    set drainHandler to pauseAndResume\n    pause readStream\n    exit this method.\nresume readStream\n\nCall this method after data has been written to the WriteStreams.", "author": "julianladisch", "createdAt": "2020-06-30T22:55:15Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,57 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {\n+    readStream.handler(data -> {\n+      AtomicInteger pend = new AtomicInteger();\n+      // two passes.. to avoid drainHandler being fired off too early.\n+      // first pass: see if any of writing streams are full?\n+      mainWriteStream.write(data);\n+      if (mainWriteStream.writeQueueFull()) {\n+        pend.incrementAndGet();\n+      }\n+      for (WriteStream<Buffer> w : logWriteStreams) {\n+        w.write(data);\n+        if (w.writeQueueFull()) {\n+          pend.incrementAndGet();\n+        }\n+      }\n+      if (pend.get() == 0) {\n+        return;\n+      }\n+      // second pass: at least one was full. pause and set up drainHandlers for full ones.\n+      readStream.pause();\n+      if (mainWriteStream.writeQueueFull()) {\n+        mainWriteStream.drainHandler(x -> {\n+          if (pend.decrementAndGet() == 0) {", "originalCommit": "a72c80cda6d9115c5db34687255f3ad2b5e824b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08e0b602eae0d6f827bddf0ff201d735c4096bf1", "url": "https://github.com/folio-org/okapi/commit/08e0b602eae0d6f827bddf0ff201d735c4096bf1", "message": "Make simpler utility pumpOneToMany", "committedDate": "2020-07-01T12:42:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4MTQxNw==", "url": "https://github.com/folio-org/okapi/pull/948#discussion_r448381417", "bodyText": "Using an AtomicInteger won't work in all cases:\n\nThe drainHandler may be called asynchronously at a later time. It may happen that the ProxyService missed the time period where the WriteStream queue was full and only sees the drainHandler call.\nA WriteStream implementation may have a high watermark for writeQueueFull() and a low watermark for calling drainHandler. Example: https://github.com/eclipse-vertx/vert.x/blob/3.9.1/src/main/java/io/vertx/core/file/impl/AsyncFileImpl.java#L70-L71 where high watermark is 128 * 1024 and low watermark is half of this = 64 * 1024.\n\nThis algorithm for a pauseAndResume method avoids any counting and only uses the current full status:\nfor each WriteStream\n  if not full\n    set drainHandler to null\n  else\n    set drainHandler to pauseAndResume\n    pause readStream\n    exit this method.\n// this point is only reached if all WriteStreams are not full\nresume readStream\n\nCall this method after data has been written to the WriteStreams.", "author": "julianladisch", "createdAt": "2020-07-01T13:57:02Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -754,6 +741,55 @@ private void fixupXOkapiToken(ModuleDescriptor md, MultiMap reqHeaders, MultiMap\n     }\n   }\n \n+  private static void streamHandle(ProxyContext pc, ReadStream<Buffer> readStream,\n+                                   WriteStream<Buffer> mainWriteStream,\n+                                   List<HttpClientRequest> logWriteStreams) {\n+    List<WriteStream<Buffer>> writeStreams = new LinkedList<>();\n+    writeStreams.add(mainWriteStream);\n+    for (WriteStream<Buffer> w : logWriteStreams) {\n+      writeStreams.add(w);\n+    }\n+    pumpOneToMany(readStream, writeStreams);\n+    readStream.exceptionHandler(e\n+        -> pc.warn(\"streamHandle: content exception \", e));\n+    readStream.resume();\n+  }\n+\n+  private static void pumpOneToMany(ReadStream<Buffer> readStream,\n+                                    List<WriteStream<Buffer>> writeStreams) {\n+\n+    readStream.handler(data -> {\n+      AtomicInteger pend = new AtomicInteger();", "originalCommit": "08e0b602eae0d6f827bddf0ff201d735c4096bf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8b329464507cc7c7c84d643d46c6cbe5b07d2d4", "url": "https://github.com/folio-org/okapi/commit/f8b329464507cc7c7c84d643d46c6cbe5b07d2d4", "message": "pumpOneToMany unit tests and pauseAndResume method", "committedDate": "2020-07-01T15:58:52Z", "type": "commit"}, {"oid": "9b80fd496b6ec53edbdd3974838e5c1932bda677", "url": "https://github.com/folio-org/okapi/commit/9b80fd496b6ec53edbdd3974838e5c1932bda677", "message": "Test using Okapi with two write streams and pause\n\nNew test testUpload makes use of two modules where one is regular\n(request-response) and other is request-log. The /echo service makes\ndelay which should provoke writeQueueFull returning true.", "committedDate": "2020-07-01T19:07:51Z", "type": "commit"}]}