{"pr_number": 981, "pr_title": "OKAPI-890 - Formalize Token Cache PoC", "pr_createdAt": "2020-09-29T16:15:25Z", "pr_url": "https://github.com/folio-org/okapi/pull/981", "timeline": [{"oid": "66c89b7db8b31434ab43427a1c5786c6578bb66e", "url": "https://github.com/folio-org/okapi/commit/66c89b7db8b31434ab43427a1c5786c6578bb66e", "message": "port to Okapi4 and add metrics", "committedDate": "2020-09-14T15:37:25Z", "type": "commit"}, {"oid": "9ba1f75ef3a1991331a2f5e97a7fe2b960a89fd2", "url": "https://github.com/folio-org/okapi/commit/9ba1f75ef3a1991331a2f5e97a7fe2b960a89fd2", "message": "Merge branch 'master' into tokenCache", "committedDate": "2020-09-14T15:58:43Z", "type": "commit"}, {"oid": "4c1620ff4bb845914e2af0d4df8b8f62490da35e", "url": "https://github.com/folio-org/okapi/commit/4c1620ff4bb845914e2af0d4df8b8f62490da35e", "message": "sonar", "committedDate": "2020-09-14T18:19:14Z", "type": "commit"}, {"oid": "162ae801921e2328b938264cd85ed5723835d979", "url": "https://github.com/folio-org/okapi/commit/162ae801921e2328b938264cd85ed5723835d979", "message": "Merge branch 'tokenCache' of github.com:folio-org/okapi into tokenCache", "committedDate": "2020-09-14T18:19:33Z", "type": "commit"}, {"oid": "4f3e3e222bfa8d6d2687d4cf08fc333e8bc15e35", "url": "https://github.com/folio-org/okapi/commit/4f3e3e222bfa8d6d2687d4cf08fc333e8bc15e35", "message": "fix regex", "committedDate": "2020-09-14T19:40:15Z", "type": "commit"}, {"oid": "77e98f0f58a1f844b66e2d6c03b3a9fd1465fc7a", "url": "https://github.com/folio-org/okapi/commit/77e98f0f58a1f844b66e2d6c03b3a9fd1465fc7a", "message": "sonar - again", "committedDate": "2020-09-14T20:11:51Z", "type": "commit"}, {"oid": "b17184d07cb5d18d4213e2d8a4eb1b7e35b1b7bd", "url": "https://github.com/folio-org/okapi/commit/b17184d07cb5d18d4213e2d8a4eb1b7e35b1b7bd", "message": "fixing line length", "committedDate": "2020-09-14T20:15:59Z", "type": "commit"}, {"oid": "a9dfebe1389526f06f09d19b79a76c523f5c9d42", "url": "https://github.com/folio-org/okapi/commit/a9dfebe1389526f06f09d19b79a76c523f5c9d42", "message": "addres NPE on missing userId", "committedDate": "2020-09-23T19:21:49Z", "type": "commit"}, {"oid": "b48bbef331bcc21f3bf51a3f354e7ed1dea68434", "url": "https://github.com/folio-org/okapi/commit/b48bbef331bcc21f3bf51a3f354e7ed1dea68434", "message": "Merge branch 'master' into tokenCache", "committedDate": "2020-09-23T19:26:45Z", "type": "commit"}, {"oid": "4ae7a4bf5e5b7f2fc79ee587ef7fa6c430c396b5", "url": "https://github.com/folio-org/okapi/commit/4ae7a4bf5e5b7f2fc79ee587ef7fa6c430c396b5", "message": "OKAPI-890: formalize tokenCache PoC", "committedDate": "2020-09-29T16:11:52Z", "type": "commit"}, {"oid": "a45ee7efbdd9b9d826a8d86164fb2b02ff09f91c", "url": "https://github.com/folio-org/okapi/commit/a45ee7efbdd9b9d826a8d86164fb2b02ff09f91c", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-09-29T16:23:38Z", "type": "commit"}, {"oid": "40bafe2c6bd0f03324b2b79af7e5bd1b7a5c9382", "url": "https://github.com/folio-org/okapi/commit/40bafe2c6bd0f03324b2b79af7e5bd1b7a5c9382", "message": "fixing equals and hashcode", "committedDate": "2020-09-29T17:10:01Z", "type": "commit"}, {"oid": "76368d0c418f925f1a6bf204318965cdf5023562", "url": "https://github.com/folio-org/okapi/commit/76368d0c418f925f1a6bf204318965cdf5023562", "message": "allow token cache args to be specified as system properties", "committedDate": "2020-09-29T21:00:09Z", "type": "commit"}, {"oid": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c", "url": "https://github.com/folio-org/okapi/commit/48e4bb494f9026e7d0dcd994ab85d7be2f5e392c", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-09-30T21:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTE1OQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498175159", "bodyText": "Not in use anywhere, so I don't think it's necessary to define it.", "author": "adamdickmeiss", "createdAt": "2020-10-01T11:33:39Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Convenience constructor using the default TTL and max size.\n+   */\n+  public TokenCache() {\n+    this(DEFAULT_TTL, DEFAULT_MAX_SIZE);\n+  }\n+", "originalCommit": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTM0MQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498175341", "bodyText": "That's going to be a lot of logging by default.. with info log-level I mean.", "author": "adamdickmeiss", "createdAt": "2020-10-01T11:34:07Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Convenience constructor using the default TTL and max size.\n+   */\n+  public TokenCache() {\n+    this(DEFAULT_TTL, DEFAULT_MAX_SIZE);\n+  }\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.info(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.info(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.info(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.info(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+", "originalCommit": "48e4bb494f9026e7d0dcd994ab85d7be2f5e392c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODIxNzQ2Mw==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498217463", "bodyText": "OK I'll make it debug", "author": "craigmcnally", "createdAt": "2020-10-01T12:49:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE3NTM0MQ=="}], "type": "inlineReview"}, {"oid": "4fc9613da775d173e0541a0f761f8f5e72dd5c7b", "url": "https://github.com/folio-org/okapi/commit/4fc9613da775d173e0541a0f761f8f5e72dd5c7b", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-01T12:50:27Z", "type": "commit"}, {"oid": "516eb2b77f861512714a8c4e8d41310bf21247b8", "url": "https://github.com/folio-org/okapi/commit/516eb2b77f861512714a8c4e8d41310bf21247b8", "message": "log cache messages at debug level", "committedDate": "2020-10-01T12:59:31Z", "type": "commit"}, {"oid": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "url": "https://github.com/folio-org/okapi/commit/244ed3841aa28b9b36f9860a0febe208cd9ebca3", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-01T14:57:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498944825", "bodyText": "Since userId is part of the key, is there a reason to store it as part of the CacheEntry as well?", "author": "hjiebsco", "createdAt": "2020-10-02T17:08:37Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1MTA2Mg==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r498951062", "bodyText": "yeah I guess not.  Adam and Julian have both asked questions about the cache keys as well, I guess this needs more thought", "author": "craigmcnally", "createdAt": "2020-10-02T17:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyOTE2MA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499529160", "bodyText": "I think getting rid of user will be best. That means whatever content mod-authtoken puts there in the future is \"safe\" (eg group or other property that identifies what the session/token is).", "author": "adamdickmeiss", "createdAt": "2020-10-05T11:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTYzMw==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165633", "bodyText": "Removed userId from the cache key", "author": "craigmcnally", "createdAt": "2020-10-09T03:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk0NDgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTA5Mw==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499579093", "bodyText": "Can you use consistent case of id, either always upper or always lower in method, parameter and variable?", "author": "julianladisch", "createdAt": "2020-10-05T12:59:10Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2OTM0NA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499769344", "bodyText": "Good catch - typo", "author": "craigmcnally", "createdAt": "2020-10-05T17:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU3OTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MDMzNQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499580335", "bodyText": "The lower x looks odd but it is required by Google Code Style.\nCan we remove \"xOkapi\" from the name?", "author": "julianladisch", "createdAt": "2020-10-05T13:01:10Z", "path": "okapi-core/src/main/java/org/folio/okapi/bean/ModuleInstance.java", "diffHunk": "@@ -86,4 +88,20 @@ public ModuleInstance withRetry() {\n     this.withRetry = true;\n     return this;\n   }\n+\n+  public String getxOkapiUserId() {\n+    return xokapiUserid;\n+  }\n+\n+  public void setxOkapiUserId(String xokapiUserid) {\n+    this.xokapiUserid = xokapiUserid;\n+  }\n+\n+  public String getxOkapiPermissions() {\n+    return xokapiPermissions;\n+  }\n+\n+  public void setxOkapiPermissions(String xokapiPermissions) {\n+    this.xokapiPermissions = xokapiPermissions;\n+  }", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQ4NQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165485", "bodyText": "renamed them.", "author": "craigmcnally", "createdAt": "2020-10-09T03:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MDMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MjAwOQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499582009", "bodyText": "Can we be sure that there is no old userId and permission in mi? Or should we set them to null?", "author": "julianladisch", "createdAt": "2020-10-05T13:03:52Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;\n+    String pathPattern = re.getPathPattern();\n+\n+    CacheEntry cached = tokenCache.get(pc.getTenant(), req.method().name(),\n+        pathPattern == null ? req.path() : pathPattern, req.getHeader(XOkapiHeaders.USER_ID),\n+        req.headers().get(XOkapiHeaders.TOKEN));\n+\n+    if (cached != null) {\n+      mi.setAuthToken(cached.token);\n+      mi.setxOkapiUserId(cached.xokapiUserid);\n+      mi.setxOkapiPermissions(cached.xokapiPermissions);\n+\n+      skipAuth = true;\n+    } else {\n+      mi.setAuthToken(req.headers().get(XOkapiHeaders.TOKEN));", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQzOA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165438", "bodyText": "done", "author": "craigmcnally", "createdAt": "2020-10-09T03:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzkxOQ==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499583919", "bodyText": "This variable is not needed. We can directly return true or false.\nThere should be javadoc explaining the return value.", "author": "julianladisch", "createdAt": "2020-10-05T13:07:01Z", "path": "okapi-core/src/main/java/org/folio/okapi/managers/ProxyService.java", "diffHunk": "@@ -174,6 +187,27 @@ private boolean resolveRedirects(ProxyContext pc,\n     return true;\n   }\n \n+  private boolean checkTokenCache(ProxyContext pc, HttpServerRequest req, RoutingEntry re,\n+      ModuleInstance mi) {\n+    boolean skipAuth = false;", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTQwNg==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165406", "bodyText": "done", "author": "craigmcnally", "createdAt": "2020-10-09T03:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU4MzkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499604514", "bodyText": "Why do we the replaceAll?\nCan the replaceAll been applied to only those variables that needs it?", "author": "julianladisch", "createdAt": "2020-10-05T13:37:34Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);\n+  }\n+\n+  /**\n+   * Get a cached entry.\n+   * \n+   * @param tenant tenant id\n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param token X-Okapi-Token header\n+   * @param userId X-Okapi-User-Id header\n+   * @return cache entry or null\n+   */\n+  public CacheEntry get(String tenant, String method, String path, String userId, String token) {\n+    String key = genKey(method, path, userId, token);\n+    CacheEntry ret = cache.get(key);\n+    if (ret == null) {\n+      MetricsHelper.recordTokenCacheMiss(tenant, method, path, userId);\n+      logger.debug(\"Cache Miss: {}\", key);\n+      return ret;\n+    } else if (ret.isExpired()) {\n+      MetricsHelper.recordTokenCacheExpired(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit (Expired): {}\", key);\n+      cache.remove(key);\n+      return null;\n+    } else {\n+      MetricsHelper.recordTokenCacheHit(tenant, method, path, userId);\n+      logger.debug(\"Cache Hit: {} -> {}\", key, ret.token);\n+      return ret;\n+    }\n+  }\n+\n+  private String genKey(String method, String path, String userId, String token) {\n+    return (userId + \"|\" + method + \"|\" + path + \"|\" + token).replaceAll(\"[\\n\\t\\r]\", \"\");", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0MDQwNA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r501740404", "bodyText": "I added this because sonarqube was complaining.  I suppose it could be applied to only the token (userId has been removed from the cache key in my latest changes)", "author": "craigmcnally", "createdAt": "2020-10-08T13:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTM0Mg==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165342", "bodyText": "now only call this on token", "author": "craigmcnally", "createdAt": "2020-10-09T03:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNDUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MDYxOA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499670618", "bodyText": "The test runs faster when using 50 ms for ttl and 10 ms for polling.\natMost should use ttl + 2*poll. Using ttl + poll may fail because of a race condition, we don't want spurious failures.", "author": "julianladisch", "createdAt": "2020-10-05T15:08:20Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/TokenCacheTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.folio.okapi.util;\n+\n+import org.junit.Test;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.Assert.*;\n+import java.util.concurrent.TimeUnit;\n+\n+public class TokenCacheTest {\n+  \n+  @Test\n+  public void testMaxSize() {\n+    TokenCache cache = TokenCache.builder()\n+        .withMaxSize(2)\n+        .build();\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(1, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"bar\", \"barTok\");\n+    assertEquals(\"barTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\").token);\n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(2, cache.size());\n+    \n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"baz\", \"bazTok\");\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+    assertEquals(2, cache.size());\n+    \n+    assertEquals(\"fooTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"foo\").token);\n+    assertEquals(null, cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"bar\")); //evicted.\n+    assertEquals(\"bazTok\", cache.get(\"tenant\", \"method\", \"path\", \"userId\", \"baz\").token);\n+  }\n+  \n+  @Test\n+  public void testTtl() {\n+    long ttl = 500l;\n+\n+    TokenCache cache = TokenCache.builder()\n+        .withTtl(ttl)\n+        .build();\n+\n+    cache.put(\"tenant\", \"method\", \"path\", \"userId\", \"xokapiPerms\", \"foo\", \"fooTok\");\n+\n+    await().with()\n+        .pollInterval(100, TimeUnit.MILLISECONDS)\n+        .atMost(ttl + 100, TimeUnit.MILLISECONDS)", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTIwNA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165204", "bodyText": "done", "author": "craigmcnally", "createdAt": "2020-10-09T03:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MDYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MjE0Nw==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499672147", "bodyText": "This can be reduced to 200L", "author": "julianladisch", "createdAt": "2020-10-05T15:10:26Z", "path": "okapi-core/src/test/java/org/folio/okapi/util/MetricsHelperTest.java", "diffHunk": "@@ -99,6 +101,51 @@ void testRecordHttpClientResponseTime() {\n     assertEquals(1, timer.count());\n   }\n \n+  @Test\n+  void testRecordTokenCacheEvent() {\n+    String userId = \"03975dd7-8004-48cf-bd21-4d7ff2e74ca2\";\n+    String anotherUserId = \"54412e3d-a024-4914-8d54-8b84e66513a6\";\n+\n+    long ttl = 2000L;", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NTE2Mg==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502165162", "bodyText": "done", "author": "craigmcnally", "createdAt": "2020-10-09T03:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY3MjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r499681026", "bodyText": "The cache will grow to its max size and will never shrink because an expired token is only evicted if there is a get request. If there is a get request for an expired token then mod-authtoken is called and a new cache entry is created.\nConsider to extend the put method to check the two oldest cache entries whether they are expired and to remove them.", "author": "julianladisch", "createdAt": "2020-10-05T15:22:50Z", "path": "okapi-core/src/main/java/org/folio/okapi/util/TokenCache.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.folio.okapi.util;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.logging.log4j.Logger;\n+import org.folio.okapi.common.OkapiLogger;\n+\n+public class TokenCache {\n+\n+  public static final long DEFAULT_TTL = 3 * 60 * 1000L;\n+  public static final int DEFAULT_MAX_SIZE = 10000;\n+\n+  private final Map<String, CacheEntry> cache;\n+  private final long ttl;\n+\n+  private static final Logger logger = OkapiLogger.get(TokenCache.class);\n+\n+  /**\n+   * Constructor using the provided TTL and maxSize.\n+   * \n+   * @param ttl cache entry time to live in milliseconds\n+   * @param maxSize the maximum number of entries that may be cached at once\n+   */\n+  private TokenCache(long ttl, int maxSize) {\n+    logger.info(\"Initializing token cache w/ ttl: {}, maxSize: {}\", ttl, maxSize);\n+    this.ttl = ttl;\n+\n+    this.cache = Collections.synchronizedMap(new LruCache<>(maxSize));\n+  }\n+\n+  /**\n+   * Cache an entry.\n+   * \n+   * @param method HTTP method\n+   * @param path path pattern\n+   * @param userId X-Okapi-User-Id header to cache\n+   * @param xokapiPerms X-Okapi-Permissions header to cache\n+   * @param keyToken the token to be used in the cache key, from the request which triggered the\n+   *        call to mod-authtoken\n+   * @param token access token to cache - from the mod-authtoken response\n+   */\n+  public void put(String tenant, String method, String path, String userId, String xokapiPerms,\n+      String keyToken, String token) {\n+    long now = System.currentTimeMillis();\n+    CacheEntry entry = new CacheEntry(token, userId, xokapiPerms, now + ttl);\n+    String key = genKey(method, path, userId, keyToken);\n+    MetricsHelper.recordTokenCacheCached(tenant, method, path, userId);\n+    logger.debug(\"Caching: {} -> {}\", key, token);\n+    cache.put(key, entry);", "originalCommit": "244ed3841aa28b9b36f9860a0febe208cd9ebca3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgwODM0MA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r501808340", "bodyText": "I'm not seeing any good way to get the two oldest cache entries w/o iterating the entire keySet...  Any ideas?", "author": "craigmcnally", "createdAt": "2020-10-08T15:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUzMTMxNA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502531314", "bodyText": "In LruCache replace K by String and V by CacheEntry. Then do this:\n@Override\npublic CacheEntry put(String key, CacheEntry value) {\n  CacheEntry old = super.put(key, value);\n\n  if (size() < 3) {\n    return old;\n  }\n\n  Iterator<Map.Entry<String, CacheEntry>> it = entrySet().iterator();\n  for (int i=0; i<2; i++) {\n    String k = it.next();\n    if (expired(k)) {\n      remove(k);\n    } else {\n      break;\n    }\n  }\n\n  return old;\n}", "author": "julianladisch", "createdAt": "2020-10-09T16:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU1NDg4NA==", "url": "https://github.com/folio-org/okapi/pull/981#discussion_r502554884", "bodyText": "I had to look at the javadocs again, but I now see that the iteration order is least-recently accessed to most-recently accessed, exactly what we want.  Thanks @julianladisch.", "author": "craigmcnally", "createdAt": "2020-10-09T16:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY4MTAyNg=="}], "type": "inlineReview"}, {"oid": "42616bfc5810c305f492adc1c15f52ac9837c7c3", "url": "https://github.com/folio-org/okapi/commit/42616bfc5810c305f492adc1c15f52ac9837c7c3", "message": "OKAPI-890 Add iat claim to token", "committedDate": "2020-10-09T02:56:18Z", "type": "commit"}, {"oid": "ea941baa73ccee20329f302c9a09afa92a44dbbf", "url": "https://github.com/folio-org/okapi/commit/ea941baa73ccee20329f302c9a09afa92a44dbbf", "message": "OKAPI-890 remove userId from cache key", "committedDate": "2020-10-09T02:57:41Z", "type": "commit"}, {"oid": "2a546c9f7f0c8b77e65f90a617dd58b5bdf0a804", "url": "https://github.com/folio-org/okapi/commit/2a546c9f7f0c8b77e65f90a617dd58b5bdf0a804", "message": "OKAPI-890 work skipAuth into existing loop", "committedDate": "2020-10-09T03:12:14Z", "type": "commit"}, {"oid": "9179bf50e6a9c1a724b8cb5c629bd77e142ff0f8", "url": "https://github.com/folio-org/okapi/commit/9179bf50e6a9c1a724b8cb5c629bd77e142ff0f8", "message": "OKAPI-890 rename members for readability", "committedDate": "2020-10-09T03:15:39Z", "type": "commit"}, {"oid": "3aa221bbc89262d224e8518ac0b6338991a30826", "url": "https://github.com/folio-org/okapi/commit/3aa221bbc89262d224e8518ac0b6338991a30826", "message": "OKAPI-890 minor tweaks to checkTokenCache method", "committedDate": "2020-10-09T03:24:28Z", "type": "commit"}, {"oid": "d5eeb07bde26ad7529b48e7f7bf46b5365696b7d", "url": "https://github.com/folio-org/okapi/commit/d5eeb07bde26ad7529b48e7f7bf46b5365696b7d", "message": "OKAPI-890 shorter ttls and pollInterval", "committedDate": "2020-10-09T03:29:15Z", "type": "commit"}, {"oid": "59b39eb8b0cbe978145b040bb6c3a2672268739f", "url": "https://github.com/folio-org/okapi/commit/59b39eb8b0cbe978145b040bb6c3a2672268739f", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-09T03:45:42Z", "type": "commit"}, {"oid": "89bd9d152a9b9f15bb6288808f494c4777942414", "url": "https://github.com/folio-org/okapi/commit/89bd9d152a9b9f15bb6288808f494c4777942414", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-09T04:21:13Z", "type": "commit"}, {"oid": "bd05c4195085aa0bd1f77f9a0fda0c6b4a3fe53e", "url": "https://github.com/folio-org/okapi/commit/bd05c4195085aa0bd1f77f9a0fda0c6b4a3fe53e", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-09T13:34:26Z", "type": "commit"}, {"oid": "112335a9400dd63bb3ba22d435e584abba2bcf1d", "url": "https://github.com/folio-org/okapi/commit/112335a9400dd63bb3ba22d435e584abba2bcf1d", "message": "Merge branch 'master' into OKAPI-890", "committedDate": "2020-10-09T16:31:48Z", "type": "commit"}, {"oid": "1484051b77065151f8ecf09f74706a9287c7f101", "url": "https://github.com/folio-org/okapi/commit/1484051b77065151f8ecf09f74706a9287c7f101", "message": "OKAPI-890 improved cache pruning", "committedDate": "2020-10-09T20:02:57Z", "type": "commit"}]}