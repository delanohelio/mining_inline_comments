{"pr_number": 3663, "pr_title": "Warnings about `@SuppressWarnings` on inappropriate methods", "pr_createdAt": "2020-09-14T04:10:10Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3663", "timeline": [{"oid": "af7a853f590d55913e921211dca9b08c2e1de631", "url": "https://github.com/typetools/checker-framework/commit/af7a853f590d55913e921211dca9b08c2e1de631", "message": "Warnings about @SuppressWarnings on inappropriate methods", "committedDate": "2020-09-14T00:00:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA==", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r488332704", "bodyText": "The following should work:\nTypeMirror receiverType = TreeUtils.elementFromDeclaration(node).getReceiverType();\n\nIf the method has no receiver, the type returned with have TypeKind.NONE.", "author": "smillst", "createdAt": "2020-09-15T01:45:59Z", "path": "framework/src/main/java/org/checkerframework/common/value/ValueVisitor.java", "diffHunk": "@@ -341,4 +347,71 @@ public boolean validateType(Tree tree, AnnotatedTypeMirror type) {\n \n         return true;\n     }\n+\n+    /**\n+     * Returns true if an expression of the given type can be a compile-time constant value.\n+     *\n+     * @param tm a type\n+     * @return true if an expression of the given type can be a compile-time constant value\n+     */\n+    private boolean canBeConstant(TypeMirror tm) {\n+        return TypesUtils.isPrimitive(tm)\n+                || TypesUtils.isBoxedPrimitive(tm)\n+                || TypesUtils.isString(tm)\n+                || (tm.getKind() == TypeKind.ARRAY\n+                        && canBeConstant(((ArrayType) tm).getComponentType()));\n+    }\n+\n+    @Override\n+    public Void visitMethod(MethodTree node, Void p) {\n+        super.visitMethod(node, p);\n+\n+        ExecutableElement method = TreeUtils.elementFromDeclaration(node);\n+        if (atypeFactory.getDeclAnnotation(method, StaticallyExecutable.class) != null) {\n+            // The method is annotated as @StaticallyExecutable.\n+            if (atypeFactory.getDeclAnnotation(method, Pure.class) == null) {\n+                checker.reportWarning(node, \"statically.executable.not.pure\");\n+            }\n+            TypeMirror returnType = method.getReturnType();\n+            if (returnType.getKind() != TypeKind.VOID && !canBeConstant(returnType)) {\n+                checker.reportError(\n+                        node, \"statically.executable.nonconstant.return.type\", returnType);\n+            }\n+\n+            // Ways to determin the receiver type.\n+            // 1. This definition of receiverType is null when receiver is implicit and method has\n+            //    class com.sun.tools.javac.code.Symbol$MethodSymbol.  WHY?\n+            //        TypeMirror receiverType = method.getReceiverType();\n+            // 2. Can't use the tree, because the receiver might not be explicit.\n+            // 3. Check whether method is static and use the declaring class.  Doesn't handle all\n+            //    cases, but handles the most common ones.\n+            TypeMirror receiverType = method.getReceiverType();", "originalCommit": "af7a853f590d55913e921211dca9b08c2e1de631", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM2NTAwNg==", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r488365006", "bodyText": "That doesn't seem to work for me.  It returns a null value.  Please see https://dev.azure.com/mernst22/checker-framework/_build/results?buildId=5190&view=results .", "author": "mernst", "createdAt": "2020-09-15T03:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDMxNw==", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r492164317", "bodyText": "That's strange.  The documentation of ExecutableType does not match its implementation.  You can still use that method, just check for null.", "author": "smillst", "createdAt": "2020-09-21T15:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDU5NA==", "url": "https://github.com/typetools/checker-framework/pull/3663#discussion_r492164594", "bodyText": "Or you can merge this pull request as is.", "author": "smillst", "createdAt": "2020-09-21T15:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMzMjcwNA=="}], "type": "inlineReview"}, {"oid": "0200c733299821e8e135f79e4791417e54c389c7", "url": "https://github.com/typetools/checker-framework/commit/0200c733299821e8e135f79e4791417e54c389c7", "message": "Tweak documentation", "committedDate": "2020-09-21T17:49:24Z", "type": "commit"}, {"oid": "cf9839676b8c3362eab7d758507fdd0dd885fe6b", "url": "https://github.com/typetools/checker-framework/commit/cf9839676b8c3362eab7d758507fdd0dd885fe6b", "message": "Merge ../checker-framework-branch-master into staticallyexecutable-warnings", "committedDate": "2020-09-21T17:52:03Z", "type": "commit"}]}