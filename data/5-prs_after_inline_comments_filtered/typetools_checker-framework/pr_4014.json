{"pr_number": 4014, "pr_title": "Infer method contracts", "pr_createdAt": "2020-12-13T18:55:37Z", "pr_url": "https://github.com/typetools/checker-framework/pull/4014", "timeline": [{"oid": "4e3b4885356fdcd4828344b18b4abf2dc5c750d4", "url": "https://github.com/typetools/checker-framework/commit/4e3b4885356fdcd4828344b18b4abf2dc5c750d4", "message": "Infer method preconditions and postconditions", "committedDate": "2020-12-11T01:43:49Z", "type": "commit"}, {"oid": "c0730cf9e57906adbb78550e860a21329412bc4e", "url": "https://github.com/typetools/checker-framework/commit/c0730cf9e57906adbb78550e860a21329412bc4e", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-11T01:46:46Z", "type": "commit"}, {"oid": "36c96f401d096cb0036f16110e5b0ef7e7137e8a", "url": "https://github.com/typetools/checker-framework/commit/36c96f401d096cb0036f16110e5b0ef7e7137e8a", "message": "Implement inference of `@MonotonicNonNull`", "committedDate": "2020-12-11T03:16:26Z", "type": "commit"}, {"oid": "581b8dc7e0fc54b9a7613ed6a56ba191377155ca", "url": "https://github.com/typetools/checker-framework/commit/581b8dc7e0fc54b9a7613ed6a56ba191377155ca", "message": "Pass binary names to Class.forName", "committedDate": "2020-12-11T04:42:15Z", "type": "commit"}, {"oid": "8a50ae2cfddb6d41bb52100fe85a4e21ec1cde62", "url": "https://github.com/typetools/checker-framework/commit/8a50ae2cfddb6d41bb52100fe85a4e21ec1cde62", "message": "Implement getAnnotationFieldType without depending on values", "committedDate": "2020-12-11T06:42:09Z", "type": "commit"}, {"oid": "1eeb3ca31c4e38b28a7c1d99ec8f4a29d4a1547d", "url": "https://github.com/typetools/checker-framework/commit/1eeb3ca31c4e38b28a7c1d99ec8f4a29d4a1547d", "message": "Add Javadoc", "committedDate": "2020-12-11T15:03:10Z", "type": "commit"}, {"oid": "ecdf3e459aeae4667bca87044085aff26d95f6e9", "url": "https://github.com/typetools/checker-framework/commit/ecdf3e459aeae4667bca87044085aff26d95f6e9", "message": "Don't return null", "committedDate": "2020-12-11T17:11:17Z", "type": "commit"}, {"oid": "1caed254d202dd5c33ee2479ac4b20d7f798cfa9", "url": "https://github.com/typetools/checker-framework/commit/1caed254d202dd5c33ee2479ac4b20d7f798cfa9", "message": "Merge ../checker-framework-fork-mernst-branch-typeMirrorToAnnotationFieldType into infer-contracts", "committedDate": "2020-12-11T17:20:05Z", "type": "commit"}, {"oid": "0dc1d52a3ddd46fa8ab3f04cb412b9b6b842dbbf", "url": "https://github.com/typetools/checker-framework/commit/0dc1d52a3ddd46fa8ab3f04cb412b9b6b842dbbf", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-11T18:26:24Z", "type": "commit"}, {"oid": "975f4662ef0100e93404affaf49472e6e1ae8e1a", "url": "https://github.com/typetools/checker-framework/commit/975f4662ef0100e93404affaf49472e6e1ae8e1a", "message": "annotationMirrorToAnnotation returns a non-null value", "committedDate": "2020-12-12T04:52:02Z", "type": "commit"}, {"oid": "be4fb3a7c112a3e05c23c01820fc68a1de1e42b7", "url": "https://github.com/typetools/checker-framework/commit/be4fb3a7c112a3e05c23c01820fc68a1de1e42b7", "message": "Add field WholeProgramInferenceScenesStorage.atypeFactory", "committedDate": "2020-12-12T04:57:44Z", "type": "commit"}, {"oid": "43875eb6399e7b0d0417da98d284c49052566510", "url": "https://github.com/typetools/checker-framework/commit/43875eb6399e7b0d0417da98d284c49052566510", "message": "Merge ../checker-framework-fork-mernst-branch-annotationMirrorToAnnotation-is-non-null into infer-contracts", "committedDate": "2020-12-12T05:02:24Z", "type": "commit"}, {"oid": "007f0b8bab5f95a2bca053cd61d9c0d59eac8f8e", "url": "https://github.com/typetools/checker-framework/commit/007f0b8bab5f95a2bca053cd61d9c0d59eac8f8e", "message": "Merge ../checker-framework-fork-mernst-branch-WholeProgramInferenceScenesStorage-atypeFactory into infer-contracts", "committedDate": "2020-12-12T05:08:59Z", "type": "commit"}, {"oid": "5201941af96f83ef2b3ba7a9d9b81a34f95d204f", "url": "https://github.com/typetools/checker-framework/commit/5201941af96f83ef2b3ba7a9d9b81a34f95d204f", "message": "Merge ../checker-framework-branch-master into annotationMirrorToAnnotation-is-non-null", "committedDate": "2020-12-12T06:13:40Z", "type": "commit"}, {"oid": "1559cc04db3c9d795a57008d69fbdfee07056e04", "url": "https://github.com/typetools/checker-framework/commit/1559cc04db3c9d795a57008d69fbdfee07056e04", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-12T06:14:22Z", "type": "commit"}, {"oid": "e787d66662ceda35f6e2516cdced179ffa7533cb", "url": "https://github.com/typetools/checker-framework/commit/e787d66662ceda35f6e2516cdced179ffa7533cb", "message": "Merge ../checker-framework-fork-mernst-branch-annotationMirrorToAnnotation-is-non-null into infer-contracts", "committedDate": "2020-12-12T06:15:06Z", "type": "commit"}, {"oid": "34324b09a1fc53dec286c692f896ad0f84ae98f9", "url": "https://github.com/typetools/checker-framework/commit/34324b09a1fc53dec286c692f896ad0f84ae98f9", "message": "Merge ../checker-framework-branch-master into WholeProgramInferenceScenesStorage-atypeFactory", "committedDate": "2020-12-12T14:36:03Z", "type": "commit"}, {"oid": "9a04a3ed175d86d035eb9b8e7f237783cf4d39d7", "url": "https://github.com/typetools/checker-framework/commit/9a04a3ed175d86d035eb9b8e7f237783cf4d39d7", "message": "Add prepareSceneForWriting hook", "committedDate": "2020-12-12T14:55:00Z", "type": "commit"}, {"oid": "49ce9520af5afff83c9c422f02d8d97293e1dd48", "url": "https://github.com/typetools/checker-framework/commit/49ce9520af5afff83c9c422f02d8d97293e1dd48", "message": "Updates", "committedDate": "2020-12-12T14:56:08Z", "type": "commit"}, {"oid": "440b630a92a70d0c7caab619231bc48090dc5a2c", "url": "https://github.com/typetools/checker-framework/commit/440b630a92a70d0c7caab619231bc48090dc5a2c", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts", "committedDate": "2020-12-12T14:57:05Z", "type": "commit"}, {"oid": "1c37997a7a3bd427dc68890f6caeac0c4cf63a77", "url": "https://github.com/typetools/checker-framework/commit/1c37997a7a3bd427dc68890f6caeac0c4cf63a77", "message": "Tweak documentation", "committedDate": "2020-12-12T15:11:51Z", "type": "commit"}, {"oid": "c3ea3902aec56ba71aa63386586fe763b0659a36", "url": "https://github.com/typetools/checker-framework/commit/c3ea3902aec56ba71aa63386586fe763b0659a36", "message": "Add Javadoc", "committedDate": "2020-12-12T15:56:23Z", "type": "commit"}, {"oid": "23c9da5265436d385f362c8d76c00861db850d52", "url": "https://github.com/typetools/checker-framework/commit/23c9da5265436d385f362c8d76c00861db850d52", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts", "committedDate": "2020-12-12T15:58:24Z", "type": "commit"}, {"oid": "539178173ad24845c61c8f0efe3c72c0976ee634", "url": "https://github.com/typetools/checker-framework/commit/539178173ad24845c61c8f0efe3c72c0976ee634", "message": "Fix format string", "committedDate": "2020-12-12T18:06:33Z", "type": "commit"}, {"oid": "c4f95cc59b1261f98246d46477514437055d3ccf", "url": "https://github.com/typetools/checker-framework/commit/c4f95cc59b1261f98246d46477514437055d3ccf", "message": "Merge ../checker-framework-branch-master into prepareSceneForWriting", "committedDate": "2020-12-13T06:34:53Z", "type": "commit"}, {"oid": "07c646b23ea3c772ac6f130d8604d69eb74b21a7", "url": "https://github.com/typetools/checker-framework/commit/07c646b23ea3c772ac6f130d8604d69eb74b21a7", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts", "committedDate": "2020-12-13T06:37:21Z", "type": "commit"}, {"oid": "6b5cbe9c0ae2c07c26a16e6963ab7b05cdf3bd76", "url": "https://github.com/typetools/checker-framework/commit/6b5cbe9c0ae2c07c26a16e6963ab7b05cdf3bd76", "message": "Add annotation", "committedDate": "2020-12-13T06:39:11Z", "type": "commit"}, {"oid": "aef8875790d08ff2166932673d4155fe1b80a2ef", "url": "https://github.com/typetools/checker-framework/commit/aef8875790d08ff2166932673d4155fe1b80a2ef", "message": "Undo some diagnostic output", "committedDate": "2020-12-13T15:58:32Z", "type": "commit"}, {"oid": "766b4b027163c061afb63c007845b0aca19c13ea", "url": "https://github.com/typetools/checker-framework/commit/766b4b027163c061afb63c007845b0aca19c13ea", "message": "Merge ../checker-framework-branch-master into WholeProgramInferenceScenesStorage-atypeFactory", "committedDate": "2020-12-13T17:14:03Z", "type": "commit"}, {"oid": "e82c2f591ac40d42030b789d2ff96056aa386a97", "url": "https://github.com/typetools/checker-framework/commit/e82c2f591ac40d42030b789d2ff96056aa386a97", "message": "Merge ../checker-framework-fork-mernst-branch-WholeProgramInferenceScenesStorage-atypeFactory into prepareSceneForWriting", "committedDate": "2020-12-13T17:14:39Z", "type": "commit"}, {"oid": "eb8c2a3ee73a54fdc120a20a067c5a591ef6c701", "url": "https://github.com/typetools/checker-framework/commit/eb8c2a3ee73a54fdc120a20a067c5a591ef6c701", "message": "Merge ../checker-framework-fork-mernst-branch-prepareSceneForWriting into infer-contracts", "committedDate": "2020-12-13T17:14:50Z", "type": "commit"}, {"oid": "2d7dc3c47c7e161601e43e2c983dc574d884ecec", "url": "https://github.com/typetools/checker-framework/commit/2d7dc3c47c7e161601e43e2c983dc574d884ecec", "message": "Expand changelog", "committedDate": "2020-12-13T18:47:40Z", "type": "commit"}, {"oid": "cd769c38bbb3bdf42bbf9b89eec5055c3bfc2241", "url": "https://github.com/typetools/checker-framework/commit/cd769c38bbb3bdf42bbf9b89eec5055c3bfc2241", "message": "Undo changes to reduce diffs", "committedDate": "2020-12-13T18:48:05Z", "type": "commit"}, {"oid": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "url": "https://github.com/typetools/checker-framework/commit/297f5c733e8b10e3143b0005e395abdd3f1a03a1", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-14T17:44:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyODEwOQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542828109", "bodyText": "You could pass the AnnotatedTypeFactory instead of the checker.", "author": "smillst", "createdAt": "2020-12-14T21:45:08Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/SceneToStubWriter.java", "diffHunk": "@@ -706,7 +723,11 @@ private static void printClass(\n             printWriter.println();\n             for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n                 printMethodDeclaration(\n-                        methodEntry.getValue(), innermostClassname, printWriter, indentLevel);\n+                        methodEntry.getValue(),\n+                        innermostClassname,\n+                        printWriter,\n+                        indentLevel,\n+                        checker.getTypeFactory());", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MDgwNQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543650805", "bodyText": "This does pass the AnnotatedTypeFactory.\nAre you suggesting that the containing method printClass could have its formal parameter list changed, so it takes an AnnotatedTypeFactory rather than a checker?  The changes in #4025 require the checker rather than the type factory.", "author": "mernst", "createdAt": "2020-12-15T20:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyODEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgyOTQ0OA==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542829448", "bodyText": "You added a formal parameter, so is this fixed?", "author": "smillst", "createdAt": "2020-12-14T21:46:28Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenesStorage.java", "diffHunk": "@@ -488,8 +494,10 @@ private void updateTypeElementFromATM(\n             typeToUpdate.tlAnnotationsHere.removeAll(annosToRemove);\n         }\n \n+        // PROBLEM:  This causes pre- and post-conditions to be ignored, though they might be\n+        // stronger.  Add a formal parameter.", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzNTY1MA==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r542835650", "bodyText": "Instead of passing in the checker, could you add the contracts to the AMethod before writing out the scene, reusing the code below?", "author": "smillst", "createdAt": "2020-12-14T21:52:18Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -144,9 +150,23 @@ public void writeToFile(\n             try {\n                 switch (outputFormat) {\n                     case STUB:\n-                        SceneToStubWriter.write(this, filepath);\n+                        SceneToStubWriter.write(this, filepath, checker);", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjEwNTYyMg==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546105622", "bodyText": "The checker is still needed for @AnnotatedFor annotations, but I can use the same code to compute the contracts in both places.", "author": "mernst", "createdAt": "2020-12-18T21:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjgzNTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NDc0OQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543584749", "bodyText": "This checks if the field is declared in the current class, but it doesn't make sure that the receiver of the field access is this.  (For static fields, you don't have to check.)", "author": "smillst", "createdAt": "2020-12-15T18:29:08Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU4NjE5NA==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543586194", "bodyText": "Instead of looping through all the field accesses in the store above, could you just add an else branch here that does the same thing as the code above?", "author": "smillst", "createdAt": "2020-12-15T18:31:20Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/WholeProgramInferenceScenes.java", "diffHunk": "@@ -192,6 +210,112 @@ private void updateInferredExecutableParameterTypes(\n         }\n     }\n \n+    @Override\n+    public void updateContracts(\n+            Analysis.BeforeOrAfter preOrPost,\n+            ExecutableElement methodElt,\n+            CFAbstractStore<?, ?> store) {\n+\n+        if (store == null) {\n+            throw new BugInCF(\n+                    \"updateContracts(%s, %s, null) for %s\",\n+                    preOrPost, methodElt, atypeFactory.getClass().getSimpleName());\n+        }\n+\n+        String className = getEnclosingClassName(methodElt);\n+        String jaifPath = storage.getJaifPath(className);\n+        AClass clazz =\n+                storage.getAClass(className, jaifPath, ((MethodSymbol) methodElt).enclClass());\n+        AMethod amethod = clazz.methods.getVivify(JVMNames.getJVMMethodSignature(methodElt));\n+\n+        amethod.setFieldsFromMethodElement(methodElt);\n+\n+        // TODO: Probably move some part of this into the AnnotatedTypeFactory.\n+\n+        // TODO: Handle more than just fields of \"this\".\n+\n+        // Process the store's fields.\n+        for (Map.Entry<FieldAccess, ? extends CFAbstractValue<?>> entry :\n+                store.getFieldValues().entrySet()) {\n+            FieldAccess fa = entry.getKey();\n+            CFAbstractValue<?> v = entry.getValue();\n+\n+            VariableElement fieldElement = fa.getField();\n+            AnnotatedTypeMirror fieldType = atypeFactory.getAnnotatedType(fieldElement);\n+\n+            if (!ElementUtils.inSameClass(methodElt, fieldElement)) {\n+                continue;\n+            }\n+\n+            AnnotatedTypeMirror atm = convertCFAbstractValueToAnnotatedTypeMirror(v, fieldType);\n+            adjustForUpdateNonField(atm);\n+\n+            AField afield = vivifyAndAddTypeMirrorToContract(amethod, preOrPost, fieldElement);\n+\n+            updateAnnotationSetInScene(\n+                    afield.type, TypeUseLocation.FIELD, atm, fieldType, jaifPath, false);\n+        }\n+\n+        // Process fields that are not in the store.\n+        TypeElement containingClass = (TypeElement) methodElt.getEnclosingElement();\n+        ThisReference thisReference = new ThisReference(containingClass.asType());\n+        ClassName classNameReceiver = new ClassName(containingClass.asType());\n+        for (VariableElement fieldElement :\n+                ElementFilter.fieldsIn(containingClass.getEnclosedElements())) {\n+            FieldAccess fa =\n+                    new FieldAccess(\n+                            (ElementUtils.isStatic(fieldElement)\n+                                    ? classNameReceiver\n+                                    : thisReference),\n+                            fieldElement.asType(),\n+                            fieldElement);\n+            if (store.getFieldValue(fa) == null) {", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDE3Ng==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590176", "bodyText": "It's not clear what \"all the below\" is referring to.", "author": "smillst", "createdAt": "2020-12-15T18:37:27Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MDcyMQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543590721", "bodyText": "I think this is done? Or should precondition be postcondition?", "author": "smillst", "createdAt": "2020-12-15T18:38:18Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2224,177 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the string representation of contract annotations (that is, pre- and post-conditions)\n+     * for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the string representation of precondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            VariableElement elt = entry.getKey();\n+            AField afield = entry.getValue();\n+            result.addAll(getPreconditionAnnotation(elt, afield));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        WholeProgramInferenceScenes wholeProgramInference =\n+                (WholeProgramInferenceScenes) getWholeProgramInference();\n+        if (wholeProgramInference == null) {\n+            return Collections.emptyList();\n+        }\n+\n+        AnnotatedTypeMirror declaredType = fromElement(elt);\n+\n+        TypeMirror typeMirror = elt.asType();\n+        AnnotatedTypeMirror inferredType =\n+                wholeProgramInference.atmFromATypeElement(typeMirror, f.type);\n+\n+        // TODO: should this only check the top-level annotations?\n+        if (declaredType.equals(inferredType)) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<AnnotationMirror> result = new ArrayList<AnnotationMirror>();\n+        for (AnnotationMirror inferredAm : inferredType.getAnnotations()) {\n+            AnnotationMirror declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+            if (declaredAm == null) {\n+                // There is no explicitly-written annotation for the given qualifier hierarchy.\n+                // Determine the default.\n+                addComputedTypeAnnotations(elt, declaredType);\n+                declaredAm = declaredType.getAnnotationInHierarchy(inferredAm);\n+                if (declaredAm == null) {\n+                    throw new BugInCF(\n+                            \"getPreconditionAnnotation(%s, %s): no defaulted annotation%n  declaredType=%s%n  inferredType=%s%n\",\n+                            elt, f, declaredType.toString(true), inferredType.toString(true));\n+                }\n+            }\n+\n+            if (declaredAm == null || AnnotationUtils.areSame(inferredAm, declaredAm)) {\n+                continue;\n+            }\n+            // inferredAm must be a subtype of declaredAm (since they are not equal).\n+            AnnotationMirror requiresQualifierAnno = requiresQualifierAnno(elt, inferredAm);\n+            if (requiresQualifierAnno != null) {\n+                result.add(requiresQualifierAnno);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code RequiresQualifier(\"...\")} annotation for the given field. Returns null if\n+     * none can be created, because the qualifier has elements/arguments, which\n+     * {@code @RequiresQualifier} does not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param fieldElement a field\n+     * @param qualifier the qualifier that must be present\n+     * @return a {@code RequiresQualifier(\"...\")} annotation for the given field, or null\n+     */\n+    protected AnnotationMirror requiresQualifierAnno(\n+            VariableElement fieldElement, AnnotationMirror qualifier) {\n+        if (!qualifier.getElementValues().isEmpty()) {\n+            return null;\n+        }\n+\n+        AnnotationBuilder builder = new AnnotationBuilder(processingEnv, RequiresQualifier.class);\n+        builder.setValue(\"expression\", new String[] {\"this.\" + fieldElement.getSimpleName()});\n+        builder.setValue(\"qualifier\", AnnotationMirrorToClass(qualifier));\n+        return builder.build();\n+    }\n+\n+    /**\n+     * Converts an AnnotationMirror to a Class.\n+     *\n+     * @param am an AnnotationMirror\n+     * @return the Class corresponding to the given AnnotationMirror\n+     */\n+    protected Class<?> AnnotationMirrorToClass(AnnotationMirror am) {\n+        try {\n+            return Class.forName(AnnotationUtils.annotationBinaryName(am));\n+        } catch (ClassNotFoundException e) {\n+            throw new BugInCF(e);\n+        }\n+    }\n+\n+    // TODO: Implement all the below, probably by copying from the above or abstracting it.\n+\n+    /**\n+     * Return the string representation of postcondition annotations for the given AMethod. Does not\n+     * modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        return result;\n+    }\n+\n+    // TODO: Implement this here in this class, reading @PreconditionAnnotation meta-annotations.", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDYxNw==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r543594617", "bodyText": "There's another version of this method org.checkerframework.javacutil.TypeAnnotationUtils#unannotatedType.  It makes more sense to have this method in TypesUtils.  Or at least that's where I always look for it first.", "author": "smillst", "createdAt": "2020-12-15T18:43:32Z", "path": "javacutil/src/main/java/org/checkerframework/javacutil/TypesUtils.java", "diffHunk": "@@ -893,4 +894,24 @@ public static TypeMirror substitute(\n                 com.sun.tools.javac.util.List.from(newP),\n                 com.sun.tools.javac.util.List.from(newT));\n     }\n+\n+    // This method is necessary because Type.stripMetadata does no work for primitive types.\n+    /**\n+     * Returns a copy of a type without annotations. May return tm itself if it has no annotations.\n+     *\n+     * @param tm a TypeMirror\n+     * @return a copy of the given type without annotations\n+     */\n+    public static TypeMirror unannotatedType(TypeMirror tm) {", "originalCommit": "297f5c733e8b10e3143b0005e395abdd3f1a03a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d88af64646d21e358ae57629811e5822e66de06", "url": "https://github.com/typetools/checker-framework/commit/0d88af64646d21e358ae57629811e5822e66de06", "message": "Don't re-implement a method", "committedDate": "2020-12-15T20:21:37Z", "type": "commit"}, {"oid": "34b65247e9f4b53e6727f1cdeff639236fd615f7", "url": "https://github.com/typetools/checker-framework/commit/34b65247e9f4b53e6727f1cdeff639236fd615f7", "message": "Clarify comments (that show this pull request is not yet ready)", "committedDate": "2020-12-15T20:22:09Z", "type": "commit"}, {"oid": "ff43d062c058da27220e36edd8583b49472340a8", "url": "https://github.com/typetools/checker-framework/commit/ff43d062c058da27220e36edd8583b49472340a8", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-15T21:40:19Z", "type": "commit"}, {"oid": "9e45175eabb529216d78e38f9f48fc07f71b2b76", "url": "https://github.com/typetools/checker-framework/commit/9e45175eabb529216d78e38f9f48fc07f71b2b76", "message": "Update expected output", "committedDate": "2020-12-15T23:57:02Z", "type": "commit"}, {"oid": "984286ea3c6f10fbb70983722a6dda36b5e6c72d", "url": "https://github.com/typetools/checker-framework/commit/984286ea3c6f10fbb70983722a6dda36b5e6c72d", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-16T06:00:17Z", "type": "commit"}, {"oid": "7956d6137f18ab2aea9da16da866a1a9fd65d643", "url": "https://github.com/typetools/checker-framework/commit/7956d6137f18ab2aea9da16da866a1a9fd65d643", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-16T15:33:16Z", "type": "commit"}, {"oid": "cb9104a39dae25b4282b78e3f01d887e349dfd3c", "url": "https://github.com/typetools/checker-framework/commit/cb9104a39dae25b4282b78e3f01d887e349dfd3c", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-16T21:17:16Z", "type": "commit"}, {"oid": "811064aee981050af6f4ccc1e5a5ef397beb5a05", "url": "https://github.com/typetools/checker-framework/commit/811064aee981050af6f4ccc1e5a5ef397beb5a05", "message": "Fix Javadoc", "committedDate": "2020-12-17T03:14:47Z", "type": "commit"}, {"oid": "ec223a70d21d084f9640bc4b6f504e05053ac2b7", "url": "https://github.com/typetools/checker-framework/commit/ec223a70d21d084f9640bc4b6f504e05053ac2b7", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-17T15:40:08Z", "type": "commit"}, {"oid": "c38a658e31ac5759d1a1cb3a19d918f21739bff2", "url": "https://github.com/typetools/checker-framework/commit/c38a658e31ac5759d1a1cb3a19d918f21739bff2", "message": "Add comment", "committedDate": "2020-12-17T17:22:16Z", "type": "commit"}, {"oid": "2f2d2fb2d01f64133c473005ea6ffca4a7d1cf9c", "url": "https://github.com/typetools/checker-framework/commit/2f2d2fb2d01f64133c473005ea6ffca4a7d1cf9c", "message": "Rename checker/tests/whole-program-inference/ to checker/tests/wpi-testchecker/", "committedDate": "2020-12-18T14:35:48Z", "type": "commit"}, {"oid": "f0f7cb89df81ad67a0f2a981e37490502e44685d", "url": "https://github.com/typetools/checker-framework/commit/f0f7cb89df81ad67a0f2a981e37490502e44685d", "message": "Remove debugging output", "committedDate": "2020-12-18T14:38:03Z", "type": "commit"}, {"oid": "3faa277cc79b86fe563f00f824cf642f7c598795", "url": "https://github.com/typetools/checker-framework/commit/3faa277cc79b86fe563f00f824cf642f7c598795", "message": "Renamings", "committedDate": "2020-12-18T14:58:27Z", "type": "commit"}, {"oid": "771c8f66508c8992fa0566f43483cd78454e9c0b", "url": "https://github.com/typetools/checker-framework/commit/771c8f66508c8992fa0566f43483cd78454e9c0b", "message": "Tweaks", "committedDate": "2020-12-18T15:24:22Z", "type": "commit"}, {"oid": "4993c744c33101db6f7c811dcc696cebbb69185a", "url": "https://github.com/typetools/checker-framework/commit/4993c744c33101db6f7c811dcc696cebbb69185a", "message": "Merge ../checker-framework-branch-master into wpi-tests", "committedDate": "2020-12-18T15:25:02Z", "type": "commit"}, {"oid": "9444b7d5b784018c3e563272040bca65165bdee8", "url": "https://github.com/typetools/checker-framework/commit/9444b7d5b784018c3e563272040bca65165bdee8", "message": "Checkpoint while renaming and adding tests", "committedDate": "2020-12-18T15:27:05Z", "type": "commit"}, {"oid": "ee8d54acdd252126a3268f707f7f7af99a3a8c1d", "url": "https://github.com/typetools/checker-framework/commit/ee8d54acdd252126a3268f707f7f7af99a3a8c1d", "message": "Merge ../checker-framework-fork-mernst-branch-wpi-tests into infer-contracts", "committedDate": "2020-12-18T15:30:53Z", "type": "commit"}, {"oid": "db0755fd8dc597c4ae1d793bb69a1e4ce947329e", "url": "https://github.com/typetools/checker-framework/commit/db0755fd8dc597c4ae1d793bb69a1e4ce947329e", "message": "Task renaming", "committedDate": "2020-12-18T17:59:04Z", "type": "commit"}, {"oid": "7bd2952e1b5037cb7a327ce509db17d997f2b01e", "url": "https://github.com/typetools/checker-framework/commit/7bd2952e1b5037cb7a327ce509db17d997f2b01e", "message": "Add test for `@MonotonicNonNull`", "committedDate": "2020-12-18T18:56:38Z", "type": "commit"}, {"oid": "5a10f3889c5e9f66df566af8f634369e6f40b0d4", "url": "https://github.com/typetools/checker-framework/commit/5a10f3889c5e9f66df566af8f634369e6f40b0d4", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-18T19:01:36Z", "type": "commit"}, {"oid": "e2d821fdcb4fbb63e3535eb48fa10785920a92d3", "url": "https://github.com/typetools/checker-framework/commit/e2d821fdcb4fbb63e3535eb48fa10785920a92d3", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-18T20:09:21Z", "type": "commit"}, {"oid": "b3e85211f646dd7fb2176fa3cb33b5995d8763c4", "url": "https://github.com/typetools/checker-framework/commit/b3e85211f646dd7fb2176fa3cb33b5995d8763c4", "message": "Infer postcondition annotations", "committedDate": "2020-12-18T20:47:13Z", "type": "commit"}, {"oid": "5683807cb4f8fc71097c21ad0f48d88bc0735ef7", "url": "https://github.com/typetools/checker-framework/commit/5683807cb4f8fc71097c21ad0f48d88bc0735ef7", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-18T20:49:41Z", "type": "commit"}, {"oid": "36cde2ef26e6a2efffcbb26c4dea4212cff4279a", "url": "https://github.com/typetools/checker-framework/commit/36cde2ef26e6a2efffcbb26c4dea4212cff4279a", "message": "Fix name", "committedDate": "2020-12-18T21:13:52Z", "type": "commit"}, {"oid": "e47fd39ca6c8e40bc5d1939c3bde105a99c33240", "url": "https://github.com/typetools/checker-framework/commit/e47fd39ca6c8e40bc5d1939c3bde105a99c33240", "message": "Javadoc", "committedDate": "2020-12-18T21:14:42Z", "type": "commit"}, {"oid": "316ee94c43d7f1a27cc72c74704f203710e98785", "url": "https://github.com/typetools/checker-framework/commit/316ee94c43d7f1a27cc72c74704f203710e98785", "message": "Compute contract annotations in one place, centrally", "committedDate": "2020-12-18T21:16:23Z", "type": "commit"}, {"oid": "5e897b37386d3900be5cb2bcae8d40c75067b4b8", "url": "https://github.com/typetools/checker-framework/commit/5e897b37386d3900be5cb2bcae8d40c75067b4b8", "message": "Suppress inference for irrelevant type system", "committedDate": "2020-12-18T21:17:03Z", "type": "commit"}, {"oid": "395aab11629b3bbc2ced47482c61542e8a7b00f2", "url": "https://github.com/typetools/checker-framework/commit/395aab11629b3bbc2ced47482c61542e8a7b00f2", "message": "Don't put AFU manipulations outside SceneToStubWriter and ASceneWrapper", "committedDate": "2020-12-18T21:36:56Z", "type": "commit"}, {"oid": "94917d36729349ea0048205ff4cbbb1321662f07", "url": "https://github.com/typetools/checker-framework/commit/94917d36729349ea0048205ff4cbbb1321662f07", "message": "Rename method", "committedDate": "2020-12-18T21:55:54Z", "type": "commit"}, {"oid": "d5a7f271aa35bb32258a6d7fcb1775d3d17ea726", "url": "https://github.com/typetools/checker-framework/commit/d5a7f271aa35bb32258a6d7fcb1775d3d17ea726", "message": "Remove undesirable diagnostic output", "committedDate": "2020-12-18T22:50:29Z", "type": "commit"}, {"oid": "ea227d51887038b43681d0c65e6da2332c48c2db", "url": "https://github.com/typetools/checker-framework/commit/ea227d51887038b43681d0c65e6da2332c48c2db", "message": "Fix classpath", "committedDate": "2020-12-18T22:59:33Z", "type": "commit"}, {"oid": "c7598f37a0a22e86fe1aba6562c158e861fcd29c", "url": "https://github.com/typetools/checker-framework/commit/c7598f37a0a22e86fe1aba6562c158e861fcd29c", "message": "Fix test", "committedDate": "2020-12-18T23:01:55Z", "type": "commit"}, {"oid": "80e438c60ca029bf52816a5dbe29ada4a335c406", "url": "https://github.com/typetools/checker-framework/commit/80e438c60ca029bf52816a5dbe29ada4a335c406", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-18T23:40:11Z", "type": "commit"}, {"oid": "17896389456fdb386eefc82cbe56d3fc934eef56", "url": "https://github.com/typetools/checker-framework/commit/17896389456fdb386eefc82cbe56d3fc934eef56", "message": "Undo refactoring to bring computation of preconditions together", "committedDate": "2020-12-19T00:20:43Z", "type": "commit"}, {"oid": "765eb78c6f6bdb6e586f2b3e3d2e0e6ba1e1037b", "url": "https://github.com/typetools/checker-framework/commit/765eb78c6f6bdb6e586f2b3e3d2e0e6ba1e1037b", "message": "Use plume-lib version 1.3.0", "committedDate": "2020-12-19T12:34:44Z", "type": "commit"}, {"oid": "4faf92cb7ae85f048fc864043566ecc8d133997f", "url": "https://github.com/typetools/checker-framework/commit/4faf92cb7ae85f048fc864043566ecc8d133997f", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-19T16:52:14Z", "type": "commit"}, {"oid": "4faf92cb7ae85f048fc864043566ecc8d133997f", "url": "https://github.com/typetools/checker-framework/commit/4faf92cb7ae85f048fc864043566ecc8d133997f", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-19T16:52:14Z", "type": "forcePushed"}, {"oid": "b3fd36c185c0b18a8c71d964eae984fa5fb0ee76", "url": "https://github.com/typetools/checker-framework/commit/b3fd36c185c0b18a8c71d964eae984fa5fb0ee76", "message": "Merge commit '45e666188db4ddfd2625c06cd3ddad1b65dfaf81' into infer-contracts", "committedDate": "2020-12-21T07:02:20Z", "type": "commit"}, {"oid": "c41cd455b2ab483222ad06d37bd34e747797d1c9", "url": "https://github.com/typetools/checker-framework/commit/c41cd455b2ab483222ad06d37bd34e747797d1c9", "message": "Merge commit '8f345c13969a7371bbe11d1d8cdfe4b27f26ab44' into infer-contracts", "committedDate": "2020-12-21T07:02:25Z", "type": "commit"}, {"oid": "c720dcc29b70a5afcbf593ad4e169ac34f1f6511", "url": "https://github.com/typetools/checker-framework/commit/c720dcc29b70a5afcbf593ad4e169ac34f1f6511", "message": "Reorder methods", "committedDate": "2020-12-21T13:52:00Z", "type": "commit"}, {"oid": "4f596f391f8248d2c72d0be0e0f94fdabc7664c6", "url": "https://github.com/typetools/checker-framework/commit/4f596f391f8248d2c72d0be0e0f94fdabc7664c6", "message": "Renamings to prepare for merging with d305a562c62f9db1155c2b86a65b9fac489db00c", "committedDate": "2020-12-21T14:08:41Z", "type": "commit"}, {"oid": "a9c371832640094daf1865bdab02e5396ba12f16", "url": "https://github.com/typetools/checker-framework/commit/a9c371832640094daf1865bdab02e5396ba12f16", "message": "Merge commit 'd305a562c62f9db1155c2b86a65b9fac489db00c' into infer-contracts", "committedDate": "2020-12-21T14:19:21Z", "type": "commit"}, {"oid": "2ee89d4fea8798318c75404b292baff5c3df995a", "url": "https://github.com/typetools/checker-framework/commit/2ee89d4fea8798318c75404b292baff5c3df995a", "message": "Merge commit 'bc9fea3987bde1543fb0671bab114c2b3511db00' into infer-contracts", "committedDate": "2020-12-21T14:20:18Z", "type": "commit"}, {"oid": "2bdcbe42afc844a5322ba717c8ca0f647d0f917f", "url": "https://github.com/typetools/checker-framework/commit/2bdcbe42afc844a5322ba717c8ca0f647d0f917f", "message": "Reduce whitespace differences", "committedDate": "2020-12-21T15:52:35Z", "type": "commit"}, {"oid": "a94f1474443ac0fae11fc29152a5a510faffe5ea", "url": "https://github.com/typetools/checker-framework/commit/a94f1474443ac0fae11fc29152a5a510faffe5ea", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-21T15:55:18Z", "type": "commit"}, {"oid": "608e52287df88b1939d20ffbc25dd0484a0d67dc", "url": "https://github.com/typetools/checker-framework/commit/608e52287df88b1939d20ffbc25dd0484a0d67dc", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-21T18:13:26Z", "type": "commit"}, {"oid": "fe16a0aff276c7caffd26bce4cda6487ca854e3c", "url": "https://github.com/typetools/checker-framework/commit/fe16a0aff276c7caffd26bce4cda6487ca854e3c", "message": "Refer to test directory correctly.", "committedDate": "2020-12-21T23:11:38Z", "type": "commit"}, {"oid": "a7c8699a9b41fea3716994d8339837978502c254", "url": "https://github.com/typetools/checker-framework/commit/a7c8699a9b41fea3716994d8339837978502c254", "message": "Fix comment.", "committedDate": "2020-12-21T23:12:43Z", "type": "commit"}, {"oid": "f32bf985eabb6a1eab550c36251d925d06563faa", "url": "https://github.com/typetools/checker-framework/commit/f32bf985eabb6a1eab550c36251d925d06563faa", "message": "Add Nullable.", "committedDate": "2020-12-21T23:43:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDM1OQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980359", "bodyText": "I think we avoid statically importing methods/fields.", "author": "smillst", "createdAt": "2020-12-21T23:19:29Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -1,19 +1,24 @@\n package org.checkerframework.common.wholeprograminference.scenelib;\n \n+import static org.plumelib.util.CollectionsPlume.mapList;", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxMjE2MQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r547312161", "bodyText": "If this is not statically imported, then the call is little shorter than the verbose stream version.  I propose to make an exception for this method.", "author": "mernst", "createdAt": "2020-12-22T14:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MDY5OQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546980699", "bodyText": "This for loop is now duplicated above.", "author": "smillst", "createdAt": "2020-12-21T23:20:38Z", "path": "framework/src/main/java/org/checkerframework/common/wholeprograminference/scenelib/ASceneWrapper.java", "diffHunk": "@@ -139,14 +144,48 @@ public void writeToFile(\n                 throw new BugInCF(\"Unhandled outputFormat \" + outputFormat);\n         }\n         new File(filepath).delete();\n+        // Only write non-empty scenes into files.\n         if (!scene.isEmpty()) {\n-            // Only write non-empty scenes into files.\n             try {\n+                for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {\n+                    AClass aClass = classEntry.getValue();\n+                    for (Map.Entry<String, AMethod> methodEntry : aClass.getMethods().entrySet()) {\n+                        AMethod aMethod = methodEntry.getValue();\n+                        List<AnnotationMirror> contractAnnotationMirrors =\n+                                checker.getTypeFactory().getContractAnnotations(aMethod);\n+                        List<Annotation> contractAnnotations =\n+                                mapList(\n+                                        AnnotationConverter::annotationMirrorToAnnotation,\n+                                        contractAnnotationMirrors);\n+                        aMethod.contracts = contractAnnotations;\n+                    }\n+                }\n+\n                 switch (outputFormat) {\n                     case STUB:\n+                        // For stub files, pass in the checker to compute contracts on the fly;\n+                        // precomputing yields incorrect annotations, most likely due to nested\n+                        // classes.\n                         SceneToStubWriter.write(this, filepath, checker);\n                         break;\n                     case JAIF:\n+                        // For .jaif files, precompute contracts because the Annotation File\n+                        // Utilities knows nothing about (and cannot depend on) the Checker\n+                        // Framework.\n+                        for (Map.Entry<String, AClass> classEntry : scene.classes.entrySet()) {", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4MjIwMA==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546982200", "bodyText": "More static imports.", "author": "smillst", "createdAt": "2020-12-21T23:25:56Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -1,5 +1,9 @@\n package org.checkerframework.framework.type;\n \n+import static org.checkerframework.dataflow.analysis.Analysis.BeforeOrAfter.AFTER;", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDU4NQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984585", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "author": "smillst", "createdAt": "2020-12-21T23:34:04Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDc1Mw==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984753", "bodyText": "This can be replaced with result.sort(Ordering.usingToString()); if you like.", "author": "smillst", "createdAt": "2020-12-21T23:34:39Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDgxNQ==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984815", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "author": "smillst", "createdAt": "2020-12-21T23:34:59Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk4NDg3MA==", "url": "https://github.com/typetools/checker-framework/pull/4014#discussion_r546984870", "bodyText": "This says it returns null, but the implementation seems to return the empty list.  I'm not sure which was intended.  If clients should expect null, then please add @Nullable to the return type.", "author": "smillst", "createdAt": "2020-12-21T23:35:08Z", "path": "framework/src/main/java/org/checkerframework/framework/type/GenericAnnotatedTypeFactory.java", "diffHunk": "@@ -2218,4 +2228,204 @@ public AnnotatedTypeMirror getDefaultValueAnnotatedType(TypeMirror typeMirror) {\n                 TreeUtils.getDefaultValueTree(typeMirror, processingEnv), defaultValue, false);\n         return defaultValue;\n     }\n+\n+    /**\n+     * Return the contract annotations (that is, pre- and post-conditions) for the given AMethod.\n+     * Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return contract annotations for the method\n+     */\n+    public List<AnnotationMirror> getContractAnnotations(AMethod m) {\n+        List<AnnotationMirror> preconds = getPreconditionAnnotations(m);\n+        List<AnnotationMirror> postconds = getPostconditionAnnotations(m, preconds);\n+        List<AnnotationMirror> result = preconds;\n+        result.addAll(postconds);\n+        return result;\n+    }\n+\n+    /**\n+     * Return the precondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @return precondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotations(AMethod m) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPreconditions().entrySet()) {\n+            result.addAll(getPreconditionAnnotation(entry.getKey(), entry.getValue()));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return the postcondition annotations for the given AMethod. Does not modify the AMethod.\n+     *\n+     * @param m AFU representation of a method\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return postcondition annotations for the method\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotations(\n+            AMethod m, List<AnnotationMirror> preconds) {\n+        List<AnnotationMirror> result = new ArrayList<>();\n+        for (Map.Entry<VariableElement, AField> entry : m.getPostconditions().entrySet()) {\n+            result.addAll(getPostconditionAnnotation(entry.getKey(), entry.getValue(), preconds));\n+        }\n+        Collections.sort(result, Ordering.usingToString());\n+        return result;\n+    }\n+\n+    /**\n+     * Return a list of precondition annotations for the given field. Returns null if none can be\n+     * created, because the qualifier has elements/arguments, which {@code @RequiresQualifier} does\n+     * not support.\n+     *\n+     * <p>This is of the form {@code @RequiresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field, which is declared in the same class as the method\n+     * @param f AFU representation of a field's precondition annotations\n+     * @return a precondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPreconditionAnnotation(VariableElement elt, AField f) {\n+        return getPreOrPostconditionAnnotation(elt, f, BEFORE, null);\n+    }\n+\n+    /**\n+     * Returns an {@code @EnsuresQualifier} annotation for the given field. Returns null if none can\n+     * be created, because the qualifier has elements/arguments, which {@code @EnsuresQualifier}\n+     * does not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * <p>This is of the form {@code @EnsuresQualifier(expression=\"this.elt\",\n+     * qualifier=MyQual.class)} when elt is declared as {@code @A} or {@code @Poly*} and f contains\n+     * {@code @B} which is a sub-qualifier of {@code @A}.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions\n+     * @return a postcondition annotation for the element, or null if none is appropriate\n+     */\n+    public List<AnnotationMirror> getPostconditionAnnotation(\n+            VariableElement elt, AField f, List<AnnotationMirror> preconds) {\n+        return getPreOrPostconditionAnnotation(elt, f, AFTER, preconds);\n+    }\n+\n+    /**\n+     * Helper method for {@link #getPreconditionAnnotation} and {@link #getPostconditionAnnotation}.\n+     *\n+     * <p>Returns an {@code @EnsuresQualifier} or {@code @EnsuresQualifier} annotation for the given\n+     * field. Returns null if none can be created, because the qualifier has elements/arguments,\n+     * which {@code @EnsuresQualifier} and {@code @RequiresQualifier} do not support.\n+     *\n+     * <p>This implementation makes no assumptions about preconditions suppressing postconditions,\n+     * but subclasses may do so.\n+     *\n+     * @param elt element for a field\n+     * @param f AFU representation of a field's postcondition annotations\n+     * @param preOrPost whether to return preconditions or postconditions\n+     * @param preconds the precondition annotations for the method; used to suppress redundant\n+     *     postconditions; non-null exactly when {@code preOrPost} is {@code AFTER}\n+     * @return a postcondition annotation for the element, or null if none is appropriate", "originalCommit": "a7c8699a9b41fea3716994d8339837978502c254", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e978f3d51be9b6f249994601a502082f461a4d3c", "url": "https://github.com/typetools/checker-framework/commit/e978f3d51be9b6f249994601a502082f461a4d3c", "message": "Merge ../checker-framework-branch-master into infer-contracts", "committedDate": "2020-12-22T14:36:50Z", "type": "commit"}, {"oid": "822c6fda4a2b1b6710ed28c6d4d8fe8cde5f9289", "url": "https://github.com/typetools/checker-framework/commit/822c6fda4a2b1b6710ed28c6d4d8fe8cde5f9289", "message": "Remove duplicated code", "committedDate": "2020-12-22T14:37:35Z", "type": "commit"}, {"oid": "0e02e43500b6f3dc5b4315edccca1fdd649a1d79", "url": "https://github.com/typetools/checker-framework/commit/0e02e43500b6f3dc5b4315edccca1fdd649a1d79", "message": "Address code review feedback", "committedDate": "2020-12-22T14:45:28Z", "type": "commit"}]}