{"pr_number": 3199, "pr_title": "Returns Receiver Checker", "pr_createdAt": "2020-03-26T20:09:27Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3199", "timeline": [{"oid": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "url": "https://github.com/typetools/checker-framework/commit/e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "message": "add method ref test", "committedDate": "2020-04-23T04:20:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414901065", "bodyText": "You could meta-annotate all your qualifiers as org.checkerframework.framework.qual.TargetLocations for RETURN and RECEIVER. The annotation isn't enforced yet, but it might already be good documentation.", "author": "wmdietl", "createdAt": "2020-04-24T22:37:47Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return type, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent\n+ * to:\n+ *\n+ * <pre><code>\n+ * &#064;This MyBuilder setName(@This MyBuilder this, String name) {\n+ *   this.name = name;\n+ *   return this;\n+ * }\n+ * </code></pre>\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ * @checker_framework.manual #qualifier-polymorphism Qualifier polymorphism\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})", "originalCommit": "e10c6f5ad5af2d460033b27de73a8b93e6d8acab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNTA0Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416305042", "bodyText": "It is also allowed in a downcast.  Would that be prohibited if we add the @TargetLocations meta-annotation?", "author": "msridhar", "createdAt": "2020-04-28T03:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc0NjMwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416746301", "bodyText": "I went ahead and added the @TargetLocations annotation, under the assumption that a qualifier is always allowed to appear in a downcast", "author": "msridhar", "createdAt": "2020-04-28T16:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTA2NQ=="}], "type": "inlineReview"}, {"oid": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "url": "https://github.com/typetools/checker-framework/commit/0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "message": "Modified @This declaration", "committedDate": "2020-04-27T21:10:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1Nzk2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416157966", "bodyText": "Please delete this code rather than commenting it out", "author": "msridhar", "createdAt": "2020-04-27T21:22:30Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            //            // If return type is annotated with @This, add @This annotation", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTA1Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159052", "bodyText": "What is the error in this file?  I don't see any method references", "author": "msridhar", "createdAt": "2020-04-27T21:24:12Z", "path": "framework/tests/all-systems/java8/lambda/Issue450.java", "diffHunk": "@@ -1,3 +1,4 @@\n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\") // See Issue #2931", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTMwOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416159308", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "author": "msridhar", "createdAt": "2020-04-27T21:24:38Z", "path": "framework/tests/all-systems/java8/memberref/MemberReferences.java", "diffHunk": "@@ -112,6 +112,7 @@ void context(Bound bound) {\n     }\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDAwNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160004", "bodyText": "Please include // See Issue #2931 at the end of the line.  Also can you move the suppression just before the specific line causing the problem?  You should be able to write a @SuppressWarnings annotation just before a method declaration", "author": "msridhar", "createdAt": "2020-04-27T21:25:52Z", "path": "framework/tests/all-systems/java8/memberref/Receivers.java", "diffHunk": "@@ -11,6 +11,7 @@\n     R supply();\n }\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MDM3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416160376", "bodyText": "Please include // See Issue #2931 at the end of the line.", "author": "msridhar", "createdAt": "2020-04-27T21:26:22Z", "path": "framework/tests/all-systems/java8inference/Issue1715.java", "diffHunk": "@@ -1,6 +1,7 @@\n import java.util.List;\n import java.util.function.Function;\n \n+@SuppressWarnings(\"returnsreceiver:methodref.receiver.bound.invalid\")", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE2MTU3NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416161575", "bodyText": "This is not a valid error.  We should either use @SuppressWarnings or add a comment indicating this is not a valid error, pointing to #2931", "author": "msridhar", "createdAt": "2020-04-27T21:28:24Z", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,31 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        // :: error: (methodref.receiver.bound.invalid)", "originalCommit": "0fd9d340e568332c0c33346e1d9c2e2e05b17ec2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "37668822ca8f01dc2be35df6dae920ed4451eec4", "url": "https://github.com/typetools/checker-framework/commit/37668822ca8f01dc2be35df6dae920ed4451eec4", "message": "Revert \"Modified @This declaration\"\n\nThis reverts commit 0fd9d340e568332c0c33346e1d9c2e2e05b17ec2.", "committedDate": "2020-04-28T01:58:35Z", "type": "commit"}, {"oid": "ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "url": "https://github.com/typetools/checker-framework/commit/ba6c8cb4c06191abd19265bf006b92e2d1e13bb9", "message": "comments on why we don't use @DefaultFor(RECEIVER)", "committedDate": "2020-04-28T03:14:38Z", "type": "commit"}, {"oid": "8fc8625f339a3090951413d14b87a9fed718b164", "url": "https://github.com/typetools/checker-framework/commit/8fc8625f339a3090951413d14b87a9fed718b164", "message": "Allow writing @This on receiver type", "committedDate": "2020-04-28T03:30:25Z", "type": "commit"}, {"oid": "74e562cf35bad6b7526b5f58c612f009458777e0", "url": "https://github.com/typetools/checker-framework/commit/74e562cf35bad6b7526b5f58c612f009458777e0", "message": "disallow @This on return type of static method", "committedDate": "2020-04-28T03:41:35Z", "type": "commit"}, {"oid": "33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "url": "https://github.com/typetools/checker-framework/commit/33306f3d1f3914fa185f4d0f87a0e7e4a82c468d", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-28T16:02:48Z", "type": "commit"}, {"oid": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "url": "https://github.com/typetools/checker-framework/commit/0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "message": "add @TargetLocations annotation", "committedDate": "2020-04-28T16:16:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjIxMA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946210", "bodyText": "Use {@code @This} or a link?", "author": "wmdietl", "createdAt": "2020-04-28T21:52:13Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjY2NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416946664", "bodyText": "I'm not sure that's the best description of the method you could come up with...", "author": "wmdietl", "createdAt": "2020-04-28T21:53:15Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,136 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. The only use of the enum\n+ * is to support fluent API generators so the checker can add @This annotations on method return\n+ * types when these generators has been used. To check whether a method is created by any of the\n+ * generators defined in the {@link FluentAPIGenerators} Enum and returns {@code this}, simply call\n+ * the {@link FluentAPIGenerator#check} on the annotated type of the method signature.\n+ */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * This is the only public method of this class", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416949094", "bodyText": "Maybe add the note about the automatic defaulting here also. Maybe file a follow-up issue to keep track of method reference handling and the false positives.", "author": "wmdietl", "createdAt": "2020-04-28T21:58:23Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@code @}{@link This} annotation. The field is package visible due to a use in {@link\n+     * ReturnsReceiverVisitor}\n+     */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation\n+            // to the receiver type.", "originalCommit": "0eaefbb86c25a70ba001d5d9e3ddfcdb5017af34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MzEyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416973121", "bodyText": "Do we need an issue separate from #2931?", "author": "msridhar", "createdAt": "2020-04-28T22:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3OTg4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416979881", "bodyText": "Now that there is a reference to that issue, this is fine.", "author": "wmdietl", "createdAt": "2020-04-28T23:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MDQ5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416980495", "bodyText": "Oh, there is none here. Can you add one, to make it easier to find all places that should be touched once #2931 is fixed?", "author": "wmdietl", "createdAt": "2020-04-28T23:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MTI4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416981288", "bodyText": "It's there:  https://github.com/typetools/checker-framework/pull/3199/files#diff-4fedb1e93f819c78e6268bc5f23478b1R82-R83  The GitHub UI is confusing with outdated views", "author": "msridhar", "createdAt": "2020-04-28T23:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4MzA4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416983081", "bodyText": "Oh, I specifically tried to look on a reload and didn't see it... thanks, so that's good then.", "author": "wmdietl", "createdAt": "2020-04-28T23:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0OTA5NA=="}], "type": "inlineReview"}, {"oid": "0bd569d6bb54ef4843f000e75a45ca5ce3192997", "url": "https://github.com/typetools/checker-framework/commit/0bd569d6bb54ef4843f000e75a45ca5ce3192997", "message": "address comments", "committedDate": "2020-04-28T22:56:20Z", "type": "commit"}, {"oid": "cbc22a2451a78beedd97e49a61a4e55762557225", "url": "https://github.com/typetools/checker-framework/commit/cbc22a2451a78beedd97e49a61a4e55762557225", "message": "Fix typo", "committedDate": "2020-04-28T23:14:16Z", "type": "commit"}, {"oid": "0760f52cda8e565368e55c7bfee44678c28509d3", "url": "https://github.com/typetools/checker-framework/commit/0760f52cda8e565368e55c7bfee44678c28509d3", "message": "tweak to manual", "committedDate": "2020-04-29T18:48:57Z", "type": "commit"}, {"oid": "beffa549428ba139408bb29bcdb899941b33294b", "url": "https://github.com/typetools/checker-framework/commit/beffa549428ba139408bb29bcdb899941b33294b", "message": "Initialization", "committedDate": "2020-03-25T18:16:00Z", "type": "commit"}, {"oid": "9b63699b1dcb6aa74e0913a770a3b4012f774428", "url": "https://github.com/typetools/checker-framework/commit/9b63699b1dcb6aa74e0913a770a3b4012f774428", "message": "resolved comments", "committedDate": "2020-03-26T19:35:59Z", "type": "commit"}, {"oid": "bc4298b92e91330a1c62f162bb32956c2018c756", "url": "https://github.com/typetools/checker-framework/commit/bc4298b92e91330a1c62f162bb32956c2018c756", "message": "resolved comments", "committedDate": "2020-03-26T19:41:34Z", "type": "commit"}, {"oid": "a77dd34f6a7a54defb7a186be322f7d276ece232", "url": "https://github.com/typetools/checker-framework/commit/a77dd34f6a7a54defb7a186be322f7d276ece232", "message": "resolved comments", "committedDate": "2020-03-26T20:01:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r398968532", "bodyText": "@kelloggm do we want these tests and the test data in returnsrcvr sub-folders?  Or should we keep everything at the top level, in which case we should rename tests, e.g., to ReturnsRcvrAutoValueTest?", "author": "msridhar", "createdAt": "2020-03-27T00:23:33Z", "path": "framework/src/test/java/tests/AutoValueTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class AutoValueTest extends CheckerFrameworkPerDirectoryTest {", "originalCommit": "a77dd34f6a7a54defb7a186be322f7d276ece232", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3Nzc1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399377757", "bodyText": "I think keeping them at the top level is fine, but we should rename them as you suggested. The actual test data should definitely be in a returnsrcvr folder, though", "author": "kelloggm", "createdAt": "2020-03-27T16:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2ODUzMg=="}], "type": "inlineReview"}, {"oid": "71f08dc67b501f0072ec03a27fa3892c4801d3e1", "url": "https://github.com/typetools/checker-framework/commit/71f08dc67b501f0072ec03a27fa3892c4801d3e1", "message": "test git", "committedDate": "2020-03-27T17:17:25Z", "type": "commit"}, {"oid": "f9f9e3fd725fcca36f0a09656fcb771229d4200d", "url": "https://github.com/typetools/checker-framework/commit/f9f9e3fd725fcca36f0a09656fcb771229d4200d", "message": "test git", "committedDate": "2020-03-27T17:20:38Z", "type": "commit"}, {"oid": "4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "url": "https://github.com/typetools/checker-framework/commit/4d347ef8e293aa126c4cdf05d8f91e65d50b860e", "message": "resolved issues and passed git pre-commit hooks", "committedDate": "2020-03-28T02:05:04Z", "type": "commit"}, {"oid": "aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "url": "https://github.com/typetools/checker-framework/commit/aa5e28fdd814f8ca415872b2cb13d3282455c2ed", "message": "fixed issue with checkBasicStyle task", "committedDate": "2020-03-28T05:21:31Z", "type": "commit"}, {"oid": "415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "url": "https://github.com/typetools/checker-framework/commit/415adda9cee3ff9ad56a0e6d1f2cd9ce9734366e", "message": "fixed all-test-jdk8 and all-test-jdk11 jobs in pipeline", "committedDate": "2020-03-28T06:36:20Z", "type": "commit"}, {"oid": "91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "url": "https://github.com/typetools/checker-framework/commit/91d0d101663a5731c4d4751c9275fef4a6c7f3ea", "message": "git test", "committedDate": "2020-03-28T06:50:42Z", "type": "commit"}, {"oid": "e005df3b5c841dbe272b502dc07bab3d2a41af98", "url": "https://github.com/typetools/checker-framework/commit/e005df3b5c841dbe272b502dc07bab3d2a41af98", "message": "fixed checkInterning task", "committedDate": "2020-03-28T07:37:32Z", "type": "commit"}, {"oid": "7690604d845c8331ce3e03232f192a5525f601b6", "url": "https://github.com/typetools/checker-framework/commit/7690604d845c8331ce3e03232f192a5525f601b6", "message": "misc_jdk8", "committedDate": "2020-03-28T08:27:05Z", "type": "commit"}, {"oid": "b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "url": "https://github.com/typetools/checker-framework/commit/b98126aa8349b0b61f00841a2bc6f7f6e4d56dc0", "message": "misc_jdk8", "committedDate": "2020-03-28T08:39:37Z", "type": "commit"}, {"oid": "27843ff602ba06a52db49498675e3be561fa1828", "url": "https://github.com/typetools/checker-framework/commit/27843ff602ba06a52db49498675e3be561fa1828", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-03-28T19:08:15Z", "type": "commit"}, {"oid": "5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "url": "https://github.com/typetools/checker-framework/commit/5b27d78bfe2a9a74d570a2eac2865b19a5724fad", "message": "fix javadoc", "committedDate": "2020-03-28T19:17:38Z", "type": "commit"}, {"oid": "8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "url": "https://github.com/typetools/checker-framework/commit/8b9f5f03bc186fb0cf0629eb44745ffb90f21346", "message": "returns receiver manual", "committedDate": "2020-03-28T21:33:17Z", "type": "commit"}, {"oid": "ed02ca65fd427780a729589976818098433543f1", "url": "https://github.com/typetools/checker-framework/commit/ed02ca65fd427780a729589976818098433543f1", "message": "trailing whitespace", "committedDate": "2020-03-28T21:34:03Z", "type": "commit"}, {"oid": "9b5171fe0730113b1248680c19a97e5c3c75c953", "url": "https://github.com/typetools/checker-framework/commit/9b5171fe0730113b1248680c19a97e5c3c75c953", "message": "Add final newline", "committedDate": "2020-03-29T00:28:07Z", "type": "commit"}, {"oid": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "url": "https://github.com/typetools/checker-framework/commit/5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "message": "Capitalization fixes", "committedDate": "2020-03-29T00:37:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727494", "bodyText": "Each annotation's Javadoc should link to its manual chapter, to enable users to learn more.\nThe bottom type should additionally link to https://checkerframework.org/manual/#bottom-type.\nSee how other qualifiers do this, for example https://checkerframework.org/api/org/checkerframework/checker/nullness/qual/KeyForBottom.html .\nEven more importantly, say what the annotation means.  (The fact that it's the bottom type is relevant but isn't the most important information.)  For example, is null the only value of this type?\nThese comments apply to other annotations as well.", "author": "mernst", "createdAt": "2020-03-29T00:39:58Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/BottomThis.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.SubtypeOf;\n+import org.checkerframework.framework.qual.TargetLocations;\n+import org.checkerframework.framework.qual.TypeUseLocation;\n+\n+/** The bottom type for the Returns Receiver Checker's type system. */", "originalCommit": "9b5171fe0730113b1248680c19a97e5c3c75c953", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDMxNjI4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400316288", "bodyText": "Hi @mernst, I see this documentation in the manual for other bottom types:\n\nThis is the bottom type for the XYZ type system. It should never need to be written by the programmer.\n\nIs that sufficient here?  I'm honestly not even sure what values (if any) take on the bottom type in the returns receiver type system.", "author": "msridhar", "createdAt": "2020-03-30T16:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM0NTQwMA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r400345400", "bodyText": "Yes, that is often sufficient.  Usually the only value of the bottom type is null, but sometimes that is different.  Knowing what values helps readers to understand the type.  If you can't figure it out, you could leave that off.", "author": "mernst", "createdAt": "2020-03-30T16:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzQ5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTcyNzY5OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399727698", "bodyText": "The @This annotation does not represent a method.  Please rephrase.\nNit: please end sentences with punctuation.", "author": "mernst", "createdAt": "2020-03-29T00:43:17Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/qual/This.java", "diffHunk": "@@ -0,0 +1,13 @@\n+package org.checkerframework.common.returnsrcvr.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/** This represent methods that returns {@code this} */", "originalCommit": "9b5171fe0730113b1248680c19a97e5c3c75c953", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f4532df793fc199e7a440efa35c3051b0abc2e6b", "url": "https://github.com/typetools/checker-framework/commit/f4532df793fc199e7a440efa35c3051b0abc2e6b", "message": "Improve naming.  Make switch statements report errors.", "committedDate": "2020-03-29T15:24:30Z", "type": "commit"}, {"oid": "ce4f098f11080d20257088603aae6c1b4a23bc51", "url": "https://github.com/typetools/checker-framework/commit/ce4f098f11080d20257088603aae6c1b4a23bc51", "message": "Remove unnecessary text", "committedDate": "2020-03-29T15:41:40Z", "type": "commit"}, {"oid": "eff17315021c4d2899189b30c6a25149548d5fe5", "url": "https://github.com/typetools/checker-framework/commit/eff17315021c4d2899189b30c6a25149548d5fe5", "message": "Improve naming", "committedDate": "2020-03-29T15:41:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813101", "bodyText": "From this documentation, I cannot tell what a FrameworkSupport is.  Documentation for a type should indicate what it represents.  (And possibly should include other information such as how to use it.)\nFrom later reading, I'm not sure why this needs to be an interface with multiple implementations.\nWhy not just have a method in the Returns Receiver Checker that takes a framework as an argument, or takes a list of frameworks as an argument, and has a switch statement and inlines the definitions?  Or why not put the method in the Framework class?  Either of these designs seems simpler than the FrameworkSupport interface.", "author": "mernst", "createdAt": "2020-03-29T15:28:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** To add support for frameworks that need to have {@code @This} in certain generated methods */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxNzg4MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r401217880", "bodyText": "Our plan here is to just put the method inside each enum element in the Framework class; thanks for pointing this out.", "author": "msridhar", "createdAt": "2020-03-31T21:11:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzIyNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813224", "bodyText": "Please indicate what the class does or is used for.  This comment doesn't tell the reader anything that the class name does not.", "author": "mernst", "createdAt": "2020-03-29T15:29:22Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzM3MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813370", "bodyText": "If it is non-instantiable, the constructor must throw an error.  Making the constructor return normally lets errors creep in later.", "author": "mernst", "createdAt": "2020-03-29T15:30:24Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQzOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813438", "bodyText": "Please spell names correctly.  There should be no space in \"AutoValue\".", "author": "mernst", "createdAt": "2020-03-29T15:30:57Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzQ2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813461", "bodyText": "Please spell names correctly.", "author": "mernst", "createdAt": "2020-03-29T15:31:11Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzcwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813705", "bodyText": "It seems inside-out to make the framework class a nested class and the utilities be the top-level class.\nAlso, why is this an inner class rather than a static nested class?", "author": "mernst", "createdAt": "2020-03-29T15:33:10Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgxMzc5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r399813794", "bodyText": "Really, if it has an annotation of the given class.", "author": "mernst", "createdAt": "2020-03-29T15:33:41Z", "path": "framework/src/main/java/org/checkerframework/common/returnsrcvr/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.checkerframework.common.returnsrcvr.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsrcvr.ReturnsRcvrChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in returns receiver checker */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /** enum of supported frameworks */\n+    public enum Framework {\n+        /** Auto Value framework */\n+        AUTO_VALUE,\n+        /** LOMBOK framework */\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Determine the framework supports that should be disabled according to the flag {@code\n+     * disableFrameworkSupports}, return a EnumSet containing the framework supports in use\n+     *\n+     * @param option a comma-separated list of frameworks whose support should be disabled\n+     * @return an EnumSet of all framework supports in use\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFrameworkSupport.toUpperCase()) {\n+                    case ReturnsRcvrChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSet.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsRcvrChecker.LOMBOK_SUPPORT:\n+                        frameworkSet.remove(Framework.LOMBOK);\n+                        break;\n+                }\n+            }\n+        }\n+        return frameworkSet;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has the annotation", "originalCommit": "5c101f170c8891eaa9f1b58d492d3a4be0eb6236", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d13fe35aeee5b038c375da84e9377835b2dd5a84", "url": "https://github.com/typetools/checker-framework/commit/d13fe35aeee5b038c375da84e9377835b2dd5a84", "message": "Fixed contructor throw RuntimeException and javadoc", "committedDate": "2020-03-30T16:24:48Z", "type": "commit"}, {"oid": "fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "url": "https://github.com/typetools/checker-framework/commit/fd8c8609a4541267ce05fe26dd3ec335a2823ea4", "message": "fix misc-jdk8 and misc-jdk11", "committedDate": "2020-03-30T19:33:55Z", "type": "commit"}, {"oid": "85682f77cf4b561fb948799f672369f9238d2fd3", "url": "https://github.com/typetools/checker-framework/commit/85682f77cf4b561fb948799f672369f9238d2fd3", "message": "working on manual", "committedDate": "2020-04-01T17:28:07Z", "type": "commit"}, {"oid": "f897ece84d1d0742df8a5d44218f975ff0a800c0", "url": "https://github.com/typetools/checker-framework/commit/f897ece84d1d0742df8a5d44218f975ff0a800c0", "message": "pass on manual", "committedDate": "2020-04-01T17:38:52Z", "type": "commit"}, {"oid": "2c326d568f2b94e6e3417c27fefac8ad955dab9b", "url": "https://github.com/typetools/checker-framework/commit/2c326d568f2b94e6e3417c27fefac8ad955dab9b", "message": "changed framework support to enums", "committedDate": "2020-04-01T17:41:45Z", "type": "commit"}, {"oid": "65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "url": "https://github.com/typetools/checker-framework/commit/65e4454b2d36b6e9a6809ba9b1b2cbadb83aabfd", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-01T17:42:00Z", "type": "commit"}, {"oid": "748a84c18498ee263accd07d5107af4927db474d", "url": "https://github.com/typetools/checker-framework/commit/748a84c18498ee263accd07d5107af4927db474d", "message": "remove paragraph on disabling framework support", "committedDate": "2020-04-01T17:50:09Z", "type": "commit"}, {"oid": "30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "url": "https://github.com/typetools/checker-framework/commit/30c2d5eb1b0ae317c00bdd89d8fb5c96299d4d34", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-01T21:10:47Z", "type": "commit"}, {"oid": "d1c028fade3062f9cba9fbb3019984ca38b30171", "url": "https://github.com/typetools/checker-framework/commit/d1c028fade3062f9cba9fbb3019984ca38b30171", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-02T01:13:35Z", "type": "commit"}, {"oid": "482809a6694b522ffd7c97ca7676a5db936c4866", "url": "https://github.com/typetools/checker-framework/commit/482809a6694b522ffd7c97ca7676a5db936c4866", "message": "Rename MaybeThis to UnknownThis.\n\nThe name MaybeThis isn't bad, but the rest of the Checker Framework uses\nthe naming convention \"Unknown\" for the top type.", "committedDate": "2020-04-02T01:28:44Z", "type": "commit"}, {"oid": "cc7a321c3c288e4e3a377edf683fe8f0559b6026", "url": "https://github.com/typetools/checker-framework/commit/cc7a321c3c288e4e3a377edf683fe8f0559b6026", "message": "Improve Javadoc: add explanations, examples, links", "committedDate": "2020-04-02T01:51:44Z", "type": "commit"}, {"oid": "cf31b932ea22fb758a113f144732cb39bdab46fa", "url": "https://github.com/typetools/checker-framework/commit/cf31b932ea22fb758a113f144732cb39bdab46fa", "message": "Edits to manual section", "committedDate": "2020-04-02T02:17:57Z", "type": "commit"}, {"oid": "b8e6b7290aad40d59affcf1e0e2113be79188368", "url": "https://github.com/typetools/checker-framework/commit/b8e6b7290aad40d59affcf1e0e2113be79188368", "message": "Mention terminology \"fluent API\"", "committedDate": "2020-04-02T02:19:05Z", "type": "commit"}, {"oid": "941d35b64856461dca9c5ae04b253f3f9ec66b4e", "url": "https://github.com/typetools/checker-framework/commit/941d35b64856461dca9c5ae04b253f3f9ec66b4e", "message": "Tweak message", "committedDate": "2020-04-02T03:56:38Z", "type": "commit"}, {"oid": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "url": "https://github.com/typetools/checker-framework/commit/daafb8f1937dcf9ba1c78f58a69a675465cc62be", "message": "Edits from code review", "committedDate": "2020-04-02T05:19:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402277848", "bodyText": "I find it surprising that this block is skipped for constructors, but the above block is not.  What is the reason for the discrepancy?", "author": "mernst", "createdAt": "2020-04-02T12:34:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDUxODcxNw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r404518717", "bodyText": "Restructured the logic so both blocks are skipped for constructors", "author": "msridhar", "createdAt": "2020-04-07T03:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3Nzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODE4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278188", "bodyText": "Make a field like THIS_ANNOTATION.", "author": "mernst", "createdAt": "2020-04-02T12:35:29Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI3ODg3MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402278871", "bodyText": "If you move the supported frameworks block first in the method, then you can delete these lines as they will be redundant.", "author": "mernst", "createdAt": "2020-04-02T12:36:41Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Collection;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupport;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;\n+\n+    /** The supported frameworks (the built-in ones minus any that were disabled). */\n+    Collection<FrameworkSupport> frameworks;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        frameworks =\n+                FrameworkSupportUtils.getSupportedFrameworks(\n+                        checker.getOption(ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT));\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new ReturnsReceiverTypeAnnotator(this));\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+            AnnotationMirror unknownThisAnnot =\n+                    AnnotationBuilder.fromClass(elements, UnknownThis.class);\n+            AnnotationMirror retAnnotation = returnType.getAnnotationInHierarchy(unknownThisAnnot);\n+            if (retAnnotation != null && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                // add @This to the receiver type\n+                AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                receiverType.replaceAnnotation(THIS_ANNOTATION);\n+            }\n+\n+            // skip constructors\n+            if (!isConstructor(t)) {\n+                // check each supported framework\n+                for (FrameworkSupport frameworkSupport : frameworks) {\n+                    // see if the method in the framework should return this\n+                    if (frameworkSupport.returnsThis(t)) {\n+                        // add @This annotation\n+                        returnType.replaceAnnotation(THIS_ANNOTATION);\n+                        AnnotatedTypeMirror.AnnotatedDeclaredType receiverType =\n+                                t.getReceiverType();\n+                        receiverType.replaceAnnotation(THIS_ANNOTATION);", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MDQxOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402280419", "bodyText": "These comments are vacuous:  LOMBOK_SUPPORT is the string representation for LOMBOK_SUPPORT.\nUpon reading the code, I found out that these are the string representation of enum constants.\nIf so, they should be defined near the enum constants, not here in a different package.  Furthermore, there is no need for the enum constants.  It would be better to either iterate through the enum constants getting their toString representation.  (Or maybe create a method that takes a string and returns a matching enum constant.)\nBut, maybe these aren't needed at all if the Returns Receiver Checker doesn't need to support a --disableFrameworks command-line option.", "author": "mernst", "createdAt": "2020-04-02T12:39:12Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverChecker.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.source.SupportedOptions;\n+\n+/** Entry point for the Returns Receiver Checker. */\n+@SupportedOptions({ReturnsReceiverChecker.DISABLE_FRAMEWORK_SUPPORT})\n+public class ReturnsReceiverChecker extends BaseTypeChecker {\n+    /** String representation for DISABLE_FRAMEWORK_SUPPORTS. */\n+    public static final String DISABLE_FRAMEWORK_SUPPORT = \"disableFrameworks\";\n+    /** String representation for LOMBOK_SUPPORT. */", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MTE0OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402281148", "bodyText": "This is a weird name.  What is a \"FrameworkSupport\"?  Each class should represent some clearly-defined concept.\nHere, I think that concept is a framework.  You could name this IFramework, but it would be better to structure the code not to need this class.", "author": "mernst", "createdAt": "2020-04-02T12:40:32Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/**\n+ * A framework supported by the Returns Receiver Checker. That is, some methods generated by the\n+ * framework return their receiver.\n+ */\n+public interface FrameworkSupport {", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4MjI2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402282266", "bodyText": "How can the return type be null?\nI think it would be a bug in this method if inAnnotationValueBuilder is true but returnType is null.  In that case, I think it's better to throw an exception.  The same comment applies later in this file.", "author": "mernst", "createdAt": "2020-04-02T12:42:28Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework implements FrameworkSupport {\n+    /** AutoValue framework. */\n+    AUTO_VALUE {\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    FrameworkSupportUtils.hasAnnotation(enclosingElement, AutoValue.Builder.class);\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code\n+                TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                // if enclosingType is an interface, the superclass has TypeKind NONE\n+                if (superclass.getKind() != TypeKind.NONE) {\n+                    // update enclosingElement to be for the superclass for this case\n+                    enclosingElement = TypesUtils.getTypeElement(superclass);\n+                    inAutoValueBuilder =\n+                            enclosingElement.getAnnotation(AutoValue.Builder.class) != null;\n+                }\n+            }\n+\n+            if (inAutoValueBuilder) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+                return returnType != null", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDA5OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284098", "bodyText": "There is no documentation of this in the manual.  It should either be documented or removed.  I thought we agreed to remove it, so I'm not sure why it is still here in the code.\nIf it is retained, this logic belongs in the checker, not here in a separate package, because it is logically part of the checker.", "author": "mernst", "createdAt": "2020-04-02T12:45:27Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284572", "bodyText": "Eliminate these constant values and instead iterate through all frameworks, using their toString representation.", "author": "mernst", "createdAt": "2020-04-02T12:46:20Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI4NDkxMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402284912", "bodyText": "What is the point of using an ArrayDeque, which is a more expensive data structure than an EnumSet?", "author": "mernst", "createdAt": "2020-04-02T12:46:55Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjMwMTI5Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r402301297", "bodyText": "Can you use the containsSameByClass method from AnnotationUtils or from AnnotatedTypeFactory?\nSame question for the implementation below (AnnotatedTypeFactory has no containsSameByName, but we could add it if needed).", "author": "mernst", "createdAt": "2020-04-02T13:12:50Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayDeque;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {\n+\n+    /** this class is non-instantiable */\n+    private FrameworkSupportUtils() {\n+        throw new RuntimeException();\n+    }\n+\n+    /**\n+     * Return which frameworks should be supported, respecting the command-line argument {@code\n+     * --disableFrameworkSupport}.\n+     *\n+     * @param disabledFrameworks a comma-separated list of frameworks whose support should be\n+     *     disabled; may be null\n+     * @return the frameworks supported by this instantiation of the Returns Receiver Checker\n+     */\n+    public static Collection<FrameworkSupport> getSupportedFrameworks(String disabledFrameworks) {\n+        Collection<FrameworkSupport> frameworkSupports =\n+                new ArrayDeque<>(EnumSet.allOf(Framework.class));\n+\n+        if (disabledFrameworks != null) {\n+            for (String disabledFramework : disabledFrameworks.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFramework.toUpperCase()) {\n+                    case ReturnsReceiverChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSupports.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case ReturnsReceiverChecker.LOMBOK_SUPPORT:\n+                        frameworkSupports.remove(Framework.LOMBOK);\n+                        break;\n+                    default:\n+                        throw new UserError(\n+                                \"Unrecognized framework in --disabledFrameworkSupport: \"\n+                                        + disabledFrameworks);\n+                }\n+            }\n+        }\n+        return frameworkSupports;\n+    }\n+\n+    /**\n+     * Given an annotation class, return true if the element has an annotation of that class.\n+     *\n+     * @param element the element that might have an annotation\n+     * @param annotClass the class of the annotation that might be present\n+     * @return true if the element has the annotation\n+     */\n+    public static boolean hasAnnotation(Element element, Class<? extends Annotation> annotClass) {\n+        return element.getAnnotationMirrors().stream()", "originalCommit": "daafb8f1937dcf9ba1c78f58a69a675465cc62be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "url": "https://github.com/typetools/checker-framework/commit/fa3c48b363b6f243f9a98ccf356324f8f9d1cdae", "message": "Update changelog", "committedDate": "2020-04-02T19:28:31Z", "type": "commit"}, {"oid": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "url": "https://github.com/typetools/checker-framework/commit/84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "message": "removed frameworkSupport Interface and resolved comments", "committedDate": "2020-04-03T07:28:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1NTM5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403055390", "bodyText": "The fields in this class should have visibility modifiers.\nCan they be final?", "author": "wmdietl", "createdAt": "2020-04-03T14:42:39Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.framework.Framework;\n+import org.checkerframework.common.returnsreceiver.framework.FrameworkSupportUtils;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    AnnotationMirror THIS_ANNOTATION;", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403061882", "bodyText": "Note that this only validates explicit annotations in source code.\nYou could instead validate all methods/fields to ensure correct usage to also ensure stub files are correct.", "author": "wmdietl", "createdAt": "2020-04-03T14:52:05Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.tools.Diagnostic;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.framework.source.DiagMessage;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTExODU4MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405118581", "bodyText": "@wmdietl can we handle validation of stub files in a follow-up task?  I'm afraid we will end up going down a bit of a rabbit hole if we do that here (what about classes?  or generic type arguments?).  Or maybe I am misunderstanding and it's a simple change?", "author": "msridhar", "createdAt": "2020-04-07T21:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTM0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455345", "bodyText": "Sure. Maybe we don't have a nice way to validate executable types at the moment. So maybe file a follow-up issue.", "author": "wmdietl", "createdAt": "2020-04-17T20:31:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4Mjc2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413182766", "bodyText": "Will file the follow-up after this lands", "author": "msridhar", "createdAt": "2020-04-22T17:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2MTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NDY0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403064645", "bodyText": "Framework is a very vague name. Could you find a better name? SupportedReturnsReceiverSpecialCases is a bit long.", "author": "wmdietl", "createdAt": "2020-04-03T14:55:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/Framework.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import com.google.auto.value.AutoValue;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Enum of supported frameworks. */\n+public enum Framework {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403066661", "bodyText": "Is this class really worth it?\ngetSupportedFrameworks could be in Frameworks and the other two methods are very simple wrappers. (And I would like to remove the version that uses a Class, to not require a compile-time dependency on each framework.)", "author": "wmdietl", "createdAt": "2020-04-03T14:58:36Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package org.checkerframework.common.returnsreceiver.framework;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class for framework support in the Returns Receiver Checker. */\n+public class FrameworkSupportUtils {", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzEyMTQyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403121421", "bodyText": "I agree this class is not worth it.  @wmdietl I think hasAnnotation and hasAnnotationByName belong in some other Checker Framework utility class, if they are not already there.  Do you have a suggestion on where they should go, or whether they should just be inlined?", "author": "msridhar", "createdAt": "2020-04-03T16:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2NjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403067780", "bodyText": "Is there a reason to use the top type for null, Void, or lower bounds? It would be more standard to use the bottom type for these locations.", "author": "wmdietl", "createdAt": "2020-04-03T15:00:06Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/UnknownThis.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.*;\n+\n+/**\n+ * The top type for the Returns Receiver Checker's type system. Values of the annotated type might\n+ * be the receiver ({@code this}) or might not. Programmers should rarely write this type.\n+ *\n+ * @checker_framework.manual #returns-receiver-checker Returns Receiver Checker\n+ */\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})\n+@DefaultQualifierInHierarchy\n+@SubtypeOf({})\n+@QualifierForLiterals(LiteralKind.NULL)", "originalCommit": "84a3798e6d70ac1c553f88bf95d5929b93e8ad12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzExNDE5NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r403114194", "bodyText": "For null, we want to get an error for code like this (from a test):\n        @This B dontRetThis() {\n            // :: error: return.type.incompatible\n            return null;\n        }\nWithout using the top type for null we don't get an error.\nFor Void and lower bounds, I am less sure, but I'm pretty confident weird errors showed up in large benchmarks that motivated these additions.  I can try to track those down and add corresponding unit tests.", "author": "msridhar", "createdAt": "2020-04-03T16:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1MTExNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405251116", "bodyText": "Looked into this.  Because we want to use the top type for null, we also need to use it for generic type lower bounds.  Otherwise, the GenericNull test case from the all-systems tests fails.  I could not find a case where using @UnknownThis for Void was required, so I removed that.", "author": "msridhar", "createdAt": "2020-04-08T04:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NzY5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406377690", "bodyText": "Void can't be initialized, so its type probably doesn't matter.", "author": "kelloggm", "createdAt": "2020-04-09T17:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA2Nzc4MA=="}], "type": "inlineReview"}, {"oid": "acfb71a082e2aa5ed579bcad04447d36be7ef724", "url": "https://github.com/typetools/checker-framework/commit/acfb71a082e2aa5ed579bcad04447d36be7ef724", "message": "Don't replace existing annotations.", "committedDate": "2020-04-05T18:20:05Z", "type": "commit"}, {"oid": "d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "url": "https://github.com/typetools/checker-framework/commit/d7baf84d2ae3a3ffa40f1df39ff5215f7206ccf0", "message": "fix misc_jdk8", "committedDate": "2020-04-06T02:20:13Z", "type": "commit"}, {"oid": "b51b9199f33112538d3ecad583c7934248b13495", "url": "https://github.com/typetools/checker-framework/commit/b51b9199f33112538d3ecad583c7934248b13495", "message": "removed FrameworkSupportUtils", "committedDate": "2020-04-06T23:24:54Z", "type": "commit"}, {"oid": "71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "url": "https://github.com/typetools/checker-framework/commit/71b5578d5cff91a4a1553eb2ed5a14dc671c9795", "message": "removed dependecies to AutoValue", "committedDate": "2020-04-07T01:36:46Z", "type": "commit"}, {"oid": "606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "url": "https://github.com/typetools/checker-framework/commit/606a7a14aee1fe93c4c80fee489df5a8f7d290e7", "message": "clean up some logic in type factory", "committedDate": "2020-04-07T03:46:33Z", "type": "commit"}, {"oid": "fe7036cc37fd2929169301e3543ee7aa128683a1", "url": "https://github.com/typetools/checker-framework/commit/fe7036cc37fd2929169301e3543ee7aa128683a1", "message": "fixed modifiers", "committedDate": "2020-04-07T17:18:28Z", "type": "commit"}, {"oid": "d54fc10e5111d30df096277d11619b70e1c478bd", "url": "https://github.com/typetools/checker-framework/commit/d54fc10e5111d30df096277d11619b70e1c478bd", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-07T17:18:45Z", "type": "commit"}, {"oid": "a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "url": "https://github.com/typetools/checker-framework/commit/a3d574a36e96ba5441a729f3cc82b4c87f2179ce", "message": "test that @This annotations are actually getting inserted", "committedDate": "2020-04-08T00:05:29Z", "type": "commit"}, {"oid": "85b047f3fc43707a1f1db671f92bfaf1d50729fb", "url": "https://github.com/typetools/checker-framework/commit/85b047f3fc43707a1f1db671f92bfaf1d50729fb", "message": "fixed framesupport name & fixed AutoValue string", "committedDate": "2020-04-08T00:54:16Z", "type": "commit"}, {"oid": "96ba71365267951399a1b0314d89d9c7460bd92d", "url": "https://github.com/typetools/checker-framework/commit/96ba71365267951399a1b0314d89d9c7460bd92d", "message": "don't make @UnknownThis default for Void", "committedDate": "2020-04-08T04:25:16Z", "type": "commit"}, {"oid": "8235bfe8873bd936ef456dcbb1996b3e1239c24f", "url": "https://github.com/typetools/checker-framework/commit/8235bfe8873bd936ef456dcbb1996b3e1239c24f", "message": "fix javadoc and variable names", "committedDate": "2020-04-08T04:34:21Z", "type": "commit"}, {"oid": "319154ff04a573308c2589fbdf61281ca2fb86fa", "url": "https://github.com/typetools/checker-framework/commit/319154ff04a573308c2589fbdf61281ca2fb86fa", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-08T05:06:12Z", "type": "commit"}, {"oid": "74d8beb7b29d1acdb2eed153f6796020e594f9fd", "url": "https://github.com/typetools/checker-framework/commit/74d8beb7b29d1acdb2eed153f6796020e594f9fd", "message": "Don't make a package for just one file", "committedDate": "2020-04-08T05:10:41Z", "type": "commit"}, {"oid": "b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "url": "https://github.com/typetools/checker-framework/commit/b1c71dd1ed17252292e9afdb2c8194ed1f47dd53", "message": "javadoc", "committedDate": "2020-04-08T16:08:14Z", "type": "commit"}, {"oid": "f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "url": "https://github.com/typetools/checker-framework/commit/f7eb1483dfa88db86fb4103e9feff8a0eab619c9", "message": "narrow visibility", "committedDate": "2020-04-08T16:11:58Z", "type": "commit"}, {"oid": "87ce086428cbe7931c5964e77f3c7999598d049a", "url": "https://github.com/typetools/checker-framework/commit/87ce086428cbe7931c5964e77f3c7999598d049a", "message": "Code review improvements", "committedDate": "2020-04-08T16:16:35Z", "type": "commit"}, {"oid": "15c4a33975b813a0efa9fbee05ca7a1633adca9a", "url": "https://github.com/typetools/checker-framework/commit/15c4a33975b813a0efa9fbee05ca7a1633adca9a", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-08T16:17:15Z", "type": "commit"}, {"oid": "45df4580377cef06691e8476aa03042e5d6c208b", "url": "https://github.com/typetools/checker-framework/commit/45df4580377cef06691e8476aa03042e5d6c208b", "message": "Code review improvements", "committedDate": "2020-04-08T16:20:35Z", "type": "commit"}, {"oid": "3b9d77c45ecbf32674f6dce632616c3687786485", "url": "https://github.com/typetools/checker-framework/commit/3b9d77c45ecbf32674f6dce632616c3687786485", "message": "Punctuation", "committedDate": "2020-04-08T16:28:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTQ1NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405651454", "bodyText": "This code doesn't care about the existence of the FluentAPIGenerator class.  I would be inclined to create a method returnsThis and put the for loop within it.  Then the FluentAPIGenerator enum can be private, since it is only used by that method.", "author": "mernst", "createdAt": "2020-04-08T16:23:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.EnumSet;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                for (FluentAPIGenerator fluentAPIGenerator :", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MjA4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405652087", "bodyText": "It is inconsistent that this code uses getAnnotationByName but the below code uses containsSameByName.", "author": "mernst", "createdAt": "2020-04-08T16:24:35Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzgxMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405653812", "bodyText": "Could you clarify this comment?  Is code generated if the superclass is an AutoValue builder, or if the superclass is not?  What is done with generated code:  ignore it, or be sure to process it too?", "author": "mernst", "createdAt": "2020-04-08T16:27:08Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+        @Override\n+        public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+            ExecutableElement element = t.getElement();\n+            Element enclosingElement = element.getEnclosingElement();\n+            boolean inAutoValueBuilder =\n+                    AnnotationUtils.getAnnotationByName(\n+                                    enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER)\n+                            != null;\n+\n+            if (!inAutoValueBuilder) {\n+                // see if superclass is an AutoValue Builder, to handle generated code", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1NDIyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r405654229", "bodyText": "Could you document this field?", "author": "mernst", "createdAt": "2020-04-08T16:27:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * Enum of supported fluent API generators. For such generators, the checker can automatically\n+ * add @This annotations on method return types in the generated code.\n+ */\n+public enum FluentAPIGenerator {\n+    /**\n+     * The <a\n+     * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+     * framework.\n+     */\n+    AUTO_VALUE {\n+\n+        private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();", "originalCommit": "45df4580377cef06691e8476aa03042e5d6c208b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "url": "https://github.com/typetools/checker-framework/commit/4941b9e27b1872a2f2b0367fb3877c48fe1fcf22", "message": "wrapped FluentAPIGenerators", "committedDate": "2020-04-08T18:40:48Z", "type": "commit"}, {"oid": "92ea24988903262e7a706c9b172c9a2ba2e0d578", "url": "https://github.com/typetools/checker-framework/commit/92ea24988903262e7a706c9b172c9a2ba2e0d578", "message": "fixed javadoc", "committedDate": "2020-04-08T19:08:07Z", "type": "commit"}, {"oid": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "url": "https://github.com/typetools/checker-framework/commit/5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "message": "added documantion for AUTO_VALUE_BUILDER field", "committedDate": "2020-04-08T19:21:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MTgyNA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406371824", "bodyText": "nit: \"due to a side effect\"", "author": "kelloggm", "createdAt": "2020-04-09T17:45:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MjQ5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406372490", "bodyText": "Nit: this code would be easier to read if you imported AnnotatedExecutableType directly rather than qualifying it everywhere it appears. Most of the other code in the CF uses that style.", "author": "kelloggm", "createdAt": "2020-04-09T17:46:59Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzAxOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373018", "bodyText": "Why RuntimeException rather than BugInCF?", "author": "kelloggm", "createdAt": "2020-04-09T17:47:54Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3MzgwMg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406373802", "bodyText": "same question about RuntimeException vs BugInCF", "author": "kelloggm", "createdAt": "2020-04-09T17:49:12Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDI0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374245", "bodyText": "Nit: t is the annotated type of the method signature, not the method itself (which would be an ExecutableElement, probably)", "author": "kelloggm", "createdAt": "2020-04-09T17:49:59Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NDU0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406374541", "bodyText": "Same comment as above about t", "author": "kelloggm", "createdAt": "2020-04-09T17:50:31Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3NTEzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406375139", "bodyText": "It is better style to always use { and } to surround the body of an if, even if it is one statement, because the code might change later to include multiple statements.", "author": "kelloggm", "createdAt": "2020-04-09T17:51:35Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,125 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new RuntimeException(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the method to check\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the method to check\n+     * @return {@code true} if the method was created by any of the generators defined in {@link\n+     *     FluentAPIGenerators} and returns {@code this}\n+     */\n+    public static boolean checkForFluentAPIGenerators(\n+            AnnotatedTypeMirror.AnnotatedExecutableType t) {\n+        for (FluentAPIGenerators fluentAPIGenerator : FluentAPIGenerators.values()) {\n+            if (fluentAPIGenerator.returnsThis(t)) return true;", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODE3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378172", "bodyText": "Please add a Javadoc comment for this test", "author": "kelloggm", "createdAt": "2020-04-09T17:56:54Z", "path": "framework/src/test/java/tests/ReturnsReceiverAutoValueTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tests;\n+\n+import static org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.List;\n+import org.checkerframework.framework.test.*;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+public class ReturnsReceiverAutoValueTest extends CheckerFrameworkPerDirectoryTest {", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378559", "bodyText": "This comment is no longer accurate. It can be shortened to just \"tests the returns receiver checker's lombok integration\" or similar", "author": "kelloggm", "createdAt": "2020-04-09T17:57:29Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/lombok} folder. To add a new test case, create\n+ * a Java file in that directory. The file contains \"// ::\" comments to indicate expected errors and\n+ * warnings; see https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODc3NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406378774", "bodyText": "It probably ought to also mention that the test files have been delomobok'd", "author": "kelloggm", "createdAt": "2020-04-09T17:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3ODU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjM3OTE3Mw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r406379173", "bodyText": "We probably don't need this comment here anymore. If nothing else, please change the link so that it's no longer a URL, since these are now in the same repo.", "author": "kelloggm", "createdAt": "2020-04-09T17:58:35Z", "path": "framework/src/test/java/tests/ReturnsReceiverTest.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * Test runner for tests of the Returns Receiver Checker.\n+ *\n+ * <p>Tests appear as Java files in the {@code tests/returnsreceiver} folder. To add a new test\n+ * case, create a Java file in that directory. The file contains \"// ::\" comments to indicate\n+ * expected errors and warnings; see\n+ * https://github.com/typetools/checker-framework/blob/master/checker/tests/README .\n+ */", "originalCommit": "5dcec62aa155fee6bc3adce0aebc5cdf7b59c444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8484e84d32c6915f92ff03a62ef31812bc176f4b", "url": "https://github.com/typetools/checker-framework/commit/8484e84d32c6915f92ff03a62ef31812bc176f4b", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-09T21:59:55Z", "type": "commit"}, {"oid": "c99ff12b206151524b2d5941b91ae42664f359a0", "url": "https://github.com/typetools/checker-framework/commit/c99ff12b206151524b2d5941b91ae42664f359a0", "message": "Merge branch 'returnsrcvr-checker' of github.com:nimakarimipour/checker-framework into returnsrcvr-checker", "committedDate": "2020-04-09T22:00:36Z", "type": "commit"}, {"oid": "1fc75ded7470e0022c3d543df066fb9f88fe05da", "url": "https://github.com/typetools/checker-framework/commit/1fc75ded7470e0022c3d543df066fb9f88fe05da", "message": "fixed comments", "committedDate": "2020-04-10T22:23:36Z", "type": "commit"}, {"oid": "6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "url": "https://github.com/typetools/checker-framework/commit/6b55daa298f92d79a2e0e0bfbaff34ee4438dcca", "message": "Merge ../checker-framework-branch-master into returnsrcvr-checker", "committedDate": "2020-04-13T20:11:18Z", "type": "commit"}, {"oid": "acada3aca97257d8cb6d01b80c6df509ea6ec91f", "url": "https://github.com/typetools/checker-framework/commit/acada3aca97257d8cb6d01b80c6df509ea6ec91f", "message": "added delombok task", "committedDate": "2020-04-13T23:05:33Z", "type": "commit"}, {"oid": "44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "url": "https://github.com/typetools/checker-framework/commit/44d3d96f8da307f1b2341db94e7c79ad5bad02a6", "message": "cleaned build.gradle file", "committedDate": "2020-04-13T23:12:11Z", "type": "commit"}, {"oid": "d9bab392b39000a5a6973ac69050271684d91d0a", "url": "https://github.com/typetools/checker-framework/commit/d9bab392b39000a5a6973ac69050271684d91d0a", "message": "added newLine for framework/build.gradle", "committedDate": "2020-04-14T00:29:30Z", "type": "commit"}, {"oid": "7995c9e095d48f3297d8d8091a01b567a64c85f7", "url": "https://github.com/typetools/checker-framework/commit/7995c9e095d48f3297d8d8091a01b567a64c85f7", "message": "test configurations", "committedDate": "2020-04-14T01:29:48Z", "type": "commit"}, {"oid": "aceac536d09448a02432560d9cc05414f03ce8a6", "url": "https://github.com/typetools/checker-framework/commit/aceac536d09448a02432560d9cc05414f03ce8a6", "message": "added wrapper methods and fixed gradle cache for delombok task", "committedDate": "2020-04-14T21:48:07Z", "type": "commit"}, {"oid": "199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "url": "https://github.com/typetools/checker-framework/commit/199665ad2a8bdcd78eee07f8bcc1029ba98736e6", "message": "Run delombok as an action, not during configuration time", "committedDate": "2020-04-14T22:29:08Z", "type": "commit"}, {"oid": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "url": "https://github.com/typetools/checker-framework/commit/a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "message": "switch to using testCompileClasspath in delombok task", "committedDate": "2020-04-14T22:51:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDAyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510029", "bodyText": "not -> note\nAlso, I think this comment needs to be updated given the new strategy for delombok'ing the tests.", "author": "kelloggm", "createdAt": "2020-04-15T00:21:13Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, please not that the test files have been", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMDg0MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408510840", "bodyText": "These two builders are not \"good\" - they're both incorrect. That comment looks like a holdover from the Object Construction Checker, and should be removed.", "author": "kelloggm", "createdAt": "2020-04-15T00:23:51Z", "path": "framework/tests/returnsreceiverlombok/BuilderTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderTest {\n+    @Getter @Setter private Integer x;\n+    @Getter @Setter @NonNull private Integer y;\n+    @Getter @Setter @NonNull private Integer z;\n+\n+    public static void test_simplePattern() {\n+        BuilderTest.builder().x(0).y(0).build(); // good builder\n+        BuilderTest.builder().y(0).build(); // good builder", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r408512054", "bodyText": "@kelloggm this subclass has the wrapper methods that ensure that @This annotations are getting inserted correctly for Lombok.  I think this should be sufficient for testing, but let us know if you think they belong elsewhere or need better documentation", "author": "msridhar", "createdAt": "2020-04-15T00:27:54Z", "path": "framework/tests/returnsreceiverlombok/BuilderMethodRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+import java.util.Optional;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import org.checkerframework.common.returnsreceiver.qual.*;\n+\n+@Builder\n+@Accessors(fluent = true)\n+public class BuilderMethodRef {\n+    @Getter @Setter @lombok.NonNull String foo;\n+    @Getter @Setter Object bar;\n+\n+    public static void test(Optional<Object> opt) {\n+        BuilderMethodRefBuilder b = builder().foo(\"Hello\");\n+        opt.ifPresent(b::bar);\n+        b.build();\n+    }\n+}\n+\n+class CustomBuilderMethodRefBuilder extends BuilderMethodRef.BuilderMethodRefBuilder {", "originalCommit": "a579e01e8d77eb54388b2fe9fc8b82dd9bc56b2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTExMDA2MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409110060", "bodyText": "These are great. My comment wasn't clear, but I was referring to framework/tests/returnsreceiverlombok/BuilderTest.java, which doesn't test anything other than that the RR checker issues no error on that file. It should check that the setters have @This annotations, too.", "author": "kelloggm", "createdAt": "2020-04-15T20:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2NzU3NA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409167574", "bodyText": "Now added", "author": "msridhar", "createdAt": "2020-04-15T22:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODEwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r409168105", "bodyText": "BTW, these extra tests are how we discovered the need for the extra flag for Lombok.  So they are definitely useful \ud83d\udc4d", "author": "msridhar", "createdAt": "2020-04-15T22:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxMjA1NA=="}], "type": "inlineReview"}, {"oid": "b879b77b7fde9edd496e668100611e9caafa0f68", "url": "https://github.com/typetools/checker-framework/commit/b879b77b7fde9edd496e668100611e9caafa0f68", "message": "fixed comment", "committedDate": "2020-04-15T17:55:45Z", "type": "commit"}, {"oid": "f67c44be28b04af2e1602cf6afa046d1281086b7", "url": "https://github.com/typetools/checker-framework/commit/f67c44be28b04af2e1602cf6afa046d1281086b7", "message": "Added wrapper methods", "committedDate": "2020-04-15T21:10:40Z", "type": "commit"}, {"oid": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "url": "https://github.com/typetools/checker-framework/commit/505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-16T20:52:07Z", "type": "commit"}, {"oid": "9ac96286a2c944ce7b0929bba4dc487e69521bd9", "url": "https://github.com/typetools/checker-framework/commit/9ac96286a2c944ce7b0929bba4dc487e69521bd9", "message": "Fix capitalization.", "committedDate": "2020-04-17T20:45:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444033", "bodyText": "Documentation of the public purpose of this class would still be useful... is this meant as an opaque token?", "author": "wmdietl", "createdAt": "2020-04-17T20:06:06Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODA5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448092", "bodyText": "The point of the class seems to be method checkForFluentAPIGenerators. So I would have liked to see a documentation of that, not the implementation detail about the enum.", "author": "wmdietl", "createdAt": "2020-04-17T20:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0ODk4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410448987", "bodyText": "(I'm also not sure whether I would repeat the class name in the method name... instead of FluentAPIGenerator.checkForFluentAPIGenerators isn't FluentAPIGenerator.check simpler and as clear?)", "author": "wmdietl", "createdAt": "2020-04-17T20:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MzQ2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410463466", "bodyText": "You could also move the method to the beginning of the class...", "author": "wmdietl", "createdAt": "2020-04-17T20:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NDU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410444572", "bodyText": "Should the needed instead be needs?", "author": "wmdietl", "createdAt": "2020-04-17T20:07:24Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NTUzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410445531", "bodyText": "Should enclosingType be enclosingElement or something else?", "author": "wmdietl", "createdAt": "2020-04-17T20:09:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTI0OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449249", "bodyText": "This is the only public method for this class and should be documented.", "author": "wmdietl", "createdAt": "2020-04-17T20:18:00Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/FluentAPIGenerator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/** Wrapper class for {@link FluentAPIGenerators} Enum to keep it private. */\n+public class FluentAPIGenerator {\n+\n+    /**\n+     * Enum of supported fluent API generators. For such generators, the checker can automatically\n+     * add @This annotations on method return types in the generated code.\n+     */\n+    private enum FluentAPIGenerators {\n+        /**\n+         * The <a\n+         * href=\"https://github.com/google/auto/blob/master/value/userguide/builders.md\">AutoValue</a>\n+         * framework.\n+         */\n+        AUTO_VALUE {\n+\n+            /**\n+             * The qualified name of the AutoValue Builder annotation. This needed to be constructed\n+             * dynamically due to a side effect of the shadow plugin. See {@link\n+             * org.checkerframework.common.returnsreceiver.FluentAPIGenerator.FluentAPIGenerators#AUTO_VALUE#getAutoValueBuilderCanonicalName()}\n+             * for more information.\n+             */\n+            private final String AUTO_VALUE_BUILDER = getAutoValueBuilderCanonicalName();\n+\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inAutoValueBuilder =\n+                        AnnotationUtils.containsSameByName(\n+                                enclosingElement.getAnnotationMirrors(), AUTO_VALUE_BUILDER);\n+\n+                if (!inAutoValueBuilder) {\n+                    // see if superclass is an AutoValue Builder, to handle generated code\n+                    TypeMirror superclass = ((TypeElement) enclosingElement).getSuperclass();\n+                    // if enclosingType is an interface, the superclass has TypeKind NONE\n+                    if (superclass.getKind() != TypeKind.NONE) {\n+                        // update enclosingElement to be for the superclass for this case\n+                        enclosingElement = TypesUtils.getTypeElement(superclass);\n+                        inAutoValueBuilder =\n+                                AnnotationUtils.containsSameByName(\n+                                        enclosingElement.getAnnotationMirrors(),\n+                                        AUTO_VALUE_BUILDER);\n+                    }\n+                }\n+\n+                if (inAutoValueBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+\n+            /**\n+             * Get the qualified name of the AutoValue Builder annotation. This method constructs\n+             * the String dynamically, to ensure it does not get rewritten due to relocation of the\n+             * {@code \"com.google\"} package during the build process.\n+             *\n+             * @return {@code \"com.google.auto.value.AutoValue.Builder\"}\n+             */\n+            private String getAutoValueBuilderCanonicalName() {\n+                String com = \"com\";\n+                return com + \".\" + \"google.auto.value.AutoValue.Builder\";\n+            }\n+        },\n+        /** <a href=\"https://projectlombok.org/features/Builder\">Project Lombok</a>. */\n+        LOMBOK {\n+            @Override\n+            public boolean returnsThis(AnnotatedExecutableType t) {\n+                ExecutableElement element = t.getElement();\n+                Element enclosingElement = element.getEnclosingElement();\n+                boolean inLombokBuilder =\n+                        (AnnotationUtils.containsSameByName(\n+                                                enclosingElement.getAnnotationMirrors(),\n+                                                \"lombok.Generated\")\n+                                        || AnnotationUtils.containsSameByName(\n+                                                element.getAnnotationMirrors(), \"lombok.Generated\"))\n+                                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\");\n+\n+                if (inLombokBuilder) {\n+                    AnnotatedTypeMirror returnType = t.getReturnType();\n+                    if (returnType == null) {\n+                        throw new BugInCF(\"Return type cannot be null: \" + t);\n+                    }\n+                    return enclosingElement.equals(\n+                            TypesUtils.getTypeElement(returnType.getUnderlyingType()));\n+                }\n+                return false;\n+            }\n+        };\n+\n+        /**\n+         * @param t the annotated type of the method signature\n+         * @return {@code true} if the method was created by this generator and returns {@code this}\n+         */\n+        protected abstract boolean returnsThis(AnnotatedExecutableType t);\n+    }\n+\n+    /**\n+     * @param t the annotated type of the method signature", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410449511", "bodyText": "Why does this need to be package private? Could it be protected or even private?", "author": "wmdietl", "createdAt": "2020-04-17T20:18:30Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDA2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410464062", "bodyText": "I see one usage outside this package, which could just use areSameByClass...\nat least add a comment why you used package private.", "author": "wmdietl", "createdAt": "2020-04-17T20:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDY3Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410450677", "bodyText": "Why not simply return if it's a constructor? That makes the intent even clearer and reduces the indentation for the rest of the method.", "author": "wmdietl", "createdAt": "2020-04-17T20:20:53Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MTk5MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410451990", "bodyText": "Why do you need this special logic?\nCouldn't you simply add @DefaultFor({TypeUseLocation.RECEIVER}) to the declaration of @This?\nAll receivers are @This. The only extra logic you need is to automatically make the fluent API return types @This.", "author": "wmdietl", "createdAt": "2020-04-17T20:23:46Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MzQyNw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410453427", "bodyText": "There is a single use of this method.\nWouldn't it be much simpler to simply write if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) { return; } above? (Addressing my earlier comment about returning early.)", "author": "wmdietl", "createdAt": "2020-04-17T20:26:58Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (!isConstructor(t)) {\n+                AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+                // If any FluentAPIGenerator indicates the method returns this,\n+                // add an @This annotation on the return type.\n+                if (FluentAPIGenerator.checkForFluentAPIGenerators(t)) {\n+                    if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        returnType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+\n+                // If return type is annotated with @This, add @This annotation\n+                // to the receiver type.\n+                AnnotationMirror retAnnotation =\n+                        returnType.getAnnotationInHierarchy(THIS_ANNOTATION);\n+                if (retAnnotation != null\n+                        && AnnotationUtils.areSame(retAnnotation, THIS_ANNOTATION)) {\n+                    AnnotatedTypeMirror.AnnotatedDeclaredType receiverType = t.getReceiverType();\n+                    if (!receiverType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                        receiverType.addAnnotation(THIS_ANNOTATION);\n+                    }\n+                }\n+            }\n+            return super.visitExecutable(t, p);\n+        }\n+    }\n+\n+    /**\n+     * @return {@code true} if the param {@code t} is a {@code Constructor}\n+     * @param t a {@link AnnotatedTypeMirror}\n+     */\n+    private boolean isConstructor(AnnotatedTypeMirror.AnnotatedExecutableType t) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410455739", "bodyText": "I find !isReturn && !isCastAnnot easier to look at visually and easier to understand... but you might prefer this way.", "author": "wmdietl", "createdAt": "2020-04-17T20:32:31Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverVisitor.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import com.sun.source.tree.*;\n+import com.sun.source.util.TreePath;\n+import javax.lang.model.element.AnnotationMirror;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.basetype.BaseTypeVisitor;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The visitor for the Returns Receiver Checker. */\n+public class ReturnsReceiverVisitor extends BaseTypeVisitor<ReturnsReceiverAnnotatedTypeFactory> {\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverVisitor}.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public ReturnsReceiverVisitor(BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitAnnotation(AnnotationTree node, Void p) {\n+        AnnotationMirror annot = TreeUtils.annotationFromAnnotationTree(node);\n+        // Warn if a @This annotation is in an illegal location.\n+        if (AnnotationUtils.areSame(annot, getTypeFactory().THIS_ANNOTATION)) {\n+            TreePath parentPath = getCurrentPath().getParentPath();\n+            Tree parent = parentPath.getLeaf();\n+            Tree grandparent = parentPath.getParentPath().getLeaf();\n+            boolean isReturnAnnot =\n+                    grandparent instanceof MethodTree\n+                            && (parent.equals(((MethodTree) grandparent).getReturnType())\n+                                    || parent instanceof ModifiersTree);\n+            boolean isCastAnnot =\n+                    grandparent instanceof TypeCastTree\n+                            && parent.equals(((TypeCastTree) grandparent).getType());\n+            if (!(isReturnAnnot || isCastAnnot)) {", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM2OTQ1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412369456", "bodyText": "I personally like it this way \ud83d\ude42 I think we will leave it", "author": "msridhar", "createdAt": "2020-04-21T17:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDc5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413404799", "bodyText": "Sure, no objection.", "author": "wmdietl", "createdAt": "2020-04-22T23:38:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1NTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1OTY4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410459687", "bodyText": "value -> type", "author": "wmdietl", "createdAt": "2020-04-17T20:42:18Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410460189", "bodyText": "Instead of putting it so operationally, why not make this simply a default for all receivers.\nIs there any harm if they are always @This?\nIs there any harm in allowing programmers to explicitly mark receivers @This?", "author": "wmdietl", "createdAt": "2020-04-17T20:43:29Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/qual/This.java", "diffHunk": "@@ -0,0 +1,39 @@\n+package org.checkerframework.common.returnsreceiver.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import org.checkerframework.framework.qual.PolymorphicQualifier;\n+\n+/**\n+ * Write {@code @This} on the return type of a method that always returns its receiver ({@code\n+ * this}). For example:\n+ *\n+ * <pre><code>\n+ * class MyBuilder {\n+ *   &#064;This MyBuilder setName(String name) {\n+ *     this.name = name;\n+ *     return this;\n+ *   }\n+ * }\n+ * </code></pre>\n+ *\n+ * Strictly speaking, this is a polymorphic annotation, but when you write it on a return value, the\n+ * Returns Receiver Checker automatically adds it to the receiver, so the above method is equivalent", "originalCommit": "505bee2d5449f9d2d67283fa7a21a39ca0f2813f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MDgxNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413180816", "bodyText": "In terms of explicitly marking receivers @This, I think that just adds confusion with not much gain (probably most programmers don't even know you can annotate the receiver).  But let's see, maybe we'll be able to make it default if we can work out the implementation issues.", "author": "msridhar", "createdAt": "2020-04-22T17:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzA4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407082", "bodyText": "I would see it the other way around: why forbid something that other type systems allow? Conceptually, you want that both the receiver and return type are annotated @This. So if somebody wants to make that explicit, what's the harm? Most users won't care about this, I agree, but it would make the type system follow the common style of the framework.", "author": "wmdietl", "createdAt": "2020-04-22T23:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk5NzAyNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413997026", "bodyText": "@wmdietl what if a programmer writes @This on the receiver but not the return value?  Should we add code to insert @This on the return value in that case?", "author": "msridhar", "createdAt": "2020-04-23T17:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMzAzMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414033033", "bodyText": "I would add @This on the return value exactly when it is currently, regardless of whether @This is explicitly or implicitly written on the receiver.", "author": "mernst", "createdAt": "2020-04-23T18:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NDMxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r414644311", "bodyText": "In my mind, the receiver parameter is always @This. The return type is only @This if it is a special method that actually returns the receiver.\nSo no, I don't think there should be logic that adds @This to the return type if the receiver has it.", "author": "wmdietl", "createdAt": "2020-04-24T15:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MDE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2MTkxMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r410461913", "bodyText": "You should start javadoc sentences with an upper case letter and end it with a ..", "author": "wmdietl", "createdAt": "2020-04-17T20:47:27Z", "path": "framework/src/test/java/tests/ReturnsReceiverLombokTest.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+/**\n+ * tests the returns receiver checker's lombok integration, the test files in", "originalCommit": "9ac96286a2c944ce7b0929bba4dc487e69521bd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63ae99f8b3c757104c221ca87f52c2e56fba693e", "url": "https://github.com/typetools/checker-framework/commit/63ae99f8b3c757104c221ca87f52c2e56fba693e", "message": "resolved comments", "committedDate": "2020-04-20T00:31:54Z", "type": "commit"}, {"oid": "73f6ce9dcf2d274ea08f003243f7db531f446f40", "url": "https://github.com/typetools/checker-framework/commit/73f6ce9dcf2d274ea08f003243f7db531f446f40", "message": "fix javadoc", "committedDate": "2020-04-20T01:24:46Z", "type": "commit"}, {"oid": "9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "url": "https://github.com/typetools/checker-framework/commit/9958a0d5cd8552a83e658d07f94e39ba7dd87f82", "message": "Spell-check", "committedDate": "2020-04-20T20:27:47Z", "type": "commit"}, {"oid": "0a89bed9475226d1cce89e009d15ad7eeb0400f8", "url": "https://github.com/typetools/checker-framework/commit/0a89bed9475226d1cce89e009d15ad7eeb0400f8", "message": "Improve changelog entry", "committedDate": "2020-04-20T20:27:52Z", "type": "commit"}, {"oid": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "url": "https://github.com/typetools/checker-framework/commit/7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "message": "Rewordings from review", "committedDate": "2020-04-20T20:30:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r411710045", "bodyText": "#3199 (comment)\nDid you try using @DefaultFor({TypeUseLocation.RECEIVER}) on the declaration of @This?", "author": "wmdietl", "createdAt": "2020-04-20T21:38:33Z", "path": "framework/src/main/java/org/checkerframework/common/returnsreceiver/ReturnsReceiverAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.checkerframework.common.returnsreceiver;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ElementKind;\n+import org.checkerframework.common.basetype.BaseAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.qual.BottomThis;\n+import org.checkerframework.common.returnsreceiver.qual.This;\n+import org.checkerframework.common.returnsreceiver.qual.UnknownThis;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.AnnotationBuilder;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** The type factory for the Returns Receiver Checker. */\n+public class ReturnsReceiverAnnotatedTypeFactory extends BaseAnnotatedTypeFactory {\n+\n+    /** The {@code @}{@link This} annotation. */\n+    final AnnotationMirror THIS_ANNOTATION;\n+\n+    /**\n+     * Create a new {@code ReturnsReceiverAnnotatedTypeFactory}.\n+     *\n+     * @param checker the type-checker associated with this factory\n+     */\n+    public ReturnsReceiverAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(checker);\n+        THIS_ANNOTATION = AnnotationBuilder.fromClass(elements, This.class);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected Set<Class<? extends Annotation>> createSupportedTypeQualifiers() {\n+        return getBundledTypeQualifiers(BottomThis.class, UnknownThis.class, This.class);\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                new ReturnsReceiverTypeAnnotator(this), super.createTypeAnnotator());\n+    }\n+\n+    /** A TypeAnnotator to add the {@code @}{@link This} annotation. */\n+    private class ReturnsReceiverTypeAnnotator extends TypeAnnotator {\n+\n+        /**\n+         * Create a new ReturnsReceiverTypeAnnotator.\n+         *\n+         * @param typeFactory the {@link AnnotatedTypeFactory} associated with this {@link\n+         *     TypeAnnotator}\n+         */\n+        public ReturnsReceiverTypeAnnotator(AnnotatedTypeFactory typeFactory) {\n+            super(typeFactory);\n+        }\n+\n+        @Override\n+        public Void visitExecutable(AnnotatedTypeMirror.AnnotatedExecutableType t, Void p) {\n+\n+            // skip constructors, as we never need to add annotations to them\n+            if (t.getElement().getKind() == ElementKind.CONSTRUCTOR) {\n+                return super.visitExecutable(t, p);\n+            }\n+\n+            AnnotatedTypeMirror returnType = t.getReturnType();\n+\n+            // If any FluentAPIGenerator indicates the method returns this,\n+            // add an @This annotation on the return type.\n+            if (FluentAPIGenerator.check(t)) {\n+                if (!returnType.isAnnotatedInHierarchy(THIS_ANNOTATION)) {\n+                    returnType.addAnnotation(THIS_ANNOTATION);\n+                }\n+            }\n+\n+            // If return type is annotated with @This, add @This annotation", "originalCommit": "7242e9cc6bd47f7918d96069f0cfebbe12a930cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTIzOA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r412435238", "bodyText": "I tried adding this to the declaration of @This, but below tests fails for this change:\n\nreturnsreceiver\nall-systems/java8/memberref\nall-systems/java8/lambda\nall-systems/java8inference\n\nIs there anything else I should do to make this change or we should keep it as it is ?", "author": "nimakarimipour", "createdAt": "2020-04-21T19:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE3OTA0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413179046", "bodyText": "It seems the primary issue here is with method references.  Here is one false-positive report we get:\ntests/all-systems/java8/memberref/MemberReferences.java:119: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n        Consumer<Number> f1 = bound::func1;\n                              ^\n  Method\n    @UnknownThis BoundWithArg<@UnknownThis Number>\n  is not a valid method reference for\n    void func1(@This BoundWithArg<@UnknownThis Number> this, @UnknownThis Number p0) in BoundWithArg\n  found   : @UnknownThis BoundWithArg<@UnknownThis Number>\n  required: @This BoundWithArg<@UnknownThis Number>\n\n@wmdietl I'm not sure why this is an error; seems like an interaction between polymorphic annotations and generics?  Maybe it's a Checker Framework bug?", "author": "msridhar", "createdAt": "2020-04-22T17:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMzQ3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413403476", "bodyText": "It looks like you don't have a lot of lambda/method reference tests and running on all-systems with the change revealed that...\nThe following test without generics gives a similar error (incorrectly I named it Lambda, but then I used a method reference... I'm sure you can write something similar that actually uses a lambda):\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass Lambda {\n\n    @This Lambda set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n}\ngives:\nLambda.java:13: error: [methodref.receiver.bound.invalid] Incompatible receiver type\n    Setter co = this::set;\n                ^\n  Method\n    @UnknownThis Lambda\n  is not a valid method reference for\n    @This Lambda set(@This Lambda this, @UnknownThis Object p0) in Lambda\n  found   : @UnknownThis Lambda\n  required: @This Lambda\n1 error\n\nThis is with tip of this branch, so independent of the proposed change.\nShould that be an error? What is the allowed interaction between @This and lamdas/method references?", "author": "wmdietl", "createdAt": "2020-04-22T23:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNzI5NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413407295", "bodyText": "Good catch!  I am not sure what is going on here.  Our checker should be adding @This on the receiver of set().  @wmdietl do you happen to know why this error message says @UnknownThis Lambda as opposed to @This Lambda?", "author": "msridhar", "createdAt": "2020-04-22T23:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMDE4OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413410188", "bodyText": "No, I don't. Maybe there is a problem with how polymorphic annotations are resolved on receivers?", "author": "wmdietl", "createdAt": "2020-04-22T23:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQxMjU4NQ==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413412585", "bodyText": "The error message seems odd, as it says Method @UnknownThis Lambda, which is just a declared type, not a method type.", "author": "wmdietl", "createdAt": "2020-04-22T23:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5NzkwMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r413497903", "bodyText": "I think the error message is just phrased poorly.  What seems to be going on is that there is a subtype check that fails because @UnknownThis Lambda is not a subtype of @This Lambda.  I've added this example as a test case now but renamed it to MethodRef.\nI am not too sure about how to fix this one, and whether it's a bug in our checker or not.  @smillst any chance you could take a look?", "author": "msridhar", "createdAt": "2020-04-23T04:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM3MDAxMw==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415370013", "bodyText": "Thinking more, this example is actually quite subtle, and I'm now not sure if there should be a type error or not.  Consider this extended version of the example:\nimport org.checkerframework.common.returnsreceiver.qual.*;\n\nclass MethodRef {\n\n    @This MethodRef set(Object o) {\n        return this;\n    }\n\n    interface Setter {\n        @This Object consume(Object p);\n    }\n\n    Setter co = this::set;\n\n    public static void main(String[] args) {\n        MethodRef m = new MethodRef();\n        // this assertion fails!\n        assert m.co.consume(new Object()) == m.co : \"not returning receiver\";\n    }\n}\nI read the @This annotation on the Setter.consume() return type as indicating that any implementation of Setter.consume() should return its receiver.  But if we allow the above code to type check, that property does not hold (since this::set will return the value of this bound by the method reference, not the receiver passed into the call to consume()).\nSo maybe there should be an error in this case (perhaps with a better message)?  @wmdietl @kelloggm @mernst thoughts?", "author": "msridhar", "createdAt": "2020-04-26T18:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQzNzk3MA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415437970", "bodyText": "The Checker Framework does not handle polymorphic qualifiers receivers on the functional methods to member references are assigned.  For example, the receiver of Setter#consume has a polymorphic annotation on its receiver so, Setter co = this::set; causes a weird error.  There should be some sort of error, but methodref.receiver.bound.invalid seems to be the wrong one.\nWe have one open issue on the #2931.  I've added an example to that issue using the Tainting Checker that shows this problem.\nI would just work around this problem in this checker, which I think that's why you wrote the defaulting in place to begin with.  So, maybe just add a comment pointing to #2931?", "author": "smillst", "createdAt": "2020-04-27T00:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0NzUzNg==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r415447536", "bodyText": "Thanks a lot, @smillst!  It seems like we will run into this issue whether @This is the default for receivers or not.  So I think ideally we should follow @wmdietl's suggestion to use @DefaultFor({TypeUseLocation.RECEIVER}) (which will save us a bit of code).  But then, some of the all-systems tests will fail.  Is there a way to suppress some warnings but still use the all-systems tests?", "author": "msridhar", "createdAt": "2020-04-27T01:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwMzg0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416103846", "bodyText": "You can add\n@SuppressWarnings(\"returnsreceiver: methodref.receiver.bound.invalid\") // See Issue #2931\n\nto any all-systems tests that need it.  In general, it is acceptable to suppress a type system specific warning in the all-system test so long as an explanation is given.", "author": "smillst", "createdAt": "2020-04-27T19:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI3NDM1OA==", "url": "https://github.com/typetools/checker-framework/pull/3199#discussion_r416274358", "bodyText": "Unfortunately, it seems that currently, we get too many false positives with method references if we use @DefaultFor({TypeUseLocation.RECEIVER}) on @This.  E.g., with receiver defaulting, we get an error in this variant:\nclass MethodRef {\n    void doNothing() {}\n\n    interface Fun {\n        void run();\n    }\n\n    Fun f = this::doNothing;\n}\nI think any method reference that binds the receiver will yield an error with the returns receiver checker if receivers are defaulted to @This.  I think this is an unacceptable level of false positives, so for now we will not do the defaulting but will leave a comment as to why we don't do it.", "author": "msridhar", "createdAt": "2020-04-28T02:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDA0NQ=="}], "type": "inlineReview"}, {"oid": "aeffa88f34d52e488558c2423c1badc4142192ee", "url": "https://github.com/typetools/checker-framework/commit/aeffa88f34d52e488558c2423c1badc4142192ee", "message": "Merge branch 'master' into returnsrcvr-checker", "committedDate": "2020-04-22T17:18:02Z", "type": "commit"}, {"oid": "e6289b40a4c707268b186464097192be23c668aa", "url": "https://github.com/typetools/checker-framework/commit/e6289b40a4c707268b186464097192be23c668aa", "message": "add a comment", "committedDate": "2020-04-22T17:36:15Z", "type": "commit"}]}