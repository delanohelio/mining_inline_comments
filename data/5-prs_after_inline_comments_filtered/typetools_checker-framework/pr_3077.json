{"pr_number": 3077, "pr_title": "Refactor and document BoundsInitializer.InitializerVisitor", "pr_createdAt": "2020-02-03T20:46:07Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3077", "timeline": [{"oid": "da860db9caf604a1990e5c1a204d8df0630d9fe0", "url": "https://github.com/typetools/checker-framework/commit/da860db9caf604a1990e5c1a204d8df0630d9fe0", "message": "Refactor and document org.checkerframework.framework.type.BoundsInitializer.InitializerVisitor\n\nand the classes it uses.", "committedDate": "2020-02-03T20:02:23Z", "type": "commit"}, {"oid": "4d242753bc375ea28c73f259add47ed0dafee9ff", "url": "https://github.com/typetools/checker-framework/commit/4d242753bc375ea28c73f259add47ed0dafee9ff", "message": "Revert some changes.", "committedDate": "2020-02-03T22:20:04Z", "type": "commit"}, {"oid": "f9c904df76bc285b7aa33bdff568ec7235218579", "url": "https://github.com/typetools/checker-framework/commit/f9c904df76bc285b7aa33bdff568ec7235218579", "message": "Add Javadoc.", "committedDate": "2020-02-03T22:21:04Z", "type": "commit"}, {"oid": "0a8578e1598d39acc2d56e250c5781c870936290", "url": "https://github.com/typetools/checker-framework/commit/0a8578e1598d39acc2d56e250c5781c870936290", "message": "Add more javadoc.", "committedDate": "2020-02-04T00:01:37Z", "type": "commit"}, {"oid": "2f430e24dd18e0d3a66849522bc77836069eb833", "url": "https://github.com/typetools/checker-framework/commit/2f430e24dd18e0d3a66849522bc77836069eb833", "message": "Fix link.", "committedDate": "2020-02-04T17:24:34Z", "type": "commit"}, {"oid": "3b1000f8f6585360b828b114e557ac95b379892b", "url": "https://github.com/typetools/checker-framework/commit/3b1000f8f6585360b828b114e557ac95b379892b", "message": "Merge remote-tracking branch 'origin/master' into refactorBoundsInit", "committedDate": "2020-02-04T17:52:03Z", "type": "commit"}, {"oid": "2f2d3e3846b2fb69c2f5de098a78d9a403e87236", "url": "https://github.com/typetools/checker-framework/commit/2f2d3e3846b2fb69c2f5de098a78d9a403e87236", "message": "Tweaks.", "committedDate": "2020-02-10T16:56:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE3NTgzOA==", "url": "https://github.com/typetools/checker-framework/pull/3077#discussion_r377175838", "bodyText": "Could you add a comment why this is a mapping to AnnotatedTypeMirror instead of AnnotatedTypeVariable?\nFrom the previous two maps I expected an AnnotatedTypeVariable here.", "author": "wmdietl", "createdAt": "2020-02-10T16:34:41Z", "path": "framework/src/main/java/org/checkerframework/framework/type/BoundsInitializer.java", "diffHunk": "@@ -279,32 +276,63 @@ private static void initializeExtendsBound(\n      */\n     private static class InitializerVisitor implements AnnotatedTypeVisitor<Void, Void> {\n         /**\n-         * The BoundStructure starting from the first wildcard or type variable bound initialization\n-         * that kicked this visitation off.\n+         * The RecursiveTypeStructure corresponding to the first wildcard or type variable bound\n+         * initialization that kicked this visitation off.\n          */\n-        private final BoundStructure topLevelStructure;\n+        private final RecursiveTypeStructure topLevelStructure;\n \n-        private BoundStructure currentStructure = null;\n+        /**\n+         * The {@link RecursiveTypeStructure} corresponding to the wildcard or type variable that is\n+         * currently being visited.\n+         */\n+        private RecursiveTypeStructure currentStructure;\n \n+        /** A mapping from TypeVariable to its {@link TypeVariableStructure}. */\n         private final Map<TypeVariable, TypeVariableStructure> typeVarToStructure = new HashMap<>();\n-        // private final Map<TypeVariable, TypeVariableRecord> typeVarToRecord = new HashMap<>();\n+\n+        /**\n+         * A mapping from WildcardType to its {@link AnnotatedWildcardType}. The first time this\n+         * visitor encounters a wildcard it creates an annotated type and adds it to this map. The\n+         * next time the wilcard is encounter, the annotated type in this map is returned.\n+         */\n         private final Map<WildcardType, AnnotatedWildcardType> wildcards = new HashMap<>();\n+\n+        /**\n+         * A mapping from IntersectionType to its {@link AnnotatedIntersectionType}. The first time\n+         * this visitor encounters an intersection it creates an annotated type and adds it to this\n+         * map. The next time the intersection is encounter, the annotated type in this map is\n+         * returned.\n+         */\n         private final Map<IntersectionType, AnnotatedIntersectionType> intersections =\n                 new HashMap<>();\n+        /**\n+         * Mapping from {@link TypeVariable} to {@link AnnotatedTypeMirror}. The annotated type", "originalCommit": "3b1000f8f6585360b828b114e557ac95b379892b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE3NjgxNw==", "url": "https://github.com/typetools/checker-framework/pull/3077#discussion_r377176817", "bodyText": "When should an @link be used in javadoc and when not?\nThe documentation above for topLevelStructure doesn't link to the field type, whereas this does. Similar inconsistency for other javadoc below, where e.g. the key type is not linked, but the value type is.\nIs it ever worth to @link these, as one can simply use the type from the signature?", "author": "wmdietl", "createdAt": "2020-02-10T16:36:21Z", "path": "framework/src/main/java/org/checkerframework/framework/type/BoundsInitializer.java", "diffHunk": "@@ -279,32 +276,63 @@ private static void initializeExtendsBound(\n      */\n     private static class InitializerVisitor implements AnnotatedTypeVisitor<Void, Void> {\n         /**\n-         * The BoundStructure starting from the first wildcard or type variable bound initialization\n-         * that kicked this visitation off.\n+         * The RecursiveTypeStructure corresponding to the first wildcard or type variable bound\n+         * initialization that kicked this visitation off.\n          */\n-        private final BoundStructure topLevelStructure;\n+        private final RecursiveTypeStructure topLevelStructure;\n \n-        private BoundStructure currentStructure = null;\n+        /**\n+         * The {@link RecursiveTypeStructure} corresponding to the wildcard or type variable that is", "originalCommit": "3b1000f8f6585360b828b114e557ac95b379892b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NjQ0MA==", "url": "https://github.com/typetools/checker-framework/pull/3077#discussion_r377186440", "bodyText": "The this a list part is unclear.", "author": "wmdietl", "createdAt": "2020-02-10T16:51:29Z", "path": "framework/src/main/java/org/checkerframework/framework/type/BoundsInitializer.java", "diffHunk": "@@ -823,47 +756,121 @@ private static AnnotatedTypeMirror createAndSetLowerBound(final AnnotatedTypeVar\n             Symtab syms = Symtab.instance(context);\n             lb = syms.botType;\n         }\n-        final AnnotatedTypeMirror lowerBound =\n+        AnnotatedTypeMirror lowerBound =\n                 AnnotatedTypeMirror.createType(lb, typeVar.atypeFactory, false);\n         typeVar.setLowerBound(lowerBound);\n         return lowerBound;\n     }\n \n-    private static boolean isImmediateBoundPath(final BoundPath path) {\n-        if (path.size() == 1) {\n-            switch (path.getFirst().kind) {\n-                case UpperBound:\n-                case LowerBound:\n-                    return true;\n+    /**\n+     * Contains all the type variables and the type path to reach them found when scanning a\n+     * particular type variable or wildcard. then uses this information for replace the type\n+     * variables with AnnotatedTypeVariables.\n+     */\n+    private static class RecursiveTypeStructure {\n+\n+        /** List of TypePath and TypeVariables that were found will traversing this type. */\n+        private final List<Pair<TypePath, TypeVariable>> typeVarsInType = new ArrayList<>();\n \n-                default:\n-                    // do nothing\n-            }\n+        /** Current path used to mark the locations of TypeVariables. */\n+        private final TypePath currentPath = new TypePath();\n+\n+        /**\n+         * Add a type variable found at the current path while visiting the type variable or\n+         * wildcard associated with this structure.\n+         *\n+         * @param typeVariable TypeVariable\n+         */\n+        public void addTypeVar(TypeVariable typeVariable) {\n+            typeVarsInType.add(Pair.of(this.currentPath.copy(), typeVariable));\n         }\n \n-        return false;\n-    }\n+        /**\n+         * Add a node in the path.\n+         *\n+         * @param node node to add\n+         * @return {@code node}\n+         */\n+        public TypePathNode addPathNode(TypePathNode node) {\n+            currentPath.add(node);\n+            return node;\n+        }\n \n-    private abstract static class BoundStructure {\n+        /**\n+         * Remove the last node in the path if it is {@code node}; otherwise, throw an exception.\n+         *\n+         * @param node last node in the path\n+         */\n+        public void removePathNode(TypePathNode node) {\n+            if (currentPath.getLeaf() != node) {\n+                throw new BugInCF(\n+                        \"Cannot remove node: %s. It is not the last node. currentPath= %s\",\n+                        node, currentPath);\n+            }\n+            currentPath.removeLeaf();\n+        }\n \n         /**\n-         * A mapping of all BoundPaths to TypeVariables for all type variables contained within\n-         * annotatedTypeVar.\n+         * For all type variables contained with in the type variable or wildcard that this\n+         * structure represents, this a list of the replacement {@link AnnotatedTypeVariable} for", "originalCommit": "3b1000f8f6585360b828b114e557ac95b379892b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4OTU2Mw==", "url": "https://github.com/typetools/checker-framework/pull/3077#discussion_r377189563", "bodyText": "The overrides of this method are all public. Should they also be protected?", "author": "wmdietl", "createdAt": "2020-02-10T16:56:28Z", "path": "framework/src/main/java/org/checkerframework/framework/type/BoundsInitializer.java", "diffHunk": "@@ -874,259 +881,302 @@ public void addTypeVar(final TypeVariable typeVariable) {\n          */\n         public final AnnotatedTypeVariable annotatedTypeVar;\n \n-        /** The boundStructure that was active before this one. */\n-        private final BoundStructure parent;\n-\n         /**\n-         * If this type variable is upper or lower bounded by another type variable (not a declared\n-         * type or intersection) then this variable will contain the path to that type variable.\n-         *\n-         * <p>TODO: Add link to explanation\n+         * Creates an {@link TypeVariableStructure}\n          *\n-         * <p>e.g. {@code T extends E} &rArr; The structure for T will have an\n-         * immediateBoundTypeVars = List(UpperBound) The BoundPaths here must exist in pathToTypeVar\n+         * @param annotatedTypeVar annotated type for the type variable whose structure is being\n+         *     described\n          */\n-        public Set<BoundPath> immediateBoundTypeVars = new LinkedHashSet<>();\n-\n-        public TypeVariableStructure(\n-                final BoundStructure parent, final AnnotatedTypeVariable annotatedTypeVar) {\n-            this.parent = parent;\n+        public TypeVariableStructure(AnnotatedTypeVariable annotatedTypeVar) {\n             this.typeVar = annotatedTypeVar.getUnderlyingType();\n             this.annotatedTypeVar = annotatedTypeVar;\n         }\n-\n-        @Override\n-        public void addTypeVar(TypeVariable typeVariable) {\n-            final BoundPath copy = currentPath.copy();\n-            pathToTypeVar.put(copy, typeVariable);\n-\n-            if (isImmediateBoundPath(copy)) {\n-                immediateBoundTypeVars.add(copy);\n-            }\n-        }\n     }\n \n-    /** A linked list of BoundPathNodes whose equals method is a referential equality check. */\n-    @SuppressWarnings({\"serial\", \"JdkObsolete\"})\n-    private static class BoundPath extends LinkedList<BoundPathNode> {\n-\n-        @Override\n-        public boolean equals(final Object obj) {\n-            return this == obj;\n-        }\n+    /**\n+     * A list of {@link TypePathNode}s. Each node represents a \"location\" of a composite type. For\n+     * example, an {@link UpperBoundNode} represents the upper bound type of a type variable\n+     */\n+    @SuppressWarnings(\"serial\")\n+    private static class TypePath extends ArrayList<TypePathNode> {\n \n         @Override\n         public String toString() {\n             return PluginUtil.join(\",\", this);\n         }\n \n-        public BoundPath copy() {\n-            final BoundPath copy = new BoundPath();\n-            for (final BoundPathNode node : this) {\n+        /**\n+         * Create a copy of this path\n+         *\n+         * @return a copy of this path\n+         */\n+        public TypePath copy() {\n+            TypePath copy = new TypePath();\n+            for (TypePathNode node : this) {\n                 copy.add(node.copy());\n             }\n-\n             return copy;\n         }\n-    }\n \n-    /** BoundPathNode's are a step in a \"type path\". */\n-    private abstract static class BoundPathNode {\n-\n-        /** Kinds of {@link BoundPathNode}s. */\n-        enum Kind {\n-            /** Intersection kind */\n-            Extends,\n-            /** Intersection kind */\n-            Super,\n-            /** Intersection kind */\n-            UpperBound,\n-            /** Intersection kind */\n-            LowerBound,\n-            /** Intersection kind */\n-            ArrayComponent,\n-            /** Intersection kind */\n-            Intersection,\n-            /** Union kind */\n-            Union,\n-            /** TypeArg kind */\n-            TypeArg,\n-            /** Enclosing kind */\n-            Enclosing\n-        }\n-\n-        public Kind kind;\n-        public TypeKind typeKind;\n-\n-        BoundPathNode() {}\n-\n-        BoundPathNode(final BoundPathNode template) {\n-            this.kind = template.kind;\n-            this.typeKind = template.typeKind;\n+        /**\n+         * Return the leaf node of this path.\n+         *\n+         * @return the leaf node or null if the path is empty\n+         */\n+        public TypePathNode getLeaf() {\n+            if (this.isEmpty()) {\n+                return null;\n+            }\n+            return this.get(size() - 1);\n         }\n \n-        @Override\n-        public String toString() {\n-            return kind.toString();\n+        /** Remove the leaf node if one exists. */\n+        public void removeLeaf() {\n+            if (this.isEmpty()) {\n+                return;\n+            }\n+            this.remove(size() - 1);\n         }\n \n-        public AnnotatedTypeMirror next(final AnnotatedTypeMirror parent) {\n-            abortIfParentNotKind(typeKind, null, parent);\n-            return getType(parent);\n+        /**\n+         * In {@code type}, replace the type at the location specified by this path with {@code\n+         * replacement}.\n+         *\n+         * @param type annotated type that is side-effected\n+         * @param replacement annotated type to add to {@code type}\n+         */\n+        public void replaceTypeVariable(\n+                AnnotatedTypeMirror type, AnnotatedTypeVariable replacement) {\n+            AnnotatedTypeMirror current = type;\n+            for (int i = 0; i < size() - 1; i++) {\n+                current = get(i).getType(current);\n+            }\n+            this.getLeaf().replaceType(current, replacement);\n         }\n+    }\n \n-        public void replaceType(\n-                final AnnotatedTypeMirror parent, final AnnotatedTypeVariable replacement) {\n-            abortIfParentNotKind(typeKind, replacement, parent);\n-            setType(parent, replacement);\n+    /**\n+     * A {@link TypePathNode} represents represents a \"location\" of a composite type. For example,\n+     * an {@link UpperBoundNode} represents the upper bound type of a type variable.\n+     */\n+    private abstract static class TypePathNode {\n+\n+        /** The {@link TypeKind} of the parent of this node. */\n+        public final TypeKind parentTypeKind;\n+\n+        /**\n+         * Creates a {@link TypePathNode}.\n+         *\n+         * @param parentTypeKind kind of parent of this node\n+         */\n+        TypePathNode(TypeKind parentTypeKind) {\n+            this.parentTypeKind = parentTypeKind;\n         }\n \n-        public abstract void setType(\n-                final AnnotatedTypeMirror parent, final AnnotatedTypeVariable replacement);\n+        /**\n+         * Copy constructor\n+         *\n+         * @param template node to copy\n+         */\n+        TypePathNode(TypePathNode template) {\n+            this.parentTypeKind = template.parentTypeKind;\n+        }\n \n-        public abstract AnnotatedTypeMirror getType(final AnnotatedTypeMirror parent);\n+        @Override\n+        public String toString() {\n+            return this.getClass().getSimpleName();\n+        }\n \n-        public abstract BoundPathNode copy();\n-    }\n+        /**\n+         * Returns the annotated type at the location represented by this node in {@code type}.\n+         *\n+         * @param type parent type\n+         * @return the annotated type at the location represented by this node in {@code type}\n+         * @throws BugInCF if {@code type} does not have a type at this location\n+         */\n+        public final AnnotatedTypeMirror getType(AnnotatedTypeMirror type) {\n+            abortIfNotKind(parentTypeKind, null, type);\n+            return getTypeInternal(type);\n+        }\n \n-    /** Represents an enclosing type in a path. */\n-    private static class EnclosingNode extends BoundPathNode {\n+        /**\n+         * Internal implementation of {@link #getType(AnnotatedTypeMirror)}.\n+         *\n+         * @param parent type that is sideffected by this method\n+         * @return the annotated type at the location represented by this node in {@code type}\n+         */\n+        protected abstract AnnotatedTypeMirror getTypeInternal(AnnotatedTypeMirror parent);", "originalCommit": "3b1000f8f6585360b828b114e557ac95b379892b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9bdb9b4d9661a7d9ad21a568592f7e9e77709249", "url": "https://github.com/typetools/checker-framework/commit/9bdb9b4d9661a7d9ad21a568592f7e9e77709249", "message": "Merge branch 'master' into refactorBoundsInit", "committedDate": "2020-02-10T18:35:33Z", "type": "commit"}, {"oid": "53bfc2a773360991aa4fa60b0e1451fe4ec760a4", "url": "https://github.com/typetools/checker-framework/commit/53bfc2a773360991aa4fa60b0e1451fe4ec760a4", "message": "Address code review.", "committedDate": "2020-02-10T18:43:40Z", "type": "commit"}, {"oid": "50963f1374c280754103934eb8418e03126d32ab", "url": "https://github.com/typetools/checker-framework/commit/50963f1374c280754103934eb8418e03126d32ab", "message": "Merge branch 'refactorBoundsInit' of github.com:smillst/checker-framework into refactorBoundsInit", "committedDate": "2020-02-10T18:44:43Z", "type": "commit"}, {"oid": "67f19adda05eb479ebf0f81d03bb76ba7ff146ea", "url": "https://github.com/typetools/checker-framework/commit/67f19adda05eb479ebf0f81d03bb76ba7ff146ea", "message": "Fix links.", "committedDate": "2020-02-10T19:35:37Z", "type": "commit"}]}