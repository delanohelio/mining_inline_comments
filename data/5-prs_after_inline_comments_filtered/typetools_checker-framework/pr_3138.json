{"pr_number": 3138, "pr_title": "Make annotations repeatable; fixes #1307", "pr_createdAt": "2020-03-08T03:09:15Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3138", "timeline": [{"oid": "c7bc8e76ac2bf0c1384cff9773cf738514585c1e", "url": "https://github.com/typetools/checker-framework/commit/c7bc8e76ac2bf0c1384cff9773cf738514585c1e", "message": "Make annotations repeatable", "committedDate": "2019-08-12T01:37:10Z", "type": "commit"}, {"oid": "eff8f9f6edc205f865ec29d0076a72f82d0ebf29", "url": "https://github.com/typetools/checker-framework/commit/eff8f9f6edc205f865ec29d0076a72f82d0ebf29", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-08-15T17:07:15Z", "type": "commit"}, {"oid": "7e98d839d50ddc81e58eb211e67e41b8bf064d16", "url": "https://github.com/typetools/checker-framework/commit/7e98d839d50ddc81e58eb211e67e41b8bf064d16", "message": "Use inner annotation `List` as wrapper, consistently", "committedDate": "2019-08-15T18:09:51Z", "type": "commit"}, {"oid": "95b89737b84f98eb0c992d790e05468c3e942a4e", "url": "https://github.com/typetools/checker-framework/commit/95b89737b84f98eb0c992d790e05468c3e942a4e", "message": "Whitespace change", "committedDate": "2019-08-15T19:46:24Z", "type": "commit"}, {"oid": "5370f8635f6ea8fea76facadf30c10d7f02feb15", "url": "https://github.com/typetools/checker-framework/commit/5370f8635f6ea8fea76facadf30c10d7f02feb15", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-08-19T15:32:29Z", "type": "commit"}, {"oid": "e000f6a4b57c967bebd054049caaa5157121fe03", "url": "https://github.com/typetools/checker-framework/commit/e000f6a4b57c967bebd054049caaa5157121fe03", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-08-20T15:18:42Z", "type": "commit"}, {"oid": "bffa651f262a5bd7c6528329a837870baa95fc06", "url": "https://github.com/typetools/checker-framework/commit/bffa651f262a5bd7c6528329a837870baa95fc06", "message": "Merge branch 'repeatable-annotations' of github.com:mernst/checker-framework into repeatable-annotations", "committedDate": "2019-08-20T23:58:58Z", "type": "commit"}, {"oid": "d6a450745f92cd662727a7b9cb7ab8953b0599d6", "url": "https://github.com/typetools/checker-framework/commit/d6a450745f92cd662727a7b9cb7ab8953b0599d6", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-09-09T23:15:43Z", "type": "commit"}, {"oid": "8d60eb4b64bc077712f653ee5de514873a942250", "url": "https://github.com/typetools/checker-framework/commit/8d60eb4b64bc077712f653ee5de514873a942250", "message": "Merge branch 'repeatable-annotations' of github.com:mernst/checker-framework into repeatable-annotations", "committedDate": "2019-09-13T16:41:55Z", "type": "commit"}, {"oid": "1d5c2fa26036f75cc6e7c8c0d48c25c9d4c65a8e", "url": "https://github.com/typetools/checker-framework/commit/1d5c2fa26036f75cc6e7c8c0d48c25c9d4c65a8e", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-09-13T16:42:14Z", "type": "commit"}, {"oid": "ca5bf57d921e38c1dbf068f3191a80bebb5e97c8", "url": "https://github.com/typetools/checker-framework/commit/ca5bf57d921e38c1dbf068f3191a80bebb5e97c8", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-10-27T23:43:19Z", "type": "commit"}, {"oid": "92b3f426188d8e4a8c3740f3d9f22f85f6ff9180", "url": "https://github.com/typetools/checker-framework/commit/92b3f426188d8e4a8c3740f3d9f22f85f6ff9180", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-08T00:07:29Z", "type": "commit"}, {"oid": "d768892aa12458a0e8b7b92150330c44e62ebf6e", "url": "https://github.com/typetools/checker-framework/commit/d768892aa12458a0e8b7b92150330c44e62ebf6e", "message": "Make more wrappers into inner classes", "committedDate": "2019-12-08T00:21:17Z", "type": "commit"}, {"oid": "e3328440e226add2378d43ff3d0294b1f4b20625", "url": "https://github.com/typetools/checker-framework/commit/e3328440e226add2378d43ff3d0294b1f4b20625", "message": "Tweak changelog", "committedDate": "2019-12-08T00:27:17Z", "type": "commit"}, {"oid": "28172a5be25f8f4ce091ac4c3c160645d90aa2f1", "url": "https://github.com/typetools/checker-framework/commit/28172a5be25f8f4ce091ac4c3c160645d90aa2f1", "message": "Don't use annotations that were removed", "committedDate": "2019-12-08T01:21:25Z", "type": "commit"}, {"oid": "edd58759187e5c3e70d2c8e52a9058be50a79387", "url": "https://github.com/typetools/checker-framework/commit/edd58759187e5c3e70d2c8e52a9058be50a79387", "message": "Tweaks", "committedDate": "2019-12-08T03:55:08Z", "type": "commit"}, {"oid": "a7733f1164351d1b5f5237228cedf9c86ed1e668", "url": "https://github.com/typetools/checker-framework/commit/a7733f1164351d1b5f5237228cedf9c86ed1e668", "message": "Use interface rather than class", "committedDate": "2019-12-08T06:01:35Z", "type": "commit"}, {"oid": "5b857c664624720bb406b39131c4bc20fe62d59a", "url": "https://github.com/typetools/checker-framework/commit/5b857c664624720bb406b39131c4bc20fe62d59a", "message": "Typo fix", "committedDate": "2019-12-08T16:51:51Z", "type": "commit"}, {"oid": "e1305eaac4656fad32bace0b3d7db2a90386c6f1", "url": "https://github.com/typetools/checker-framework/commit/e1305eaac4656fad32bace0b3d7db2a90386c6f1", "message": "Fix grammar", "committedDate": "2019-12-08T18:23:16Z", "type": "commit"}, {"oid": "9257c661c837601ec62541c15639987bad426412", "url": "https://github.com/typetools/checker-framework/commit/9257c661c837601ec62541c15639987bad426412", "message": "Cleanups", "committedDate": "2019-12-08T18:23:30Z", "type": "commit"}, {"oid": "0c57390dc48b9b18b3a10f0384782ba4328e6575", "url": "https://github.com/typetools/checker-framework/commit/0c57390dc48b9b18b3a10f0384782ba4328e6575", "message": "Fix grammar", "committedDate": "2019-12-08T18:27:29Z", "type": "commit"}, {"oid": "f013251e58b44910cc1a29678461abfb8337a7f3", "url": "https://github.com/typetools/checker-framework/commit/f013251e58b44910cc1a29678461abfb8337a7f3", "message": "Update documentation", "committedDate": "2019-12-08T18:45:11Z", "type": "commit"}, {"oid": "8a1641fa5821e96c0d272a36071b3b524fa38d39", "url": "https://github.com/typetools/checker-framework/commit/8a1641fa5821e96c0d272a36071b3b524fa38d39", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-09T04:46:11Z", "type": "commit"}, {"oid": "aa291783d7f26c9f4eea507bb85003a61948f449", "url": "https://github.com/typetools/checker-framework/commit/aa291783d7f26c9f4eea507bb85003a61948f449", "message": "Merge branch 'master' of github.com:typetools/checker-framework", "committedDate": "2019-12-09T04:47:08Z", "type": "commit"}, {"oid": "41719e0bdb20dd3b37957e86d71c7fd467888b86", "url": "https://github.com/typetools/checker-framework/commit/41719e0bdb20dd3b37957e86d71c7fd467888b86", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-09T04:47:28Z", "type": "commit"}, {"oid": "5c8f03166e874d842e564e7b3df3c354882c8414", "url": "https://github.com/typetools/checker-framework/commit/5c8f03166e874d842e564e7b3df3c354882c8414", "message": "Undo changes in logic", "committedDate": "2019-12-09T04:53:35Z", "type": "commit"}, {"oid": "9a4e17fe3554e9beb4f28393ec4b9b1193c5ead5", "url": "https://github.com/typetools/checker-framework/commit/9a4e17fe3554e9beb4f28393ec4b9b1193c5ead5", "message": "Change directory name", "committedDate": "2019-12-10T16:12:32Z", "type": "commit"}, {"oid": "e571e5d38277892fa6a83023440283ee57365fac", "url": "https://github.com/typetools/checker-framework/commit/e571e5d38277892fa6a83023440283ee57365fac", "message": "Improve diagnostics", "committedDate": "2019-12-10T16:12:54Z", "type": "commit"}, {"oid": "89b831749a3aa5a60f98323cb779e3ff2138981e", "url": "https://github.com/typetools/checker-framework/commit/89b831749a3aa5a60f98323cb779e3ff2138981e", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-10T16:13:13Z", "type": "commit"}, {"oid": "0119aa1cc7b22f13c86002a09ff8dd3bccd16efe", "url": "https://github.com/typetools/checker-framework/commit/0119aa1cc7b22f13c86002a09ff8dd3bccd16efe", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-14T03:04:39Z", "type": "commit"}, {"oid": "3cb86199e309406ae9a7ced6fb08a875847b0ca1", "url": "https://github.com/typetools/checker-framework/commit/3cb86199e309406ae9a7ced6fb08a875847b0ca1", "message": "Add diagnostics", "committedDate": "2019-12-14T16:12:28Z", "type": "commit"}, {"oid": "4b304b4c802897f11dbbf46d1abd71819cf7e55b", "url": "https://github.com/typetools/checker-framework/commit/4b304b4c802897f11dbbf46d1abd71819cf7e55b", "message": "Small changes", "committedDate": "2019-12-22T20:58:48Z", "type": "commit"}, {"oid": "13edafe5059595c4e66c111a90add302825a69e7", "url": "https://github.com/typetools/checker-framework/commit/13edafe5059595c4e66c111a90add302825a69e7", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2019-12-22T20:59:57Z", "type": "commit"}, {"oid": "16af1f6b5ba745a54f8e1b6cefbbb2602cbd63ad", "url": "https://github.com/typetools/checker-framework/commit/16af1f6b5ba745a54f8e1b6cefbbb2602cbd63ad", "message": "Add new test", "committedDate": "2019-12-22T21:03:33Z", "type": "commit"}, {"oid": "2a7fe46fc945af808c0d75527e751f7829906ec6", "url": "https://github.com/typetools/checker-framework/commit/2a7fe46fc945af808c0d75527e751f7829906ec6", "message": "Complete test", "committedDate": "2019-12-22T21:03:57Z", "type": "commit"}, {"oid": "e2f1534e3da425a3b5e82e00b56f8c7d6288f87f", "url": "https://github.com/typetools/checker-framework/commit/e2f1534e3da425a3b5e82e00b56f8c7d6288f87f", "message": "Fix compilation failures", "committedDate": "2019-12-22T21:09:41Z", "type": "commit"}, {"oid": "2b19bd8ef842d22e85221ed4c6ce639b3ba36b35", "url": "https://github.com/typetools/checker-framework/commit/2b19bd8ef842d22e85221ed4c6ce639b3ba36b35", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-01-29T19:47:49Z", "type": "commit"}, {"oid": "a75c87c20b325daf430ad82b738b164202a335e7", "url": "https://github.com/typetools/checker-framework/commit/a75c87c20b325daf430ad82b738b164202a335e7", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-07T21:56:26Z", "type": "commit"}, {"oid": "07cf0eff59a1408373c75c4e91c247b1d1a2b61a", "url": "https://github.com/typetools/checker-framework/commit/07cf0eff59a1408373c75c4e91c247b1d1a2b61a", "message": "Handle wrappers for repeated annotations", "committedDate": "2020-03-08T02:03:25Z", "type": "commit"}, {"oid": "3f51c87041a0ce0a03d6088647ba33aafc1dbbd2", "url": "https://github.com/typetools/checker-framework/commit/3f51c87041a0ce0a03d6088647ba33aafc1dbbd2", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-11T06:30:52Z", "type": "commit"}, {"oid": "97010040ffd2ecf72ce5b6651466c9cbe74f9887", "url": "https://github.com/typetools/checker-framework/commit/97010040ffd2ecf72ce5b6651466c9cbe74f9887", "message": "Add Javadoc", "committedDate": "2020-03-11T08:12:47Z", "type": "commit"}, {"oid": "720a71c74808e00f6decbbb60677b5b8fb0b0292", "url": "https://github.com/typetools/checker-framework/commit/720a71c74808e00f6decbbb60677b5b8fb0b0292", "message": "Add Javadoc", "committedDate": "2020-03-11T15:51:35Z", "type": "commit"}, {"oid": "8529ccec98a07fab5995199500cc012313e1e331", "url": "https://github.com/typetools/checker-framework/commit/8529ccec98a07fab5995199500cc012313e1e331", "message": "Add Javadoc", "committedDate": "2020-03-11T16:34:15Z", "type": "commit"}, {"oid": "2cbea90daecc705347b33e1b254b616d632cfff7", "url": "https://github.com/typetools/checker-framework/commit/2cbea90daecc705347b33e1b254b616d632cfff7", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-13T00:10:16Z", "type": "commit"}, {"oid": "0e8110d0bf5383c46cfb147734aa971a29f7d6ec", "url": "https://github.com/typetools/checker-framework/commit/0e8110d0bf5383c46cfb147734aa971a29f7d6ec", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-13T00:10:46Z", "type": "commit"}, {"oid": "d88b8258687a00e787fc5a03004ceb0afde3b797", "url": "https://github.com/typetools/checker-framework/commit/d88b8258687a00e787fc5a03004ceb0afde3b797", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-16T00:14:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwMTIyMg==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396601222", "bodyText": "The naming of many of these test files is a bit confusing. Could you add the Ensures etc. word to the test files? For some, e.g. the jtreg tests, you already do this.", "author": "wmdietl", "createdAt": "2020-03-23T16:51:36Z", "path": "checker/tests/nullness/RepeatNonNull.java", "diffHunk": "@@ -0,0 +1,91 @@\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNull;\n+import org.checkerframework.checker.nullness.qual.EnsuresNonNullIf;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+public class RepeatNonNull {", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNTA1MA==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396605050", "bodyText": "How do I chose between the two options?\nIs one when I'm declaring a single annotation and the other when I declare a repeatable annotation? But the repeatable annotation wouldn't contain a result, would it?", "author": "wmdietl", "createdAt": "2020-03-23T16:57:10Z", "path": "framework/src/main/java/org/checkerframework/framework/qual/ConditionalPostconditionAnnotation.java", "diffHunk": "@@ -11,11 +11,17 @@\n  * A meta-annotation that indicates that an annotation E is a conditional postcondition annotation,\n  * i.e., E is a type-specialized version of {@link EnsuresQualifierIf}.\n  *\n- * <p>The annotation E that is meta-annotated as {@link ConditionalPostconditionAnnotation} must\n- * have an element called {@code expression} that is an array of {@code String}s of the same format\n- * and with the same meaning as the value {@code expression} in {@link EnsuresQualifierIf}. E must\n- * also have an element {@code result} with the same meaning as the element {@code result} in {@link\n- * EnsuresQualifierIf}.\n+ * <ul>\n+ *   <li>E must have one of the following:", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwNjM1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396606351", "bodyText": "I'm also not clear here how to chose between the two options.", "author": "wmdietl", "createdAt": "2020-03-23T16:58:49Z", "path": "framework/src/main/java/org/checkerframework/framework/qual/PostconditionAnnotation.java", "diffHunk": "@@ -11,9 +11,12 @@\n  * A meta-annotation that indicates that an annotation E is a postcondition annotation, i.e., E is a\n  * type-specialized version of {@link EnsuresQualifier}.\n  *\n- * <p>The annotation E that is meta-annotated as {@link PostconditionAnnotation} must have an\n- * element called {@code value} that is an array of {@code String}s of the same format and with the\n- * same meaning as the value {@code expression} in {@link EnsuresQualifier}.\n+ * <p>E must have an element {@code value} that is one of the following:", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYwOTkzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396609931", "bodyText": "Should this field be private or protected?", "author": "wmdietl", "createdAt": "2020-03-23T17:03:49Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMDE0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396610141", "bodyText": "Can the field be final?", "author": "wmdietl", "createdAt": "2020-03-23T17:04:09Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMDkzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396610931", "bodyText": "Should this method be private or protected?", "author": "wmdietl", "createdAt": "2020-03-23T17:05:20Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotation(AnnotationMirror a) {", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMTA2Ng==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396611066", "bodyText": "Should this method be private or protected?", "author": "wmdietl", "createdAt": "2020-03-23T17:05:32Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        if (!isListForRepeatedAnnotationCache.containsKey(a)) {\n+            isListForRepeatedAnnotationCache.put(a, isListForRepeatedAnnotationImplementation(a));\n+        }\n+        return isListForRepeatedAnnotationCache.get(a);\n+    }\n+\n+    /**\n+     * Returns true if the annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a the annotation to test\n+     * @return true if the annotation is a wrapper for multiple repeated annotations\n+     */\n+    boolean isListForRepeatedAnnotationImplementation(AnnotationMirror a) {", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzMDMzMw==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r396630333", "bodyText": "From the diffs in this file it seems a bit odd why these new imports are required.\nDo you see the reason?", "author": "wmdietl", "createdAt": "2020-03-23T17:32:53Z", "path": "framework/src/main/java/org/checkerframework/framework/util/Contract.java", "diffHunk": "@@ -7,12 +7,12 @@\n import org.checkerframework.framework.qual.ConditionalPostconditionAnnotation;\n import org.checkerframework.framework.qual.EnsuresQualifier;\n import org.checkerframework.framework.qual.EnsuresQualifierIf;\n-import org.checkerframework.framework.qual.EnsuresQualifiers;\n-import org.checkerframework.framework.qual.EnsuresQualifiersIf;\n import org.checkerframework.framework.qual.PostconditionAnnotation;\n import org.checkerframework.framework.qual.PreconditionAnnotation;\n import org.checkerframework.framework.qual.RequiresQualifier;\n-import org.checkerframework.framework.qual.RequiresQualifiers;\n+import org.checkerframework.framework.util.Contract.ConditionalPostcondition;", "originalCommit": "d88b8258687a00e787fc5a03004ceb0afde3b797", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "725734fe16d6b6b9c3f146ea990149aa2a2b1690", "url": "https://github.com/typetools/checker-framework/commit/725734fe16d6b6b9c3f146ea990149aa2a2b1690", "message": "Remove unnecessary imports", "committedDate": "2020-03-23T22:10:14Z", "type": "commit"}, {"oid": "208449471abd46accd660ec69bf58884628d4079", "url": "https://github.com/typetools/checker-framework/commit/208449471abd46accd660ec69bf58884628d4079", "message": "Remove a stub file", "committedDate": "2020-03-23T22:17:18Z", "type": "commit"}, {"oid": "b9b46d599ee493176a12424a01a7d1d5f9da71ed", "url": "https://github.com/typetools/checker-framework/commit/b9b46d599ee493176a12424a01a7d1d5f9da71ed", "message": "Rename test files", "committedDate": "2020-03-23T22:19:51Z", "type": "commit"}, {"oid": "331b7e38e64900f274ed207775aedfd220d2208b", "url": "https://github.com/typetools/checker-framework/commit/331b7e38e64900f274ed207775aedfd220d2208b", "message": "Add `private` modifiers", "committedDate": "2020-03-23T22:27:45Z", "type": "commit"}, {"oid": "ef6ffb11ddb0060c47fe54de81f651ad3b576874", "url": "https://github.com/typetools/checker-framework/commit/ef6ffb11ddb0060c47fe54de81f651ad3b576874", "message": "Remove test that goes along with removed stub file", "committedDate": "2020-03-23T22:28:45Z", "type": "commit"}, {"oid": "255c39a8c9f86f6aa2cf1cc63652d4b1df3654f3", "url": "https://github.com/typetools/checker-framework/commit/255c39a8c9f86f6aa2cf1cc63652d4b1df3654f3", "message": "Add `final` modifier", "committedDate": "2020-03-23T22:29:33Z", "type": "commit"}, {"oid": "12ca01fdd864b0f52c1a265b7ad2fe5a488b1114", "url": "https://github.com/typetools/checker-framework/commit/12ca01fdd864b0f52c1a265b7ad2fe5a488b1114", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-23T22:35:09Z", "type": "commit"}, {"oid": "a90f61f5e240473a0ea2deba8de07a32ce8399cb", "url": "https://github.com/typetools/checker-framework/commit/a90f61f5e240473a0ea2deba8de07a32ce8399cb", "message": "Javadoc fix", "committedDate": "2020-03-23T22:37:49Z", "type": "commit"}, {"oid": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "url": "https://github.com/typetools/checker-framework/commit/6b46ea13e4427365901c6f4c2202f7cd032a2171", "message": "Clarify Javadoc comments", "committedDate": "2020-03-23T22:48:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzMzEwMA==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398633100", "bodyText": "The trailing colon shouldn't be necessary any longer.", "author": "wmdietl", "createdAt": "2020-03-26T14:50:11Z", "path": "checker/src/test/java/tests/NullnessStubfileTest.java", "diffHunk": "@@ -17,7 +17,7 @@ public NullnessStubfileTest(List<File> testFiles) {\n                 \"-AstubWarnIfNotFound\",\n                 \"-Astubs=\"\n                         + \"tests/nullness-stubfile/stubfile1.astub:\"\n-                        + \"tests/nullness-stubfile/stubfile2.astub\");\n+                        + \"tests/nullness-stubfile/stubfile2.astub:\");", "originalCommit": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNDg5MQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398634891", "bodyText": "You could push these unrelated changes separately to have a more suitable commit message for the change.", "author": "wmdietl", "createdAt": "2020-03-26T14:52:27Z", "path": "dataflow/src/main/java/org/checkerframework/dataflow/analysis/Analysis.java", "diffHunk": "@@ -124,18 +124,20 @@ public void setCurrentTree(Tree currentTree) {\n         this.currentTree = currentTree;\n     }\n \n+    // `@code`, not `@link`, because dataflow module doesn't depend on framework moduel.", "originalCommit": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY4ODEyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398688121", "bodyText": "Done, in #3198.", "author": "mernst", "createdAt": "2020-03-26T15:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYzNDg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0MTUxOA==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398641518", "bodyText": "I'm wondering whether this cache should be set with the other caches in the constructor (using CollectionUtils.createLRUCache(cacheSize)) and whether it should be cleared in setRoot, like other caches.\nOtherwise, couldn't this cache grow arbitrarily large, as there can be many different repeated annotations that all have distinct AnnotationMirrors.", "author": "wmdietl", "createdAt": "2020-03-26T15:00:37Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();", "originalCommit": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY0MzMyNw==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398643327", "bodyText": "Should this use a variant of AnnotationUtils.containsSame, to account for AnnotationMirrors coming either from the compiler or a stub file?\nOr maybe this should be rewritten to use the type from the AnnotationMirror (from getAnnotationType()), which will be easier to compare and of which there will be many fewer of (addressing my caching concern above).", "author": "wmdietl", "createdAt": "2020-03-26T15:03:01Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3237,41 +3237,90 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n      * @param metaAnnotationClass the class of the meta-annotation that needs to be present\n      * @return a list of pairs {@code (anno, metaAnno)} where {@code anno} is the annotation mirror\n      *     at {@code element}, and {@code metaAnno} is the annotation mirror (of type {@code\n-     *     metaAnnotationClass}) used to annotate {@code anno}.\n+     *     metaAnnotationClass}) used to meta-annotate the declaration of {@code anno}\n      */\n     public List<Pair<AnnotationMirror, AnnotationMirror>> getDeclAnnotationWithMetaAnnotation(\n             Element element, Class<? extends Annotation> metaAnnotationClass) {\n         List<Pair<AnnotationMirror, AnnotationMirror>> result = new ArrayList<>();\n         Set<AnnotationMirror> annotationMirrors = getDeclAnnotations(element);\n \n-        // Go through all annotations found.\n-        for (AnnotationMirror annotation : annotationMirrors) {\n-            List<? extends AnnotationMirror> annotationsOnAnnotation;\n+        for (AnnotationMirror candidate : annotationMirrors) {\n+            List<? extends AnnotationMirror> metaAnnotationsOnAnnotation;\n             try {\n-                annotationsOnAnnotation =\n-                        annotation.getAnnotationType().asElement().getAnnotationMirrors();\n+                metaAnnotationsOnAnnotation =\n+                        candidate.getAnnotationType().asElement().getAnnotationMirrors();\n             } catch (com.sun.tools.javac.code.Symbol.CompletionFailure cf) {\n                 // Fix for Issue 309: If a CompletionFailure occurs, issue a warning.\n                 // I didn't find a nicer alternative to check whether the Symbol can be completed.\n                 // The completer field of a Symbol might be non-null also in successful cases.\n                 // Issue a warning (exception only happens once) and continue.\n                 checker.reportWarning(\n-                        annotation.getAnnotationType().asElement(),\n+                        candidate.getAnnotationType().asElement(),\n                         \"annotation.not.completed\",\n                         ElementUtils.getVerboseName(element),\n-                        annotation);\n+                        candidate);\n                 continue;\n             }\n             // First call copier, if exception, continue normal modula laws.\n-            for (AnnotationMirror a : annotationsOnAnnotation) {\n-                if (areSameByClass(a, metaAnnotationClass)) {\n-                    result.add(Pair.of(annotation, a));\n+            for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n+                if (areSameByClass(ma, metaAnnotationClass)) {\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<AnnotationMirror, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        if (!isListForRepeatedAnnotationCache.containsKey(a)) {", "originalCommit": "6b46ea13e4427365901c6f4c2202f7cd032a2171", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a754ff275b924c2c9c4edc25377a0fc3ed45893", "url": "https://github.com/typetools/checker-framework/commit/1a754ff275b924c2c9c4edc25377a0fc3ed45893", "message": "Optimistically move changes into upcoming release", "committedDate": "2020-03-26T15:19:59Z", "type": "commit"}, {"oid": "51adf46f985c095cc25061c9856dc71c2e717586", "url": "https://github.com/typetools/checker-framework/commit/51adf46f985c095cc25061c9856dc71c2e717586", "message": "Remove colon", "committedDate": "2020-03-26T15:20:57Z", "type": "commit"}, {"oid": "f591ca8dfc21eb2f0de626e147b986d574cecb7a", "url": "https://github.com/typetools/checker-framework/commit/f591ca8dfc21eb2f0de626e147b986d574cecb7a", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-26T15:21:33Z", "type": "commit"}, {"oid": "c9353588f21ee9a0e322214c9b54bc370d60d548", "url": "https://github.com/typetools/checker-framework/commit/c9353588f21ee9a0e322214c9b54bc370d60d548", "message": "Reduce size of cache", "committedDate": "2020-03-26T15:54:06Z", "type": "commit"}, {"oid": "c0602e2424dabb88f36a123785308149490be9a6", "url": "https://github.com/typetools/checker-framework/commit/c0602e2424dabb88f36a123785308149490be9a6", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-26T15:56:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2NTU1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r398965556", "bodyText": "It would be good to document the naming and nesting requirement, maybe in the \"how to write a checker\" section of the manual.\nAlso, this is related to the TODO below, as this naming convention shouldn't be a strict requirement.", "author": "wmdietl", "createdAt": "2020-03-27T00:13:25Z", "path": "framework/src/main/java/org/checkerframework/framework/type/AnnotatedTypeFactory.java", "diffHunk": "@@ -3265,13 +3264,66 @@ private void addOrMerge(Set<AnnotationMirror> results, AnnotationMirror annotati\n             // First call copier, if exception, continue normal modula laws.\n             for (AnnotationMirror ma : metaAnnotationsOnAnnotation) {\n                 if (areSameByClass(ma, metaAnnotationClass)) {\n-                    result.add(Pair.of(candidate, ma));\n+                    // This candidate has the right kind of meta-annotation.\n+                    // It might be a real contract, or a list of contracts.\n+                    if (isListForRepeatedAnnotation(candidate)) {\n+                        List<AnnotationMirror> wrappedCandidates =\n+                                AnnotationUtils.getElementValueArray(\n+                                        candidate, \"value\", AnnotationMirror.class, false);\n+                        for (AnnotationMirror wrappedCandidate : wrappedCandidates) {\n+                            result.add(Pair.of(wrappedCandidate, ma));\n+                        }\n+                    } else {\n+                        result.add(Pair.of(candidate, ma));\n+                    }\n                 }\n             }\n         }\n         return result;\n     }\n \n+    /** Cache for {@link #isListForRepeatedAnnotation}. */\n+    private final Map<DeclaredType, Boolean> isListForRepeatedAnnotationCache = new HashMap<>();\n+\n+    /**\n+     * Returns true if the given annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param a an annotation that might be a wrapper\n+     * @return true if the argument is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotation(AnnotationMirror a) {\n+        DeclaredType annotationType = a.getAnnotationType();\n+        Boolean resultObject = isListForRepeatedAnnotationCache.get(annotationType);\n+        if (resultObject != null) {\n+            return resultObject;\n+        }\n+        boolean result = isListForRepeatedAnnotationImplementation(annotationType);\n+        isListForRepeatedAnnotationCache.put(annotationType, result);\n+        return result;\n+    }\n+\n+    /**\n+     * Returns true if the annotation is a wrapper for multiple repeated annotations.\n+     *\n+     * @param annotationType the declaration of the annotation to test\n+     * @return true if the annotation is a wrapper for multiple repeated annotations\n+     */\n+    private boolean isListForRepeatedAnnotationImplementation(DeclaredType annotationType) {\n+        TypeMirror enclosingType = annotationType.getEnclosingType();\n+        if (enclosingType == null) {\n+            return false;\n+        }\n+        if (!annotationType.asElement().getSimpleName().contentEquals(\"List\")) {", "originalCommit": "c0602e2424dabb88f36a123785308149490be9a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUzMjgxNA==", "url": "https://github.com/typetools/checker-framework/pull/3138#discussion_r399532814", "bodyText": "Thanks for pointing this out.\nI think it's best to make this pull request complete rather than splitting the work across multiple pull requests.  I have added documentation to the manual.\nI also think it's better to be opinionated about the naming convention.  Consistency will help users to understand behavior, and there will be less for users to understand.", "author": "mernst", "createdAt": "2020-03-27T20:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk2NTU1Ng=="}], "type": "inlineReview"}, {"oid": "c0ea5503b1cfe968e6a86bf73e3927c8cc713be1", "url": "https://github.com/typetools/checker-framework/commit/c0ea5503b1cfe968e6a86bf73e3927c8cc713be1", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-27T20:36:28Z", "type": "commit"}, {"oid": "76e25c1186bf09daf1f286867eb866de1a881915", "url": "https://github.com/typetools/checker-framework/commit/76e25c1186bf09daf1f286867eb866de1a881915", "message": "How to make a pre- or post-condition annotation repeatable", "committedDate": "2020-03-27T20:52:41Z", "type": "commit"}, {"oid": "8aee39783ce099cd8e48b66cc03a56877212293a", "url": "https://github.com/typetools/checker-framework/commit/8aee39783ce099cd8e48b66cc03a56877212293a", "message": "Merge ../checker-framework-branch-master into repeatable-annotations", "committedDate": "2020-03-30T05:59:47Z", "type": "commit"}]}