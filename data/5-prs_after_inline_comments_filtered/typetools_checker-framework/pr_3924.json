{"pr_number": 3924, "pr_title": "Define method ElementUtils.closure", "pr_createdAt": "2020-11-23T15:07:18Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3924", "timeline": [{"oid": "348062dd77be7223058bd7c601f324d1f9848772", "url": "https://github.com/typetools/checker-framework/commit/348062dd77be7223058bd7c601f324d1f9848772", "message": "Define method ElementUtils.closure", "committedDate": "2020-11-22T10:56:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2MjMyOQ==", "url": "https://github.com/typetools/checker-framework/pull/3924#discussion_r529162329", "bodyText": "closure is a very non-specific name for this method. What does it close over? All supertypes? Or all subtypes? Or something else?\nWasn't the previous getAllSupertypes much clearer?", "author": "wmdietl", "createdAt": "2020-11-24T02:37:17Z", "path": "javacutil/src/main/java/org/checkerframework/javacutil/ElementUtils.java", "diffHunk": "@@ -661,4 +664,20 @@ public static TypeElement getTypeElement(ProcessingEnvironment processingEnv, Cl\n         }\n         return processingEnv.getElementUtils().getTypeElement(className);\n     }\n+\n+    /**\n+     * Get all the supertypes of a given type, including the type itself.\n+     *\n+     * @param type a type\n+     * @param env the processing environment\n+     * @return list including the type and all its supertypes, with a guarantee that supertypes\n+     *     (i.e. those that appear in extends clauses) appear before indirect supertypes\n+     */\n+    public static List<TypeElement> closure(TypeElement type, ProcessingEnvironment env) {", "originalCommit": "348062dd77be7223058bd7c601f324d1f9848772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTUzNTIwNw==", "url": "https://github.com/typetools/checker-framework/pull/3924#discussion_r529535207", "bodyText": "Yes, I also prefer the name getAllSupertypes.\nThis method is just a wrapper around an existing method in com.sun.tools.javac.code.Types.  I want to make the correspondence clear, and I don't want to invent new terminology.", "author": "mernst", "createdAt": "2020-11-24T13:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2MjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY0MDE5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3924#discussion_r529640199", "bodyText": "In many recent changes we preferred clear terminology based on the JLS over implementation terminology from javac.\nThis would seem like a clear instance where we should not feel bound to an obscure term that is used in an implementation class and instead strive for clarity and uniformity in our utility classes.", "author": "wmdietl", "createdAt": "2020-11-24T15:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2MjMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzk5Ng==", "url": "https://github.com/typetools/checker-framework/pull/3924#discussion_r529727996", "bodyText": "I think you are right.  I will change this.  Thanks for the suggestion.", "author": "mernst", "createdAt": "2020-11-24T16:52:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE2MjMyOQ=="}], "type": "inlineReview"}]}