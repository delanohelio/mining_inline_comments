{"pr_number": 3529, "pr_title": "Called Methods Checker", "pr_createdAt": "2020-07-30T00:49:45Z", "pr_url": "https://github.com/typetools/checker-framework/pull/3529", "timeline": [{"oid": "8557afb731f93747dd013519bcf1961754a69fb7", "url": "https://github.com/typetools/checker-framework/commit/8557afb731f93747dd013519bcf1961754a69fb7", "message": "initial draft of Object Construction Checker built on the generic accumulation checker", "committedDate": "2020-07-30T00:39:49Z", "type": "commit"}, {"oid": "f8b40b15fd21bb36de8d40a071a4e9412fb0701c", "url": "https://github.com/typetools/checker-framework/commit/f8b40b15fd21bb36de8d40a071a4e9412fb0701c", "message": "remove external link to OCC, and actually include the manual chapteR", "committedDate": "2020-07-30T00:45:03Z", "type": "commit"}, {"oid": "ae4ca6f50c8dcbc85cfb793a58c1abae99177a5f", "url": "https://github.com/typetools/checker-framework/commit/ae4ca6f50c8dcbc85cfb793a58c1abae99177a5f", "message": "Merge branch 'master' of github.com:typetools/checker-framework into object-construction-checker", "committedDate": "2020-07-30T15:59:57Z", "type": "commit"}, {"oid": "e8802fd89567c3ba8ca853d92b453fab4c382197", "url": "https://github.com/typetools/checker-framework/commit/e8802fd89567c3ba8ca853d92b453fab4c382197", "message": "add newline", "committedDate": "2020-07-30T17:02:59Z", "type": "commit"}, {"oid": "eb2bf542a525793c513ba476ee9958e6d8da1f11", "url": "https://github.com/typetools/checker-framework/commit/eb2bf542a525793c513ba476ee9958e6d8da1f11", "message": "fix up Javadoc", "committedDate": "2020-07-30T23:20:23Z", "type": "commit"}, {"oid": "12c181cf07b818191b5672ea2dc7367a58fc7c21", "url": "https://github.com/typetools/checker-framework/commit/12c181cf07b818191b5672ea2dc7367a58fc7c21", "message": "force UTF-8 in predicate test", "committedDate": "2020-07-30T23:20:52Z", "type": "commit"}, {"oid": "5d9f3ae9aec51836777e02f561cae590b8880d2e", "url": "https://github.com/typetools/checker-framework/commit/5d9f3ae9aec51836777e02f561cae590b8880d2e", "message": "rename objcon chapter to match pattern", "committedDate": "2020-07-31T16:16:32Z", "type": "commit"}, {"oid": "437ff337d120da0fca42df422a65f125c1e892c6", "url": "https://github.com/typetools/checker-framework/commit/437ff337d120da0fca42df422a65f125c1e892c6", "message": "move expected error message location because of formatting change", "committedDate": "2020-07-31T16:32:11Z", "type": "commit"}, {"oid": "b9be21ccd1116ff983d6c7785defa7d736411f2a", "url": "https://github.com/typetools/checker-framework/commit/b9be21ccd1116ff983d6c7785defa7d736411f2a", "message": "fix compilermessagekey problem", "committedDate": "2020-07-31T18:04:28Z", "type": "commit"}, {"oid": "8d1b0972bf68ce286fa6283b6232866e12c47cda", "url": "https://github.com/typetools/checker-framework/commit/8d1b0972bf68ce286fa6283b6232866e12c47cda", "message": "interning", "committedDate": "2020-07-31T19:21:40Z", "type": "commit"}, {"oid": "407359fda3d0c5f65808d11d89685c6755cb0f70", "url": "https://github.com/typetools/checker-framework/commit/407359fda3d0c5f65808d11d89685c6755cb0f70", "message": "correct some latex errors", "committedDate": "2020-07-31T22:12:27Z", "type": "commit"}, {"oid": "4d08c3e2b2fa38d4f094d070468be1d036903a71", "url": "https://github.com/typetools/checker-framework/commit/4d08c3e2b2fa38d4f094d070468be1d036903a71", "message": "correct latex error", "committedDate": "2020-08-03T14:53:12Z", "type": "commit"}, {"oid": "3c6c0ef199f93b881f22b6109cb14333341c59e5", "url": "https://github.com/typetools/checker-framework/commit/3c6c0ef199f93b881f22b6109cb14333341c59e5", "message": "do not depend on AutoValue at compile time", "committedDate": "2020-08-03T20:46:34Z", "type": "commit"}, {"oid": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "url": "https://github.com/typetools/checker-framework/commit/cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "message": "rename everything to called methods", "committedDate": "2020-08-03T23:26:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MDg1OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464750858", "bodyText": "Maybe rephrase?  Something like \"An old version of the annotation, retained for compatibility with Lombok\"\nCan we add a @Deprecated annotation here?", "author": "msridhar", "createdAt": "2020-08-04T01:45:06Z", "path": "checker/src/main/java/org/checkerframework/checker/builder/qual/CalledMethods.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.checkerframework.checker.builder.qual;\n+\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * For compatibility with Lombok, retain the old annotations it generates.", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxNzg3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465317879", "bodyText": "We decided against it when we merged kelloggm/object-construction-checker#122. The reason is that it would cause deprecation warnings in delomboked code, which is annoying. I'll add a comment to that effect.", "author": "kelloggm", "createdAt": "2020-08-04T20:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MDg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzgxOQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465377819", "bodyText": "Ok.  I would still rephrase the first sentence of this Javadoc comment", "author": "msridhar", "createdAt": "2020-08-04T23:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MDg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTA5OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464751099", "bodyText": "Maybe @Deprecated for this one also?", "author": "msridhar", "createdAt": "2020-08-04T01:46:12Z", "path": "checker/src/main/java/org/checkerframework/checker/builder/qual/ReturnsReceiver.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package org.checkerframework.checker.builder.qual;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * This declaration annotation indicates that the method on which it is written returns exactly the\n+ * receiver object.\n+ *\n+ * <p>This annotation can only be written on a method declaration. It is inherited by all overrides\n+ * of that method.\n+ *\n+ * <p>This annotation has been replaced by {@link\n+ * org.checkerframework.common.returnsreceiver.qual.This}. It is retained only for", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTMwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464751301", "bodyText": "Is it a meaningful performance optimization to keep this in a field?", "author": "msridhar", "createdAt": "2020-08-04T01:47:00Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,334 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /** {@link java.util.Collections#singletonList} is treated specially by the EC2 logic. */\n+    private final ExecutableElement collectionsSingletonList;", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMxOTMzOA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465319338", "bodyText": "I don't have any evidence that it is. It's in a field now for code readability, I think.", "author": "kelloggm", "createdAt": "2020-08-04T20:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTMwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3Nzk3MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465377971", "bodyText": "Ok.  Since we don't create a lot of type factory objects this is fine", "author": "msridhar", "createdAt": "2020-08-04T23:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ3NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464751474", "bodyText": "Do we need to rename this option to mention it's for this checker?", "author": "msridhar", "createdAt": "2020-08-04T01:47:41Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,334 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /** {@link java.util.Collections#singletonList} is treated specially by the EC2 logic. */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyODM3NQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465328375", "bodyText": "Good catch, we definitely should. I'm going to change it to -AcalledMethodsUseValueChecker, but I'm open to other names.\nDo you think we should also rename -AdisableFrameworkSupports in a similar way?", "author": "kelloggm", "createdAt": "2020-08-04T21:02:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg1MzAwNQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465853005", "bodyText": "There is a general mechanism to pass an option only to a particular checker: https://github.com/typetools/checker-framework/blob/master/docs/manual/introduction.tex#L572\nSo including the checker name in the option seems like overkill to me.", "author": "wmdietl", "createdAt": "2020-08-05T16:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA1NjE3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r466056179", "bodyText": "Thanks for pointing this out, @wmdietl. I've made the change.", "author": "kelloggm", "createdAt": "2020-08-05T23:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjMxOA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464752318", "bodyText": "Camel case", "author": "msridhar", "createdAt": "2020-08-04T01:50:46Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,334 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /** {@link java.util.Collections#singletonList} is treated specially by the EC2 logic. */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The collection of built-in framework support for the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new calledmethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new calledmethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,\n+                // passing through as many method invocation trees as needed. This code is searching\n+                // for code of the form:\n+                // new Filter(\"owner\").withValues(\"...\")\n+                // or code of the form:\n+                // new Filter().*.withName(\"owner\").*\n+\n+                // Set to non-null iff a call to withName was observed; in that case, this\n+                // variable's\n+                // value is the argument to withName.\n+                String withNameArg = null;\n+                ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\n+\n+                while (filterTree != null && filterTree.getKind() == Tree.Kind.METHOD_INVOCATION) {\n+\n+                    MethodInvocationTree filterTreeAsMethodInvocation =\n+                            (MethodInvocationTree) filterTree;\n+                    String filterMethodName =\n+                            TreeUtils.methodName(filterTreeAsMethodInvocation).toString();\n+                    if (\"withName\".equals(filterMethodName)\n+                            && filterTreeAsMethodInvocation.getArguments().size() >= 1) {\n+                        Tree withNameArgTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                        withNameArg =\n+                                ValueCheckerUtils.getExactStringValue(withNameArgTree, valueATF);\n+                    }\n+\n+                    // Descend into a call to Collections.singletonList()\n+                    if (TreeUtils.isMethodInvocation(\n+                            filterTree, collectionsSingletonList, getProcessingEnv())) {\n+                        filterTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                    } else {\n+                        filterTree =\n+                                TreeUtils.getReceiverTree(\n+                                        filterTreeAsMethodInvocation.getMethodSelect());\n+                    }\n+                }\n+                if (filterTree == null) {\n+                    continue;\n+                }\n+                if (filterTree.getKind() == Tree.Kind.NEW_CLASS) {\n+\n+                    String value;\n+                    if (withNameArg != null) {\n+                        value = withNameArg;\n+                    } else {\n+                        ExpressionTree constructorArg =\n+                                ((NewClassTree) filterTree).getArguments().get(0);\n+                        value = ValueCheckerUtils.getExactStringValue(constructorArg, valueATF);\n+                    }\n+\n+                    if (value != null) {\n+                        switch (value) {\n+                            case \"owner\":\n+                            case \"owner-alias\":\n+                            case \"owner-id\":\n+                                return \"withOwners\";\n+                            case \"image-id\":\n+                                return \"withImageIds\";\n+                            default:\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return methodName;\n+    }\n+\n+    /** Necessary for the type rule for called methods described below. */\n+    private class calledmethodsTreeAnnotator extends AccumulationTreeAnnotator {", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjQxMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464752412", "bodyText": "Camel case", "author": "msridhar", "createdAt": "2020-08-04T01:51:08Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,334 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /** {@link java.util.Collections#singletonList} is treated specially by the EC2 logic. */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The collection of built-in framework support for the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new calledmethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new calledmethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,\n+                // passing through as many method invocation trees as needed. This code is searching\n+                // for code of the form:\n+                // new Filter(\"owner\").withValues(\"...\")\n+                // or code of the form:\n+                // new Filter().*.withName(\"owner\").*\n+\n+                // Set to non-null iff a call to withName was observed; in that case, this\n+                // variable's\n+                // value is the argument to withName.\n+                String withNameArg = null;\n+                ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\n+\n+                while (filterTree != null && filterTree.getKind() == Tree.Kind.METHOD_INVOCATION) {\n+\n+                    MethodInvocationTree filterTreeAsMethodInvocation =\n+                            (MethodInvocationTree) filterTree;\n+                    String filterMethodName =\n+                            TreeUtils.methodName(filterTreeAsMethodInvocation).toString();\n+                    if (\"withName\".equals(filterMethodName)\n+                            && filterTreeAsMethodInvocation.getArguments().size() >= 1) {\n+                        Tree withNameArgTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                        withNameArg =\n+                                ValueCheckerUtils.getExactStringValue(withNameArgTree, valueATF);\n+                    }\n+\n+                    // Descend into a call to Collections.singletonList()\n+                    if (TreeUtils.isMethodInvocation(\n+                            filterTree, collectionsSingletonList, getProcessingEnv())) {\n+                        filterTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                    } else {\n+                        filterTree =\n+                                TreeUtils.getReceiverTree(\n+                                        filterTreeAsMethodInvocation.getMethodSelect());\n+                    }\n+                }\n+                if (filterTree == null) {\n+                    continue;\n+                }\n+                if (filterTree.getKind() == Tree.Kind.NEW_CLASS) {\n+\n+                    String value;\n+                    if (withNameArg != null) {\n+                        value = withNameArg;\n+                    } else {\n+                        ExpressionTree constructorArg =\n+                                ((NewClassTree) filterTree).getArguments().get(0);\n+                        value = ValueCheckerUtils.getExactStringValue(constructorArg, valueATF);\n+                    }\n+\n+                    if (value != null) {\n+                        switch (value) {\n+                            case \"owner\":\n+                            case \"owner-alias\":\n+                            case \"owner-id\":\n+                                return \"withOwners\";\n+                            case \"image-id\":\n+                                return \"withImageIds\";\n+                            default:\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return methodName;\n+    }\n+\n+    /** Necessary for the type rule for called methods described below. */\n+    private class calledmethodsTreeAnnotator extends AccumulationTreeAnnotator {\n+        /**\n+         * Creates an instance of this tree annotator for the given type factory.\n+         *\n+         * @param factory the type factory\n+         */\n+        public calledmethodsTreeAnnotator(AccumulationAnnotatedTypeFactory factory) {\n+            super(factory);\n+        }\n+\n+        @Override\n+        public Void visitMethodInvocation(MethodInvocationTree tree, AnnotatedTypeMirror type) {\n+            // CalledMethods requires special treatment of the return values of methods that return\n+            // their receiver: the default return type must include the method being invoked.\n+            //\n+            // The basic accumulation analysis cannot handle this case - it can use the RR checker\n+            // to transfer an annotation from the receiver to the return type, but because\n+            // accumulation\n+            // (has to) happen in dataflow, the correct annotation may not yet be available. The\n+            // basic\n+            // accumulation analysis therefore only supports \"pass-through\" returns receiver\n+            // methods;\n+            // it does not support automatically accumulating at the same time.\n+            if (returnsThis(tree)) {\n+                String methodName = TreeUtils.getMethodName(tree.getMethodSelect());\n+                methodName = adjustMethodNameUsingValueChecker(methodName, tree);\n+                AnnotationMirror oldAnno = type.getAnnotationInHierarchy(top);\n+                AnnotationMirror newAnno =\n+                        qualHierarchy.greatestLowerBound(\n+                                oldAnno, createAccumulatorAnnotation(methodName));\n+                type.replaceAnnotation(newAnno);\n+            }\n+            return super.visitMethodInvocation(tree, type);\n+        }\n+\n+        @Override\n+        public Void visitNewClass(NewClassTree tree, AnnotatedTypeMirror type) {\n+            for (FrameworkSupport frameworkSupport : frameworkSupports) {\n+                frameworkSupport.handleConstructor(tree, type);\n+            }\n+            return super.visitNewClass(tree, type);\n+        }\n+    }\n+\n+    /**\n+     * Adds @CalledMethod annotations for build() methods of AutoValue and Lombok Builders to ensure\n+     * required properties have been set.\n+     */\n+    private class calledmethodsTypeAnnotator extends TypeAnnotator {", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MjcyMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464752722", "bodyText": "Update to say this is just one use case for the checker?", "author": "msridhar", "createdAt": "2020-08-04T01:52:12Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods checker, which allows programmers to specify\n+ * unsafe combinations of options to builder or builder-like interfaces and prevent dangerous", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MzA1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464753059", "bodyText": "Do we still want to keep this code for collecting metrics?", "author": "msridhar", "createdAt": "2020-08-04T01:53:27Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods checker, which allows programmers to specify\n+ * unsafe combinations of options to builder or builder-like interfaces and prevent dangerous\n+ * objects from being instantiated.\n+ *\n+ * <p>Note that this checker respects the suppress warning keys from its earlier names (\"builder\",\n+ * \"object.construction\", and \"objectconstruction\" in addition to its own keys (\"calledmethods\" and\n+ * \"called.methods\").\n+ */\n+@SuppressWarningsPrefix({\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\",\n+    \"calledmethods\",\n+    \"called.methods\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, use the Value Checker to reduce false positives when analyzing\n+     * calls to the AWS SDK.\n+     */\n+    public static final String USE_VALUE_CHECKER = \"useValueChecker\";\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMyOTQ2Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465329462", "bodyText": "I don't see any reason to remove it", "author": "kelloggm", "createdAt": "2020-08-04T21:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3ODA1OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r465378058", "bodyText": "Ok", "author": "msridhar", "createdAt": "2020-08-04T23:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MzA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1NDMwMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r464754300", "bodyText": "We should change these Lombok tests to run delombok on the original source rather than committing the delombok'd code.  We did this for returns receiver", "author": "msridhar", "createdAt": "2020-08-04T01:58:15Z", "path": "checker/tests/calledmethods-lombok/BuilderTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+// Generated by delombok at Thu May 16 14:44:28 PDT 2019\n+\n+import lombok.NonNull;\n+\n+public class BuilderTest {", "originalCommit": "cc4bea6b0e1241dd56ddd539168b2e0c11a93c2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e017441887025bb1cae2d320f622c10f8ace69bc", "url": "https://github.com/typetools/checker-framework/commit/e017441887025bb1cae2d320f622c10f8ace69bc", "message": "Merge branch 'master' of github.com:typetools/checker-framework into object-construction-checker", "committedDate": "2020-08-04T20:38:05Z", "type": "commit"}, {"oid": "f35fb4644908777ebbc49f5ce82c4025a5d8e767", "url": "https://github.com/typetools/checker-framework/commit/f35fb4644908777ebbc49f5ce82c4025a5d8e767", "message": "address PR feedback", "committedDate": "2020-08-04T22:30:40Z", "type": "commit"}, {"oid": "0ed085e8b1d0c4f6330f207a8d3d044cf967c24e", "url": "https://github.com/typetools/checker-framework/commit/0ed085e8b1d0c4f6330f207a8d3d044cf967c24e", "message": "remove commented code", "committedDate": "2020-08-05T16:15:59Z", "type": "commit"}, {"oid": "d39dbc1689fbb01efcfebdb75d2f5cb228234caf", "url": "https://github.com/typetools/checker-framework/commit/d39dbc1689fbb01efcfebdb75d2f5cb228234caf", "message": "Merge branch 'master' of github.com:typetools/checker-framework into object-construction-checker", "committedDate": "2020-08-05T22:42:20Z", "type": "commit"}, {"oid": "8b2bd0fa274033240529d5b93d7c82e5cf117060", "url": "https://github.com/typetools/checker-framework/commit/8b2bd0fa274033240529d5b93d7c82e5cf117060", "message": "edits to opening of CMC manual chapter, and add a section about AMI sniping", "committedDate": "2020-08-05T23:00:37Z", "type": "commit"}, {"oid": "a1181c4206bb1c793e6a17974d172c3cf74393a9", "url": "https://github.com/typetools/checker-framework/commit/a1181c4206bb1c793e6a17974d172c3cf74393a9", "message": "use standard convention for checker-specific option", "committedDate": "2020-08-05T23:18:23Z", "type": "commit"}, {"oid": "1f8ed8fab27efd20be993bd5f889c783fd67712a", "url": "https://github.com/typetools/checker-framework/commit/1f8ed8fab27efd20be993bd5f889c783fd67712a", "message": "correct latex error", "committedDate": "2020-08-06T15:17:56Z", "type": "commit"}, {"oid": "34dc760b51e4599bc128f7d93bab9aa0e7e72c2b", "url": "https://github.com/typetools/checker-framework/commit/34dc760b51e4599bc128f7d93bab9aa0e7e72c2b", "message": "use checker-specific option", "committedDate": "2020-08-07T22:26:14Z", "type": "commit"}, {"oid": "e53246ac8cf8ea6008bdddf48989b605974988e9", "url": "https://github.com/typetools/checker-framework/commit/e53246ac8cf8ea6008bdddf48989b605974988e9", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-08-08T17:59:54Z", "type": "commit"}, {"oid": "904340b2d0ed00cc417f03c23970ab11d79417ae", "url": "https://github.com/typetools/checker-framework/commit/904340b2d0ed00cc417f03c23970ab11d79417ae", "message": "Fix LaTeX error", "committedDate": "2020-08-08T18:01:58Z", "type": "commit"}, {"oid": "3a9222f8b032890957a26c42dabf355ec2ef1574", "url": "https://github.com/typetools/checker-framework/commit/3a9222f8b032890957a26c42dabf355ec2ef1574", "message": "Review of manual", "committedDate": "2020-08-08T19:54:18Z", "type": "commit"}, {"oid": "009d77280a8c665a1feb8ba00b9fd9a7f9d6e257", "url": "https://github.com/typetools/checker-framework/commit/009d77280a8c665a1feb8ba00b9fd9a7f9d6e257", "message": "Code review of qualifiers", "committedDate": "2020-08-09T00:13:15Z", "type": "commit"}, {"oid": "a5fd00dc3ae334669eb6df142e9f0e51fd565970", "url": "https://github.com/typetools/checker-framework/commit/a5fd00dc3ae334669eb6df142e9f0e51fd565970", "message": "Update version of require-javadoc", "committedDate": "2020-08-09T00:46:55Z", "type": "commit"}, {"oid": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "url": "https://github.com/typetools/checker-framework/commit/87575cdbdea673a5180c899f412db9cb3e7b28d2", "message": "Checkpoint", "committedDate": "2020-08-09T03:47:35Z", "type": "commit"}, {"oid": "f573b247dfba008a4eecfbf064291d2aace8d0b2", "url": "https://github.com/typetools/checker-framework/commit/f573b247dfba008a4eecfbf064291d2aace8d0b2", "message": "Checkpoint", "committedDate": "2020-08-09T04:23:26Z", "type": "commit"}, {"oid": "e2f20febfed5559e0183ae380be467d4c9fd4d02", "url": "https://github.com/typetools/checker-framework/commit/e2f20febfed5559e0183ae380be467d4c9fd4d02", "message": "Add failing test", "committedDate": "2020-08-09T04:23:45Z", "type": "commit"}, {"oid": "608cf2bf1dad2572436e06b32f6ab2d5f82398e4", "url": "https://github.com/typetools/checker-framework/commit/608cf2bf1dad2572436e06b32f6ab2d5f82398e4", "message": "Checkpoint", "committedDate": "2020-08-09T04:46:18Z", "type": "commit"}, {"oid": "e969396f5c26ff302a36dc854b6098e537cc9200", "url": "https://github.com/typetools/checker-framework/commit/e969396f5c26ff302a36dc854b6098e537cc9200", "message": "Tweak terminology", "committedDate": "2020-08-09T04:51:38Z", "type": "commit"}, {"oid": "26bc1b78d99ebcb4b5300890696be1815ca7ed6f", "url": "https://github.com/typetools/checker-framework/commit/26bc1b78d99ebcb4b5300890696be1815ca7ed6f", "message": "Fix typo", "committedDate": "2020-08-09T04:52:20Z", "type": "commit"}, {"oid": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "url": "https://github.com/typetools/checker-framework/commit/14be05553b2f8d6abfae73a7f31718b2737e9f81", "message": "Checkpoint", "committedDate": "2020-08-09T04:54:19Z", "type": "commit"}, {"oid": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "url": "https://github.com/typetools/checker-framework/commit/3650f626a239d0ff430e7f61ee436bf60c0e160a", "message": "Checkpoint", "committedDate": "2020-08-09T05:12:46Z", "type": "commit"}, {"oid": "8d61d864463c1e6157dfaf1d4588f0534f0d7191", "url": "https://github.com/typetools/checker-framework/commit/8d61d864463c1e6157dfaf1d4588f0534f0d7191", "message": "Checkpoint", "committedDate": "2020-08-09T05:24:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjU0OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467532549", "bodyText": "When reading this, I wondered how EC2's operation mattered to the checker.  Making this into a cross-reference would make it clearer.", "author": "mernst", "createdAt": "2020-08-09T03:56:54Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by the EC2\n+     * logic.", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjkyMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467532920", "bodyText": "I don't see a benefit to supporting whitespace, especially on both sides of the comma.  It would simplify the code to require users to use a more restricted format.  That is compatible with what the Checker Framework uses elsewhere (comma-no-space-separated), and it means that there won't be multiple different user invocations that mean the same thing but look different because of whitespace.", "author": "mernst", "createdAt": "2020-08-09T04:02:27Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class of static methods used in supporting builder-generation frameworks. */\n+public class FrameworkSupportUtils {\n+    /** This class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /**\n+     * Checks whether the given type is one of the immutable collections defined in\n+     * com.google.common.collect.\n+     *\n+     * @param type a Java type\n+     * @return whether the type is a Guava immutable collection\n+     */\n+    public static boolean isGuavaImmutableType(TypeMirror type) {\n+        return type.toString().startsWith(\"com.google.common.collect.Immutable\");\n+    }\n+\n+    /**\n+     * Capitalizes the first letter of the given string\n+     *\n+     * @param prop a String\n+     * @return the same String, but with the first character capitalized\n+     */\n+    public static String capitalize(String prop) {\n+        return prop.substring(0, 1).toUpperCase() + prop.substring(1);\n+    }\n+\n+    /**\n+     * Given an annotation name, return true if the element has the annotation of that name\n+     *\n+     * @param element the element\n+     * @param annotName name of the annotation\n+     * @return true if the element has the annotation of that name\n+     */\n+    public static boolean hasAnnotation(Element element, String annotName) {\n+        return element.getAnnotationMirrors().stream()\n+                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotName));\n+    }\n+\n+    /** The frameworks supported by the checker. */\n+    public enum Framework {\n+        AUTO_VALUE,\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Gets the list of supported that are currently enabled frameworks.\n+     *\n+     * @param option the value of the framework support option\n+     * @return the list of enabled frameworks\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMjkyMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467532922", "bodyText": "Since the variables LOMBOK_SUPPORT and AUTOVALUE_SUPPORT already exist, why is there a need for an enum as well?  The code below translates from strings to an enum, but the sole client immediately uses a switch statement (just like the one here).  That client might as well just use strings in its switch statement, eliminating the need for the enum and for the getFrameworkSet routine.", "author": "mernst", "createdAt": "2020-08-09T04:02:28Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class of static methods used in supporting builder-generation frameworks. */\n+public class FrameworkSupportUtils {\n+    /** This class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /**\n+     * Checks whether the given type is one of the immutable collections defined in\n+     * com.google.common.collect.\n+     *\n+     * @param type a Java type\n+     * @return whether the type is a Guava immutable collection\n+     */\n+    public static boolean isGuavaImmutableType(TypeMirror type) {\n+        return type.toString().startsWith(\"com.google.common.collect.Immutable\");\n+    }\n+\n+    /**\n+     * Capitalizes the first letter of the given string\n+     *\n+     * @param prop a String\n+     * @return the same String, but with the first character capitalized\n+     */\n+    public static String capitalize(String prop) {\n+        return prop.substring(0, 1).toUpperCase() + prop.substring(1);\n+    }\n+\n+    /**\n+     * Given an annotation name, return true if the element has the annotation of that name\n+     *\n+     * @param element the element\n+     * @param annotName name of the annotation\n+     * @return true if the element has the annotation of that name\n+     */\n+    public static boolean hasAnnotation(Element element, String annotName) {\n+        return element.getAnnotationMirrors().stream()\n+                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotName));\n+    }\n+\n+    /** The frameworks supported by the checker. */\n+    public enum Framework {", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMzExNA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467533114", "bodyText": "When revising the code, please issue an error if any of the strings is not recognized.", "author": "mernst", "createdAt": "2020-08-09T04:05:10Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class of static methods used in supporting builder-generation frameworks. */\n+public class FrameworkSupportUtils {\n+    /** This class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /**\n+     * Checks whether the given type is one of the immutable collections defined in\n+     * com.google.common.collect.\n+     *\n+     * @param type a Java type\n+     * @return whether the type is a Guava immutable collection\n+     */\n+    public static boolean isGuavaImmutableType(TypeMirror type) {\n+        return type.toString().startsWith(\"com.google.common.collect.Immutable\");\n+    }\n+\n+    /**\n+     * Capitalizes the first letter of the given string\n+     *\n+     * @param prop a String\n+     * @return the same String, but with the first character capitalized\n+     */\n+    public static String capitalize(String prop) {\n+        return prop.substring(0, 1).toUpperCase() + prop.substring(1);\n+    }\n+\n+    /**\n+     * Given an annotation name, return true if the element has the annotation of that name\n+     *\n+     * @param element the element\n+     * @param annotName name of the annotation\n+     * @return true if the element has the annotation of that name\n+     */\n+    public static boolean hasAnnotation(Element element, String annotName) {\n+        return element.getAnnotationMirrors().stream()\n+                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotName));\n+    }\n+\n+    /** The frameworks supported by the checker. */\n+    public enum Framework {\n+        AUTO_VALUE,\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Gets the list of supported that are currently enabled frameworks.\n+     *\n+     * @param option the value of the framework support option\n+     * @return the list of enabled frameworks\n+     */\n+    public static EnumSet<Framework> getFrameworkSet(String option) {\n+        EnumSet<Framework> frameworkSet = EnumSet.allOf(Framework.class);\n+\n+        if (option != null) {\n+            for (String disabledFrameworkSupport : option.split(\"\\\\s?,\\\\s?\")) {\n+                switch (disabledFrameworkSupport.toUpperCase()) {\n+                    case CalledMethodsChecker.AUTOVALUE_SUPPORT:\n+                        frameworkSet.remove(Framework.AUTO_VALUE);\n+                        break;\n+                    case CalledMethodsChecker.LOMBOK_SUPPORT:\n+                        frameworkSet.remove(Framework.LOMBOK);\n+                        break;\n+                }", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMzQ4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467533482", "bodyText": "I don't see the code searching for \"withValues\".", "author": "mernst", "createdAt": "2020-08-09T04:11:29Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by the EC2\n+     * logic.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The frameworks (such as Lombok and AutoValue) supported by the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new CalledMethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new CalledMethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,\n+                // passing through as many method invocation trees as needed. This code is searching\n+                // for code of the form:\n+                // new Filter(\"owner\").withValues(\"...\")", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODExMTgxNw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468111817", "bodyText": "That's an example, not the actual target. I've clarified the comment.", "author": "kelloggm", "createdAt": "2020-08-10T18:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMzQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzMzYwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467533601", "bodyText": "Please make the name of the class consistent with the name of the directory.  Otherwise, there may be confusion, and my automated tools don't work to run the appropriate test.\nIn this case, I think the best name for the test and the directory should mention the Value Checker.  Both \"EC2\" and \"CVE\" don't describe what functionality the test is testing.", "author": "mernst", "createdAt": "2020-08-09T04:13:40Z", "path": "checker/src/test/java/tests/CalledMethodsEC2Test.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package tests;\n+\n+import java.io.File;\n+import java.util.List;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.framework.test.CheckerFrameworkPerDirectoryTest;\n+import org.junit.runners.Parameterized;\n+\n+public class CalledMethodsEC2Test extends CheckerFrameworkPerDirectoryTest {", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNDQ5OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467534498", "bodyText": "It is surprising to me that the loop continues and may reset withNameArg.  Since the loop goes from the end of the expression to the beginning, this overwriting of withNameArg seems like the wrong thing.\nIt might permit cleaner code (that could use the return statement, for example) to abstract out obtaining withNameArg.  I'm not positive that refactoring would work out, but it might be worth considering.", "author": "mernst", "createdAt": "2020-08-09T04:26:52Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by the EC2\n+     * logic.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The frameworks (such as Lombok and AutoValue) supported by the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new CalledMethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new CalledMethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,\n+                // passing through as many method invocation trees as needed. This code is searching\n+                // for code of the form:\n+                // new Filter(\"owner\").withValues(\"...\")\n+                // or code of the form:\n+                // new Filter().*.withName(\"owner\").*\n+\n+                // Set to non-null iff a call to withName was observed; in that case, this\n+                // variable's\n+                // value is the argument to withName.\n+                String withNameArg = null;\n+                ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\n+\n+                while (filterTree != null && filterTree.getKind() == Tree.Kind.METHOD_INVOCATION) {\n+\n+                    MethodInvocationTree filterTreeAsMethodInvocation =\n+                            (MethodInvocationTree) filterTree;\n+                    String filterMethodName =\n+                            TreeUtils.methodName(filterTreeAsMethodInvocation).toString();\n+                    if (\"withName\".equals(filterMethodName)\n+                            && filterTreeAsMethodInvocation.getArguments().size() >= 1) {\n+                        Tree withNameArgTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                        withNameArg =", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNDg0Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467534847", "bodyText": "This isn't searching the arguments to find one Filter invocation.  (That's how I read the comment.)  Rather, it processes each argument that is a Filter constructor invocation.", "author": "mernst", "createdAt": "2020-08-09T04:31:54Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by the EC2\n+     * logic.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The frameworks (such as Lombok and AutoValue) supported by the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new CalledMethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new CalledMethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNTAwMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467535001", "bodyText": "Please choose a more descriptive variable name, or add a comment to explain what this variable represents.\nIt seems to be either the argument to getName or the argument to new Filter.", "author": "mernst", "createdAt": "2020-08-09T04:34:52Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,337 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.EnumSet;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.framework.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupportUtils;\n+import org.checkerframework.checker.calledmethods.framework.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by the EC2\n+     * logic.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /** The frameworks (such as Lombok and AutoValue) supported by the Called Methods checker. */\n+    private Collection<FrameworkSupport> frameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new accumulation checker's annotated type factory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        EnumSet<FrameworkSupportUtils.Framework> frameworkSet =\n+                FrameworkSupportUtils.getFrameworkSet(\n+                        checker.getOption(CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS));\n+        frameworkSupports = new ArrayList<>();\n+\n+        for (FrameworkSupportUtils.Framework framework : frameworkSet) {\n+            switch (framework) {\n+                case AUTO_VALUE:\n+                    frameworkSupports.add(new AutoValueSupport(this));\n+                    break;\n+                case LOMBOK:\n+                    frameworkSupports.add(new LombokSupport(this));\n+                    break;\n+            }\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new CalledMethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new CalledMethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for\n+     * backwards-compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has a ReturnsReceiver declaration\n+     *     annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(TreeUtils.elementFromUse(tree), ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the method that the tree should be considered as calling. Returns\n+     * \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter. Returns\n+     * \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition.\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            for (Tree filterTree : tree.getArguments()) {\n+                // Search the arguments to withFilters for a Filter constructor invocation,\n+                // passing through as many method invocation trees as needed. This code is searching\n+                // for code of the form:\n+                // new Filter(\"owner\").withValues(\"...\")\n+                // or code of the form:\n+                // new Filter().*.withName(\"owner\").*\n+\n+                // Set to non-null iff a call to withName was observed; in that case, this\n+                // variable's\n+                // value is the argument to withName.\n+                String withNameArg = null;\n+                ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\n+\n+                while (filterTree != null && filterTree.getKind() == Tree.Kind.METHOD_INVOCATION) {\n+\n+                    MethodInvocationTree filterTreeAsMethodInvocation =\n+                            (MethodInvocationTree) filterTree;\n+                    String filterMethodName =\n+                            TreeUtils.methodName(filterTreeAsMethodInvocation).toString();\n+                    if (\"withName\".equals(filterMethodName)\n+                            && filterTreeAsMethodInvocation.getArguments().size() >= 1) {\n+                        Tree withNameArgTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                        withNameArg =\n+                                ValueCheckerUtils.getExactStringValue(withNameArgTree, valueATF);\n+                    }\n+\n+                    // Descend into a call to Collections.singletonList()\n+                    if (TreeUtils.isMethodInvocation(\n+                            filterTree, collectionsSingletonList, getProcessingEnv())) {\n+                        filterTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                    } else {\n+                        filterTree =\n+                                TreeUtils.getReceiverTree(\n+                                        filterTreeAsMethodInvocation.getMethodSelect());\n+                    }\n+                }\n+                if (filterTree == null) {\n+                    continue;\n+                }\n+                if (filterTree.getKind() == Tree.Kind.NEW_CLASS) {\n+\n+                    String value;", "originalCommit": "87575cdbdea673a5180c899f412db9cb3e7b28d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjIzMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536231", "bodyText": "Remove this checkername.  It doesn't conform to https://checkerframework.org/manual/#suppresswarnings-annotation-syntax.  It also isn't documented in the manual.  So, keep the interface simpler and cleaner, and client code more internally consistent, by not adding variants.\nCan any of the other variants be removed?", "author": "mernst", "createdAt": "2020-08-09T04:53:48Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods Checker, which tracks the methods that have\n+ * definitely been called on an object. One common use case for the Called Methods Checker is to\n+ * specify safe combinations of options to builder or builder-like interfaces, preventing objects\n+ * from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    \"called.methods\",", "originalCommit": "26bc1b78d99ebcb4b5300890696be1815ca7ed6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3MDc2Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468170763", "bodyText": "The object construction checker supports the other variants, so to be fully compatible so does this checker. I would prefer backwards compatibility over purity in our internal consistency, so I'd prefer to keep those (I did remove the new, weird one).", "author": "kelloggm", "createdAt": "2020-08-10T20:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjQxNQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536415", "bodyText": "The spelling is inconsistent: \"disabled\" versus \"disable\".", "author": "mernst", "createdAt": "2020-08-09T04:56:18Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods Checker, which tracks the methods that have\n+ * definitely been called on an object. One common use case for the Called Methods Checker is to\n+ * specify safe combinations of options to builder or builder-like interfaces, preventing objects\n+ * from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    \"called.methods\",\n+    // Deprecated checkernames, supported for backward compatibility.\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";\n+\n+    /**\n+     * This option can be used to disable the support (and therefore the automated checking of) code\n+     * that uses the given frameworks. Useful when a user **only** wants to enforce specifications\n+     * on custom builder objects (such as the AWS SDK examples).\n+     */\n+    public static final String DISABLED_FRAMEWORK_SUPPORTS = \"disableFrameworkSupports\";", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjQ2NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536464", "bodyText": "A number of comments were refilled poorly by the Java formatter.  I fixed a few; please correct the remaining ones.", "author": "mernst", "createdAt": "2020-08-09T04:57:14Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods Checker, which tracks the methods that have\n+ * definitely been called on an object. One common use case for the Called Methods Checker is to\n+ * specify safe combinations of options to builder or builder-like interfaces, preventing objects\n+ * from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    \"called.methods\",\n+    // Deprecated checkernames, supported for backward compatibility.\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";\n+\n+    /**\n+     * This option can be used to disable the support (and therefore the automated checking of) code\n+     * that uses the given frameworks. Useful when a user **only** wants to enforce specifications\n+     * on custom builder objects (such as the AWS SDK examples).\n+     */\n+    public static final String DISABLED_FRAMEWORK_SUPPORTS = \"disableFrameworkSupports\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable Lombok support. Use it\n+     * via {@code -AdisableFrameworkSupports=LOMBOK}.\n+     */\n+    public static final String LOMBOK_SUPPORT = \"LOMBOK\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable AutoValue support. Use\n+     * it via {@code -AdisableFrameworkSupports=AUTOVALUE}.\n+     */\n+    public static final String AUTOVALUE_SUPPORT = \"AUTOVALUE\";\n+\n+    /**\n+     * If this option is supplied, use the Value Checker to reduce false positives when analyzing\n+     * calls to the AWS SDK.\n+     */\n+    public static final String USE_VALUE_CHECKER = \"useValueChecker\";\n+\n+    /**\n+     * The number of calls to build frameworks supported by this invocation, if the {@link\n+     * #COUNT_FRAMEWORK_BUILD_CALLS} option was supplied.\n+     */\n+    int numBuildCalls = 0;\n+\n+    @Override\n+    protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n+        LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n+                super.getImmediateSubcheckerClasses();\n+        checkers.add(ReturnsReceiverChecker.class);\n+\n+        // BaseTypeChecker#hasOption calls this method (so that all subcheckers' options are\n+        // considered),", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjU4NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536584", "bodyText": "The \"CheckerName_option\" mechanism described at https://checkerframework.org/manual/#checker-options should be automatically applied.  (If not, please write a comment why.)  It would be surprising to have an option in that same format but which isn't treated like other occurrences of that syntax in the command line.", "author": "mernst", "createdAt": "2020-08-09T04:59:23Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods Checker, which tracks the methods that have\n+ * definitely been called on an object. One common use case for the Called Methods Checker is to\n+ * specify safe combinations of options to builder or builder-like interfaces, preventing objects\n+ * from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    \"called.methods\",\n+    // Deprecated checkernames, supported for backward compatibility.\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";\n+\n+    /**\n+     * This option can be used to disable the support (and therefore the automated checking of) code\n+     * that uses the given frameworks. Useful when a user **only** wants to enforce specifications\n+     * on custom builder objects (such as the AWS SDK examples).\n+     */\n+    public static final String DISABLED_FRAMEWORK_SUPPORTS = \"disableFrameworkSupports\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable Lombok support. Use it\n+     * via {@code -AdisableFrameworkSupports=LOMBOK}.\n+     */\n+    public static final String LOMBOK_SUPPORT = \"LOMBOK\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable AutoValue support. Use\n+     * it via {@code -AdisableFrameworkSupports=AUTOVALUE}.\n+     */\n+    public static final String AUTOVALUE_SUPPORT = \"AUTOVALUE\";\n+\n+    /**\n+     * If this option is supplied, use the Value Checker to reduce false positives when analyzing\n+     * calls to the AWS SDK.\n+     */\n+    public static final String USE_VALUE_CHECKER = \"useValueChecker\";\n+\n+    /**\n+     * The number of calls to build frameworks supported by this invocation, if the {@link\n+     * #COUNT_FRAMEWORK_BUILD_CALLS} option was supplied.\n+     */\n+    int numBuildCalls = 0;\n+\n+    @Override\n+    protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n+        LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n+                super.getImmediateSubcheckerClasses();\n+        checkers.add(ReturnsReceiverChecker.class);\n+\n+        // BaseTypeChecker#hasOption calls this method (so that all subcheckers' options are\n+        // considered),\n+        // so the processingEnvironment must be checked for the option directly.\n+        if (this.processingEnv.getOptions().containsKey(USE_VALUE_CHECKER)\n+                || this.processingEnv\n+                        .getOptions()\n+                        .containsKey(this.getClass().getSimpleName() + \"_\" + USE_VALUE_CHECKER)) {", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3MjE3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468172176", "bodyText": "There is already a comment here explaining why: BaseTypeChecker#hasOption calls getImmediateSubcheckers, so using the CF's standard option code doesn't work. We have to implement the logic ourselves (for just this option) here, because the effect of the option is to enable a new subchecker.\nIt might be possible to refactor the logic for options so that this hack can be avoided, but I'd prefer to do that separately (if we do it at all, which I don't see much reason to - it is quite rare for a subchecker to be guarded by an option flag).", "author": "kelloggm", "createdAt": "2020-08-10T20:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjY0NQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536645", "bodyText": "Never use \\n in printed output, because it is not portable across operating systems.  Use %n instead.", "author": "mernst", "createdAt": "2020-08-09T05:00:07Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The primary typechecker for the Called Methods Checker, which tracks the methods that have\n+ * definitely been called on an object. One common use case for the Called Methods Checker is to\n+ * specify safe combinations of options to builder or builder-like interfaces, preventing objects\n+ * from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    \"called.methods\",\n+    // Deprecated checkernames, supported for backward compatibility.\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLED_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";\n+\n+    /**\n+     * This option can be used to disable the support (and therefore the automated checking of) code\n+     * that uses the given frameworks. Useful when a user **only** wants to enforce specifications\n+     * on custom builder objects (such as the AWS SDK examples).\n+     */\n+    public static final String DISABLED_FRAMEWORK_SUPPORTS = \"disableFrameworkSupports\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable Lombok support. Use it\n+     * via {@code -AdisableFrameworkSupports=LOMBOK}.\n+     */\n+    public static final String LOMBOK_SUPPORT = \"LOMBOK\";\n+\n+    /**\n+     * The key for the {@link #DISABLED_FRAMEWORK_SUPPORTS} option to disable AutoValue support. Use\n+     * it via {@code -AdisableFrameworkSupports=AUTOVALUE}.\n+     */\n+    public static final String AUTOVALUE_SUPPORT = \"AUTOVALUE\";\n+\n+    /**\n+     * If this option is supplied, use the Value Checker to reduce false positives when analyzing\n+     * calls to the AWS SDK.\n+     */\n+    public static final String USE_VALUE_CHECKER = \"useValueChecker\";\n+\n+    /**\n+     * The number of calls to build frameworks supported by this invocation, if the {@link\n+     * #COUNT_FRAMEWORK_BUILD_CALLS} option was supplied.\n+     */\n+    int numBuildCalls = 0;\n+\n+    @Override\n+    protected LinkedHashSet<Class<? extends BaseTypeChecker>> getImmediateSubcheckerClasses() {\n+        LinkedHashSet<Class<? extends BaseTypeChecker>> checkers =\n+                super.getImmediateSubcheckerClasses();\n+        checkers.add(ReturnsReceiverChecker.class);\n+\n+        // BaseTypeChecker#hasOption calls this method (so that all subcheckers' options are\n+        // considered),\n+        // so the processingEnvironment must be checked for the option directly.\n+        if (this.processingEnv.getOptions().containsKey(USE_VALUE_CHECKER)\n+                || this.processingEnv\n+                        .getOptions()\n+                        .containsKey(this.getClass().getSimpleName() + \"_\" + USE_VALUE_CHECKER)) {\n+            checkers.add(ValueChecker.class);\n+        }\n+        return checkers;\n+    }\n+\n+    @Override\n+    public void typeProcessingOver() {\n+        if (getBooleanOption(COUNT_FRAMEWORK_BUILD_CALLS)) {\n+            System.out.printf(\"Found %d build() method calls.\\n\", numBuildCalls);", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjc0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536741", "bodyText": "Please write a meaningful comment.  This is worse than nothing.  (Though a good comment is better than nothing, even if the comment is short.)", "author": "mernst", "createdAt": "2020-08-09T05:01:08Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsTransfer.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import org.checkerframework.common.accumulation.AccumulationTransfer;\n+import org.checkerframework.dataflow.analysis.TransferInput;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFValue;\n+\n+/** A basic transfer function that accumulates the names of methods called. */\n+public class CalledMethodsTransfer extends AccumulationTransfer {\n+\n+    /** The type factory. */\n+    private final CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * default constructor", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3MzAwNg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468173006", "bodyText": "This is worse than nothing\n\nThe original code had nothing, and I would have preferred to keep it, but that causes require javadoc to fail.\n\na good comment is better than nothing, even if the comment is short\n\nI don't think that's true, in this case. I'll try to improve the comment, but there really isn't anything to say about this constructor - all it does is call super.", "author": "kelloggm", "createdAt": "2020-08-10T20:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjk0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467536943", "bodyText": "This test against methodName seems to come too late.  For efficiency, it could occur after the assignment and before the reassignment.  More importantly, can methodName ever be \"<init>\"?  If the method is <init>, wouldn't node have to be a ConstructorInvocationNode?\nAlso, the reassignment could occur within the receiver != null test.", "author": "mernst", "createdAt": "2020-08-09T05:04:22Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsTransfer.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import org.checkerframework.common.accumulation.AccumulationTransfer;\n+import org.checkerframework.dataflow.analysis.TransferInput;\n+import org.checkerframework.dataflow.analysis.TransferResult;\n+import org.checkerframework.dataflow.cfg.node.MethodInvocationNode;\n+import org.checkerframework.dataflow.cfg.node.Node;\n+import org.checkerframework.framework.flow.CFAnalysis;\n+import org.checkerframework.framework.flow.CFStore;\n+import org.checkerframework.framework.flow.CFValue;\n+\n+/** A basic transfer function that accumulates the names of methods called. */\n+public class CalledMethodsTransfer extends AccumulationTransfer {\n+\n+    /** The type factory. */\n+    private final CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * default constructor\n+     *\n+     * @param analysis the analysis\n+     */\n+    public CalledMethodsTransfer(final CFAnalysis analysis) {\n+        super(analysis);\n+        atypeFactory = (CalledMethodsAnnotatedTypeFactory) analysis.getTypeFactory();\n+    }\n+\n+    @Override\n+    public TransferResult<CFValue, CFStore> visitMethodInvocation(\n+            final MethodInvocationNode node, final TransferInput<CFValue, CFStore> input) {\n+        TransferResult<CFValue, CFStore> result = super.visitMethodInvocation(node, input);\n+        String methodName = node.getTarget().getMethod().getSimpleName().toString();\n+        methodName = atypeFactory.adjustMethodNameUsingValueChecker(methodName, node.getTree());\n+        Node receiver = node.getTarget().getReceiver();\n+        if (!\"<init>\".equals(methodName) && receiver != null) {", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3NDk1NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468174954", "bodyText": "If the method is , wouldn't node have to be a ConstructorInvocationNode\n\nThat's what I would expect. I thought this had caused a failure when I was testing the accumulation checker, but I can't reproduce it. I'll remove the test.\n\nAlso, the reassignment could occur within the receiver != null test.\n\nI think that is bad style.", "author": "kelloggm", "createdAt": "2020-08-10T20:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNjk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzAzMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537030", "bodyText": "Write a meaningful comment.", "author": "mernst", "createdAt": "2020-08-09T05:05:09Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsVisitor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.compilermsgs.qual.CompilerMessageKey;\n+import org.checkerframework.common.accumulation.AccumulationVisitor;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * This visitor implements the custom error message finalizer.invocation.invalid, and supports\n+ * counting the number of framework build calls.\n+ */\n+public class CalledMethodsVisitor extends AccumulationVisitor {\n+\n+    /**\n+     * Custom error message key for finalizer invocations. The custom error message makes it easier\n+     * for users to tell what methods weren't called.\n+     */\n+    public static final @CompilerMessageKey String FINALIZER_INVOCATION_INVALID =\n+            \"finalizer.invocation.invalid\";\n+\n+    /**\n+     * Constructor matching super.", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzA2Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537063", "bodyText": "I see no transformation that turns some errors into others.", "author": "mernst", "createdAt": "2020-08-09T05:05:36Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsVisitor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.compilermsgs.qual.CompilerMessageKey;\n+import org.checkerframework.common.accumulation.AccumulationVisitor;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * This visitor implements the custom error message finalizer.invocation.invalid, and supports\n+ * counting the number of framework build calls.\n+ */\n+public class CalledMethodsVisitor extends AccumulationVisitor {\n+\n+    /**\n+     * Custom error message key for finalizer invocations. The custom error message makes it easier\n+     * for users to tell what methods weren't called.\n+     */\n+    public static final @CompilerMessageKey String FINALIZER_INVOCATION_INVALID =\n+            \"finalizer.invocation.invalid\";\n+\n+    /**\n+     * Constructor matching super.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public CalledMethodsVisitor(final BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree node, Void p) {\n+\n+        if (checker.getBooleanOption(CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS)) {\n+            ExecutableElement element = TreeUtils.elementFromUse(node);\n+            for (FrameworkSupport frameworkSupport :\n+                    ((CalledMethodsAnnotatedTypeFactory) getTypeFactory()).getFrameworkSupports()) {\n+                if (frameworkSupport.isBuilderBuildMethod(element)) {\n+                    ((CalledMethodsChecker) checker).numBuildCalls++;\n+                    break;\n+                }\n+            }\n+        }\n+        return super.visitMethodInvocation(node, p);\n+    }\n+\n+    /**\n+     * Adds special reporting for method.invocation.invalid errors to turn them into", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3NjU2Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r468176567", "bodyText": "It is implicit: this method in BaseTypeVisitor normally would report a method.invocation.invalid error every time it is called. This implementation doesn't do that, and instead reports finalizer.invocation.invalid errors in the same places.", "author": "kelloggm", "createdAt": "2020-08-10T20:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzEwOA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537108", "bodyText": "Rather than having a trailing space at the end of missingMethods, use a StringJoiner.", "author": "mernst", "createdAt": "2020-08-09T05:06:10Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsVisitor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.calledmethods.framework.FrameworkSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.compilermsgs.qual.CompilerMessageKey;\n+import org.checkerframework.common.accumulation.AccumulationVisitor;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * This visitor implements the custom error message finalizer.invocation.invalid, and supports\n+ * counting the number of framework build calls.\n+ */\n+public class CalledMethodsVisitor extends AccumulationVisitor {\n+\n+    /**\n+     * Custom error message key for finalizer invocations. The custom error message makes it easier\n+     * for users to tell what methods weren't called.\n+     */\n+    public static final @CompilerMessageKey String FINALIZER_INVOCATION_INVALID =\n+            \"finalizer.invocation.invalid\";\n+\n+    /**\n+     * Constructor matching super.\n+     *\n+     * @param checker the type-checker associated with this visitor\n+     */\n+    public CalledMethodsVisitor(final BaseTypeChecker checker) {\n+        super(checker);\n+    }\n+\n+    @Override\n+    public Void visitMethodInvocation(MethodInvocationTree node, Void p) {\n+\n+        if (checker.getBooleanOption(CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS)) {\n+            ExecutableElement element = TreeUtils.elementFromUse(node);\n+            for (FrameworkSupport frameworkSupport :\n+                    ((CalledMethodsAnnotatedTypeFactory) getTypeFactory()).getFrameworkSupports()) {\n+                if (frameworkSupport.isBuilderBuildMethod(element)) {\n+                    ((CalledMethodsChecker) checker).numBuildCalls++;\n+                    break;\n+                }\n+            }\n+        }\n+        return super.visitMethodInvocation(node, p);\n+    }\n+\n+    /**\n+     * Adds special reporting for method.invocation.invalid errors to turn them into\n+     * finalizer.invocation.invalid errors.\n+     */\n+    @Override\n+    protected void reportMethodInvocabilityError(\n+            MethodInvocationTree node, AnnotatedTypeMirror found, AnnotatedTypeMirror expected) {\n+\n+        AnnotationMirror expectedCM = expected.getAnnotation(CalledMethods.class);\n+        if (expectedCM != null) {\n+            AnnotationMirror foundCM = found.getAnnotation(CalledMethods.class);\n+            Set<String> foundMethods =\n+                    foundCM == null\n+                            ? Collections.emptySet()\n+                            : new HashSet<>(atypeFactory.getAccumulatedValues(foundCM));\n+            List<String> expectedMethods = atypeFactory.getAccumulatedValues(expectedCM);\n+            StringBuilder missingMethods = new StringBuilder();\n+            for (String expectedMethod : expectedMethods) {\n+                if (!foundMethods.contains(expectedMethod)) {\n+                    missingMethods.append(expectedMethod);\n+                    missingMethods.append(\"() \");", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzQ1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537459", "bodyText": "This comment is copied from the superclass.  If so, you might as well leave it off, since it will be inherited automatically.\nBetter, say what this method does.", "author": "mernst", "createdAt": "2020-08-09T05:11:15Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,451 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue Support for the Called Methods Checker, which adds CalledMethods annotation to the code\n+ * generated by AutoValue.\n+ */\n+public class AutoValueSupport implements FrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Simple constructor.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * For frameworks to add any necessary @{@link", "originalCommit": "14be05553b2f8d6abfae73a7f31718b2737e9f81", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzY4OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537688", "bodyText": "Please expand this comment.", "author": "mernst", "createdAt": "2020-08-09T05:14:30Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** add CalledMethods annotations to code generated by framework */", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzc4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537787", "bodyText": "The term \"framework\" is too broad.  It's confusing in a project named the \"Checker Framework\" that has a component called \"framework\".  I suggest that you change \"framework\" to \"builder framework\" (and Framework to BuilderFramework, etc.) throughout.  I think that will be clearer.", "author": "mernst", "createdAt": "2020-08-09T05:15:35Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** add CalledMethods annotations to code generated by framework */\n+public interface FrameworkSupport {", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzNzg0MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467537840", "bodyText": "This doesn't say what the method is or when it is called.  A discussion of intended use is helpful, but first describe the method.", "author": "mernst", "createdAt": "2020-08-09T05:16:30Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** add CalledMethods annotations to code generated by framework */\n+public interface FrameworkSupport {\n+\n+    /**\n+     * Allows for supporting a framework's {@code toBuilder} routine. Typically, the returned", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzODE4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467538187", "bodyText": "I was confused by this comment.  I now think \"should determine\" may describe what an implementation of this method should do, but that was not clear.  On rereading it makes sense, but please rephrase it to make sense the first time through.  This comment applies to all of the methods in this interface.", "author": "mernst", "createdAt": "2020-08-09T05:21:05Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupport.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+\n+/** add CalledMethods annotations to code generated by framework */\n+public interface FrameworkSupport {\n+\n+    /**\n+     * Allows for supporting a framework's {@code toBuilder} routine. Typically, the returned\n+     * Builder has had all of its required setters invoked. So, the framework support can add a\n+     * {@link org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation capturing\n+     * this fact.\n+     *\n+     * @param t a method that is possibly the {@code toBuilder} method for a type that has an\n+     *     associated builder. An implementation must check that this is actually the {@code\n+     *     toBuilder} method for the corresponding framework.\n+     */\n+    void handlePossibleToBuilder(AnnotatedTypeMirror.AnnotatedExecutableType t);\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the framework support should determine", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzODI2OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467538269", "bodyText": "I suggest putting this in ElementUtils.", "author": "mernst", "createdAt": "2020-08-09T05:22:17Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class of static methods used in supporting builder-generation frameworks. */\n+public class FrameworkSupportUtils {\n+    /** This class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /**\n+     * Checks whether the given type is one of the immutable collections defined in\n+     * com.google.common.collect.\n+     *\n+     * @param type a Java type\n+     * @return whether the type is a Guava immutable collection\n+     */\n+    public static boolean isGuavaImmutableType(TypeMirror type) {\n+        return type.toString().startsWith(\"com.google.common.collect.Immutable\");\n+    }\n+\n+    /**\n+     * Capitalizes the first letter of the given string\n+     *\n+     * @param prop a String\n+     * @return the same String, but with the first character capitalized\n+     */\n+    public static String capitalize(String prop) {\n+        return prop.substring(0, 1).toUpperCase() + prop.substring(1);\n+    }\n+\n+    /**\n+     * Given an annotation name, return true if the element has the annotation of that name\n+     *\n+     * @param element the element\n+     * @param annotName name of the annotation\n+     * @return true if the element has the annotation of that name\n+     */\n+    public static boolean hasAnnotation(Element element, String annotName) {", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzUzODM2OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r467538369", "bodyText": "Be specific:  give the name of the command-line option here.", "author": "mernst", "createdAt": "2020-08-09T05:23:37Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/framework/FrameworkSupportUtils.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.checkerframework.checker.calledmethods.framework;\n+\n+import java.util.EnumSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsChecker;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+\n+/** A utility class of static methods used in supporting builder-generation frameworks. */\n+public class FrameworkSupportUtils {\n+    /** This class is non-instantiable */\n+    private FrameworkSupportUtils() {}\n+\n+    /**\n+     * Checks whether the given type is one of the immutable collections defined in\n+     * com.google.common.collect.\n+     *\n+     * @param type a Java type\n+     * @return whether the type is a Guava immutable collection\n+     */\n+    public static boolean isGuavaImmutableType(TypeMirror type) {\n+        return type.toString().startsWith(\"com.google.common.collect.Immutable\");\n+    }\n+\n+    /**\n+     * Capitalizes the first letter of the given string\n+     *\n+     * @param prop a String\n+     * @return the same String, but with the first character capitalized\n+     */\n+    public static String capitalize(String prop) {\n+        return prop.substring(0, 1).toUpperCase() + prop.substring(1);\n+    }\n+\n+    /**\n+     * Given an annotation name, return true if the element has the annotation of that name\n+     *\n+     * @param element the element\n+     * @param annotName name of the annotation\n+     * @return true if the element has the annotation of that name\n+     */\n+    public static boolean hasAnnotation(Element element, String annotName) {\n+        return element.getAnnotationMirrors().stream()\n+                .anyMatch(anm -> AnnotationUtils.areSameByName(anm, annotName));\n+    }\n+\n+    /** The frameworks supported by the checker. */\n+    public enum Framework {\n+        AUTO_VALUE,\n+        LOMBOK;\n+    }\n+\n+    /**\n+     * Gets the list of supported that are currently enabled frameworks.\n+     *\n+     * @param option the value of the framework support option", "originalCommit": "3650f626a239d0ff430e7f61ee436bf60c0e160a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98efc6225b2b46501b56b7c6aa05883060b8adf9", "url": "https://github.com/typetools/checker-framework/commit/98efc6225b2b46501b56b7c6aa05883060b8adf9", "message": "fix failing test, and some improvements in that method", "committedDate": "2020-08-10T16:19:35Z", "type": "commit"}, {"oid": "ccef8a97042075245a18ff2fda80ac0992820622", "url": "https://github.com/typetools/checker-framework/commit/ccef8a97042075245a18ff2fda80ac0992820622", "message": "checkpoint", "committedDate": "2020-08-10T17:49:37Z", "type": "commit"}, {"oid": "4d9e763ad6ddb7ea3a2cdf01a9276be02e16bbe3", "url": "https://github.com/typetools/checker-framework/commit/4d9e763ad6ddb7ea3a2cdf01a9276be02e16bbe3", "message": "all PR changes except manual", "committedDate": "2020-08-10T22:28:08Z", "type": "commit"}, {"oid": "5cbf93179c6873dc97fdf208827436bb0b453bca", "url": "https://github.com/typetools/checker-framework/commit/5cbf93179c6873dc97fdf208827436bb0b453bca", "message": "ensurescalledmethodsif annotation", "committedDate": "2020-08-10T23:25:37Z", "type": "commit"}, {"oid": "f0941e513bb93b17a061c0608bc7e5447ca434df", "url": "https://github.com/typetools/checker-framework/commit/f0941e513bb93b17a061c0608bc7e5447ca434df", "message": "fix some bugs, finish a renaming, and hopefully get the build to pass", "committedDate": "2020-08-10T23:33:58Z", "type": "commit"}, {"oid": "1b5b9f18e6ba1b0256251b61861035001b1c0d37", "url": "https://github.com/typetools/checker-framework/commit/1b5b9f18e6ba1b0256251b61861035001b1c0d37", "message": "javadoc nit", "committedDate": "2020-08-12T16:10:06Z", "type": "commit"}, {"oid": "776d9b170f1b5c7cfc083944b261d1a1f2107c37", "url": "https://github.com/typetools/checker-framework/commit/776d9b170f1b5c7cfc083944b261d1a1f2107c37", "message": "add CM bottom to manual, and include a lattice diagram", "committedDate": "2020-08-12T17:39:48Z", "type": "commit"}, {"oid": "28ccff835a3e9bbca2f5b99543b2933665b08271", "url": "https://github.com/typetools/checker-framework/commit/28ccff835a3e9bbca2f5b99543b2933665b08271", "message": "prettify svg", "committedDate": "2020-08-12T18:43:13Z", "type": "commit"}, {"oid": "e30e48a559907096f95635c930db8cdd3983e6e3", "url": "https://github.com/typetools/checker-framework/commit/e30e48a559907096f95635c930db8cdd3983e6e3", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-08-14T03:52:00Z", "type": "commit"}, {"oid": "1fb2244a9239c1b2e4539f987bc5347999e41d7a", "url": "https://github.com/typetools/checker-framework/commit/1fb2244a9239c1b2e4539f987bc5347999e41d7a", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-08-24T22:55:46Z", "type": "commit"}, {"oid": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "url": "https://github.com/typetools/checker-framework/commit/2ec53672e529796c70e16ec94427d5ce4e6396c2", "message": "Code review improvements", "committedDate": "2020-08-25T04:49:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476465892", "bodyText": "The interface contains an isBuilderBuildMethod method.  Each implementation of handlePossibleBuilderBuildMethod must call it.  It would simplify the interface and the implementing code if this method's contract is that t is a build method.  The Called Methods Checker can itself call isBuilderBuildMethod in order to invoke this method only on such methods.\nThe interface could also include an isToBuilder so that handlePossibleToBuilder can become handleToBuilder.", "author": "mernst", "createdAt": "2020-08-25T13:53:04Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/BuilderFrameworkSupport.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+\n+/**\n+ * Provides hooks to add CalledMethods annotations to code generated by a builder framework like\n+ * Lombok or AutoValue. If you are adding support to the Called Methods Checker for a new builder\n+ * framework, you should create a subclass of this class and modify the private method {@code\n+ * enableFramework} in {@link\n+ * org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory}.\n+ *\n+ * <p>Every method in this class is permitted to do nothing (or always return false). The work that\n+ * each method must do is particular to the builder framework being supported.\n+ */\n+public interface BuilderFrameworkSupport {\n+\n+    /**\n+     * Hook for supporting a builder framework's {@code toBuilder} routine. Typically, the returned\n+     * Builder has had all of its required setters invoked. So, implementations of this method\n+     * should add a {@link org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation\n+     * capturing this fact.\n+     *\n+     * @param t the type of a method that is possibly the {@code toBuilder} method for a type that\n+     *     has an associated builder. An implementation must check that this is actually the {@code\n+     *     toBuilder} method for the corresponding builder framework.\n+     */\n+    void handlePossibleToBuilder(AnnotatedExecutableType t);\n+\n+    /**\n+     * Hook for automatically adding annotations to a build() method (i.e. a finalizer) generated by\n+     * a builder framework.\n+     *\n+     * <p>For {@code build} methods on {@code Builder} types, implementations of this method should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the type of the\n+     * receiver parameter.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3MzQyMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481473421", "bodyText": "I've made this change. I think it does improve the code overall, but it also made some of the code in AutoValueSupport a bit unpleasant - the logic for isToBuilder and handleToBuilderMethod were coupled, and I didn't find a way to uncouple them entirely.", "author": "kelloggm", "createdAt": "2020-09-01T22:46:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2NjQ4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476466482", "bodyText": "It is inconsistent that handlePossibleToBuilder does not end with Method but handlePossibleBuilderBuildMethod does.", "author": "mernst", "createdAt": "2020-08-25T13:53:53Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/BuilderFrameworkSupport.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+\n+/**\n+ * Provides hooks to add CalledMethods annotations to code generated by a builder framework like\n+ * Lombok or AutoValue. If you are adding support to the Called Methods Checker for a new builder\n+ * framework, you should create a subclass of this class and modify the private method {@code\n+ * enableFramework} in {@link\n+ * org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory}.\n+ *\n+ * <p>Every method in this class is permitted to do nothing (or always return false). The work that\n+ * each method must do is particular to the builder framework being supported.\n+ */\n+public interface BuilderFrameworkSupport {\n+\n+    /**\n+     * Hook for supporting a builder framework's {@code toBuilder} routine. Typically, the returned\n+     * Builder has had all of its required setters invoked. So, implementations of this method\n+     * should add a {@link org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation\n+     * capturing this fact.\n+     *\n+     * @param t the type of a method that is possibly the {@code toBuilder} method for a type that\n+     *     has an associated builder. An implementation must check that this is actually the {@code\n+     *     toBuilder} method for the corresponding builder framework.\n+     */\n+    void handlePossibleToBuilder(AnnotatedExecutableType t);", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2Njc0NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476466744", "bodyText": "Where on the constructor call?", "author": "mernst", "createdAt": "2020-08-25T13:54:16Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/BuilderFrameworkSupport.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+\n+/**\n+ * Provides hooks to add CalledMethods annotations to code generated by a builder framework like\n+ * Lombok or AutoValue. If you are adding support to the Called Methods Checker for a new builder\n+ * framework, you should create a subclass of this class and modify the private method {@code\n+ * enableFramework} in {@link\n+ * org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory}.\n+ *\n+ * <p>Every method in this class is permitted to do nothing (or always return false). The work that\n+ * each method must do is particular to the builder framework being supported.\n+ */\n+public interface BuilderFrameworkSupport {\n+\n+    /**\n+     * Hook for supporting a builder framework's {@code toBuilder} routine. Typically, the returned\n+     * Builder has had all of its required setters invoked. So, implementations of this method\n+     * should add a {@link org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation\n+     * capturing this fact.\n+     *\n+     * @param t the type of a method that is possibly the {@code toBuilder} method for a type that\n+     *     has an associated builder. An implementation must check that this is actually the {@code\n+     *     toBuilder} method for the corresponding builder framework.\n+     */\n+    void handlePossibleToBuilder(AnnotatedExecutableType t);\n+\n+    /**\n+     * Hook for automatically adding annotations to a build() method (i.e. a finalizer) generated by\n+     * a builder framework.\n+     *\n+     * <p>For {@code build} methods on {@code Builder} types, implementations of this method should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the type of the\n+     * receiver parameter.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t);\n+\n+    /**\n+     * Hook to add any necessary @{@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to a constructor", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDEwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481474109", "bodyText": "The specification doesn't require annotations to be added in a particular place, and in fact the support for Lombok and for AutoValue implement this method differently (there are no annotations to infer for Lombok, but for AutoValue the generated copy constructor is treated the same as a toBuilder method).", "author": "kelloggm", "createdAt": "2020-09-01T22:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2Njc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODA0MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476468040", "bodyText": "How does it ensure the fact?  Does it throw an exception if the fact is not true?  Or does it perform side effects to make the fact true?", "author": "mernst", "createdAt": "2020-08-25T13:55:50Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDQyMw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481474423", "bodyText": "It performs side effects to make the fact true. I'll clarify the documentation.", "author": "kelloggm", "createdAt": "2020-09-01T22:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODM3MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476468370", "bodyText": "This is a call to a copy constructor, I think.  Please clarify.", "author": "mernst", "createdAt": "2020-08-25T13:56:17Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NDk1MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481474950", "bodyText": "Not necessarily - this is a call to any constructor. This method's body decides if that constructor is a copy constructor generated by AutoValue, and side-effects its type if so.", "author": "kelloggm", "createdAt": "2020-09-01T22:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ3NTI2NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481475264", "bodyText": "I've clarified the documentation.", "author": "kelloggm", "createdAt": "2020-09-01T22:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2ODM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2OTE4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476469187", "bodyText": "Say (in a comment or via variable names) what these are expected to be.  I think enclosingElement is the builder class and nextEnclosingElement is the class being built.", "author": "mernst", "createdAt": "2020-08-25T13:57:24Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2OTU3Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476469572", "bodyText": "Declare an assign this within the if statement, for efficiency and to reduce the scope of the variable.", "author": "mernst", "createdAt": "2020-08-25T13:57:55Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ2OTc2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476469761", "bodyText": "t is a type, not a method.", "author": "mernst", "createdAt": "2020-08-25T13:58:11Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3MzE4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476473189", "bodyText": "These 3 statements that create a complete @CalledMethods annotation appear twice.  I suggest abstracting them out so that you can give them a name and make the use sites easier to understand.\nI further suggest making that a method in the BuilderFrameworkSupport interface, since \"create a @CalledMethods that represents all required setters\" is a common concept to all builder support.", "author": "mernst", "createdAt": "2020-08-25T14:02:51Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4MjAyMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481482022", "bodyText": "I followed the former suggestion, but I disagree with the latter. Because there is no need for such a method outside the implementation of a class that is implementing BuilderFrameworkSupport, adding it to the interface would clutter the interface and make implementation of new builder framework support classes more annoying. (I agree that it's common to all builder supports, but I don't think it's helpful to proscribe e.g. the inputs for such a method, since different builder frameworks might use different information to decide on the required properties.)", "author": "kelloggm", "createdAt": "2020-09-01T23:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3MzE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3Mzg5MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476473891", "bodyText": "The name of this variable suggests it is only setters, but the description says it is \"all methods\".  Please make them consistent.  Fix all occurrences -- this appears multiple times.", "author": "mernst", "createdAt": "2020-08-25T14:03:47Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3NTU4NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476475584", "bodyText": "The size of this set is either 1 or 2.  Using a LinkedHashSet is overkill.  Just use an array.  There would be 3 assignments to the array, each of whose right-hand-side is new String[] { ... }.", "author": "mernst", "createdAt": "2020-08-25T14:05:55Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3NTk4Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476475982", "bodyText": "Here, too, just use an array for efficiency.", "author": "mernst", "createdAt": "2020-08-25T14:06:26Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3NzA4OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476477088", "bodyText": "The local variable is not necessary.  Just inline the body at the one use on line 310, which will simplify the code and make it easier to understand.", "author": "mernst", "createdAt": "2020-08-25T14:07:50Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3NzUwMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476477500", "bodyText": "Inline the value at the use on line 327, to eliminate the need for an extra variable that is used only once.", "author": "mernst", "createdAt": "2020-08-25T14:08:21Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3NzkzNA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476477934", "bodyText": "This comment doesn't say what the value is.  Please document it.", "author": "mernst", "createdAt": "2020-08-25T14:08:49Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3ODE2MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476478161", "bodyText": "This comment doesn't say what the method does.  Please document it.  If you retain this text, it can be a // code comment rather than a Javadoc specification comment.", "author": "mernst", "createdAt": "2020-08-25T14:09:05Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */\n+    private static final Set<String> OPTIONAL_CLASS_NAMES =\n+            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));\n+\n+    /**\n+     * Adapted from AutoValue source code.", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ3OTM4NQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476479385", "bodyText": "Can you use a more specific subtype of Element?  Or at least document here what the element is -- a method, a type, or whatever.", "author": "mernst", "createdAt": "2020-08-25T14:10:28Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */\n+    private static final Set<String> OPTIONAL_CLASS_NAMES =\n+            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));\n+\n+    /**\n+     * Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        return OPTIONAL_CLASS_NAMES.contains(typeElement.getQualifiedName().toString())\n+                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();\n+    }\n+\n+    /**\n+     * Returns the names of setter methods for an AutoValue builder.\n+     *\n+     * @param builderElement the Element for an AutoValue builder", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MjUyNA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476482524", "bodyText": "overriddenMethods is side-effected by other loop iterations.  Can you add a comment explaining how we know that nothing will be added to overriddenMethods later that would make the addition of member to abstractMethods incorrect?  I think it's the fact that getAllSupertypes returns a list in a specific order (but see my comment about that).", "author": "mernst", "createdAt": "2020-08-25T14:14:40Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */\n+    private static final Set<String> OPTIONAL_CLASS_NAMES =\n+            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));\n+\n+    /**\n+     * Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        return OPTIONAL_CLASS_NAMES.contains(typeElement.getQualifiedName().toString())\n+                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();\n+    }\n+\n+    /**\n+     * Returns the names of setter methods for an AutoValue builder.\n+     *\n+     * @param builderElement the Element for an AutoValue builder\n+     * @return names of all methods whose return type is the builder itself or that return a Guava\n+     *     Immutable type\n+     */\n+    private Set<String> getAutoValueBuilderSetterMethodNames(Element builderElement) {\n+        return getAllAbstractMethods(builderElement).stream()\n+                .filter(e -> isAutoValueBuilderSetter(e, builderElement))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Is method a setter for an AutoValue builder?\n+     *\n+     * @param method a method of builder or one of its supertypes\n+     * @param builderElement element for the AutoValue builder\n+     * @return {@code true} if e is a setter for the builder, {@code false} otherwise\n+     */\n+    private boolean isAutoValueBuilderSetter(ExecutableElement method, Element builderElement) {\n+        TypeMirror retType = method.getReturnType();\n+        if (retType.getKind() == TypeKind.TYPEVAR) {\n+            // instantiate the type variable for the Builder class\n+            retType =\n+                    AnnotatedTypes.asMemberOf(\n+                                    atypeFactory.getContext().getTypeUtils(),\n+                                    atypeFactory,\n+                                    atypeFactory.getAnnotatedType(builderElement),\n+                                    method)\n+                            .getReturnType()\n+                            .getUnderlyingType();\n+        }\n+        // either the return type should be the builder itself, or it should be a Guava immutable\n+        // type\n+        return BuilderFrameworkSupportUtils.isGuavaImmutableType(retType)\n+                || builderElement.equals(TypesUtils.getTypeElement(retType));\n+    }\n+\n+    /**\n+     * Get all the abstract methods for a class. This includes inherited abstract methods that are\n+     * not overridden by the class or a superclass.\n+     *\n+     * @param classElement the class\n+     * @return list of all abstract methods\n+     */\n+    public List<ExecutableElement> getAllAbstractMethods(Element classElement) {\n+        List<Element> supertypes = getAllSupertypes((Symbol) classElement);\n+        List<ExecutableElement> abstractMethods = new ArrayList<>();\n+        Set<ExecutableElement> overriddenMethods = new HashSet<>();\n+        for (Element t : supertypes) {\n+            for (Element member : t.getEnclosedElements()) {\n+                if (member.getKind() != ElementKind.METHOD) {\n+                    continue;\n+                }\n+                Set<Modifier> modifiers = member.getModifiers();\n+                if (modifiers.contains(Modifier.STATIC)) {\n+                    continue;\n+                }\n+                if (modifiers.contains(Modifier.ABSTRACT)) {\n+                    // make sure it's not overridden\n+                    if (!overriddenMethods.contains(member)) {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MzA5MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476483090", "bodyText": "This is missing a summary Javadoc description.", "author": "mernst", "createdAt": "2020-08-25T14:15:18Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */\n+    private static final Set<String> OPTIONAL_CLASS_NAMES =\n+            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));\n+\n+    /**\n+     * Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        return OPTIONAL_CLASS_NAMES.contains(typeElement.getQualifiedName().toString())\n+                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();\n+    }\n+\n+    /**\n+     * Returns the names of setter methods for an AutoValue builder.\n+     *\n+     * @param builderElement the Element for an AutoValue builder\n+     * @return names of all methods whose return type is the builder itself or that return a Guava\n+     *     Immutable type\n+     */\n+    private Set<String> getAutoValueBuilderSetterMethodNames(Element builderElement) {\n+        return getAllAbstractMethods(builderElement).stream()\n+                .filter(e -> isAutoValueBuilderSetter(e, builderElement))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Is method a setter for an AutoValue builder?\n+     *\n+     * @param method a method of builder or one of its supertypes\n+     * @param builderElement element for the AutoValue builder\n+     * @return {@code true} if e is a setter for the builder, {@code false} otherwise\n+     */\n+    private boolean isAutoValueBuilderSetter(ExecutableElement method, Element builderElement) {\n+        TypeMirror retType = method.getReturnType();\n+        if (retType.getKind() == TypeKind.TYPEVAR) {\n+            // instantiate the type variable for the Builder class\n+            retType =\n+                    AnnotatedTypes.asMemberOf(\n+                                    atypeFactory.getContext().getTypeUtils(),\n+                                    atypeFactory,\n+                                    atypeFactory.getAnnotatedType(builderElement),\n+                                    method)\n+                            .getReturnType()\n+                            .getUnderlyingType();\n+        }\n+        // either the return type should be the builder itself, or it should be a Guava immutable\n+        // type\n+        return BuilderFrameworkSupportUtils.isGuavaImmutableType(retType)\n+                || builderElement.equals(TypesUtils.getTypeElement(retType));\n+    }\n+\n+    /**\n+     * Get all the abstract methods for a class. This includes inherited abstract methods that are\n+     * not overridden by the class or a superclass.\n+     *\n+     * @param classElement the class\n+     * @return list of all abstract methods\n+     */\n+    public List<ExecutableElement> getAllAbstractMethods(Element classElement) {\n+        List<Element> supertypes = getAllSupertypes((Symbol) classElement);\n+        List<ExecutableElement> abstractMethods = new ArrayList<>();\n+        Set<ExecutableElement> overriddenMethods = new HashSet<>();\n+        for (Element t : supertypes) {\n+            for (Element member : t.getEnclosedElements()) {\n+                if (member.getKind() != ElementKind.METHOD) {\n+                    continue;\n+                }\n+                Set<Modifier> modifiers = member.getModifiers();\n+                if (modifiers.contains(Modifier.STATIC)) {\n+                    continue;\n+                }\n+                if (modifiers.contains(Modifier.ABSTRACT)) {\n+                    // make sure it's not overridden\n+                    if (!overriddenMethods.contains(member)) {\n+                        abstractMethods.add((ExecutableElement) member);\n+                    }\n+                } else {\n+                    // exclude any methods that this overrides\n+                    overriddenMethods.addAll(\n+                            AnnotatedTypes.overriddenMethods(\n+                                            atypeFactory.getElementUtils(),\n+                                            atypeFactory,\n+                                            (ExecutableElement) member)\n+                                    .values());\n+                }\n+            }\n+        }\n+        return abstractMethods;\n+    }\n+\n+    /**\n+     * Get the qualified name of the package containing AutoValue annotations. This method\n+     * constructs the String dynamically, to ensure it does not get rewritten due to relocation of\n+     * the {@code \"com.google\"} package during the build process.\n+     *\n+     * @return {@code \"com.google.auto.value\"}\n+     */\n+    private String getAutoValuePackageName() {\n+        String com = \"com\";\n+        return com + \".\" + \"google.auto.value\";\n+    }\n+\n+    /**\n+     * @param symbol symbol for a class", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NTA1Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476485053", "bodyText": "I do not read the documentation of closure as giving this guarantee.  It says \"subclasses come first, arbitrary but fixed otherwise\".  That suggests to me that some subtypes (in particular type relations induced by implements rather than extends clauses) might not be in order.  Could you look into this?  Maybe closure gives a stronger guarantee, or maybe the weaker guarantee is enough for your code, or maybe there is a potential bug.", "author": "mernst", "createdAt": "2020-08-25T14:17:57Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,448 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method ensures that the type of a copy constructor matches the type of the AutoValue\n+     * toBuilder method.\n+     *\n+     * @param tree AST for the call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type, superclass, TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        if (ElementUtils.hasAnnotation(\n+                enclosingElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            assert ElementUtils.hasAnnotation(\n+                            nextEnclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + nextEnclosingElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType()).equals(nextEnclosingElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            // determine the required properties and add a corresponding @CalledMethods annotation\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+            Set<String> avBuilderSetterNames =\n+                    getAutoValueBuilderSetterMethodNames(enclosingElement);\n+            List<String> requiredProperties =\n+                    getAutoValueRequiredProperties(nextEnclosingElement, avBuilderSetterNames);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    createCalledMethodsForAutoValueProperties(\n+                            requiredProperties, avBuilderSetterNames);\n+            // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+            // annotation present\n+            AnnotationMirror possibleBuildAnnotations =\n+                    t.getReceiverType()\n+                            .getAnnotationInHierarchy(\n+                                    atypeFactory\n+                                            .getQualifierHierarchy()\n+                                            .getTopAnnotation(newCalledMethodsAnno));\n+            if (possibleBuildAnnotations == null) {\n+                t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            TypeMirror superclass = enclosingElement.getSuperclass();\n+\n+            if (ElementUtils.hasAnnotation(\n+                            enclosingElement, getAutoValuePackageName() + \".AutoValue\")\n+                    && element.getModifiers().contains(Modifier.ABSTRACT)) {\n+                handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+            }\n+\n+            if (superclass.getKind() != TypeKind.NONE) {\n+                TypeElement superElement = TypesUtils.getTypeElement(superclass);\n+                if (ElementUtils.hasAnnotation(\n+                        superElement, getAutoValuePackageName() + \".AutoValue\")) {\n+                    handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, Element classElement) {\n+        Element builderElement = TypesUtils.getTypeElement(builderType);\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all methods in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        Set<String> possiblePropNames = new LinkedHashSet<>();\n+        possiblePropNames.add(prop);\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(3)));\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames.add(Introspector.decapitalize(prop.substring(2)));\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            HashSet<String> setterNamesToTry = new HashSet<>();\n+            setterNamesToTry.add(propName);\n+            setterNamesToTry.add(\"set\" + BuilderFrameworkSupportUtils.capitalize(propName));\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final Element autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member member of an AutoValue class or superclass\n+     * @param allBuilderMethodNames names of methods in corresponding AutoValue builder\n+     * @return {@code true} if member is required, {@code false} otherwise\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> allBuilderMethodNames) {\n+        String name = member.getSimpleName().toString();\n+        if (IGNORED_METHOD_NAMES.contains(name)) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && allBuilderMethodNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] IGNORED_METHOD_VALUES =\n+            new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"};\n+\n+    /**\n+     * Ignore java.lang.Object overrides, constructors, and toBuilder method in AutoValue classes.\n+     *\n+     * <p>Strictly speaking we should probably be checking return types, etc. here to handle strange\n+     * overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+     */\n+    private static final Set<String> IGNORED_METHOD_NAMES =\n+            new HashSet<>(Arrays.asList(IGNORED_METHOD_VALUES));;\n+\n+    /**\n+     * No Set.of in Java 8, so use this intermediate array instead following the suggestion at\n+     * https://stackoverflow.com/questions/2041778/how-to-initialize-hashset-values-by-construction.\n+     */\n+    private static final String[] OPTIONAL_CLASS_NAMES_VALUES =\n+            new String[] {\n+                \"com.google.common.base.Optional\",\n+                \"java.util.Optional\",\n+                \"java.util.OptionalDouble\",\n+                \"java.util.OptionalInt\",\n+                \"java.util.OptionalLong\"\n+            };\n+\n+    /** Taken from AutoValue source code */\n+    private static final Set<String> OPTIONAL_CLASS_NAMES =\n+            new HashSet<>(Arrays.asList(OPTIONAL_CLASS_NAMES_VALUES));\n+\n+    /**\n+     * Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        return OPTIONAL_CLASS_NAMES.contains(typeElement.getQualifiedName().toString())\n+                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();\n+    }\n+\n+    /**\n+     * Returns the names of setter methods for an AutoValue builder.\n+     *\n+     * @param builderElement the Element for an AutoValue builder\n+     * @return names of all methods whose return type is the builder itself or that return a Guava\n+     *     Immutable type\n+     */\n+    private Set<String> getAutoValueBuilderSetterMethodNames(Element builderElement) {\n+        return getAllAbstractMethods(builderElement).stream()\n+                .filter(e -> isAutoValueBuilderSetter(e, builderElement))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Is method a setter for an AutoValue builder?\n+     *\n+     * @param method a method of builder or one of its supertypes\n+     * @param builderElement element for the AutoValue builder\n+     * @return {@code true} if e is a setter for the builder, {@code false} otherwise\n+     */\n+    private boolean isAutoValueBuilderSetter(ExecutableElement method, Element builderElement) {\n+        TypeMirror retType = method.getReturnType();\n+        if (retType.getKind() == TypeKind.TYPEVAR) {\n+            // instantiate the type variable for the Builder class\n+            retType =\n+                    AnnotatedTypes.asMemberOf(\n+                                    atypeFactory.getContext().getTypeUtils(),\n+                                    atypeFactory,\n+                                    atypeFactory.getAnnotatedType(builderElement),\n+                                    method)\n+                            .getReturnType()\n+                            .getUnderlyingType();\n+        }\n+        // either the return type should be the builder itself, or it should be a Guava immutable\n+        // type\n+        return BuilderFrameworkSupportUtils.isGuavaImmutableType(retType)\n+                || builderElement.equals(TypesUtils.getTypeElement(retType));\n+    }\n+\n+    /**\n+     * Get all the abstract methods for a class. This includes inherited abstract methods that are\n+     * not overridden by the class or a superclass.\n+     *\n+     * @param classElement the class\n+     * @return list of all abstract methods\n+     */\n+    public List<ExecutableElement> getAllAbstractMethods(Element classElement) {\n+        List<Element> supertypes = getAllSupertypes((Symbol) classElement);\n+        List<ExecutableElement> abstractMethods = new ArrayList<>();\n+        Set<ExecutableElement> overriddenMethods = new HashSet<>();\n+        for (Element t : supertypes) {\n+            for (Element member : t.getEnclosedElements()) {\n+                if (member.getKind() != ElementKind.METHOD) {\n+                    continue;\n+                }\n+                Set<Modifier> modifiers = member.getModifiers();\n+                if (modifiers.contains(Modifier.STATIC)) {\n+                    continue;\n+                }\n+                if (modifiers.contains(Modifier.ABSTRACT)) {\n+                    // make sure it's not overridden\n+                    if (!overriddenMethods.contains(member)) {\n+                        abstractMethods.add((ExecutableElement) member);\n+                    }\n+                } else {\n+                    // exclude any methods that this overrides\n+                    overriddenMethods.addAll(\n+                            AnnotatedTypes.overriddenMethods(\n+                                            atypeFactory.getElementUtils(),\n+                                            atypeFactory,\n+                                            (ExecutableElement) member)\n+                                    .values());\n+                }\n+            }\n+        }\n+        return abstractMethods;\n+    }\n+\n+    /**\n+     * Get the qualified name of the package containing AutoValue annotations. This method\n+     * constructs the String dynamically, to ensure it does not get rewritten due to relocation of\n+     * the {@code \"com.google\"} package during the build process.\n+     *\n+     * @return {@code \"com.google.auto.value\"}\n+     */\n+    private String getAutoValuePackageName() {\n+        String com = \"com\";\n+        return com + \".\" + \"google.auto.value\";\n+    }\n+\n+    /**\n+     * @param symbol symbol for a class\n+     * @return list including the class and all its supertypes, with a guarantee that subtypes", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ5MTMwNg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r481491306", "bodyText": "I think the weaker guarantee is sufficient: AutoValue isn't going to generate anything related to interfaces, and this code is only used to find all the methods that might be AutoValue-generated. I'll update the documentation.", "author": "kelloggm", "createdAt": "2020-09-01T23:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4NTgzOQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476485839", "bodyText": "What is this?  Please start the documentation with a description of the data.  After that, a description of how or why it is used (as you have here) is useful.", "author": "mernst", "createdAt": "2020-08-25T14:19:03Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDU3OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476490579", "bodyText": "The body of this if statement does not account for the possibility that the field declaration contains an initializer.  Is that possible?", "author": "mernst", "createdAt": "2020-08-25T14:25:10Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default\n+     * correctly. Value is the property name to treat as defaulted.\n+     */\n+    private final Map<Element, String> defaultedElements = new HashMap<>();\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+            List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+            if (ElementUtils.hasAnnotation(element, \"lombok.Generated\")\n+                    || ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")) {\n+                handleToBuilderType(returnType, enclosingElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"\n+     * constructor.\n+     *\n+     * @param type type to update\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {\n+        List<String> requiredProperties = getLombokRequiredProperties(classElement);\n+        AnnotationMirror calledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Computes the required properties of a @lombok.Builder class, i.e., the names of the fields\n+     * with @lombok.NonNull annotations.\n+     *\n+     * @param lombokClassElement the class with the @lombok.Builder annotation\n+     * @return a list of required property names\n+     */\n+    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {\n+        List<String> requiredPropertyNames = new ArrayList<>();\n+        List<String> defaultedPropertyNames = new ArrayList<>();\n+        for (Element member : lombokClassElement.getEnclosedElements()) {\n+            if (member.getKind() == ElementKind.FIELD) {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NDYxMQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485944611", "bodyText": "Lombok never generates fields with initializers in classes that use @Builder, unless that field has an @Default or @Singular annotation, which are handled elsewhere (and don't need to be included here, because they can never be null).", "author": "kelloggm", "createdAt": "2020-09-09T21:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NDY5Mg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485944692", "bodyText": "I'll add a comment to this effect.", "author": "kelloggm", "createdAt": "2020-09-09T21:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MDU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MTE3Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476491176", "bodyText": "Why doesn't the first part of member's name matter?  Or is this a heuristic that might fail in practice, for obscure cases?", "author": "mernst", "createdAt": "2020-08-25T14:25:53Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default\n+     * correctly. Value is the property name to treat as defaulted.\n+     */\n+    private final Map<Element, String> defaultedElements = new HashMap<>();\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+            List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+            if (ElementUtils.hasAnnotation(element, \"lombok.Generated\")\n+                    || ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")) {\n+                handleToBuilderType(returnType, enclosingElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"\n+     * constructor.\n+     *\n+     * @param type type to update\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {\n+        List<String> requiredProperties = getLombokRequiredProperties(classElement);\n+        AnnotationMirror calledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Computes the required properties of a @lombok.Builder class, i.e., the names of the fields\n+     * with @lombok.NonNull annotations.\n+     *\n+     * @param lombokClassElement the class with the @lombok.Builder annotation\n+     * @return a list of required property names\n+     */\n+    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {\n+        List<String> requiredPropertyNames = new ArrayList<>();\n+        List<String> defaultedPropertyNames = new ArrayList<>();\n+        for (Element member : lombokClassElement.getEnclosedElements()) {\n+            if (member.getKind() == ElementKind.FIELD) {\n+                for (AnnotationMirror anm :\n+                        atypeFactory.getElementUtils().getAllAnnotationMirrors(member)) {\n+                    if (NONNULL_ANNOTATIONS.contains(AnnotationUtils.annotationName(anm))) {\n+                        requiredPropertyNames.add(member.getSimpleName().toString());\n+                    }\n+                }\n+            } else if (member.getKind() == ElementKind.METHOD\n+                    && ElementUtils.hasAnnotation(member, \"lombok.Generated\")) {\n+                String methodName = member.getSimpleName().toString();\n+                // Handle fields with @Builder.Default annotations.\n+                // If a field foo has an @Builder.Default annotation, Lombok always generates a\n+                // method called $default$foo.\n+                if (methodName.startsWith(\"$default$\")) {\n+                    String propName = methodName.substring(9); // $default$ has 9 characters\n+                    defaultedPropertyNames.add(propName);\n+                }\n+            } else if (member.getKind().isClass() && member.toString().endsWith(\"Builder\")) {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1MTg2Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485951863", "bodyText": "This is checking for the generated Builder class' element. It's a heuristic in that unless the builderClassName option to the @Builder annotation is passed, Lombok is guaranteed to generate an inner class with a name ending in Builder (e.g. FooBuilder for a Foo object). I've never seen anyone use that option in practice (though I'm sure some do), but it's not a soundness concern because the worst that happens is the code misses a singular/default annotation and expects you to set a field that's defaulted.", "author": "kelloggm", "createdAt": "2020-09-09T22:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1MTkwOQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485951909", "bodyText": "I added a comment.", "author": "kelloggm", "createdAt": "2020-09-09T22:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MjU5OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476492598", "bodyText": "Other loop iterations might set defaultedElements.  Does that lead to potentially nondeterministic behavior, or to bugs if the code does not contains members in the order that this code expects?", "author": "mernst", "createdAt": "2020-08-25T14:27:45Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default\n+     * correctly. Value is the property name to treat as defaulted.\n+     */\n+    private final Map<Element, String> defaultedElements = new HashMap<>();\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+            List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+            if (ElementUtils.hasAnnotation(element, \"lombok.Generated\")\n+                    || ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")) {\n+                handleToBuilderType(returnType, enclosingElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"\n+     * constructor.\n+     *\n+     * @param type type to update\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {\n+        List<String> requiredProperties = getLombokRequiredProperties(classElement);\n+        AnnotationMirror calledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Computes the required properties of a @lombok.Builder class, i.e., the names of the fields\n+     * with @lombok.NonNull annotations.\n+     *\n+     * @param lombokClassElement the class with the @lombok.Builder annotation\n+     * @return a list of required property names\n+     */\n+    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {\n+        List<String> requiredPropertyNames = new ArrayList<>();\n+        List<String> defaultedPropertyNames = new ArrayList<>();\n+        for (Element member : lombokClassElement.getEnclosedElements()) {\n+            if (member.getKind() == ElementKind.FIELD) {\n+                for (AnnotationMirror anm :\n+                        atypeFactory.getElementUtils().getAllAnnotationMirrors(member)) {\n+                    if (NONNULL_ANNOTATIONS.contains(AnnotationUtils.annotationName(anm))) {\n+                        requiredPropertyNames.add(member.getSimpleName().toString());\n+                    }\n+                }\n+            } else if (member.getKind() == ElementKind.METHOD\n+                    && ElementUtils.hasAnnotation(member, \"lombok.Generated\")) {\n+                String methodName = member.getSimpleName().toString();\n+                // Handle fields with @Builder.Default annotations.\n+                // If a field foo has an @Builder.Default annotation, Lombok always generates a\n+                // method called $default$foo.\n+                if (methodName.startsWith(\"$default$\")) {\n+                    String propName = methodName.substring(9); // $default$ has 9 characters\n+                    defaultedPropertyNames.add(propName);\n+                }\n+            } else if (member.getKind().isClass() && member.toString().endsWith(\"Builder\")) {\n+                // If a field bar has an @Singular annotation, Lombok always generates a method\n+                // called clearBar in the builder class itself. Therefore, search the builder for\n+                // such a method, and extract the appropriate property name to treat as defaulted.\n+                for (Element builderMember : member.getEnclosedElements()) {\n+                    if (builderMember.getKind() == ElementKind.METHOD\n+                            && ElementUtils.hasAnnotation(builderMember, \"lombok.Generated\")) {\n+                        String methodName = builderMember.getSimpleName().toString();\n+                        if (methodName.startsWith(\"clear\")) {\n+                            String propName =\n+                                    Introspector.decapitalize(\n+                                            methodName.substring(5)); // clear has 5 characters\n+                            defaultedPropertyNames.add(propName);\n+                        }\n+                    } else if (builderMember.getKind() == ElementKind.FIELD) {\n+                        VariableTree variableTree =\n+                                (VariableTree) atypeFactory.declarationFromElement(builderMember);\n+                        if (variableTree != null && variableTree.getInitializer() != null) {\n+                            String propName = variableTree.getName().toString();\n+                            defaultedPropertyNames.add(propName);\n+                            defaultedElements.put(builderMember, propName);\n+                        } else if (defaultedElements.containsKey(builderMember)) {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1NTgwOA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485955808", "bodyText": "I don't think this code relies on the order of elements, but even if it does it's not a concern because Lombok will always generate things in the same order (and it's not a soundness concern, so we'd get FP warnings that would indicate the problem if the generator changes).", "author": "kelloggm", "createdAt": "2020-09-09T22:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5MjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5NDk2MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476494960", "bodyText": "You do not need to call toString, and doing so is inefficient.  Throughout, use name.contentEquals(myString) rather than myString.equals(name.toString()).  I'm hopeful that you can eliminate all uses of toString from the code.", "author": "mernst", "createdAt": "2020-08-25T14:30:45Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * Keep a cache of these so that when declarationFromElement doesn't work, we can still default\n+     * correctly. Value is the property name to treat as defaulted.\n+     */\n+    private final Map<Element, String> defaultedElements = new HashMap<>();\n+\n+    /**\n+     * For {@code build} methods on {@code Builder} types, the builder framework support should\n+     * determine the required properties and add a corresponding {@link\n+     * org.checkerframework.checker.calledmethods.qual.CalledMethods} annotation to the receiver.\n+     *\n+     * @param t a method that is possibly the {@code build} method for a builder. The only\n+     *     guaranteed condition is that the enclosing class for the method is itself an inner class.\n+     */\n+    @Override\n+    public void handlePossibleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        if (isBuilderBuildMethod(element)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+            Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+            List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+            AnnotationMirror newCalledMethodsAnno =\n+                    atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public void handlePossibleToBuilder(AnnotatedExecutableType t) {\n+\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+\n+        String methodName = element.getSimpleName().toString();\n+\n+        // make sure the method is toBuilder\n+        if (\"toBuilder\".equals(methodName)) {\n+            TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+            if (ElementUtils.hasAnnotation(element, \"lombok.Generated\")\n+                    || ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")) {\n+                handleToBuilderType(returnType, enclosingElement);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"\n+     * constructor.\n+     *\n+     * @param type type to update\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {\n+        List<String> requiredProperties = getLombokRequiredProperties(classElement);\n+        AnnotationMirror calledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Computes the required properties of a @lombok.Builder class, i.e., the names of the fields\n+     * with @lombok.NonNull annotations.\n+     *\n+     * @param lombokClassElement the class with the @lombok.Builder annotation\n+     * @return a list of required property names\n+     */\n+    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {\n+        List<String> requiredPropertyNames = new ArrayList<>();\n+        List<String> defaultedPropertyNames = new ArrayList<>();\n+        for (Element member : lombokClassElement.getEnclosedElements()) {\n+            if (member.getKind() == ElementKind.FIELD) {\n+                for (AnnotationMirror anm :\n+                        atypeFactory.getElementUtils().getAllAnnotationMirrors(member)) {\n+                    if (NONNULL_ANNOTATIONS.contains(AnnotationUtils.annotationName(anm))) {\n+                        requiredPropertyNames.add(member.getSimpleName().toString());\n+                    }\n+                }\n+            } else if (member.getKind() == ElementKind.METHOD\n+                    && ElementUtils.hasAnnotation(member, \"lombok.Generated\")) {\n+                String methodName = member.getSimpleName().toString();\n+                // Handle fields with @Builder.Default annotations.\n+                // If a field foo has an @Builder.Default annotation, Lombok always generates a\n+                // method called $default$foo.\n+                if (methodName.startsWith(\"$default$\")) {\n+                    String propName = methodName.substring(9); // $default$ has 9 characters\n+                    defaultedPropertyNames.add(propName);\n+                }\n+            } else if (member.getKind().isClass() && member.toString().endsWith(\"Builder\")) {\n+                // If a field bar has an @Singular annotation, Lombok always generates a method\n+                // called clearBar in the builder class itself. Therefore, search the builder for\n+                // such a method, and extract the appropriate property name to treat as defaulted.\n+                for (Element builderMember : member.getEnclosedElements()) {\n+                    if (builderMember.getKind() == ElementKind.METHOD\n+                            && ElementUtils.hasAnnotation(builderMember, \"lombok.Generated\")) {\n+                        String methodName = builderMember.getSimpleName().toString();\n+                        if (methodName.startsWith(\"clear\")) {\n+                            String propName =\n+                                    Introspector.decapitalize(\n+                                            methodName.substring(5)); // clear has 5 characters\n+                            defaultedPropertyNames.add(propName);\n+                        }\n+                    } else if (builderMember.getKind() == ElementKind.FIELD) {\n+                        VariableTree variableTree =\n+                                (VariableTree) atypeFactory.declarationFromElement(builderMember);\n+                        if (variableTree != null && variableTree.getInitializer() != null) {\n+                            String propName = variableTree.getName().toString();\n+                            defaultedPropertyNames.add(propName);\n+                            defaultedElements.put(builderMember, propName);\n+                        } else if (defaultedElements.containsKey(builderMember)) {\n+                            defaultedPropertyNames.add(defaultedElements.get(builderMember));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        requiredPropertyNames.removeAll(defaultedPropertyNames);\n+        return requiredPropertyNames;\n+    }\n+\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        return;\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+        if ((ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(element, \"lombok.Generated\"))\n+                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\")) {\n+            return \"build\".equals(element.getSimpleName().toString());", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk1NzQ3OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485957478", "bodyText": "On line 199 above, the toString is necessary because Name doesn't have an endsWith method or equivalent.\nMost of the uses of Name#toString precede such a call. In other cases, a mix of Names and Strings are used, so using Name#toString is sensible so that they can all be stored together. I don't think it's possible to remove most of the toString calls in this class (or even many of them), but I've removed the ones that can be replaced with contentEquals.", "author": "kelloggm", "createdAt": "2020-09-09T22:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ5NDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUxMzIwMw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476513203", "bodyText": "It's inconsistent that some fields are set with this. prefix, but this one is not.  Be consistent.\nAlso, please make this constructor body initialize all fields in the same order they are declared in the class, to make the code easier to understand.", "author": "mernst", "createdAt": "2020-08-25T14:54:24Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,406 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by the Called Methods\n+     * checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        Set<String> disabledFrameworks = new HashSet<>();\n+        if (checker.hasOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)) {\n+            disabledFrameworks.addAll(\n+                    Arrays.asList(\n+                                    checker.getOption(\n+                                                    CalledMethodsChecker\n+                                                            .DISABLE_BUILDER_FRAMEWORK_SUPPORTS)\n+                                            .split(\",\"))\n+                            .stream()\n+                            .map(String::toUpperCase)\n+                            .collect(Collectors.toList()));\n+        }\n+        builderFrameworkSupports = new ArrayList<>();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUxNTM1OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476515358", "bodyText": "This constructor uses one loop to both set builderFrameworkSupports and to look for errors (bad strings) in DISABLED_BUILDER_FRAMEWORK_SUPPORTS.  This requires complex data structures and also side effects, which can be confusing.  The loop is over 0-2 elements.  To simplify the code, use two loops.  Then disabledFrameworks can be made an array and initialized with a single call to split.", "author": "mernst", "createdAt": "2020-08-25T14:57:06Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,406 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by the Called Methods\n+     * checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        Set<String> disabledFrameworks = new HashSet<>();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUxNzcyOA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476517728", "bodyText": "Don't normalize case.  It is confusing that the examples in the documentation and in the tests are different.  Permitting arbitrary casing leads to such confusion, and makes it more difficult for a user to find all uses of a particular string in their code or the code of other people (because it could appear in multiple different forms).  It does not prevent any hidden problems, because this code warns if a user misspells a framework name.  In other words, I see disadvantages but no benefits to this undocumented feature.", "author": "mernst", "createdAt": "2020-08-25T15:00:04Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,406 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by the Called Methods\n+     * checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        Set<String> disabledFrameworks = new HashSet<>();\n+        if (checker.hasOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)) {\n+            disabledFrameworks.addAll(\n+                    Arrays.asList(\n+                                    checker.getOption(\n+                                                    CalledMethodsChecker\n+                                                            .DISABLE_BUILDER_FRAMEWORK_SUPPORTS)\n+                                            .split(\",\"))\n+                            .stream()\n+                            .map(String::toUpperCase)", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUxOTgzNQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476519835", "bodyText": "Rather than these 3 lines of code, call UtilPlume.join.\nActually, it would be fine to just issue an error about the first incorrect string found.  That would lead to simpler code, and it is adequate for users.", "author": "mernst", "createdAt": "2020-08-25T15:02:52Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,406 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by the Called Methods\n+     * checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        Set<String> disabledFrameworks = new HashSet<>();\n+        if (checker.hasOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)) {\n+            disabledFrameworks.addAll(\n+                    Arrays.asList(\n+                                    checker.getOption(\n+                                                    CalledMethodsChecker\n+                                                            .DISABLE_BUILDER_FRAMEWORK_SUPPORTS)\n+                                            .split(\",\"))\n+                            .stream()\n+                            .map(String::toUpperCase)\n+                            .collect(Collectors.toList()));\n+        }\n+        builderFrameworkSupports = new ArrayList<>();\n+        enableFramework(CalledMethodsChecker.LOMBOK_SUPPORT, disabledFrameworks);\n+        enableFramework(CalledMethodsChecker.AUTOVALUE_SUPPORT, disabledFrameworks);\n+\n+        if (!disabledFrameworks.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            disabledFrameworks.iterator().forEachRemaining(s -> sj.add(s));\n+            String unrecognized = sj.toString();", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjM4NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476522384", "bodyText": "This method can be inlined (and specialized) where it is used, and I think the code will be simpler.", "author": "mernst", "createdAt": "2020-08-25T15:06:27Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,406 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.builder.qual.ReturnsReceiver;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.BugInCF;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by the Called Methods\n+     * checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Lombok has a flag to generate @CalledMethods annotations, but they used the old package name,\n+     * so we maintain it as an alias.\n+     */\n+    private static final String OLD_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.CalledMethods\";\n+\n+    /**\n+     * Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+     * therefore treat it as top.\n+     */\n+    private static final String OLD_NOT_CALLED_METHODS =\n+            \"org.checkerframework.checker.builder.qual.NotCalledMethods\";\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        Set<String> disabledFrameworks = new HashSet<>();\n+        if (checker.hasOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)) {\n+            disabledFrameworks.addAll(\n+                    Arrays.asList(\n+                                    checker.getOption(\n+                                                    CalledMethodsChecker\n+                                                            .DISABLE_BUILDER_FRAMEWORK_SUPPORTS)\n+                                            .split(\",\"))\n+                            .stream()\n+                            .map(String::toUpperCase)\n+                            .collect(Collectors.toList()));\n+        }\n+        builderFrameworkSupports = new ArrayList<>();\n+        enableFramework(CalledMethodsChecker.LOMBOK_SUPPORT, disabledFrameworks);\n+        enableFramework(CalledMethodsChecker.AUTOVALUE_SUPPORT, disabledFrameworks);\n+\n+        if (!disabledFrameworks.isEmpty()) {\n+            StringJoiner sj = new StringJoiner(\", \");\n+            disabledFrameworks.iterator().forEachRemaining(s -> sj.add(s));\n+            String unrecognized = sj.toString();\n+            throw new UserError(\n+                    \"The following argument(s) to the \"\n+                            + CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS\n+                            + \" command-line argument to the Called Methods Checker were unrecognized: \"\n+                            + unrecognized);\n+        }\n+\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        addAliasedAnnotation(OLD_CALLED_METHODS, CalledMethods.class, true);\n+        addAliasedAnnotation(OLD_NOT_CALLED_METHODS, this.top);\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Enables support for the given builder-generation framework, unless it is listed in the\n+     * disabled builder frameworks parsed from the -AdisableBuilderFrameworkSupport option's\n+     * arguments.\n+     *\n+     * @param framework the builder framework to enable\n+     * @param disabledFrameworks the set of disabled builder frameworks. This argument will be\n+     *     side-effected to remove a builder framework if it was actually disabled.\n+     */\n+    private void enableFramework(String framework, Set<String> disabledFrameworks) {", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2NDg1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r485964857", "bodyText": "I rewrote the whole method based on your other comments. I think it's clearer now as a separate method, but I can also inline it into the constructor if you still think that would be better.", "author": "kelloggm", "createdAt": "2020-09-09T22:52:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyMjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNDY2MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476524660", "bodyText": "This string only needs to be used once or maybe in the code, and it is unlikely to change.  (Also, the name LOMBOK_SUPPORT is a bit misleading since this is a string or name, not a BuilderFrameworkSupport.)  Just inline it where it is used.  That will simplify the code and make it easier to read.", "author": "mernst", "createdAt": "2020-08-25T15:09:33Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsChecker.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import java.util.LinkedHashSet;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.returnsreceiver.ReturnsReceiverChecker;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.framework.qual.StubFiles;\n+import org.checkerframework.framework.source.SupportedOptions;\n+import org.checkerframework.framework.source.SuppressWarningsPrefix;\n+\n+/**\n+ * The Called Methods Checker tracks the methods that have definitely been called on an object. One\n+ * common use case for the Called Methods Checker is to specify safe combinations of options to\n+ * builder or builder-like interfaces, preventing objects from being instantiated incompletely.\n+ */\n+@SuppressWarningsPrefix({\n+    // Preferred checkername.\n+    \"calledmethods\",\n+    // Deprecated checkernames, supported for backward compatibility.\n+    \"builder\",\n+    \"object.construction\",\n+    \"objectconstruction\"\n+})\n+@SupportedOptions({\n+    CalledMethodsChecker.USE_VALUE_CHECKER,\n+    CalledMethodsChecker.COUNT_FRAMEWORK_BUILD_CALLS,\n+    CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS,\n+})\n+@StubFiles({\"DescribeImages.astub\", \"GenerateDataKey.astub\"})\n+public class CalledMethodsChecker extends BaseTypeChecker {\n+\n+    /**\n+     * If this option is supplied, count the number of analyzed calls to build() in supported\n+     * builder frameworks and print it when analysis is complete. Useful for collecting metrics.\n+     */\n+    public static final String COUNT_FRAMEWORK_BUILD_CALLS = \"countFrameworkBuildCalls\";\n+\n+    /**\n+     * This option can be used to disable the support (and therefore the automated checking of) code\n+     * that uses the given builder frameworks. Useful when a user **only** wants to enforce\n+     * specifications on custom builder objects (such as the AWS SDK examples).\n+     */\n+    public static final String DISABLE_BUILDER_FRAMEWORK_SUPPORTS =\n+            \"disableBuilderFrameworkSupports\";\n+\n+    /**\n+     * The key for the {@link #DISABLE_BUILDER_FRAMEWORK_SUPPORTS} option to disable Lombok support.\n+     * Use it via {@code -AdisableBuilderFrameworkSupports=LOMBOK}.\n+     */\n+    public static final String LOMBOK_SUPPORT = \"LOMBOK\";", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUyNjA1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r476526059", "bodyText": "This is only used once.  There is no danger of misspelling because of the Compiler Message Checker.  So, please inline it to make the code shorter and easier to read.", "author": "mernst", "createdAt": "2020-08-25T15:11:32Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsVisitor.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.MethodInvocationTree;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.ExecutableElement;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.compilermsgs.qual.CompilerMessageKey;\n+import org.checkerframework.common.accumulation.AccumulationVisitor;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.javacutil.TreeUtils;\n+\n+/**\n+ * This visitor implements the custom error message finalizer.invocation.invalid, and supports\n+ * counting the number of framework build calls.\n+ */\n+public class CalledMethodsVisitor extends AccumulationVisitor {\n+\n+    /** Error message key for incorrect finalizer invocations. */\n+    public static final @CompilerMessageKey String FINALIZER_INVOCATION_INVALID =\n+            \"finalizer.invocation.invalid\";", "originalCommit": "2ec53672e529796c70e16ec94427d5ce4e6396c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c1d8d41013cb5ce24358a4adfb09a1954962230", "url": "https://github.com/typetools/checker-framework/commit/1c1d8d41013cb5ce24358a4adfb09a1954962230", "message": "Fix Javadoc warning", "committedDate": "2020-08-25T15:22:31Z", "type": "commit"}, {"oid": "2974534bdb19b74a696a7953a70f3843baf24cf2", "url": "https://github.com/typetools/checker-framework/commit/2974534bdb19b74a696a7953a70f3843baf24cf2", "message": "merge from mainline", "committedDate": "2020-09-01T22:00:57Z", "type": "commit"}, {"oid": "b721fcf44a22afe4ddf700367ab0866256dcea0a", "url": "https://github.com/typetools/checker-framework/commit/b721fcf44a22afe4ddf700367ab0866256dcea0a", "message": "address PR comments related to AutoValueSupport", "committedDate": "2020-09-01T23:46:24Z", "type": "commit"}, {"oid": "8cd794586d175e9291967d86be5177afb9ae181d", "url": "https://github.com/typetools/checker-framework/commit/8cd794586d175e9291967d86be5177afb9ae181d", "message": "merge", "committedDate": "2020-09-09T21:52:03Z", "type": "commit"}, {"oid": "f4819caa60fe5eb55446eff7b452977c750350de", "url": "https://github.com/typetools/checker-framework/commit/f4819caa60fe5eb55446eff7b452977c750350de", "message": "address all CR comments", "committedDate": "2020-09-09T23:04:57Z", "type": "commit"}, {"oid": "fc7583ff8f16c916012a8191f84eed6af8358173", "url": "https://github.com/typetools/checker-framework/commit/fc7583ff8f16c916012a8191f84eed6af8358173", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-09-10T17:46:06Z", "type": "commit"}, {"oid": "dcb42638a1754d3f61eb399a508d5551d40d23aa", "url": "https://github.com/typetools/checker-framework/commit/dcb42638a1754d3f61eb399a508d5551d40d23aa", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-09-14T23:51:30Z", "type": "commit"}, {"oid": "ac3d8a2f74b03a9e2668ac3468edbeed7daa1d4f", "url": "https://github.com/typetools/checker-framework/commit/ac3d8a2f74b03a9e2668ac3468edbeed7daa1d4f", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-09-16T23:34:39Z", "type": "commit"}, {"oid": "d90468be35756da58e9c7744863ad70a581c5b34", "url": "https://github.com/typetools/checker-framework/commit/d90468be35756da58e9c7744863ad70a581c5b34", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-09-17T23:55:32Z", "type": "commit"}, {"oid": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "url": "https://github.com/typetools/checker-framework/commit/e922ebcbc84753f5be7d1a53d769911e485b3ab6", "message": "Code review tweaks", "committedDate": "2020-09-18T00:05:39Z", "type": "commit"}, {"oid": "6fc5566cad16dd7c22608718832534caafd668de", "url": "https://github.com/typetools/checker-framework/commit/6fc5566cad16dd7c22608718832534caafd668de", "message": "Code review tweaks", "committedDate": "2020-09-18T00:15:36Z", "type": "commit"}, {"oid": "e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "url": "https://github.com/typetools/checker-framework/commit/e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "message": "Code review tweaks", "committedDate": "2020-09-18T00:21:57Z", "type": "commit"}, {"oid": "cfb8d35cbd8187c08bf89a3d07a68b79b80ffd72", "url": "https://github.com/typetools/checker-framework/commit/cfb8d35cbd8187c08bf89a3d07a68b79b80ffd72", "message": "Undo a change", "committedDate": "2020-09-18T00:34:36Z", "type": "commit"}, {"oid": "7e9bd00feace01723a4162e0ea19e268641b939b", "url": "https://github.com/typetools/checker-framework/commit/7e9bd00feace01723a4162e0ea19e268641b939b", "message": "Localize logic and comments", "committedDate": "2020-09-18T00:49:50Z", "type": "commit"}, {"oid": "8019315f4ee06d46ecb0478d8a3e47090717034f", "url": "https://github.com/typetools/checker-framework/commit/8019315f4ee06d46ecb0478d8a3e47090717034f", "message": "Move comments", "committedDate": "2020-09-18T13:06:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNjI4OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490626289", "bodyText": "Under what circumstances does declarationFromElement not work?", "author": "mernst", "createdAt": "2020-09-18T00:03:06Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still", "originalCommit": "ac3d8a2f74b03a9e2668ac3468edbeed7daa1d4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MDQ4Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495190487", "bodyText": "I added a comment, copied below:\n\n* <p>This cache is kept because the usual method for checking that an element has been defaulted\n* (calling declarationFromElement and examining the resulting VariableTree) only works if a corresponding\n* Tree is available (for code that is only available as bytecode, no such Tree is available and that\n* method returns null). See the code in {@link #getLombokRequiredProperties(Element)} that handles\n* fields.", "author": "kelloggm", "createdAt": "2020-09-25T19:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNjU1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490626551", "bodyText": "Please give these variables more descriptive names.  I think both are classes (the second a class annotated with @lombok.Builder).", "author": "mernst", "createdAt": "2020-09-18T00:04:13Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still\n+     * handled correctly.\n+     */\n+    private final Map<Element, Name> defaultedElements = new HashMap<>();\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();", "originalCommit": "ac3d8a2f74b03a9e2668ac3468edbeed7daa1d4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzM0MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490627340", "bodyText": "Use a more descriptive name.  Is this the enclosing class?", "author": "mernst", "createdAt": "2020-09-18T00:07:05Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still\n+     * handled correctly.\n+     */\n+    private final Map<Element, Name> defaultedElements = new HashMap<>();\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+        if ((ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(element, \"lombok.Generated\"))\n+                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\")) {\n+            return element.getSimpleName().contentEquals(\"build\");\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+        AnnotationMirror newCalledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        return e.getSimpleName().contentEquals(\"toBuilder\")\n+                && (ElementUtils.hasAnnotation(e, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(e.getEnclosingElement(), \"lombok.Generated\"));\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyNzQ5MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490627490", "bodyText": "I think \"or the\" should be \"or of the\".", "author": "mernst", "createdAt": "2020-09-18T00:07:37Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still\n+     * handled correctly.\n+     */\n+    private final Map<Element, Name> defaultedElements = new HashMap<>();\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+        if ((ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(element, \"lombok.Generated\"))\n+                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\")) {\n+            return element.getSimpleName().contentEquals(\"build\");\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+        AnnotationMirror newCalledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        return e.getSimpleName().contentEquals(\"toBuilder\")\n+                && (ElementUtils.hasAnnotation(e, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(e.getEnclosingElement(), \"lombok.Generated\"));\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        handleToBuilderType(returnType, enclosingElement);\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyODAyMw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490628023", "bodyText": "I don't see a test for that.  Do you just mean that it ignores the presence or absence of initializers?  That's different than ignoring fields with initializers.", "author": "mernst", "createdAt": "2020-09-18T00:09:37Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still\n+     * handled correctly.\n+     */\n+    private final Map<Element, Name> defaultedElements = new HashMap<>();\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+\n+        if ((ElementUtils.hasAnnotation(enclosingElement, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(element, \"lombok.Generated\"))\n+                && enclosingElement.getSimpleName().toString().endsWith(\"Builder\")) {\n+            return element.getSimpleName().contentEquals(\"build\");\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        Element nextEnclosingElement = enclosingElement.getEnclosingElement();\n+\n+        List<String> requiredProperties = getLombokRequiredProperties(nextEnclosingElement);\n+        AnnotationMirror newCalledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        return e.getSimpleName().contentEquals(\"toBuilder\")\n+                && (ElementUtils.hasAnnotation(e, \"lombok.Generated\")\n+                        || ElementUtils.hasAnnotation(e.getEnclosingElement(), \"lombok.Generated\"));\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement element = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();\n+        handleToBuilderType(returnType, enclosingElement);\n+    }\n+\n+    /**\n+     * Add, to a type, a CalledMethods annotation that states that all required setters have been\n+     * called. The type can be the return type of toBuilder or the corresponding generated \"copy\"\n+     * constructor.\n+     *\n+     * @param type type to update\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(AnnotatedTypeMirror type, Element classElement) {\n+        List<String> requiredProperties = getLombokRequiredProperties(classElement);\n+        AnnotationMirror calledMethodsAnno =\n+                atypeFactory.createAccumulatorAnnotation(requiredProperties);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Computes the required properties of a @lombok.Builder class, i.e., the names of the fields\n+     * with @lombok.NonNull annotations.\n+     *\n+     * @param lombokClassElement the class with the @lombok.Builder annotation\n+     * @return a list of required property names\n+     */\n+    private List<String> getLombokRequiredProperties(final Element lombokClassElement) {\n+        List<String> requiredPropertyNames = new ArrayList<>();\n+        List<String> defaultedPropertyNames = new ArrayList<>();\n+        for (Element member : lombokClassElement.getEnclosedElements()) {\n+            if (member.getKind() == ElementKind.FIELD) {\n+                // Lombok never generates non-null fields with initializers in builders, unless\n+                // the field is annotated with @Default or @Singular, which are handled elsewhere.\n+                // So, this code doesn't need to consider fields with initializers.", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5MjQwMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495192400", "bodyText": "Yes. I've clarified the comment.", "author": "kelloggm", "createdAt": "2020-09-25T19:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyODAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyODE0OA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490628148", "bodyText": "Use a more descriptive variable name.", "author": "mernst", "createdAt": "2020-09-18T00:09:59Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/LombokSupport.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.VariableTree;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Name;\n+import javax.lang.model.element.TypeElement;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+\n+/**\n+ * Lombok Support for the Called Methods Checker, which adds CalledMethods annotations to the code\n+ * generated by Lombok.\n+ */\n+public class LombokSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new LombokSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public LombokSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    // The list is copied from lombok.core.handlers.HandlerUtil. The list cannot be used from that\n+    // class directly because Lombok does not provide class files for its own implementation, to\n+    // prevent itself from being accidentally added to clients' compile classpaths. This design\n+    // decision means that it is impossible to depend directly on Lombok internals.\n+    /** The list of annotations that Lombok treats as non-null. */\n+    public static final List<String> NONNULL_ANNOTATIONS =\n+            Collections.unmodifiableList(\n+                    Arrays.asList(\n+                            \"android.annotation.NonNull\",\n+                            \"android.support.annotation.NonNull\",\n+                            \"com.sun.istack.internal.NotNull\",\n+                            \"edu.umd.cs.findbugs.annotations.NonNull\",\n+                            \"javax.annotation.Nonnull\",\n+                            // \"javax.validation.constraints.NotNull\", // The field might contain a\n+                            // null value until it is persisted.\n+                            \"lombok.NonNull\",\n+                            \"org.checkerframework.checker.nullness.qual.NonNull\",\n+                            \"org.eclipse.jdt.annotation.NonNull\",\n+                            \"org.eclipse.jgit.annotations.NonNull\",\n+                            \"org.jetbrains.annotations.NotNull\",\n+                            \"org.jmlspecs.annotation.NonNull\",\n+                            \"org.netbeans.api.annotations.common.NonNull\",\n+                            \"org.springframework.lang.NonNull\"));\n+\n+    /**\n+     * A map from elements that have a lombok.Builder.Default annotation to the simple property name\n+     * that should be treated as defaulted.\n+     *\n+     * <p>This cache is kept so that when declarationFromElement doesn't work, defaults are still\n+     * handled correctly.\n+     */\n+    private final Map<Element, Name> defaultedElements = new HashMap<>();\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyODU4MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490628580", "bodyText": "Rather than assert, please throw the appropriate exception, such as BugInCF or UserError.", "author": "mernst", "createdAt": "2020-09-18T00:11:34Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * kind of constructor.\n+     *\n+     * @param tree AST for a call to any constructor\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyOTM0Mw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490629343", "bodyText": "Variable naming", "author": "mernst", "createdAt": "2020-09-18T00:13:51Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * kind of constructor.\n+     *\n+     * @param tree AST for a call to any constructor\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present\n+        AnnotationMirror possibleBuildAnnotations =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (possibleBuildAnnotations == null) {\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyOTQzMA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490629430", "bodyText": "Is this the superclass of e, enclosingElement, or both?", "author": "mernst", "createdAt": "2020-09-18T00:14:13Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * kind of constructor.\n+     *\n+     * @param tree AST for a call to any constructor\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        // only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present\n+        AnnotationMirror possibleBuildAnnotations =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (possibleBuildAnnotations == null) {\n+            t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();", "originalCommit": "e922ebcbc84753f5be7d1a53d769911e485b3ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMDI1Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490630256", "bodyText": "Variable naming.  I think this is the enclosing class.", "author": "mernst", "createdAt": "2020-09-18T00:16:48Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,460 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();", "originalCommit": "6fc5566cad16dd7c22608718832534caafd668de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMDg0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490630846", "bodyText": "This corresponds to type, not builderType, I think.", "author": "mernst", "createdAt": "2020-09-18T00:18:45Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,460 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod\n+        // would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was definitely generated by AutoValue, false otherwise\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class", "originalCommit": "6fc5566cad16dd7c22608718832534caafd668de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NjMwNw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495196307", "bodyText": "The comment was unclear - that was the intended meaning, but I see (and have fixed) the ambiguity.", "author": "kelloggm", "createdAt": "2020-09-25T19:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMTMyMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490631322", "bodyText": "Should this be moved to the main issue tracker?", "author": "mernst", "createdAt": "2020-09-18T00:20:32Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,460 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod\n+        // would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was definitely generated by AutoValue, false otherwise\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, TypeElement classElement) {\n+        TypeElement builderElement = TypesUtils.getTypeElement(builderType);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, classElement);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Create an @CalledMethods annotation for the given AutoValue class and builder by computing\n+     * the required setters.\n+     *\n+     * @param builderElement the element for the actual Builder class\n+     * @param classElement the element for the AutoValue class (i.e. the class that is built by the\n+     *     builder)\n+     * @return an @CalledMethods annotation representing the\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueClass(\n+            TypeElement builderElement, TypeElement classElement) {\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        return createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all setters in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e. a field) into the name of its setter.\n+     *\n+     * @param prop the property name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        String[] possiblePropNames;\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(3))};\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(2))};\n+        } else {\n+            possiblePropNames = new String[] {prop};\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            String[] setterNamesToTry =\n+                    new String[] {\n+                        propName, \"set\" + BuilderFrameworkSupportUtils.capitalize(propName)\n+                    };\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .", "originalCommit": "6fc5566cad16dd7c22608718832534caafd668de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5NzM1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495197357", "bodyText": "Eventually. Let's wait to move issues over until the checker actually exists in the framework proper, though. I'll go through the open OCC issues and move all the pertinent ones after this PR is merged (and fix this reference when I do).", "author": "kelloggm", "createdAt": "2020-09-25T19:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjA1OQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490632059", "bodyText": "Make this a static field:\n\nfor efficiency (so it doesn't get created anew each time this method is called)\nso it can be given documentation.", "author": "mernst", "createdAt": "2020-09-18T00:23:15Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,458 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was generated by AutoValue\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, TypeElement classElement) {\n+        TypeElement builderElement = TypesUtils.getTypeElement(builderType);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, classElement);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Create an @CalledMethods annotation for the given AutoValue class and builder. The returned\n+     * annotation contains all the required setters.\n+     *\n+     * @param builderElement the element for the Builder class\n+     * @param classElement the element for the AutoValue class (i.e. the class that is built by the\n+     *     builder)\n+     * @return an @CalledMethods annotation representing that all the required setters have been\n+     *     called\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueClass(\n+            TypeElement builderElement, TypeElement classElement) {\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        return createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all setters in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e., a field) into the name of its setter.\n+     *\n+     * @param prop the property (i.e., field) name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        String[] possiblePropNames;\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(3))};\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(2))};\n+        } else {\n+            possiblePropNames = new String[] {prop};\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            String[] setterNamesToTry =\n+                    new String[] {\n+                        propName, \"set\" + BuilderFrameworkSupportUtils.capitalize(propName)\n+                    };\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final TypeElement autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member a member of an AutoValue class or superclass\n+     * @param avBuilderSetterNames names of all setters in corresponding AutoValue builder class\n+     * @return true if {@code member} is required\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> avBuilderSetterNames) {\n+        String name = member.getSimpleName().toString();\n+        // Ignore java.lang.Object overrides, constructors, and toBuilder methods in AutoValue\n+        // classes.\n+        // Strictly speaking, this code should check return types, etc. to handle strange\n+        // overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+        if (ArraysPlume.indexOf(\n+                        new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"},", "originalCommit": "e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyMzczMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r491123732", "bodyText": "In your previous review (here: #3529 (comment)), you suggested inlining the existing final static field because it is only used once, which directly contradicts this suggestion.", "author": "kelloggm", "createdAt": "2020-09-18T18:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzNjE0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r491136141", "bodyText": "Oops!  Sorry about that.  I must not have been thinking about the cost of recomputing it.  I don't have a feel for whether the run-time cost is actually a problem -- I just worried about the extra allocation and garbage collection.", "author": "mernst", "createdAt": "2020-09-18T18:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5ODQzMg==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495198432", "bodyText": "I think the benefit to readability is worth the little bit of extra allocation/deallocation. This method is only called when actually analyzing a class that AutoValue generated (which shouldn't be that many classes), so the runtime overhead shouldn't be too bad.", "author": "kelloggm", "createdAt": "2020-09-25T19:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjU1MA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490632550", "bodyText": "Does this need to be concatenated?  There could instead be two different calls, joined by ||, which would avoid the overhead of concatenation.  It's not a huge deal either way.", "author": "mernst", "createdAt": "2020-09-18T00:25:07Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,458 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was generated by AutoValue\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, TypeElement classElement) {\n+        TypeElement builderElement = TypesUtils.getTypeElement(builderType);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, classElement);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Create an @CalledMethods annotation for the given AutoValue class and builder. The returned\n+     * annotation contains all the required setters.\n+     *\n+     * @param builderElement the element for the Builder class\n+     * @param classElement the element for the AutoValue class (i.e. the class that is built by the\n+     *     builder)\n+     * @return an @CalledMethods annotation representing that all the required setters have been\n+     *     called\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueClass(\n+            TypeElement builderElement, TypeElement classElement) {\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        return createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all setters in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e., a field) into the name of its setter.\n+     *\n+     * @param prop the property (i.e., field) name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        String[] possiblePropNames;\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(3))};\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(2))};\n+        } else {\n+            possiblePropNames = new String[] {prop};\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            String[] setterNamesToTry =\n+                    new String[] {\n+                        propName, \"set\" + BuilderFrameworkSupportUtils.capitalize(propName)\n+                    };\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final TypeElement autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member a member of an AutoValue class or superclass\n+     * @param avBuilderSetterNames names of all setters in corresponding AutoValue builder class\n+     * @return true if {@code member} is required\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> avBuilderSetterNames) {\n+        String name = member.getSimpleName().toString();\n+        // Ignore java.lang.Object overrides, constructors, and toBuilder methods in AutoValue\n+        // classes.\n+        // Strictly speaking, this code should check return types, etc. to handle strange\n+        // overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+        if (ArraysPlume.indexOf(\n+                        new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"},\n+                        name)\n+                != -1) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(", "originalCommit": "e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5ODg3NA==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495198874", "bodyText": "I think either way is fine. I'm going to leave it as-is since I don't see a compelling reason to change it and this version works.", "author": "kelloggm", "createdAt": "2020-09-25T19:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjY1Nw==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490632657", "bodyText": "Abstract this into a static field, for efficiency and to give it its own documentation.", "author": "mernst", "createdAt": "2020-09-18T00:25:30Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,458 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was generated by AutoValue\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, TypeElement classElement) {\n+        TypeElement builderElement = TypesUtils.getTypeElement(builderType);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, classElement);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Create an @CalledMethods annotation for the given AutoValue class and builder. The returned\n+     * annotation contains all the required setters.\n+     *\n+     * @param builderElement the element for the Builder class\n+     * @param classElement the element for the AutoValue class (i.e. the class that is built by the\n+     *     builder)\n+     * @return an @CalledMethods annotation representing that all the required setters have been\n+     *     called\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueClass(\n+            TypeElement builderElement, TypeElement classElement) {\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        return createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all setters in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e., a field) into the name of its setter.\n+     *\n+     * @param prop the property (i.e., field) name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        String[] possiblePropNames;\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(3))};\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(2))};\n+        } else {\n+            possiblePropNames = new String[] {prop};\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            String[] setterNamesToTry =\n+                    new String[] {\n+                        propName, \"set\" + BuilderFrameworkSupportUtils.capitalize(propName)\n+                    };\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final TypeElement autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member a member of an AutoValue class or superclass\n+     * @param avBuilderSetterNames names of all setters in corresponding AutoValue builder class\n+     * @return true if {@code member} is required\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> avBuilderSetterNames) {\n+        String name = member.getSimpleName().toString();\n+        // Ignore java.lang.Object overrides, constructors, and toBuilder methods in AutoValue\n+        // classes.\n+        // Strictly speaking, this code should check return types, etc. to handle strange\n+        // overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+        if (ArraysPlume.indexOf(\n+                        new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"},\n+                        name)\n+                != -1) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && avBuilderSetterNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * Returns whether AutoValue considers a type to be \"optional.\" Optional types do not need to be\n+     * set before build is called on a builder. Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        // This list of classes that AutoValue considers \"optional\" comes from AutoValue's source", "originalCommit": "e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE5OTU1MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495199551", "bodyText": "Similar to the other potential static field in this class, you specifically asked me to inline this in your previous review. I think the benefit to readability that is gained from having this list at the exact place that it is used is worth the small efficiency loss.", "author": "kelloggm", "createdAt": "2020-09-25T19:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzMjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNDE0MQ==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490634141", "bodyText": "I think this should be:\nsupertypes (i.e. those that appear in extends clauses) appear before indirect supertypes", "author": "mernst", "createdAt": "2020-09-18T00:31:19Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/builder/AutoValueSupport.java", "diffHunk": "@@ -0,0 +1,458 @@\n+package org.checkerframework.checker.calledmethods.builder;\n+\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.processing.JavacProcessingEnvironment;\n+import java.beans.Introspector;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.CalledMethodsAnnotatedTypeFactory;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror.AnnotatedExecutableType;\n+import org.checkerframework.framework.util.AnnotatedTypes;\n+import org.checkerframework.javacutil.AnnotationUtils;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.TypesUtils;\n+import org.plumelib.util.ArraysPlume;\n+\n+/**\n+ * AutoValue support for the Called Methods Checker, which adds {@code @}{@link CalledMethods}\n+ * annotations to the code generated by AutoValue.\n+ */\n+public class AutoValueSupport implements BuilderFrameworkSupport {\n+\n+    /** The type factory. */\n+    private CalledMethodsAnnotatedTypeFactory atypeFactory;\n+\n+    /**\n+     * Create a new AutoValueSupport.\n+     *\n+     * @param atypeFactory the typechecker's type factory\n+     */\n+    public AutoValueSupport(CalledMethodsAnnotatedTypeFactory atypeFactory) {\n+        this.atypeFactory = atypeFactory;\n+    }\n+\n+    /**\n+     * This method modifies the type of a copy constructor generated by AutoValue to match the type\n+     * of the AutoValue toBuilder method, and has no effect if {@code tree} is a call to any other\n+     * constructor.\n+     *\n+     * @param tree AST for a constructor call\n+     * @param type type of the call expression\n+     */\n+    @Override\n+    public void handleConstructor(NewClassTree tree, AnnotatedTypeMirror type) {\n+        ExecutableElement element = TreeUtils.elementFromUse(tree);\n+        TypeMirror superclass = ((TypeElement) element.getEnclosingElement()).getSuperclass();\n+\n+        if (superclass.getKind() != TypeKind.NONE\n+                && ElementUtils.hasAnnotation(\n+                        TypesUtils.getTypeElement(superclass),\n+                        getAutoValuePackageName() + \".AutoValue.Builder\")\n+                && element.getParameters().size() > 0) {\n+            handleToBuilderType(\n+                    type,\n+                    superclass,\n+                    (TypeElement) TypesUtils.getTypeElement(superclass).getEnclosingElement());\n+        }\n+    }\n+\n+    @Override\n+    public boolean isBuilderBuildMethod(ExecutableElement element) {\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        if (ElementUtils.hasAnnotation(\n+                builderElement, getAutoValuePackageName() + \".AutoValue.Builder\")) {\n+            Element classContainingBuilderElement = builderElement.getEnclosingElement();\n+            assert ElementUtils.hasAnnotation(\n+                            classContainingBuilderElement, getAutoValuePackageName() + \".AutoValue\")\n+                    : \"class \"\n+                            + classContainingBuilderElement.getSimpleName()\n+                            + \" is missing @AutoValue annotation\";\n+            // it is a build method if it returns the type with the @AutoValue annotation\n+            if (TypesUtils.getTypeElement(element.getReturnType())\n+                    .equals(classContainingBuilderElement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleBuilderBuildMethod(AnnotatedExecutableType t) {\n+        // Only add the new @CalledMethods annotation if there is not already a @CalledMethods\n+        // annotation present.\n+        AnnotationMirror explicitCalledMethodsAnno =\n+                t.getReceiverType()\n+                        .getAnnotationInHierarchy(\n+                                atypeFactory\n+                                        .getQualifierHierarchy()\n+                                        .getTopAnnotation(newCalledMethodsAnno));\n+        if (explicitCalledMethodsAnno != null) {\n+            return;\n+        }\n+\n+        ExecutableElement element = t.getElement();\n+        TypeElement builderElement = (TypeElement) element.getEnclosingElement();\n+        TypeElement autoValueClassElement = (TypeElement) builderElement.getEnclosingElement();\n+        AnnotationMirror newCalledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, autoValueClassElement);\n+        t.getReceiverType().addAnnotation(newCalledMethodsAnno);\n+    }\n+\n+    @Override\n+    public boolean isToBuilderMethod(ExecutableElement e) {\n+        if (!\"toBuilder\".equals(e.getSimpleName().toString())) {\n+            return false;\n+        }\n+\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        boolean isAbstractAV =\n+                isAutoValueGenerated(enclosingElement)\n+                        && e.getModifiers().contains(Modifier.ABSTRACT);\n+        TypeMirror superclass = enclosingElement.getSuperclass();\n+        boolean superIsAV = false;\n+        if (superclass.getKind() != TypeKind.NONE) {\n+            superIsAV = isAutoValueGenerated(TypesUtils.getTypeElement(superclass));\n+        }\n+        return superIsAV || isAbstractAV;\n+    }\n+\n+    @Override\n+    public void handleToBuilderMethod(AnnotatedExecutableType t) {\n+        AnnotatedTypeMirror returnType = t.getReturnType();\n+        ExecutableElement e = t.getElement();\n+        TypeElement enclosingElement = (TypeElement) e.getEnclosingElement();\n+        // Because of the way that the check in #isToBuilderMethod works, if the code reaches this\n+        // point and this condition is false, the other condition MUST be true (otherwise,\n+        // isToBuilderMethod would have returned false).\n+        if (isAutoValueGenerated(enclosingElement)\n+                && e.getModifiers().contains(Modifier.ABSTRACT)) {\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), enclosingElement);\n+        } else {\n+            TypeElement superElement = TypesUtils.getTypeElement(enclosingElement.getSuperclass());\n+            handleToBuilderType(returnType, returnType.getUnderlyingType(), superElement);\n+        }\n+    }\n+\n+    /**\n+     * Was the given element generated by AutoValue?\n+     *\n+     * @param element the element to check\n+     * @return true if the element was generated by AutoValue\n+     */\n+    private boolean isAutoValueGenerated(Element element) {\n+        return ElementUtils.hasAnnotation(element, getAutoValuePackageName() + \".AutoValue\");\n+    }\n+\n+    /**\n+     * Add, to {@code type}, a CalledMethods annotation with all required methods called. The type\n+     * can be the return type of toBuilder or the corresponding generated \"copy\" constructor.\n+     *\n+     * @param type type to update\n+     * @param builderType type of abstract @AutoValue.Builder class\n+     * @param classElement corresponding AutoValue class\n+     */\n+    private void handleToBuilderType(\n+            AnnotatedTypeMirror type, TypeMirror builderType, TypeElement classElement) {\n+        TypeElement builderElement = TypesUtils.getTypeElement(builderType);\n+        AnnotationMirror calledMethodsAnno =\n+                createCalledMethodsForAutoValueClass(builderElement, classElement);\n+        type.replaceAnnotation(calledMethodsAnno);\n+    }\n+\n+    /**\n+     * Create an @CalledMethods annotation for the given AutoValue class and builder. The returned\n+     * annotation contains all the required setters.\n+     *\n+     * @param builderElement the element for the Builder class\n+     * @param classElement the element for the AutoValue class (i.e. the class that is built by the\n+     *     builder)\n+     * @return an @CalledMethods annotation representing that all the required setters have been\n+     *     called\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueClass(\n+            TypeElement builderElement, TypeElement classElement) {\n+        Set<String> avBuilderSetterNames = getAutoValueBuilderSetterMethodNames(builderElement);\n+        List<String> requiredProperties =\n+                getAutoValueRequiredProperties(classElement, avBuilderSetterNames);\n+        return createCalledMethodsForAutoValueProperties(requiredProperties, avBuilderSetterNames);\n+    }\n+\n+    /**\n+     * Creates a @CalledMethods annotation for the given property names, converting the names to the\n+     * corresponding setter method name in the Builder.\n+     *\n+     * @param propertyNames the property names\n+     * @param avBuilderSetterNames names of all setters in the builder class\n+     * @return a @CalledMethods annotation that indicates all the given properties have been set\n+     */\n+    private AnnotationMirror createCalledMethodsForAutoValueProperties(\n+            final List<String> propertyNames, Set<String> avBuilderSetterNames) {\n+        List<String> calledMethodNames =\n+                propertyNames.stream()\n+                        .map(prop -> autoValuePropToBuilderSetterName(prop, avBuilderSetterNames))\n+                        .filter(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+        return atypeFactory.createAccumulatorAnnotation(calledMethodNames);\n+    }\n+\n+    /**\n+     * Converts the name of a property (i.e., a field) into the name of its setter.\n+     *\n+     * @param prop the property (i.e., field) name\n+     * @param builderSetterNames names of all methods in the builder class\n+     * @return the name of the setter for prop\n+     */\n+    private static String autoValuePropToBuilderSetterName(\n+            String prop, Set<String> builderSetterNames) {\n+        // We have two cases, depending on whether AutoValue strips JavaBean-style prefixes 'get'\n+        // and 'is'.\n+        String[] possiblePropNames;\n+        if (prop.startsWith(\"get\") && prop.length() > 3 && Character.isUpperCase(prop.charAt(3))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(3))};\n+        } else if (prop.startsWith(\"is\")\n+                && prop.length() > 2\n+                && Character.isUpperCase(prop.charAt(2))) {\n+            possiblePropNames = new String[] {prop, Introspector.decapitalize(prop.substring(2))};\n+        } else {\n+            possiblePropNames = new String[] {prop};\n+        }\n+\n+        for (String propName : possiblePropNames) {\n+            // in each case, the setter may be the property name itself, or prefixed by 'set'\n+            String[] setterNamesToTry =\n+                    new String[] {\n+                        propName, \"set\" + BuilderFrameworkSupportUtils.capitalize(propName)\n+                    };\n+            for (String setterName : setterNamesToTry) {\n+                if (builderSetterNames.contains(setterName)) {\n+                    return setterName;\n+                }\n+            }\n+        }\n+\n+        // Could not find a corresponding setter.  This is likely because an AutoValue Extension is\n+        // in use.  See https://github.com/kelloggm/object-construction-checker/issues/110 .\n+        // For now we return null, but once that bug is fixed, this should be changed to an\n+        // assertion failure.\n+        return null;\n+    }\n+\n+    /**\n+     * Computes the required properties of an @AutoValue class.\n+     *\n+     * @param autoValueClassElement the @AutoValue class\n+     * @param avBuilderSetterNames names of all setters in the corresponding AutoValue builder class\n+     * @return a list of required property names\n+     */\n+    private List<String> getAutoValueRequiredProperties(\n+            final TypeElement autoValueClassElement, Set<String> avBuilderSetterNames) {\n+        return getAllAbstractMethods(autoValueClassElement).stream()\n+                .filter(member -> isAutoValueRequiredProperty(member, avBuilderSetterNames))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Does member represent a required property of an AutoValue class?\n+     *\n+     * @param member a member of an AutoValue class or superclass\n+     * @param avBuilderSetterNames names of all setters in corresponding AutoValue builder class\n+     * @return true if {@code member} is required\n+     */\n+    private boolean isAutoValueRequiredProperty(Element member, Set<String> avBuilderSetterNames) {\n+        String name = member.getSimpleName().toString();\n+        // Ignore java.lang.Object overrides, constructors, and toBuilder methods in AutoValue\n+        // classes.\n+        // Strictly speaking, this code should check return types, etc. to handle strange\n+        // overloads and other corner cases. They seem unlikely enough that we are skipping for now.\n+        if (ArraysPlume.indexOf(\n+                        new String[] {\"equals\", \"hashCode\", \"toString\", \"<init>\", \"toBuilder\"},\n+                        name)\n+                != -1) {\n+            return false;\n+        }\n+        TypeMirror returnType = ((ExecutableElement) member).getReturnType();\n+        if (returnType.getKind() == TypeKind.VOID) {\n+            return false;\n+        }\n+        // shouldn't have a nullable return\n+        boolean hasNullable =\n+                Stream.concat(\n+                                atypeFactory.getElementUtils().getAllAnnotationMirrors(member)\n+                                        .stream(),\n+                                returnType.getAnnotationMirrors().stream())\n+                        .anyMatch(anm -> AnnotationUtils.annotationName(anm).endsWith(\".Nullable\"));\n+        if (hasNullable) {\n+            return false;\n+        }\n+        // if return type of foo() is a Guava Immutable type, not required if there is a\n+        // builder method fooBuilder()\n+        if (BuilderFrameworkSupportUtils.isGuavaImmutableType(returnType)\n+                && avBuilderSetterNames.contains(name + \"Builder\")) {\n+            return false;\n+        }\n+        // if it's an Optional, the Builder will automatically initialize it\n+        if (isOptional(returnType)) {\n+            return false;\n+        }\n+        // it's required!\n+        return true;\n+    }\n+\n+    /**\n+     * Returns whether AutoValue considers a type to be \"optional.\" Optional types do not need to be\n+     * set before build is called on a builder. Adapted from AutoValue source code.\n+     *\n+     * @param type some type\n+     * @return true if type is an Optional type\n+     */\n+    static boolean isOptional(TypeMirror type) {\n+        if (type.getKind() != TypeKind.DECLARED) {\n+            return false;\n+        }\n+        DeclaredType declaredType = (DeclaredType) type;\n+        TypeElement typeElement = (TypeElement) declaredType.asElement();\n+        // This list of classes that AutoValue considers \"optional\" comes from AutoValue's source\n+        // code.\n+        String[] optionalClassNames =\n+                new String[] {\n+                    \"com.google.common.base.Optional\",\n+                    \"java.util.Optional\",\n+                    \"java.util.OptionalDouble\",\n+                    \"java.util.OptionalInt\",\n+                    \"java.util.OptionalLong\"\n+                };\n+        return ArraysPlume.indexOf(optionalClassNames, typeElement.getQualifiedName().toString())\n+                        != -1\n+                && typeElement.getTypeParameters().size() == declaredType.getTypeArguments().size();\n+    }\n+\n+    /**\n+     * Returns the names of setter methods for an AutoValue builder.\n+     *\n+     * @param builderElement the element representing an AutoValue builder\n+     * @return names of all methods whose return type is the builder itself or that return a Guava\n+     *     Immutable type, and are therefore setters\n+     */\n+    private Set<String> getAutoValueBuilderSetterMethodNames(TypeElement builderElement) {\n+        return getAllAbstractMethods(builderElement).stream()\n+                .filter(e -> isAutoValueBuilderSetter(e, builderElement))\n+                .map(e -> e.getSimpleName().toString())\n+                .collect(Collectors.toSet());\n+    }\n+\n+    /**\n+     * Is method a setter for an AutoValue builder?\n+     *\n+     * @param method a method of builder or one of its supertypes\n+     * @param builderElement element for the AutoValue builder\n+     * @return {@code true} if e is a setter for the builder, {@code false} otherwise\n+     */\n+    private boolean isAutoValueBuilderSetter(ExecutableElement method, TypeElement builderElement) {\n+        TypeMirror retType = method.getReturnType();\n+        if (retType.getKind() == TypeKind.TYPEVAR) {\n+            // instantiate the type variable for the Builder class\n+            retType =\n+                    AnnotatedTypes.asMemberOf(\n+                                    atypeFactory.getContext().getTypeUtils(),\n+                                    atypeFactory,\n+                                    atypeFactory.getAnnotatedType(builderElement),\n+                                    method)\n+                            .getReturnType()\n+                            .getUnderlyingType();\n+        }\n+        // either the return type should be the builder itself, or it should be a Guava immutable\n+        // type\n+        return BuilderFrameworkSupportUtils.isGuavaImmutableType(retType)\n+                || builderElement.equals(TypesUtils.getTypeElement(retType));\n+    }\n+\n+    /**\n+     * Get all the abstract methods for a class. This includes inherited abstract methods that are\n+     * not overridden by the class or a superclass. There is no guarantee that this method will work\n+     * as intended on code that implements an interface (which AutoValue classes are not supposed to\n+     * do: https://github.com/google/auto/blob/master/value/userguide/howto.md#inherit).\n+     *\n+     * @param classElement the class\n+     * @return list of all abstract methods\n+     */\n+    public List<ExecutableElement> getAllAbstractMethods(TypeElement classElement) {\n+        List<Element> supertypes = getAllSupertypes((Symbol) classElement);\n+        List<ExecutableElement> abstractMethods = new ArrayList<>();\n+        Set<ExecutableElement> overriddenMethods = new HashSet<>();\n+        for (Element t : supertypes) {\n+            for (Element member : t.getEnclosedElements()) {\n+                if (member.getKind() != ElementKind.METHOD) {\n+                    continue;\n+                }\n+                Set<Modifier> modifiers = member.getModifiers();\n+                if (modifiers.contains(Modifier.STATIC)) {\n+                    continue;\n+                }\n+                if (modifiers.contains(Modifier.ABSTRACT)) {\n+                    // Make sure it's not overridden. This only works because #getAllSupertypes\n+                    // returns\n+                    // results in a particular order.\n+                    if (!overriddenMethods.contains(member)) {\n+                        abstractMethods.add((ExecutableElement) member);\n+                    }\n+                } else {\n+                    // Exclude any methods that this overrides.\n+                    overriddenMethods.addAll(\n+                            AnnotatedTypes.overriddenMethods(\n+                                            atypeFactory.getElementUtils(),\n+                                            atypeFactory,\n+                                            (ExecutableElement) member)\n+                                    .values());\n+                }\n+            }\n+        }\n+        return abstractMethods;\n+    }\n+\n+    /**\n+     * Get the qualified name of the package containing AutoValue annotations. This method\n+     * constructs the String dynamically, to ensure it does not get rewritten due to relocation of\n+     * the {@code \"com.google\"} package during the build process.\n+     *\n+     * @return {@code \"com.google.auto.value\"}\n+     */\n+    private String getAutoValuePackageName() {\n+        String com = \"com\";\n+        return com + \".\" + \"google.auto.value\";\n+    }\n+\n+    /**\n+     * Get all the supertypes of a given class, including that class.\n+     *\n+     * @param symbol symbol for a class\n+     * @return list including the class and all its supertypes, with a guarantee that direct\n+     *     subtypes (i.e. those that appear in extends clauses) appear before supertypes", "originalCommit": "e7d7cca1b4c40fc36b0e78c5faa0e41ac3a4d96e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIwMDA0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r495200046", "bodyText": "That is much clearer, thanks.", "author": "kelloggm", "createdAt": "2020-09-25T19:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYzNDE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzOTE0Ng==", "url": "https://github.com/typetools/checker-framework/pull/3529#discussion_r490939146", "bodyText": "Descending into singletonList is only relevant at the top level (as the argument filterTree), so it doesn't belong within the while loop.\nIn fact, it doesn't belong in filterTreeToMethodName.  Move it into adjustMethodNameUsingValueChecker, since it is logically part of the for (Tree filterTree : tree.getArguments()) loop.  I think this will clarify the logic.", "author": "mernst", "createdAt": "2020-09-18T13:12:22Z", "path": "checker/src/main/java/org/checkerframework/checker/calledmethods/CalledMethodsAnnotatedTypeFactory.java", "diffHunk": "@@ -0,0 +1,387 @@\n+package org.checkerframework.checker.calledmethods;\n+\n+import com.sun.source.tree.ExpressionTree;\n+import com.sun.source.tree.MethodInvocationTree;\n+import com.sun.source.tree.NewClassTree;\n+import com.sun.source.tree.Tree;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import javax.lang.model.element.AnnotationMirror;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import org.checkerframework.checker.calledmethods.builder.AutoValueSupport;\n+import org.checkerframework.checker.calledmethods.builder.BuilderFrameworkSupport;\n+import org.checkerframework.checker.calledmethods.builder.LombokSupport;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethods;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsBottom;\n+import org.checkerframework.checker.calledmethods.qual.CalledMethodsPredicate;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.checkerframework.common.accumulation.AccumulationAnnotatedTypeFactory;\n+import org.checkerframework.common.basetype.BaseTypeChecker;\n+import org.checkerframework.common.value.ValueAnnotatedTypeFactory;\n+import org.checkerframework.common.value.ValueChecker;\n+import org.checkerframework.common.value.ValueCheckerUtils;\n+import org.checkerframework.framework.type.AnnotatedTypeFactory;\n+import org.checkerframework.framework.type.AnnotatedTypeMirror;\n+import org.checkerframework.framework.type.treeannotator.ListTreeAnnotator;\n+import org.checkerframework.framework.type.treeannotator.TreeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.ListTypeAnnotator;\n+import org.checkerframework.framework.type.typeannotator.TypeAnnotator;\n+import org.checkerframework.javacutil.ElementUtils;\n+import org.checkerframework.javacutil.TreeUtils;\n+import org.checkerframework.javacutil.UserError;\n+\n+/** The annotated type factory for the Called Methods Checker. */\n+public class CalledMethodsAnnotatedTypeFactory extends AccumulationAnnotatedTypeFactory {\n+\n+    /**\n+     * The builder frameworks (such as Lombok and AutoValue) supported by this instance of the\n+     * Called Methods Checker.\n+     */\n+    private Collection<BuilderFrameworkSupport> builderFrameworkSupports;\n+\n+    /**\n+     * Whether to use the Value Checker as a subchecker to reduce false positives when analyzing\n+     * calls to the AWS SDK. Defaults to false. Controlled by the command-line option {@code\n+     * -AuseValueChecker}.\n+     */\n+    private final boolean useValueChecker;\n+\n+    /**\n+     * The {@link java.util.Collections#singletonList} method. It is treated specially by {@link\n+     * #adjustMethodNameUsingValueChecker(String, MethodInvocationTree)}.\n+     */\n+    private final ExecutableElement collectionsSingletonList;\n+\n+    /**\n+     * Create a new CalledMethodsAnnotatedTypeFactory.\n+     *\n+     * @param checker the checker\n+     */\n+    public CalledMethodsAnnotatedTypeFactory(BaseTypeChecker checker) {\n+        super(\n+                checker,\n+                CalledMethods.class,\n+                CalledMethodsBottom.class,\n+                CalledMethodsPredicate.class);\n+        this.builderFrameworkSupports = new ArrayList<>();\n+        String[] disabledFrameworks;\n+        if (checker.hasOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)) {\n+            disabledFrameworks =\n+                    checker.getOption(CalledMethodsChecker.DISABLE_BUILDER_FRAMEWORK_SUPPORTS)\n+                            .split(\",\");\n+        } else {\n+            disabledFrameworks = new String[0];\n+        }\n+        enableFrameworks(disabledFrameworks);\n+        this.useValueChecker = checker.hasOption(CalledMethodsChecker.USE_VALUE_CHECKER);\n+        this.collectionsSingletonList =\n+                TreeUtils.getMethod(\n+                        \"java.util.Collections\", \"singletonList\", 1, getProcessingEnv());\n+        // Lombok generates @CalledMethods annotations using an old package name,\n+        // so we maintain it as an alias.\n+        addAliasedAnnotation(\n+                \"org.checkerframework.checker.builder.qual.CalledMethods\",\n+                CalledMethods.class,\n+                true);\n+        // Lombok also generates an @NotCalledMethods annotation, which we have no support for. We\n+        // therefore treat it as top.\n+        addAliasedAnnotation(\n+                \"org.checkerframework.checker.builder.qual.NotCalledMethods\", this.top);\n+        this.postInit();\n+    }\n+\n+    /**\n+     * Enables support for the default builder-generation frameworks, except those listed in the\n+     * disabled builder frameworks parsed from the -AdisableBuilderFrameworkSupport option's\n+     * arguments. Throws a UserError if the user included an unsupported framework in the list of\n+     * frameworks to be disabled.\n+     *\n+     * @param disabledFrameworks the disabled builder frameworks.\n+     */\n+    private void enableFrameworks(String[] disabledFrameworks) {\n+        boolean enableAutoValueSupport = true;\n+        boolean enableLombokSupport = true;\n+        for (String framework : disabledFrameworks) {\n+            switch (framework) {\n+                case \"autovalue\":\n+                    enableAutoValueSupport = false;\n+                    break;\n+                case \"lombok\":\n+                    enableLombokSupport = false;\n+                    break;\n+                default:\n+                    throw new UserError(\n+                            \"Unsupported builder framework in -AdisableBuilderFrameworkSupports: \"\n+                                    + framework);\n+            }\n+        }\n+        if (enableAutoValueSupport) {\n+            builderFrameworkSupports.add(new AutoValueSupport(this));\n+        }\n+        if (enableLombokSupport) {\n+            builderFrameworkSupports.add(new LombokSupport(this));\n+        }\n+    }\n+\n+    @Override\n+    protected TreeAnnotator createTreeAnnotator() {\n+        return new ListTreeAnnotator(\n+                super.createTreeAnnotator(), new CalledMethodsTreeAnnotator(this));\n+    }\n+\n+    @Override\n+    protected TypeAnnotator createTypeAnnotator() {\n+        return new ListTypeAnnotator(\n+                super.createTypeAnnotator(), new CalledMethodsTypeAnnotator(this));\n+    }\n+\n+    @Override\n+    public boolean returnsThis(MethodInvocationTree tree) {\n+        return super.returnsThis(tree) || hasOldReturnsReceiverAnnotation(tree);\n+    }\n+\n+    /**\n+     * Continue to trust but not check the old {@link\n+     * org.checkerframework.checker.builder.qual.ReturnsReceiver} annotation, for backwards\n+     * compatibility.\n+     *\n+     * @param tree the method invocation whose invoked method is to be checked\n+     * @return true if the declaration of the invoked method has an obsolete ReturnsReceiver\n+     *     declaration annotation\n+     */\n+    private boolean hasOldReturnsReceiverAnnotation(MethodInvocationTree tree) {\n+        return this.getDeclAnnotation(\n+                        TreeUtils.elementFromUse(tree),\n+                        org.checkerframework.checker.builder.qual.ReturnsReceiver.class)\n+                != null;\n+    }\n+\n+    /**\n+     * Given a tree, returns the name of the method that the tree should be considered as calling.\n+     * Returns \"withOwners\" if the call sets an \"owner\", \"owner-alias\", or \"owner-id\" filter.\n+     * Returns \"withImageIds\" if the call sets an \"image-ids\" filter.\n+     *\n+     * <p>Package-private to permit calls from {@link CalledMethodsTransfer}.\n+     *\n+     * @param methodName the name of the method to adjust\n+     * @param tree the invocation of the method\n+     * @return either the first argument, or \"withOwners\" or \"withImageIds\" if the tree is an\n+     *     equivalent filter addition\n+     */\n+    String adjustMethodNameUsingValueChecker(\n+            final String methodName, final MethodInvocationTree tree) {\n+        if (!useValueChecker) {\n+            return methodName;\n+        }\n+\n+        ExecutableElement invokedMethod = TreeUtils.elementFromUse(tree);\n+        if (!\"com.amazonaws.services.ec2.model.DescribeImagesRequest\"\n+                .equals(ElementUtils.enclosingClass(invokedMethod).getQualifiedName().toString())) {\n+            return methodName;\n+        }\n+\n+        if (\"withFilters\".equals(methodName) || \"setFilters\".equals(methodName)) {\n+            ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\n+            for (Tree filterTree : tree.getArguments()) {\n+                String adjustedMethodName = filterTreeToMethodName(filterTree, valueATF);\n+                if (adjustedMethodName != null) {\n+                    return adjustedMethodName;\n+                }\n+            }\n+        }\n+        return methodName;\n+    }\n+\n+    /**\n+     * Determine the name of the method in DescribeImagesRequest that is equivalent to the Filter in\n+     * the given tree.\n+     *\n+     * <p>Returns null unless the argument is one of the following:\n+     *\n+     * <ul>\n+     *   <li>a constructor invocation of the Filter constructor whose first argument is the name,\n+     *       such as {@code new Filter(\"owner\").*}, or\n+     *   <li>a call to the withName method, such as {@code new Filter().*.withName(\"owner\").*}.\n+     * </ul>\n+     *\n+     * In those cases, it returns either the argument to the constructor or the argument to the last\n+     * invocation of withName (\"owner\" in both of the above examples).\n+     *\n+     * @param filterTree the tree that represents the filter (an argument to the withFilters or\n+     *     setFilters method)\n+     * @param valueATF the type factory from the Value Checker\n+     * @return the adjusted method name, or null if the method name should not be adjusted\n+     */\n+    private @Nullable String filterTreeToMethodName(\n+            Tree filterTree, ValueAnnotatedTypeFactory valueATF) {\n+        while (filterTree != null && filterTree.getKind() == Tree.Kind.METHOD_INVOCATION) {\n+\n+            MethodInvocationTree filterTreeAsMethodInvocation = (MethodInvocationTree) filterTree;\n+            String filterMethodName = TreeUtils.methodName(filterTreeAsMethodInvocation).toString();\n+            if (\"withName\".equals(filterMethodName)\n+                    && filterTreeAsMethodInvocation.getArguments().size() >= 1) {\n+                Tree withNameArgTree = filterTreeAsMethodInvocation.getArguments().get(0);\n+                String withNameArg =\n+                        ValueCheckerUtils.getExactStringValue(withNameArgTree, valueATF);\n+                return filterKindToMethodName(withNameArg);\n+            }\n+\n+            if (TreeUtils.isMethodInvocation(\n+                    filterTree, collectionsSingletonList, getProcessingEnv())) {\n+                // Descend into a call to Collections.singletonList()", "originalCommit": "8019315f4ee06d46ecb0478d8a3e47090717034f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f9adb03c02ef798363225861ac03f2c3c9b5fea", "url": "https://github.com/typetools/checker-framework/commit/9f9adb03c02ef798363225861ac03f2c3c9b5fea", "message": "Improve manual", "committedDate": "2020-09-18T13:41:19Z", "type": "commit"}, {"oid": "f1238d4714902c59ab277552634cfb007db14b67", "url": "https://github.com/typetools/checker-framework/commit/f1238d4714902c59ab277552634cfb007db14b67", "message": "Merge branch 'master' of github.com:typetools/checker-framework into object-construction-checker", "committedDate": "2020-09-25T19:23:48Z", "type": "commit"}, {"oid": "f9fd8eda1f417e1bdc8476cf62b68fae53776b62", "url": "https://github.com/typetools/checker-framework/commit/f9fd8eda1f417e1bdc8476cf62b68fae53776b62", "message": "address PR comments", "committedDate": "2020-09-25T19:59:04Z", "type": "commit"}, {"oid": "3c34bc762d514f23333f94c0e8d80980ab4f0363", "url": "https://github.com/typetools/checker-framework/commit/3c34bc762d514f23333f94c0e8d80980ab4f0363", "message": "Tweak changelog", "committedDate": "2020-09-28T03:56:52Z", "type": "commit"}, {"oid": "112e666e543f4af6431dc7b3b528ca2819b17ffa", "url": "https://github.com/typetools/checker-framework/commit/112e666e543f4af6431dc7b3b528ca2819b17ffa", "message": "Merge branch 'object-construction-checker' of github.com:kelloggm/checker-framework into object-construction-checker", "committedDate": "2020-09-28T03:57:00Z", "type": "commit"}, {"oid": "4c59408ca444b88d570df846d31da6a8d829b3cb", "url": "https://github.com/typetools/checker-framework/commit/4c59408ca444b88d570df846d31da6a8d829b3cb", "message": "adapt to new naming convention in test checkers", "committedDate": "2020-09-28T16:23:00Z", "type": "commit"}, {"oid": "7f14607d94011f8c2ca75dc25220d40c99df091f", "url": "https://github.com/typetools/checker-framework/commit/7f14607d94011f8c2ca75dc25220d40c99df091f", "message": "Tweaks", "committedDate": "2020-09-28T17:51:51Z", "type": "commit"}, {"oid": "4b25f537d2024d5e63a6569900f5e61738ccf7f3", "url": "https://github.com/typetools/checker-framework/commit/4b25f537d2024d5e63a6569900f5e61738ccf7f3", "message": "Fix logic", "committedDate": "2020-09-28T18:03:06Z", "type": "commit"}, {"oid": "17e1995fd97c69205c15d3c250fa17464e65108b", "url": "https://github.com/typetools/checker-framework/commit/17e1995fd97c69205c15d3c250fa17464e65108b", "message": "Merge ../checker-framework-branch-master into object-construction-checker", "committedDate": "2020-09-28T18:03:15Z", "type": "commit"}]}