{"pr_number": 6146, "pr_title": "Add support for site modifiers", "pr_createdAt": "2020-08-27T10:41:36Z", "pr_url": "https://github.com/zaproxy/zaproxy/pull/6146", "timeline": [{"oid": "93960f15c1d7e2016bb68e94b50ec347accb8c33", "url": "https://github.com/zaproxy/zaproxy/commit/93960f15c1d7e2016bb68e94b50ec347accb8c33", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-08-27T11:07:20Z", "type": "forcePushed"}, {"oid": "77dbd016f196751c50148cd4f630301579ef9374", "url": "https://github.com/zaproxy/zaproxy/commit/77dbd016f196751c50148cd4f630301579ef9374", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-08-27T11:55:53Z", "type": "forcePushed"}, {"oid": "c3c552d4322924a6f5270aada3262efd99837134", "url": "https://github.com/zaproxy/zaproxy/commit/c3c552d4322924a6f5270aada3262efd99837134", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-08-27T15:36:00Z", "type": "forcePushed"}, {"oid": "89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "url": "https://github.com/zaproxy/zaproxy/commit/89fb137b62dd2fb6b2e0ea8508d6b05b31248817", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-08-27T16:01:28Z", "type": "forcePushed"}, {"oid": "a86da660bf443e89fbce941e38aaef926c54801d", "url": "https://github.com/zaproxy/zaproxy/commit/a86da660bf443e89fbce941e38aaef926c54801d", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-01T16:23:11Z", "type": "forcePushed"}, {"oid": "720af16d68195f8065318c2e50a36771c6e7b9e6", "url": "https://github.com/zaproxy/zaproxy/commit/720af16d68195f8065318c2e50a36771c6e7b9e6", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-02T09:03:30Z", "type": "forcePushed"}, {"oid": "f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "url": "https://github.com/zaproxy/zaproxy/commit/f39a9f1df38ef6d8eab1be677a27cab9531faa4e", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-02T09:38:11Z", "type": "forcePushed"}, {"oid": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "url": "https://github.com/zaproxy/zaproxy/commit/3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-02T12:53:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NTc1MA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485485750", "bodyText": "UI \u2192 e.g. Sites map, not just about the UI. (Same comment for following UI usage and elsewhere.)", "author": "thc202", "createdAt": "2020-09-09T09:50:37Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    private String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI.", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NDIyNw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485584227", "bodyText": "This should be replaced with a call to the session, it's duplicating existing logic.", "author": "thc202", "createdAt": "2020-09-09T12:49:35Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantCustom.java", "diffHunk": "@@ -228,6 +231,35 @@ public String setEscapedParameter(\n         return setParameter(msg, originalPair, param, value, true);\n     }\n \n+    /**\n+     * The standard name given to nodes in the sites tree for the given parameters\n+     *\n+     * @param nodeName the name of the node, typically the last element of the path\n+     * @param msg the message\n+     * @param params the url and post parameters for the given message\n+     * @return the name to be used in the GUI\n+     */\n+    public String getStandardLeafName(\n+            String nodeName, HttpMessage msg, List<NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        String method = msg.getRequestHeader().getMethod();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(Session.getParamDisplayString(params, NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            String contentType = msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE);\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(Session.getParamDisplayString(params, NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NTY3OQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485585679", "bodyText": "Should this be in the Model(?) instead? Being in the Session (and as an instance variable) means that the factory is \"reset\" each time a new session is created, losing the hooked variants.", "author": "thc202", "createdAt": "2020-09-09T12:51:38Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -155,6 +161,8 @@\n \n     private ParameterParser defaultParamParser = new StandardParameterParser();\n \n+    private VariantFactory variantFactory = new VariantFactory();", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4Njk0OQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485586949", "bodyText": "This is not used anymore, remove?", "author": "thc202", "createdAt": "2020-09-09T12:53:32Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/NameValuePair.java", "diffHunk": "@@ -96,6 +99,23 @@ public int getType() {\n         return targetType;\n     }\n \n+    public boolean isType(HtmlParameter.Type hpType) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzM1Ng==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587356", "bodyText": "Needs to be removed.", "author": "thc202", "createdAt": "2020-09-09T12:54:11Z", "path": "zap/src/main/java/org/parosproxy/paros/network/HtmlParameter.java", "diffHunk": "@@ -118,7 +118,6 @@ public String getValue() {\n      * @throws IllegalArgumentException if the given parameter is {@code null}.", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzQ4NA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587484", "bodyText": "Still should decide which one is \"bigger\", shouldn't be both. Worth adding tests.", "author": "thc202", "createdAt": "2020-09-09T12:54:21Z", "path": "zap/src/main/java/org/parosproxy/paros/network/HtmlParameter.java", "diffHunk": "@@ -159,7 +158,12 @@ public int compareTo(HtmlParameter o) {\n         }\n         if (result == 0) {\n             // Same type and name\n-            result = this.value.compareTo(o.getValue());\n+            if (this.value != null && o.getValue() != null) {\n+                result = this.value.compareTo(o.getValue());\n+            } else if (this.value != null || o.getValue() != null) {\n+                // They can't both be null due to previous test\n+                return 1;", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4NzkyNA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485587924", "bodyText": "Still should decide which one is \"smaller\". Worth adding tests.", "author": "thc202", "createdAt": "2020-09-09T12:55:00Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/NameValuePair.java", "diffHunk": "@@ -186,4 +206,36 @@ public String toString() {\n         strBuilder.append(']');\n         return strBuilder.toString();\n     }\n+\n+    @Override\n+    public int compareTo(NameValuePair nvp) {\n+        if (nvp == null) {\n+            return -1;\n+        }\n+        if (nvp.targetType != targetType) {\n+            return nvp.targetType - targetType;\n+        }\n+        if (nvp.position != position) {\n+            return nvp.position - position;\n+        }\n+        int cmp;\n+        if (nvp.name != null && name != null) {\n+            cmp = nvp.name.compareTo(name);\n+            if (cmp != 0) {\n+                return cmp;\n+            }\n+        } else if (nvp.name == null || name == null) {\n+            // They can't both be null due to previous test\n+            return -1;", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU4ODA5Nw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485588097", "bodyText": "Should not need the abstract modifier.", "author": "thc202", "createdAt": "2020-09-09T12:55:14Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/Variant.java", "diffHunk": "@@ -23,12 +23,14 @@\n // ZAP: 2016/05/04 Add JavaDoc to getParamList()\n // ZAP: 2019/06/01 Normalise line endings.\n // ZAP: 2019/06/05 Normalise format/style.\n+// ZAP: 2020/08/27 Added default methods for modifying the Sites tree\n package org.parosproxy.paros.core.scanner;\n \n import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n import org.parosproxy.paros.network.HttpMessage;\n \n-public interface Variant {\n+public abstract interface Variant {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDU2OA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590568", "bodyText": "This could be moved to a ZAP package, most (if not all) the code is new (compared to original Paros code). The embed ZAP comments could also be removed.", "author": "thc202", "createdAt": "2020-09-09T12:59:03Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDc1OQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590759", "bodyText": "These are not actually being used for scanning, was that on purpose? That needs to be documented (and tested) if it was.", "author": "thc202", "createdAt": "2020-09-09T12:59:20Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjI4NTc5Nw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486285797", "bodyText": "Ugh, no - was kind of the point of the hook changes :P", "author": "psiinon", "createdAt": "2020-09-10T12:11:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDgwMA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590800", "bodyText": "createVariants to be clear that's creating new instances.\nAbstractAppParamPlugin \u2192 HttpMessage, to remove the middle man.", "author": "thc202", "createdAt": "2020-09-09T12:59:25Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MDk3MQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485590971", "bodyText": "This could be removed (ZAP shouldn't care about RFC limitations, servers should and why ZAP should test anyway).", "author": "thc202", "createdAt": "2020-09-09T12:59:41Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTA3MQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591071", "bodyText": "This could be added as a custom variant by the ExtensionScript (assuming that the custom variants are going to be used for scanning).", "author": "thc202", "createdAt": "2020-09-09T12:59:50Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzOTI5NA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486439294", "bodyText": "Even though none of the existing built in rules implement this I was leaving the door open for them to do so, in which case we'd need the code here still?", "author": "psiinon", "createdAt": "2020-09-10T15:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTA3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTI5MA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591290", "bodyText": "UndeclaredThrowableException should be caught separately to check if the cause is of NoSuchMethodException for the method being called, not all script engines respect the default methods (might not be even aware of them) which would cause the script to be disabled (even if correct).\nWorth adding tests to verify the behaviour.", "author": "thc202", "createdAt": "2020-09-09T13:00:07Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        name =\n+                                vs.getLeafName(\n+                                        new VariantCustom(script, getExtension()), nodeName, msg);\n+                        if (name != null) {\n+                            return name;\n+                        }\n+                    } catch (Exception e) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTMyNg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591326", "bodyText": "Same here regarding the handling of UndeclaredThrowableException.", "author": "thc202", "createdAt": "2020-09-09T13:00:10Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = null;\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        name =\n+                                vs.getLeafName(\n+                                        new VariantCustom(script, getExtension()), nodeName, msg);\n+                        if (name != null) {\n+                            return name;\n+                        }\n+                    } catch (Exception e) {\n+                        getExtension().handleScriptException(script, e);\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (Variant variant : this.customVariants) {\n+            name = variant.getLeafName(nodeName, msg);\n+            if (name != null) {\n+                return name;\n+            }\n+        }\n+        // Note that none of the built-in variants implement this method.\n+        // If any are changed to do so in the future then then need to be called here.\n+\n+        return null;\n+    }\n+\n+    public List<String> getTreePath(HttpMessage msg) throws URIException {\n+        List<String> list = null;\n+\n+        if (getExtension() != null) {\n+            // List the scripts and create as many custom variants as the scripts\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        VariantScript vs = getExtension().getInterface(script, VariantScript.class);\n+                        list = vs.getTreePath(new VariantCustom(script, getExtension()), msg);\n+                        if (list != null) {\n+                            return list;\n+                        }\n+                    } catch (Exception e) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MTgxMw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485591813", "bodyText": "to the {@code Session}'s ...?", "author": "thc202", "createdAt": "2020-09-09T13:00:54Z", "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionHook.java", "diffHunk": "@@ -506,4 +518,40 @@ public void addHttpSenderListener(HttpSenderListener httpSenderListener) {\n         }\n         return Collections.unmodifiableList(httpSenderListeners);\n     }\n+\n+    /**\n+     * Adds the given {@code variant} to the extension hook, to be later added to the {@link\n+     * org.parosproxy.paros.model.Session Session}.\n+     *\n+     * <p>By default, the {@code Variant}s added to this extension hook are removed from the {@code\n+     * Session} when the extension is unloaded.\n+     *\n+     * @param variant the Variant that will be added to the {@code VariantFactory}", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5MjAxNg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485592016", "bodyText": "Can be removed.", "author": "thc202", "createdAt": "2020-09-09T13:01:13Z", "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionLoader.java", "diffHunk": "@@ -1514,6 +1531,18 @@ public void removeExtension(Extension extension) {\n             }\n         }\n \n+        for (Variant variant : hook.getVariants()) {\n+            try {\n+                model.getSession().getVariantFactory().removeVariant(variant);\n+                ;", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NzYxOA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485597618", "bodyText": "IMO the factory should be responsible just for the creation of the variants, the getLeafName/getTreePath should be called by interested parties on the created variants (e.g. one can ask just for the custom variants).", "author": "thc202", "createdAt": "2020-09-09T13:09:26Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/VariantFactory.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URIException;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.ascan.ExtensionActiveScan;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+\n+    private ExtensionScript extension;\n+    private List<Variant> customVariants = new ArrayList<Variant>();\n+\n+    public void addVariant(Variant variant) {\n+        this.customVariants.add(variant);\n+    }\n+\n+    public void removeVariant(Variant variant) {\n+        this.customVariants.remove(variant);\n+    }\n+\n+    public List<Variant> getAllVariants(ScannerParam scanOptions, AbstractAppParamPlugin plugin) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            // ZAP: To handle parameters in OData urls\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            // ZAP: To handle Multipart Form-Data POST requests\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            // ZAP: To handle XML based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            // ZAP: To handle JSON based POST requests\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            // ZAP: To handle GWT Serialized POST requests\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            // ZAP: To handle Direct Web Remoting (DWR) POST requests\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                HttpMessage message = plugin.getBaseMsg();\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        // Currently usual plugins seems not\n+        // suitable to cookie vulnerabilities\n+        // 'cause the character RFC limitation\n+        // is it useful?\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public String getLeafName(String nodeName, HttpMessage msg) {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDU1Mg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485600552", "bodyText": "Could the nulls be replaced with empty string and empty list, those are already invalid, right? (If not we should have tests showing the expected behaviour.)", "author": "thc202", "createdAt": "2020-09-09T13:13:49Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/Variant.java", "diffHunk": "@@ -44,4 +46,39 @@ public String setParameter(\n \n     public String setEscapedParameter(\n             HttpMessage msg, NameValuePair originalPair, String param, String value);\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI. Returning null is\n+     * taken to mean use the default name. This is currently the last element of the path (given in\n+     * {@code nodeName}) followed by the url parameter names in brackets (if any) followed by the\n+     * form parameter names in brackets (if any).\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     */\n+    default String getLeafName(String nodeName, HttpMessage msg) {\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the tree path elements for the given {@code message}. Returning null is taken to mean\n+     * use the default methods for obtaining tree path elements. This will determine the position of\n+     * this message in the sites tree.\n+     *\n+     * <p>By default the elements are returned for the following URL are:\n+     *\n+     * <ul>\n+     *   <li><i>http://example.org/path/to/element?aa=bb&cc==dd</i> : [\"path\", \"to\", \"element\"]\n+     *   <li><i>http://example.org/path/to/element</i> : [\"path\", \"to\", \"element\"]\n+     *   <li><i>http://example.org/path/to/</i> : [\"path\", \"to\"]\n+     *   <li><i>http://example.org/path/to</i> : [\"path\", \"to\"]\n+     * </ul>\n+     *\n+     * @param msg\n+     * @return a {@code List} containing the tree path elements\n+     * @throws URIException\n+     */\n+    default List<String> getTreePath(HttpMessage msg) throws URIException {\n+        return null;", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyNzI5OQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486427299", "bodyText": "Agreed on IRC that this probably wasnt worth doing.", "author": "psiinon", "createdAt": "2020-09-10T15:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMDkzMA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485600930", "bodyText": "This should be private.", "author": "thc202", "createdAt": "2020-09-09T13:14:24Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    private String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the UI.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the UI\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the UI.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the UI\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the UI\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    public static String getParamDisplayString(", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwMTU2NQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485601565", "bodyText": "Revert.", "author": "thc202", "createdAt": "2020-09-09T13:15:22Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1706,10 +1847,13 @@ public ParameterParser getFormParamParser(String url) {\n     }\n \n     public List<String> getTreePath(HttpMessage msg) throws URIException {\n+        List<String> params = variantFactory.getTreePath(msg);\n+        if (params != null) {\n+            return params;\n+        }\n         URI uri = msg.getRequestHeader().getURI();\n         return this.getUrlParamParser(uri.toString()).getTreePath(msg);\n     }\n-", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNDY5NQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485604695", "bodyText": "There's a typo in variants.", "author": "thc202", "createdAt": "2020-09-09T13:19:55Z", "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVarients() {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNjY1Mw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485606653", "bodyText": "This could be moved to the when, that's part of the behaviour being tested.", "author": "thc202", "createdAt": "2020-09-09T13:22:45Z", "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.core.scanner;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVarients() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = new ScannerParam();\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage();\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+        // Then\n+        assertThat(variants.size(), is(equalTo(10)));\n+        assertThat(variants.get(0).getClass(), is(equalTo(VariantURLQuery.class)));\n+        assertThat(variants.get(1).getClass(), is(equalTo(VariantODataIdQuery.class)));\n+        assertThat(variants.get(2).getClass(), is(equalTo(VariantODataFilterQuery.class)));\n+        assertThat(variants.get(3).getClass(), is(equalTo(VariantDdnPath.class)));\n+        assertThat(variants.get(4).getClass(), is(equalTo(VariantFormQuery.class)));\n+        assertThat(variants.get(5).getClass(), is(equalTo(VariantMultipartFormParameters.class)));\n+        assertThat(variants.get(6).getClass(), is(equalTo(VariantXMLQuery.class)));\n+        assertThat(variants.get(7).getClass(), is(equalTo(VariantJSONQuery.class)));\n+        assertThat(variants.get(8).getClass(), is(equalTo(VariantGWTQuery.class)));\n+        assertThat(variants.get(9).getClass(), is(equalTo(VariantDirectWebRemotingQuery.class)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNoVarientsWhenUnset() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = Mockito.mock(ScannerParam.class, withSettings().lenient());\n+        Mockito.when(scanOptions.getConfig()).thenReturn(new ZapXmlConfiguration());\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage();\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+\n+        scanOptions.setTargetParamsInjectable(0);\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+\n+        // Then\n+        assertThat(variants.size(), is(equalTo(0)));\n+    }\n+\n+    @Test\n+    public void shouldReturnAllVarientsWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = Mockito.mock(ScannerParam.class, withSettings().lenient());\n+        Mockito.when(scanOptions.getConfig()).thenReturn(new ZapXmlConfiguration());\n+        Mockito.when(scanOptions.getTargetParamsInjectable()).thenReturn(-1);\n+        Mockito.when(scanOptions.getTargetParamsEnabledRPC()).thenReturn(-1);\n+        AbstractAppParamPlugin mockedPlugin =\n+                Mockito.mock(AbstractAppParamPlugin.class, withSettings().lenient());\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        Mockito.when(mockedPlugin.getBaseMsg()).thenReturn(message);\n+\n+        // When\n+        List<Variant> variants = factory.getAllVariants(scanOptions, mockedPlugin);\n+\n+        // Then\n+        assertThat(variants.size(), is(equalTo(13)));\n+        assertThat(variants.get(0).getClass(), is(equalTo(VariantURLQuery.class)));\n+        assertThat(variants.get(1).getClass(), is(equalTo(VariantODataIdQuery.class)));\n+        assertThat(variants.get(2).getClass(), is(equalTo(VariantODataFilterQuery.class)));\n+        assertThat(variants.get(3).getClass(), is(equalTo(VariantFormQuery.class)));\n+        assertThat(variants.get(4).getClass(), is(equalTo(VariantMultipartFormParameters.class)));\n+        assertThat(variants.get(5).getClass(), is(equalTo(VariantXMLQuery.class)));\n+        assertThat(variants.get(6).getClass(), is(equalTo(VariantJSONQuery.class)));\n+        assertThat(variants.get(7).getClass(), is(equalTo(VariantGWTQuery.class)));\n+        assertThat(variants.get(8).getClass(), is(equalTo(VariantDirectWebRemotingQuery.class)));\n+        assertThat(variants.get(9).getClass(), is(equalTo(VariantHeader.class)));\n+        assertThat(variants.get(10).getClass(), is(equalTo(VariantURLPath.class)));\n+        assertThat(variants.get(11).getClass(), is(equalTo(VariantCookie.class)));\n+        assertThat(variants.get(12).getClass(), is(equalTo(VariantUserDefined.class)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNullLeafNameByDefault() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+\n+        // When\n+        String leafName = factory.getLeafName(\"path\", message);\n+\n+        // Then\n+        assertThat(leafName, is(equalTo(null)));\n+    }\n+\n+    @Test\n+    public void shouldReturnLeafNameWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        String expectedLeafName = \"Test\";\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public String getLeafName(String nodeName, HttpMessage msg) {\n+                        return expectedLeafName;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+\n+        // When\n+        String actualLeafName = factory.getLeafName(\"path\", message);\n+\n+        // Then\n+        assertThat(actualLeafName, is(equalTo(expectedLeafName)));\n+    }\n+\n+    @Test\n+    public void shouldReturnNullTreePathByDefault() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+\n+        // When\n+        List<String> treePath = factory.getTreePath(message);\n+\n+        // Then\n+        assertThat(treePath, is(equalTo(null)));\n+    }\n+\n+    @Test\n+    public void shouldReturnTreePathWhenSet() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        List<String> expectedTreePath = new ArrayList<>();\n+        expectedTreePath.add(\"Path1\");\n+        expectedTreePath.add(\"Path2\");\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public List<String> getTreePath(HttpMessage msg) {\n+                        return expectedTreePath;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+\n+        // When\n+        List<String> actualTreePath = factory.getTreePath(message);\n+\n+        // Then\n+        assertThat(actualTreePath.size(), is(equalTo(expectedTreePath.size())));\n+        for (int i = 0; i < actualTreePath.size(); i++) {\n+            assertThat(actualTreePath.get(i), is(equalTo(expectedTreePath.get(i))));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldReturnNullTreePathWhenVariantRemoved() throws Exception {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        HttpMessage message = new HttpMessage(new URI(\"https://www.example.com/path?query\", true));\n+        List<String> expectedTreePath = new ArrayList<>();\n+        expectedTreePath.add(\"Path1\");\n+        expectedTreePath.add(\"Path2\");\n+        Variant variant =\n+                new Variant() {\n+\n+                    @Override\n+                    public List<String> getTreePath(HttpMessage msg) {\n+                        return expectedTreePath;\n+                    }\n+\n+                    @Override\n+                    public void setMessage(HttpMessage msg) {}\n+\n+                    @Override\n+                    public List<NameValuePair> getParamList() {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public String setEscapedParameter(\n+                            HttpMessage msg,\n+                            NameValuePair originalPair,\n+                            String param,\n+                            String value) {\n+                        return null;\n+                    }\n+                };\n+        factory.addVariant(variant);\n+        factory.removeVariant(variant);", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwNzgyMA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r485607820", "bodyText": "And", "author": "thc202", "createdAt": "2020-09-09T13:24:20Z", "path": "zap/src/test/java/org/parosproxy/paros/model/SessionUnitTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.model;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.network.HttpHeader;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.I18N;\n+\n+public class SessionUnitTest {\n+\n+    private Session session;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        session = new Session(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithOneParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path?a=b\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithTwoParams() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path?c=d&a=b\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(c,a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnGetLeafNameWithTruncatedParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri =\n+                new URI(\n+                        \"https://www.example.com/path?averylongvariablenamewhichshouldbetruncated=b\",\n+                        true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"GET\", null);\n+        // Then\n+        assertThat(leafName, is(equalTo(\"GET:path(averylongvariablenamewhichshouldbetrunca)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithOnePostParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path\", true);\n+        // When\n+        String leafName = session.getLeafName(nodeName, uri, \"POST\", \"a=b\");\n+        // Then\n+        assertThat(leafName, is(equalTo(\"POST:path(a)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithTruncatedParam() throws Exception {\n+        // Given\n+        String nodeName = \"path\";\n+        URI uri = new URI(\"https://www.example.com/path\", true);\n+        // When\n+        String leafName =\n+                session.getLeafName(\n+                        nodeName, uri, \"POST\", \"averylongvariablenamewhichshouldbetruncated=b\");\n+        // Then\n+        assertThat(leafName, is(equalTo(\"POST:path(averylongvariablenamewhichshouldbetrunca)\")));\n+    }\n+\n+    @Test\n+    public void shouldReturnPostLeafNameWithOnePostandOneUrlParam() throws Exception {", "originalCommit": "3a2ea3cbab692d496f09562ef9dc8d4f5923a47a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "294990246282d2956a4856240fb949bd884f37d9", "url": "https://github.com/zaproxy/zaproxy/commit/294990246282d2956a4856240fb949bd884f37d9", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T08:14:22Z", "type": "forcePushed"}, {"oid": "1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "url": "https://github.com/zaproxy/zaproxy/commit/1c0a5c438b2baf8ae1d95f5f05f05b3e79b05fec", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T10:03:51Z", "type": "forcePushed"}, {"oid": "44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "url": "https://github.com/zaproxy/zaproxy/commit/44d00e177b0f9b6b2b07741b3fc42a59fe8d1787", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T10:29:04Z", "type": "forcePushed"}, {"oid": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "url": "https://github.com/zaproxy/zaproxy/commit/c1e36444570d5ca9522d424798fcf5bd911ea1cf", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T13:44:07Z", "type": "forcePushed"}, {"oid": "70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "url": "https://github.com/zaproxy/zaproxy/commit/70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T14:07:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2OTAwNg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486369006", "bodyText": "If done with a ternary then no intermediate declare/storage is necessary. Not a huge difference, but simpler and shorter...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String result = \"\";\n          \n          \n            \n                    if (sb.length() > 0) {\n          \n          \n            \n                        result = sb.insert(0, '(').append(')').toString();\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return result;\n          \n          \n            \n                    return sb.length() > 0 ? sb.insert(0, '(').append(')').toString() : \"\";", "author": "kingthorin", "createdAt": "2020-09-10T14:02:34Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    public String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the Site Map\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the Site Map\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the Site Map\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    private static String getParamDisplayString(\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> list, int type) {\n+        StringBuilder sb = new StringBuilder();\n+        list.stream()\n+                .sorted()\n+                .filter(entry -> entry.getType() == type)\n+                .forEach(\n+                        entry -> {\n+                            String name = entry.getName();\n+                            if (name != null) {\n+                                if (sb.length() > 0) {\n+                                    sb.append(',');\n+                                }\n+                                if (name.length() > 40) {\n+                                    // Truncate\n+                                    name = name.substring(0, 40);\n+                                }\n+                                sb.append(name);\n+                            }\n+                        });\n+        String result = \"\";\n+        if (sb.length() > 0) {\n+            result = sb.insert(0, '(').append(')').toString();\n+        }\n+\n+        return result;", "originalCommit": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM2OTc0Ng==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486369746", "bodyText": "I think we have a utility function for doing this that also inserts an ellipsis ... so that it's more obvious that it was intentionally truncated?", "author": "kingthorin", "createdAt": "2020-09-10T14:03:37Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Session.java", "diffHunk": "@@ -1636,6 +1648,135 @@ public ParameterParser getFormParamParser(String url) {\n         }\n     }\n \n+    public String getLeafName(\n+            String nodeName,\n+            String method,\n+            String contentType,\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> params) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(method);\n+        sb.append(\":\");\n+        sb.append(nodeName);\n+        sb.append(\n+                getParamDisplayString(\n+                        params, org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING));\n+\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n+                sb.append(\"(multipart/form-data)\");\n+            } else {\n+                sb.append(\n+                        getParamDisplayString(\n+                                params,\n+                                org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given {@code msg} in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param msg the message\n+     * @return the name of the node to be used in the Site Map\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, HttpMessage msg) {\n+        String name = variantFactory.getLeafName(nodeName, msg);\n+        if (name != null) {\n+            return name;\n+        }\n+\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                convertNVP(\n+                        model.getSession().getParameters(msg, Type.url),\n+                        org.parosproxy.paros.core.scanner.NameValuePair.TYPE_QUERY_STRING);\n+        if (msg.getRequestHeader().getMethod().equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            params.addAll(\n+                    convertNVP(\n+                            model.getSession().getParameters(msg, Type.form),\n+                            org.parosproxy.paros.core.scanner.NameValuePair.TYPE_POST_DATA));\n+        }\n+\n+        return getLeafName(\n+                nodeName,\n+                msg.getRequestHeader().getMethod(),\n+                msg.getRequestHeader().getHeader(HttpHeader.CONTENT_TYPE),\n+                params);\n+    }\n+\n+    /**\n+     * Gets the name of the node to be used for the given parameters in the Site Map.\n+     *\n+     * @param nodeName the last element of the path\n+     * @param uri\n+     * @param method\n+     * @param postData\n+     * @return the name of the node to be used in the Site Map\n+     * @throws HttpMalformedHeaderException\n+     * @since TODO add version\n+     */\n+    public String getLeafName(String nodeName, URI uri, String method, String postData)\n+            throws HttpMalformedHeaderException {\n+        HttpMessage msg = new HttpMessage(uri);\n+        msg.getRequestHeader().setMethod(method);\n+        if (method.equalsIgnoreCase(HttpRequestHeader.POST)) {\n+            msg.getRequestBody().setBody(postData);\n+            msg.getRequestHeader().setContentLength(msg.getRequestBody().length());\n+        }\n+        return getLeafName(nodeName, msg);\n+    }\n+\n+    private List<org.parosproxy.paros.core.scanner.NameValuePair> convertNVP(\n+            List<NameValuePair> nvpList, int type) {\n+        List<org.parosproxy.paros.core.scanner.NameValuePair> params =\n+                new ArrayList<org.parosproxy.paros.core.scanner.NameValuePair>();\n+        for (NameValuePair nvp : nvpList) {\n+            params.add(\n+                    new org.parosproxy.paros.core.scanner.NameValuePair(\n+                            type, nvp.getName(), nvp.getValue(), -1));\n+        }\n+        return params;\n+    }\n+\n+    /**\n+     * Returns the names of the parameters in a form suitable to display in the Site Map\n+     *\n+     * @param list the full set of parameters\n+     * @param type the type of parameters to be included\n+     * @return the names of the given parameters\n+     * @since TODO add version\n+     */\n+    private static String getParamDisplayString(\n+            List<org.parosproxy.paros.core.scanner.NameValuePair> list, int type) {\n+        StringBuilder sb = new StringBuilder();\n+        list.stream()\n+                .sorted()\n+                .filter(entry -> entry.getType() == type)\n+                .forEach(\n+                        entry -> {\n+                            String name = entry.getName();\n+                            if (name != null) {\n+                                if (sb.length() > 0) {\n+                                    sb.append(',');\n+                                }\n+                                if (name.length() > 40) {\n+                                    // Truncate\n+                                    name = name.substring(0, 40);", "originalCommit": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM3MTAwOQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486371009", "bodyText": "Should this be at the bottom of the block? (Just for consistency I guess)", "author": "kingthorin", "createdAt": "2020-09-10T14:05:09Z", "path": "zap/src/main/java/org/zaproxy/zap/model/SessionStructure.java", "diffHunk": "@@ -82,6 +82,36 @@ public static StructuralNode addPath(\n         }\n     }\n \n+    /**\n+     * @since TODO add version", "originalCommit": "c1e36444570d5ca9522d424798fcf5bd911ea1cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjM4Nzg4Mg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r486387882", "bodyText": "?", "author": "kingthorin", "createdAt": "2020-09-10T14:26:47Z", "path": "zap/src/test/java/org/parosproxy/paros/core/scanner/NameValuePairUnitTest.java", "diffHunk": "@@ -133,7 +133,6 @@ public void shouldBeEqualToDifferentNameValuePairWithSameContents() {\n \n     @Test\n     public void shouldBeEqualToDifferentNameValuePairWithNullNames() {\n-        // Given", "originalCommit": "70e20bcda39ff5adc1bddb6ca7445f18c43ef618", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cbaf8783e0802c821e45635fb8af1ca3bac385d6", "url": "https://github.com/zaproxy/zaproxy/commit/cbaf8783e0802c821e45635fb8af1ca3bac385d6", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T15:27:51Z", "type": "forcePushed"}, {"oid": "ffe589f1a63948a0507267bdff995d7a2ba61fea", "url": "https://github.com/zaproxy/zaproxy/commit/ffe589f1a63948a0507267bdff995d7a2ba61fea", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T16:12:17Z", "type": "forcePushed"}, {"oid": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "url": "https://github.com/zaproxy/zaproxy/commit/86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-10T16:15:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMzc4NA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487903784", "bodyText": "This change should no longer be needed.", "author": "thc202", "createdAt": "2020-09-14T13:17:03Z", "path": "zap/src/main/java/org/parosproxy/paros/core/scanner/AbstractPlugin.java", "diffHunk": "@@ -181,7 +182,7 @@ protected HttpMessage getNewMsg() {\n      *\n      * @return The base HttpMessage with request/response.\n      */\n-    protected HttpMessage getBaseMsg() {\n+    public HttpMessage getBaseMsg() {", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTcyNQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487905725", "bodyText": "The doc needs update per move to Model.", "author": "thc202", "createdAt": "2020-09-14T13:19:58Z", "path": "zap/src/main/java/org/parosproxy/paros/extension/ExtensionHook.java", "diffHunk": "@@ -506,4 +518,40 @@ public void addHttpSenderListener(HttpSenderListener httpSenderListener) {\n         }\n         return Collections.unmodifiableList(httpSenderListeners);\n     }\n+\n+    /**\n+     * Adds the given {@code variant} to the extension hook, to be later added to the {@link", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjQ5NA==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487906494", "bodyText": "Needs ZAP comment.", "author": "thc202", "createdAt": "2020-09-14T13:21:02Z", "path": "zap/src/main/java/org/parosproxy/paros/model/Model.java", "diffHunk": "@@ -88,6 +89,7 @@\n     // ZAP: Added logger\n     private Logger logger = Logger.getLogger(Model.class);\n     private List<ContextDataFactory> contextDataFactories = new ArrayList<>();\n+    private VariantFactory variantFactory = new VariantFactory();", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzc2Mw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487907763", "bodyText": "Could be final.", "author": "thc202", "createdAt": "2020-09-14T13:22:51Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwODU4Mw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487908583", "bodyText": "Could be static.", "author": "thc202", "createdAt": "2020-09-14T13:24:03Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwODY0Mw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487908643", "bodyText": "Could be final.", "author": "thc202", "createdAt": "2020-09-14T13:24:08Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMDY0Ng==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487910646", "bodyText": "Could use a mocked Model to avoid the need to tidy up.", "author": "thc202", "createdAt": "2020-09-14T13:26:48Z", "path": "zap/src/test/java/org/parosproxy/paros/model/SessionUnitTest.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.parosproxy.paros.model;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.BDDMockito.given;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.Constant;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.network.HttpHeader;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.I18N;\n+\n+public class SessionUnitTest {\n+\n+    private Session session;\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        Constant.getInstance();\n+        I18N i18n = Mockito.mock(I18N.class, withSettings().lenient());\n+        given(i18n.getString(anyString())).willReturn(\"\");\n+        given(i18n.getString(anyString(), any())).willReturn(\"\");\n+        given(i18n.getLocal()).willReturn(Locale.getDefault());\n+        Constant.messages = i18n;\n+        Control.initSingletonForTesting(Model.getSingleton());\n+\n+        session = new Session(Model.getSingleton());", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzQzNw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487913437", "bodyText": "Remove.", "author": "thc202", "createdAt": "2020-09-14T13:30:21Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNjUwMg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487916502", "bodyText": "Could be extracted, same as in createSiteModifyingVariants.", "author": "thc202", "createdAt": "2020-09-14T13:33:09Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNjczNw==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487916737", "bodyText": "Could be extracted, same as in createSiteModifyingVariants.", "author": "thc202", "createdAt": "2020-09-14T13:33:23Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                LOG.error(e.getMessage(), e);\n+            }\n+        }", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxNzIwNg==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487917206", "bodyText": "This shouldn't happen(?), VariantCustom already doing that.", "author": "thc202", "createdAt": "2020-09-14T13:33:51Z", "path": "zap/src/main/java/org/zaproxy/zap/extension/ascan/VariantFactory.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.log4j.Logger;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantCustom;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.extension.script.ExtensionScript;\n+import org.zaproxy.zap.extension.script.ScriptWrapper;\n+\n+public class VariantFactory {\n+    private static Logger LOG = Logger.getLogger(VariantFactory.class);\n+\n+    private ExtensionScript extension;\n+    private List<Class<? extends Variant>> customVariants = new ArrayList<>();\n+\n+    public void addVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.add(variantClass);\n+    }\n+\n+    public void removeVariant(Class<? extends Variant> variantClass) {\n+        this.customVariants.remove(variantClass);\n+    }\n+\n+    public List<Variant> createVariants(ScannerParam scanOptions, HttpMessage message) {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        int targets = scanOptions.getTargetParamsInjectable();\n+        int enabledRPC = scanOptions.getTargetParamsEnabledRPC();\n+\n+        // First check URL query-string target configuration\n+        if ((targets & ScannerParam.TARGET_QUERYSTRING) != 0) {\n+            VariantURLQuery vuq = new VariantURLQuery();\n+            vuq.setAddQueryParam(scanOptions.isAddQueryParam());\n+            listVariant.add(vuq);\n+\n+            if ((enabledRPC & ScannerParam.RPC_ODATA) != 0) {\n+                listVariant.add(new VariantODataIdQuery());\n+                listVariant.add(new VariantODataFilterQuery());\n+            }\n+\n+            if ((targets & ScannerParam.TARGET_URLPATH) == 0) {\n+                // If we're not already doing URLPath we should do DDN when doing QueryString\n+                listVariant.add(new VariantDdnPath());\n+            }\n+        }\n+\n+        // Then check POST data target configuration and RPC enabled methods\n+        if ((targets & ScannerParam.TARGET_POSTDATA) != 0) {\n+            listVariant.add(new VariantFormQuery());\n+\n+            if ((enabledRPC & ScannerParam.RPC_MULTIPART) != 0) {\n+                listVariant.add(new VariantMultipartFormParameters());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_XML) != 0) {\n+                listVariant.add(new VariantXMLQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_JSON) != 0) {\n+                listVariant.add(new VariantJSONQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_GWT) != 0) {\n+                listVariant.add(new VariantGWTQuery());\n+            }\n+\n+            if ((enabledRPC & ScannerParam.RPC_DWR) != 0) {\n+                listVariant.add(new VariantDirectWebRemotingQuery());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_HTTPHEADERS) != 0) {\n+            boolean addVariant = scanOptions.isScanHeadersAllRequests();\n+            if (!addVariant) {\n+                // If not scanning all requests check if it looks like a dynamic or static page\n+                // (based on query/post parameters)\n+                char[] query = message.getRequestHeader().getURI().getRawQuery();\n+                addVariant =\n+                        (query != null && query.length != 0)\n+                                || message.getRequestBody().length() != 0;\n+            }\n+\n+            if (addVariant) {\n+                listVariant.add(new VariantHeader());\n+            }\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_URLPATH) != 0) {\n+            listVariant.add(new VariantURLPath());\n+        }\n+\n+        if ((targets & ScannerParam.TARGET_COOKIE) != 0) {\n+            listVariant.add(new VariantCookie());\n+        }\n+\n+        // Now is time to initialize all the custom Variants\n+        if ((enabledRPC & ScannerParam.RPC_CUSTOM) != 0) {\n+            if (getExtension() != null) {\n+                // List the scripts and create as many custom variants as the scripts\n+                List<ScriptWrapper> scripts =\n+                        getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+                for (ScriptWrapper script : scripts) {\n+                    if (script.isEnabled()) {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((enabledRPC & ScannerParam.RPC_USERDEF) != 0) {\n+            listVariant.add(new VariantUserDefined());\n+        }\n+\n+        for (Class<? extends Variant> variant : customVariants) {\n+            try {\n+                listVariant.add(variant.getDeclaredConstructor().newInstance());\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                LOG.error(e.getMessage(), e);\n+            }\n+        }\n+\n+        return listVariant;\n+    }\n+\n+    public List<Variant> createSiteModifyingVariants() {\n+        List<Variant> listVariant = new ArrayList<Variant>();\n+\n+        if (getExtension() != null) {\n+            List<ScriptWrapper> scripts =\n+                    getExtension().getScripts(ExtensionActiveScan.SCRIPT_TYPE_VARIANT);\n+\n+            for (ScriptWrapper script : scripts) {\n+                if (script.isEnabled()) {\n+                    try {\n+                        listVariant.add(new VariantCustom(script, getExtension()));\n+                    } catch (Exception e) {", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxOTgzNQ==", "url": "https://github.com/zaproxy/zaproxy/pull/6146#discussion_r487919835", "bodyText": "This is being done in the setUp (similar comment in following methods).", "author": "thc202", "createdAt": "2020-09-14T13:36:17Z", "path": "zap/src/test/java/org/zaproxy/zap/extension/ascan/VariantFactoryUnitTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Zed Attack Proxy (ZAP) and its related class files.\n+ *\n+ * ZAP is an HTTP/HTTPS proxy for assessing web application security.\n+ *\n+ * Copyright 2020 The ZAP Development Team\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.zaproxy.zap.extension.ascan;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.withSettings;\n+\n+import java.util.List;\n+import org.apache.commons.httpclient.URI;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.parosproxy.paros.control.Control;\n+import org.parosproxy.paros.core.scanner.NameValuePair;\n+import org.parosproxy.paros.core.scanner.ScannerParam;\n+import org.parosproxy.paros.core.scanner.Variant;\n+import org.parosproxy.paros.core.scanner.VariantCookie;\n+import org.parosproxy.paros.core.scanner.VariantDdnPath;\n+import org.parosproxy.paros.core.scanner.VariantDirectWebRemotingQuery;\n+import org.parosproxy.paros.core.scanner.VariantFormQuery;\n+import org.parosproxy.paros.core.scanner.VariantGWTQuery;\n+import org.parosproxy.paros.core.scanner.VariantHeader;\n+import org.parosproxy.paros.core.scanner.VariantJSONQuery;\n+import org.parosproxy.paros.core.scanner.VariantMultipartFormParameters;\n+import org.parosproxy.paros.core.scanner.VariantODataFilterQuery;\n+import org.parosproxy.paros.core.scanner.VariantODataIdQuery;\n+import org.parosproxy.paros.core.scanner.VariantURLPath;\n+import org.parosproxy.paros.core.scanner.VariantURLQuery;\n+import org.parosproxy.paros.core.scanner.VariantUserDefined;\n+import org.parosproxy.paros.core.scanner.VariantXMLQuery;\n+import org.parosproxy.paros.extension.ExtensionLoader;\n+import org.parosproxy.paros.model.Model;\n+import org.parosproxy.paros.network.HttpMessage;\n+import org.zaproxy.zap.utils.ZapXmlConfiguration;\n+\n+public class VariantFactoryUnitTest {\n+\n+    @BeforeEach\n+    public void setUp() throws Exception {\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());\n+    }\n+\n+    @Test\n+    public void shouldReturnDefaultVariants() {\n+        // Given\n+        VariantFactory factory = new VariantFactory();\n+        ScannerParam scanOptions = new ScannerParam();\n+        HttpMessage message = new HttpMessage();\n+        ExtensionLoader extLoader = Mockito.mock(ExtensionLoader.class);\n+        Control control = Mockito.mock(Control.class, withSettings().lenient());\n+        Mockito.when(control.getExtensionLoader()).thenReturn(extLoader);\n+        Control.initSingletonForTesting(Model.getSingleton());", "originalCommit": "86cc58674a6bf0ef85e8f63cbe33f4d0f7a642bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "caa14843188d521d7a136170cbf5a1aec1c8030b", "url": "https://github.com/zaproxy/zaproxy/commit/caa14843188d521d7a136170cbf5a1aec1c8030b", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T08:13:18Z", "type": "forcePushed"}, {"oid": "2966832f768988a454529f21812dfb81cd25d104", "url": "https://github.com/zaproxy/zaproxy/commit/2966832f768988a454529f21812dfb81cd25d104", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T10:06:02Z", "type": "forcePushed"}, {"oid": "5974d5668d4f315eb7829243c3a6284c84915107", "url": "https://github.com/zaproxy/zaproxy/commit/5974d5668d4f315eb7829243c3a6284c84915107", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T10:26:12Z", "type": "forcePushed"}, {"oid": "fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "url": "https://github.com/zaproxy/zaproxy/commit/fa8d2bf8b82eaf18ada865b59ff9ae16936e5ac1", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T10:36:42Z", "type": "forcePushed"}, {"oid": "548c33cb75fea6f5a59cc7983a53061df84db029", "url": "https://github.com/zaproxy/zaproxy/commit/548c33cb75fea6f5a59cc7983a53061df84db029", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T13:13:16Z", "type": "forcePushed"}, {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "url": "https://github.com/zaproxy/zaproxy/commit/0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T13:14:09Z", "type": "commit"}, {"oid": "0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "url": "https://github.com/zaproxy/zaproxy/commit/0fee8055a850a1c5ec3d7d93f4002e410fbb76e1", "message": "Add support for site modifiers\n\nSigned-off-by: Simon Bennetts <psiinon@gmail.com>", "committedDate": "2020-09-15T13:14:09Z", "type": "forcePushed"}]}