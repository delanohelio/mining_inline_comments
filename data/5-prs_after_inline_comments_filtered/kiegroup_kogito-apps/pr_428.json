{"pr_number": 428, "pr_title": "KOGITO-3228: add outcome ids to saliency model", "pr_createdAt": "2020-09-01T15:25:39Z", "pr_url": "https://github.com/kiegroup/kogito-apps/pull/428", "timeline": [{"oid": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "url": "https://github.com/kiegroup/kogito-apps/commit/c4de24b95ac188e9ef3d653604c019edb5a8384a", "message": "KOGITO-3228: add status details field to explainability result", "committedDate": "2020-09-02T11:16:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482002768", "bodyText": "What is the reason of this change?\ngetPrediction is plain local method and localExplainer.explainAsync already create the CompletableFuture internally.\nI don't see the reason to add this additional wrapper. Btw you should not use any *Async methods without providing the executor in a managed environment", "author": "danielezonca", "createdAt": "2020-09-02T11:38:49Z", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +62,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n+        return CompletableFuture.supplyAsync(() -> getPrediction(request.getInputs(), request.getOutputs()))\n+                .thenCompose(prediction -> localExplainer.explainAsync(prediction, predictionProvider))", "originalCommit": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc1NDQ5Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482754492", "bodyText": "This is needed imho. The implementation of LimeExplainer does not wrap everything in a CompletableFuture, but instead does some computation before, that may lead to an exception being thrown (e.g. when the Prediction object it receives has no inputs).\nWith the original implementation, exceptions thrown directly in explainAsync wouldn't be catched by the exceptionally block and then bubble up to the event loop thread, blocking the whole computation (which means no failure message being sent back to the Trusty Service).\nThis way, even if the localExplainer implementation is not perfect, we are sure to catch every exception it may throw in the exceptionally block.", "author": "kostola", "createdAt": "2020-09-03T07:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyMDgwMw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482820803", "bodyText": "As @danielezonca suggested in a chat discussion we had, I now handled this issue using a try catch block instead of calling CompletableFuture::supplyAsync to avoid overloading the event loop too much.", "author": "kostola", "createdAt": "2020-09-03T09:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMjc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482003730", "bodyText": "Please add an assertion on the value too", "author": "danielezonca", "createdAt": "2020-09-02T11:40:44Z", "path": "explainability/explainability-service/src/test/java/org/kie/kogito/explainability/ExplanationServiceImplTest.java", "diffHunk": "@@ -57,27 +58,49 @@ void init() {\n         localExplainerMock = mock(LocalExplainer.class);\n         predictionProviderMock = mock(PredictionProvider.class);\n         explanationService = new ExplanationServiceImpl(localExplainerMock);\n-\n-        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock))).thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n     }\n \n     @Test\n-    void explainAsync() throws InterruptedException, ExecutionException, TimeoutException {\n-        CompletionStage<ExplainabilityResultDto> explainAsync = explanationService.explainAsync(REQUEST, predictionProviderMock);\n+    void testExplainAsyncSucceeded() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenReturn(CompletableFuture.completedFuture(SALIENCY_MAP));\n \n-        ExplainabilityResultDto resultDto = explainAsync.toCompletableFuture()\n-                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n \n         assertNotNull(resultDto);\n         assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.SUCCEEDED, resultDto.getStatus());\n+        assertNull(resultDto.getStatusDetails());\n         assertEquals(SALIENCY_MAP.size(), resultDto.getSaliencies().size());\n         assertTrue(resultDto.getSaliencies().containsKey(\"key\"));\n \n         SaliencyDto saliencyDto = resultDto.getSaliencies().get(\"key\");\n         assertEquals(SALIENCY.getPerFeatureImportance().size(), saliencyDto.getFeatureImportance().size());\n \n         FeatureImportanceDto featureImportanceDto1 = saliencyDto.getFeatureImportance().get(0);\n-        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureId());\n+        assertEquals(FEATURE_IMPORTANCE_1.getFeature().getName(), featureImportanceDto1.getFeatureName());\n         assertEquals(FEATURE_IMPORTANCE_1.getScore(), featureImportanceDto1.getScore(), 0.01);\n     }\n+\n+    @Test\n+    void testExplainAsyncFailed() {\n+        when(localExplainerMock.explainAsync(any(Prediction.class), eq(predictionProviderMock)))\n+                .thenThrow(RuntimeException.class);\n+\n+        ExplainabilityResultDto resultDto = assertDoesNotThrow(() ->\n+                explanationService.explainAsync(REQUEST, predictionProviderMock)\n+                        .toCompletableFuture()\n+                        .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit())\n+        );\n+\n+        assertNotNull(resultDto);\n+        assertEquals(EXECUTION_ID, resultDto.getExecutionId());\n+        assertSame(ExplainabilityStatus.FAILED, resultDto.getStatus());\n+        assertNotNull(resultDto.getStatusDetails());", "originalCommit": "c4de24b95ac188e9ef3d653604c019edb5a8384a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxOTUxMg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482819512", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-09-03T08:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwMzczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482170910", "bodyText": "Wdym?\nBtw can you please create a ticket and link it here if you don't want to include these tests in the PR?", "author": "danielezonca", "createdAt": "2020-09-02T15:39:45Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -43,16 +47,29 @@\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n+// TODO: improve this test with decision values", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDY2Ng==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894666", "bodyText": "Sorry that was a leftover. I implemented that part now.", "author": "kostola", "createdAt": "2020-09-03T11:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482171566", "bodyText": "Can you please update/re-enable these assertions?", "author": "danielezonca", "createdAt": "2020-09-02T15:40:38Z", "path": "trusty/trusty-service/src/test/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumerTest.java", "diffHunk": "@@ -75,48 +92,48 @@ void testInvalidPayload() {\n \n     @Test\n     void testExceptionsAreCatched() {\n-        Message<String> message = mockMessage(buildCloudEventJsonString(new ExplainabilityResultDto(\"test\", emptyMap())));\n+        Message<String> message = mockMessage(buildCloudEventJsonString(ExplainabilityResultDto.buildSucceeded(TEST_EXECUTION_ID, emptyMap())));\n \n         doThrow(new RuntimeException(\"Something really bad\")).when(trustyService).storeExplainabilityResult(any(String.class), any(ExplainabilityResult.class));\n         Assertions.assertDoesNotThrow(() -> consumer.handleMessage(message));\n     }\n \n     @Test\n     public void explainabilityResultFrom() {\n-        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null));\n+        Assertions.assertNull(ExplainabilityResultConsumer.explainabilityResultFrom(null, null));\n \n-        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(resultDto);\n+        ExplainabilityResult explainabilityResult = ExplainabilityResultConsumer.explainabilityResultFrom(TEST_RESULT_DTO, TEST_DECISION);\n \n         Assertions.assertNotNull(explainabilityResult);\n-        Assertions.assertEquals(resultDto.getExecutionId(), explainabilityResult.getExecutionId());\n-        Assertions.assertEquals(resultDto.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n-        Assertions.assertTrue(resultDto.getSaliencies().containsKey(\"saliency\"));\n-        Assertions.assertEquals(resultDto.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n-                explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getExecutionId(), explainabilityResult.getExecutionId());\n+        Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().size(), explainabilityResult.getSaliencies().size());\n+        Assertions.assertTrue(TEST_RESULT_DTO.getSaliencies().containsKey(\"saliency\"));\n+        // Assertions.assertEquals(TEST_RESULT_DTO.getSaliencies().get(\"saliency\").getFeatureImportance().size(),\n+        // explainabilityResult.getSaliencies().get(\"saliency\").getFeatureImportance().size());", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDc3MQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894771", "bodyText": "Done. It needed some refactoring but now it's ok.", "author": "kostola", "createdAt": "2020-09-03T11:05:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE3MTU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482213009", "bodyText": "Can you please add a log message if there are no Decision that match with executionId?\nCan you also add a test for it?", "author": "danielezonca", "createdAt": "2020-09-02T16:43:48Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +85,43 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n+        Decision decision = service.getDecisionById(executionId);", "originalCommit": "884822e982dead2623cdf7b4bba86435d7eb58f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5NDgyMQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482894821", "bodyText": "Done \ud83d\udc4d", "author": "kostola", "createdAt": "2020-09-03T11:06:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMzAwOQ=="}], "type": "inlineReview"}, {"oid": "ef114be0ed09b87b8fe3e93836736f904044bb3b", "url": "https://github.com/kiegroup/kogito-apps/commit/ef114be0ed09b87b8fe3e93836736f904044bb3b", "message": "KOGITO-3228: add outcome ids to saliency model", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "35b20c28fef8328844dc1c01f75db4c5c5349722", "url": "https://github.com/kiegroup/kogito-apps/commit/35b20c28fef8328844dc1c01f75db4c5c5349722", "message": "KOGITO-3228: add status directly to ExplainabilityResultDto instead of boolean attribute", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "01c0deea104fb557702d054f9dc7435d5417c467", "url": "https://github.com/kiegroup/kogito-apps/commit/01c0deea104fb557702d054f9dc7435d5417c467", "message": "KOGITO-3228: fix test", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "d7a184c1bdcb33d367f48022bd4576266680da81", "url": "https://github.com/kiegroup/kogito-apps/commit/d7a184c1bdcb33d367f48022bd4576266680da81", "message": "KOGITO-3228: add status details field to explainability result", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "url": "https://github.com/kiegroup/kogito-apps/commit/a5f7f0461e0f1ca2837c8ff48fd76e4770d6bec6", "message": "KOGITO-3228: add 'explanation' prefix to saliencies endpoint", "committedDate": "2020-09-03T07:32:23Z", "type": "commit"}, {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync", "committedDate": "2020-09-03T08:57:37Z", "type": "commit"}, {"oid": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "url": "https://github.com/kiegroup/kogito-apps/commit/6b7e33f13be5d7946926001e9ffd5e53c0168650", "message": "KOGITO-3228: remove extra CompletableFuture::supplyAsync call from ExplanationServiceImpl::explainAsync", "committedDate": "2020-09-03T08:57:37Z", "type": "forcePushed"}, {"oid": "c01963439757c1823b0abef8b6ac4c69c004e1bf", "url": "https://github.com/kiegroup/kogito-apps/commit/c01963439757c1823b0abef8b6ac4c69c004e1bf", "message": "KOGITO-3228: remove explainability-api dependency from trusty-storage-api", "committedDate": "2020-09-03T09:38:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482851924", "bodyText": "Is the try catch needed in this case? Is there a test for such scenario?", "author": "r00ta", "createdAt": "2020-09-03T09:47:12Z", "path": "explainability/explainability-service/src/main/java/org/kie/kogito/explainability/ExplanationServiceImpl.java", "diffHunk": "@@ -61,17 +63,17 @@ public ExplanationServiceImpl(\n                 request.getExecutionId(),\n                 request.getModelIdentifier().getResourceType(),\n                 request.getModelIdentifier().getResourceId());\n-        Prediction prediction = getPrediction(request.getInputs(), request.getOutputs());\n-        return localExplainer.explainAsync(prediction, predictionProvider)\n-                .thenApply(input -> createResultDto(input, request.getExecutionId()))\n-                .exceptionally(throwable -> {\n-                    LOG.error(\"Exception thrown during explainAsync\", throwable);\n-                    return new ExplainabilityResultDto(request.getExecutionId(), Collections.emptyMap());\n-                });\n+        try {\n+            return localExplainer.explainAsync(getPrediction(request.getInputs(), request.getOutputs()), predictionProvider)\n+                    .thenApply(input -> createSucceededResultDto(request.getExecutionId(), input))\n+                    .exceptionally(e -> createFailedResultDto(request.getExecutionId(), e));\n+        } catch (Exception e) {", "originalCommit": "6b7e33f13be5d7946926001e9ffd5e53c0168650", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg2ODAyNw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482868027", "bodyText": "Yes it is needed and there is a test. Please check this discussion.", "author": "kostola", "createdAt": "2020-09-03T10:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg5MTcyNw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r482891727", "bodyText": "This catch is to prevent explainAsync method to throw an unexpected exception instead of return the CompletableFuture", "author": "danielezonca", "createdAt": "2020-09-03T11:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MTkyNA=="}], "type": "inlineReview"}, {"oid": "0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "url": "https://github.com/kiegroup/kogito-apps/commit/0ffd007e6042a45220a1b6bd46e6709fe8a5c57c", "message": "KOGITO-3228: improve ExplainabilityResultConsumerTest", "committedDate": "2020-09-03T10:54:14Z", "type": "commit"}, {"oid": "6479a29d043ee911e695c46b44f9ae1060a22164", "url": "https://github.com/kiegroup/kogito-apps/commit/6479a29d043ee911e695c46b44f9ae1060a22164", "message": "KOGITO-3228: handle IllegalArgumentException in ExplainabilityResultConsumer", "committedDate": "2020-09-03T11:04:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460280", "bodyText": "Shouldn't we rather throw or exception or return some error info here?", "author": "jiripetrlik", "createdAt": "2020-09-04T08:12:04Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxMzY2Mw==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483513663", "bodyText": "Throwing a IllegalArgumentException is the current behavior of the TrustyServiceImpl when it doesn't find a decision with the associated ID.\nIn this case in my implementation I need to return null when this happens.\nFor me it's not an error and in fact it's logged as warning by the caller method because the computation can continue in a \"best effort\" way even without a Decision object.", "author": "kostola", "createdAt": "2020-09-04T09:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483460664", "bodyText": "Please consider to throw exception.", "author": "jiripetrlik", "createdAt": "2020-09-04T08:12:46Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDc5NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514794", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "author": "kostola", "createdAt": "2020-09-04T09:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461072", "bodyText": "Please consider to throw exception.", "author": "jiripetrlik", "createdAt": "2020-09-04T08:13:31Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzUxNDg2NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483514864", "bodyText": "It's not an error in my opinion: if the dto for some reason is null, then the model should be null.", "author": "kostola", "createdAt": "2020-09-04T09:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MTI4OQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/428#discussion_r483461289", "bodyText": "Please consider to throw exception.", "author": "jiripetrlik", "createdAt": "2020-09-04T08:13:54Z", "path": "trusty/trusty-service/src/main/java/org/kie/kogito/trusty/service/messaging/incoming/ExplainabilityResultConsumer.java", "diffHunk": "@@ -82,36 +86,65 @@ protected void handleCloudEvent(CloudEventImpl<ExplainabilityResultDto> cloudEve\n         LOGGER.info(\"Received CloudEvent with id {} from {}\", attributes.getId(), attributes.getSource());\n \n         ExplainabilityResultDto explainabilityResult = optData.get();\n+        String executionId = explainabilityResult.getExecutionId();\n \n-        service.storeExplainabilityResult(attributes.getId(), explainabilityResultFrom(explainabilityResult));\n+        Decision decision = getDecisionById(executionId);\n+        if (decision == null) {\n+            LOGGER.warn(\"Can't find decision related to explainability result (executionId={})\", executionId);\n+        }\n+\n+        service.storeExplainabilityResult(executionId, explainabilityResultFrom(explainabilityResult, decision));\n     }\n \n-    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto) {\n+    protected Decision getDecisionById(String executionId) {\n+        try {\n+            return service.getDecisionById(executionId);\n+        } catch (IllegalArgumentException e) {\n+            return null;\n+        }\n+    }\n+\n+    protected static ExplainabilityResult explainabilityResultFrom(ExplainabilityResultDto dto, Decision decision) {\n         if (dto == null) {\n             return null;\n         }\n-        Map<String, Saliency> saliencies = dto.getSaliencies() == null ? null :\n+\n+        Map<String, String> outcomeNameToIdMap = decision == null\n+                ? Collections.emptyMap()\n+                : decision.getOutcomes().stream().collect(Collectors.toUnmodifiableMap(DecisionOutcome::getOutcomeName, DecisionOutcome::getOutcomeId));\n+\n+        List<Saliency> saliencies = dto.getSaliencies() == null ? null :\n                 dto.getSaliencies().entrySet().stream()\n-                        .collect(Collectors.toMap(Map.Entry::getKey, e -> saliencyFrom(e.getValue())));\n-        return new ExplainabilityResult(dto.getExecutionId(), saliencies);\n+                        .map(e -> saliencyFrom(outcomeNameToIdMap.get(e.getKey()), e.getKey(), e.getValue()))\n+                        .collect(Collectors.toList());\n+        return new ExplainabilityResult(dto.getExecutionId(), statusFrom(dto.getStatus()), dto.getStatusDetails(), saliencies);\n     }\n \n     protected static FeatureImportance featureImportanceFrom(FeatureImportanceDto dto) {\n         if (dto == null) {\n             return null;\n         }\n-        return new FeatureImportance(dto.getFeatureId(), dto.getScore());\n+        return new FeatureImportance(dto.getFeatureName(), dto.getScore());\n     }\n \n-    protected static Saliency saliencyFrom(SaliencyDto dto) {\n+    protected static Saliency saliencyFrom(String outcomeId, String outcomeName, SaliencyDto dto) {\n         if (dto == null) {\n             return null;\n         }\n         List<FeatureImportance> featureImportance = dto.getFeatureImportance() == null ? null :\n                 dto.getFeatureImportance().stream()\n                         .map(ExplainabilityResultConsumer::featureImportanceFrom)\n                         .collect(Collectors.toList());\n-        return new Saliency(featureImportance);\n+        return new Saliency(outcomeId, outcomeName, featureImportance);\n     }\n-}\n \n+    protected static ExplainabilityStatus statusFrom(org.kie.kogito.explainability.api.ExplainabilityStatus status) {\n+        switch (status) {\n+            case SUCCEEDED:\n+                return ExplainabilityStatus.SUCCEEDED;\n+            case FAILED:\n+                return ExplainabilityStatus.FAILED;\n+        }\n+        return null;", "originalCommit": "6479a29d043ee911e695c46b44f9ae1060a22164", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}