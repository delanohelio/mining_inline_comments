{"pr_number": 439, "pr_title": "KOGITO-3259 - Fraud Scoring DMN IT for lists of features", "pr_createdAt": "2020-09-04T09:54:47Z", "pr_url": "https://github.com/kiegroup/kogito-apps/pull/439", "timeline": [{"oid": "8d87b2f2121af688ba78537c6243790442b000be", "url": "https://github.com/kiegroup/kogito-apps/commit/8d87b2f2121af688ba78537c6243790442b000be", "message": "KOGITO-3259 - Fraud Scoring DMN IT for lists of features", "committedDate": "2020-09-04T09:45:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDY4NQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484860685", "bodyText": "remove print", "author": "r00ta", "createdAt": "2020-09-08T11:59:12Z", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);", "originalCommit": "8d87b2f2121af688ba78537c6243790442b000be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0NDQ0OQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484944449", "bodyText": "ouch! sure :)", "author": "tteofili", "createdAt": "2020-09-08T14:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MDY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863026", "bodyText": "what are the cases in which ExplainabilityMetrics.impactScore returns 0?", "author": "r00ta", "createdAt": "2020-09-08T12:03:36Z", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(5000, 1);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        System.out.println(saliencyMap);\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            if (!topFeatures.isEmpty()) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d);", "originalCommit": "8d87b2f2121af688ba78537c6243790442b000be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk0NTYwMw==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484945603", "bodyText": "when the drop of important features doesn't trigger a flipped prediction (or a significant drop in the output score).", "author": "tteofili", "createdAt": "2020-09-08T14:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc0NTcwNQ==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r485745705", "bodyText": "Can you please add a comment with this explaination?", "author": "danielezonca", "createdAt": "2020-09-09T16:21:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg2MzQ5NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484863494", "bodyText": "not needed?", "author": "r00ta", "createdAt": "2020-09-08T12:04:30Z", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;", "originalCommit": "8d87b2f2121af688ba78537c6243790442b000be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzU2Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484887562", "bodyText": "Just a proposal changing the contract of the method so to avoid side effects and make it a bit more clean imo\n\n    public static Feature newCompositeFeature(String name, Map<String, Object> map) {\n        List<Feature> features = new LinkedList<>();\n        for (Map.Entry<String, Object> entry : map.entrySet()) {\n            features.add(parseFeatureValue(entry.getKey(), entry.getValue()));\n        }\n        return newCompositeFeature(name, features);\n    }\n\n    public static Feature newCompositeFeature(String name, List<Feature> features) {\n        return new Feature(name, Type.COMPOSITE, new Value<>(features));\n    }\n\n    private static Feature parseFeatureValue(String featureName, Object value) {\n        if (value instanceof Map) {\n            return newCompositeFeature(featureName, (Map<String, Object>) value);\n        } else if (value instanceof double[]) {\n            return newVectorFeature(featureName, (double[]) value);\n        } else if (value instanceof LocalTime) {\n            return newTimeFeature(featureName, (LocalTime) value);\n        } else if (value instanceof Duration) {\n            return newDurationFeature(featureName, (Duration) value);\n        } else if (value instanceof URI) {\n            return newURIFeature(featureName, (URI) value);\n        } else if (value instanceof ByteBuffer) {\n            return newBinaryFeature(featureName, (ByteBuffer) value);\n        } else if (value instanceof Currency) {\n            return newCurrencyFeature(featureName, (Currency) value);\n        } else if (value instanceof Boolean) {\n            return newBooleanFeature(featureName, (Boolean) value);\n        } else if (value instanceof Number) {\n            return newNumericalFeature(featureName, (Number) value);\n        } else if (value instanceof String) {\n            return newTextFeature(featureName, (String) value);\n        } else if (value instanceof Feature) {\n            return (Feature) value;\n        } else if (value instanceof List) {\n            List<?> items = (List<?>) value;\n            if (!items.isEmpty()) {\n                if (items.get(0) instanceof Feature) {\n                    return newCompositeFeature(featureName, (List<Feature>) items);\n                } else {\n                    List<?> values = (List<?>) value;\n                    List<Feature> fs = IntStream.range(0, values.size())\n                            .mapToObj(i -> parseFeatureValue(featureName + \"_\" + i, values.get(i)))\n                            .collect(Collectors.toList());\n                    return newCompositeFeature(featureName, fs);\n                }\n            } else {\n                return newCompositeFeature(featureName, Collections.emptyList());\n            }\n        } else {\n            return newObjectFeature(featureName, value);\n        }\n    }", "author": "r00ta", "createdAt": "2020-09-08T12:47:05Z", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -131,11 +133,25 @@ private static void parseFeatureValue(List<Feature> features, Map.Entry<String,\n         } else if (value instanceof Feature) {\n             feature = (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    feature = newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    Map<String, Object> map = new HashMap<>();\n+                    int index = 0;\n+                    for (Object o : (List<?>) value) {\n+                        map.put(featureName + \"_\" + index, o);\n+                        index++;\n+                    }\n+                    List<Feature> fs = new ArrayList<>(map.size());\n+                    for (Map.Entry<String, Object> e : map.entrySet()) {\n+                        parseFeatureValue(fs, e);\n+                    }\n+                    feature = newCompositeFeature(featureName, fs);\n+                }\n+            } else {\n+                feature = newCompositeFeature(featureName, Collections.emptyList());", "originalCommit": "8d87b2f2121af688ba78537c6243790442b000be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1MzM3Ng==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r484953376", "bodyText": "sounds good to me, thanks.", "author": "tteofili", "createdAt": "2020-09-08T14:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDg4NzU2Mg=="}], "type": "inlineReview"}, {"oid": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0", "url": "https://github.com/kiegroup/kogito-apps/commit/b41d7f6b9a5752023ecbb0095b0687d6b533a0b0", "message": "KOGITO-3259 - review based improvements", "committedDate": "2020-09-08T14:17:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgwODg4Mg==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r485808882", "bodyText": "You can use items instead of create values", "author": "danielezonca", "createdAt": "2020-09-09T17:54:29Z", "path": "explainability/explainability-core/src/main/java/org/kie/kogito/explainability/model/FeatureFactory.java", "diffHunk": "@@ -104,43 +108,47 @@ public static Feature newCompositeFeature(String name, List<Feature> features) {\n         return new Feature(name, Type.COMPOSITE, new Value<>(features));\n     }\n \n-    private static void parseFeatureValue(List<Feature> features, Map.Entry<String, Object> entry) {\n-        Object value = entry.getValue();\n-        String featureName = entry.getKey();\n-        Feature feature;\n+    private static Feature parseFeatureValue(String featureName, Object value) {\n         if (value instanceof Map) {\n-            feature = newCompositeFeature(featureName, (Map<String, Object>) value);\n+            return newCompositeFeature(featureName, (Map<String, Object>) value);\n         } else if (value instanceof double[]) {\n-            feature = newVectorFeature(featureName, (double[]) value);\n+            return newVectorFeature(featureName, (double[]) value);\n         } else if (value instanceof LocalTime) {\n-            feature = newTimeFeature(featureName, (LocalTime) value);\n+            return newTimeFeature(featureName, (LocalTime) value);\n         } else if (value instanceof Duration) {\n-            feature = newDurationFeature(featureName, (Duration) value);\n+            return newDurationFeature(featureName, (Duration) value);\n         } else if (value instanceof URI) {\n-            feature = newURIFeature(featureName, (URI) value);\n+            return newURIFeature(featureName, (URI) value);\n         } else if (value instanceof ByteBuffer) {\n-            feature = newBinaryFeature(featureName, (ByteBuffer) value);\n+            return newBinaryFeature(featureName, (ByteBuffer) value);\n         } else if (value instanceof Currency) {\n-            feature = newCurrencyFeature(featureName, (Currency) value);\n+            return newCurrencyFeature(featureName, (Currency) value);\n         } else if (value instanceof Boolean) {\n-            feature = newBooleanFeature(featureName, (Boolean) value);\n+            return newBooleanFeature(featureName, (Boolean) value);\n         } else if (value instanceof Number) {\n-            feature = newNumericalFeature(featureName, (Number) value);\n+            return newNumericalFeature(featureName, (Number) value);\n         } else if (value instanceof String) {\n-            feature = newTextFeature(featureName, (String) value);\n+            return newTextFeature(featureName, (String) value);\n         } else if (value instanceof Feature) {\n-            feature = (Feature) value;\n+            return (Feature) value;\n         } else if (value instanceof List) {\n-            try {\n-                List<Feature> featureList = (List<Feature>) value;\n-                feature = newCompositeFeature(featureName, featureList);\n-            } catch (ClassCastException cce) {\n-                feature = newObjectFeature(featureName, value);\n+            List<?> items = (List<?>) value;\n+            if (!items.isEmpty()) {\n+                if (items.get(0) instanceof Feature) {\n+                    return newCompositeFeature(featureName, (List<Feature>) items);\n+                } else {\n+                    List<?> values = (List<?>) value;", "originalCommit": "b41d7f6b9a5752023ecbb0095b0687d6b533a0b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1338825801d540e5d90dc3e8e5da344ed5fc75ae", "url": "https://github.com/kiegroup/kogito-apps/commit/1338825801d540e5d90dc3e8e5da344ed5fc75ae", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259", "committedDate": "2020-09-10T08:48:28Z", "type": "commit"}, {"oid": "59261e85af5be85b75e8204921b80789aa9ee1fc", "url": "https://github.com/kiegroup/kogito-apps/commit/59261e85af5be85b75e8204921b80789aa9ee1fc", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259", "committedDate": "2020-09-10T12:53:47Z", "type": "commit"}, {"oid": "ab9d7e7ddb875555b792359abd09dc07f4f8ad0e", "url": "https://github.com/kiegroup/kogito-apps/commit/ab9d7e7ddb875555b792359abd09dc07f4f8ad0e", "message": "KOGITO-3259 - adjusted linearization/dropping to better work with lists", "committedDate": "2020-09-10T16:17:51Z", "type": "commit"}, {"oid": "86d76de8fd886d435723b8f1e6a3bed63c13e994", "url": "https://github.com/kiegroup/kogito-apps/commit/86d76de8fd886d435723b8f1e6a3bed63c13e994", "message": "KOGITO-3259 - minor fixes", "committedDate": "2020-09-15T15:16:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDQ5NA==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650494", "bodyText": "I would suggest to use Assertj. It provides more specific types of asserts and it is easier to see where the problem is.", "author": "jiripetrlik", "createdAt": "2020-09-29T11:44:10Z", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).", "originalCommit": "86d76de8fd886d435723b8f1e6a3bed63c13e994", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY1MDYwMA==", "url": "https://github.com/kiegroup/kogito-apps/pull/439#discussion_r496650600", "bodyText": "Unexpected new line.", "author": "jiripetrlik", "createdAt": "2020-09-29T11:44:21Z", "path": "explainability/explainability-integrationtests/explainability-integrationtests-dmn/src/test/java/org/kie/kogito/explainability/explainability/integrationtests/dmn/FraudScoringDmnLimeExplainerTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.kie.kogito.explainability.explainability.integrationtests.dmn;\n+\n+import java.io.InputStreamReader;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.kie.dmn.api.core.DMNRuntime;\n+import org.kie.kogito.decision.DecisionModel;\n+import org.kie.kogito.dmn.DMNKogito;\n+import org.kie.kogito.dmn.DmnDecisionModel;\n+import org.kie.kogito.explainability.Config;\n+import org.kie.kogito.explainability.local.lime.LimeExplainer;\n+import org.kie.kogito.explainability.model.Feature;\n+import org.kie.kogito.explainability.model.FeatureFactory;\n+import org.kie.kogito.explainability.model.FeatureImportance;\n+import org.kie.kogito.explainability.model.Prediction;\n+import org.kie.kogito.explainability.model.PredictionInput;\n+import org.kie.kogito.explainability.model.PredictionOutput;\n+import org.kie.kogito.explainability.model.PredictionProvider;\n+import org.kie.kogito.explainability.model.Saliency;\n+import org.kie.kogito.explainability.utils.ExplainabilityMetrics;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class FraudScoringDmnLimeExplainerTest {\n+\n+    @Test\n+    void testFraudScoringDMNExplanation() throws ExecutionException, InterruptedException, TimeoutException {\n+        DMNRuntime dmnRuntime = DMNKogito.createGenericDMNRuntime(new InputStreamReader(getClass().getResourceAsStream(\"/dmn/fraud.dmn\")));\n+        assertEquals(1, dmnRuntime.getModels().size());\n+\n+        final String FRAUD_NS = \"http://www.redhat.com/dmn/definitions/_81556584-7d78-4f8c-9d5f-b3cddb9b5c73\";\n+        final String FRAUD_NAME = \"fraud-scoring\";\n+        DecisionModel decisionModel = new DmnDecisionModel(dmnRuntime, FRAUD_NS, FRAUD_NAME);\n+        List<Map<String, Object>> transactions = new LinkedList<>();\n+        Map<String, Object> t1 = new HashMap<>();\n+        t1.put(\"Card Type\", \"Debit\");\n+        t1.put(\"Location\", \"Local\");\n+        t1.put(\"Amount\", 1000);\n+        t1.put(\"Auth Code\", \"Authorized\");\n+        transactions.add(t1);\n+        Map<String, Object> t2 = new HashMap<>();\n+        t2.put(\"Card Type\", \"Credit\");\n+        t2.put(\"Location\", \"Local\");\n+        t2.put(\"Amount\", 100000);\n+        t2.put(\"Auth Code\", \"Denied\");\n+        transactions.add(t2);\n+        Map<String, Object> map = new HashMap<>();\n+        map.put(\"Transactions\", transactions);\n+\n+        PredictionProvider model = new DecisionModelWrapper(decisionModel);\n+        List<Feature> features = new LinkedList<>();\n+        features.add(FeatureFactory.newCompositeFeature(\"context\", map));\n+        PredictionInput predictionInput = new PredictionInput(features);\n+        List<PredictionOutput> predictionOutputs = model.predictAsync(List.of(predictionInput))\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        Prediction prediction = new Prediction(predictionInput, predictionOutputs.get(0));\n+        LimeExplainer limeExplainer = new LimeExplainer(10, 3);\n+        Map<String, Saliency> saliencyMap = limeExplainer.explainAsync(prediction, model)\n+                .get(Config.INSTANCE.getAsyncTimeout(), Config.INSTANCE.getAsyncTimeUnit());\n+        for (Saliency saliency : saliencyMap.values()) {\n+            assertNotNull(saliency);\n+            List<FeatureImportance> topFeatures = saliency.getTopFeatures(3);\n+            double topScore = Math.abs(topFeatures.stream().map(FeatureImportance::getScore).findFirst().orElse(0d));\n+            if (!topFeatures.isEmpty() && topScore > 0) {\n+                double v = ExplainabilityMetrics.impactScore(model, prediction, topFeatures);\n+                assertTrue(v > 0d); // checks the drop of important features triggers a flipped prediction (or a significant drop in the output score).\n+", "originalCommit": "86d76de8fd886d435723b8f1e6a3bed63c13e994", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f6716caa95475f60c22e8233ca8ff76129b6453", "url": "https://github.com/kiegroup/kogito-apps/commit/4f6716caa95475f60c22e8233ca8ff76129b6453", "message": "Merge branch 'master' of github.com:kiegroup/kogito-apps into KOGITO-3259", "committedDate": "2020-09-30T08:19:22Z", "type": "commit"}, {"oid": "980dc9fd2938eb98992c9091ffe003262ffa943e", "url": "https://github.com/kiegroup/kogito-apps/commit/980dc9fd2938eb98992c9091ffe003262ffa943e", "message": "KOGITO-3259 - minor test improvements", "committedDate": "2020-09-30T08:43:09Z", "type": "commit"}, {"oid": "77c632fae6dc3f07bab2711d35758c0636292200", "url": "https://github.com/kiegroup/kogito-apps/commit/77c632fae6dc3f07bab2711d35758c0636292200", "message": "KOGITO-3259 - minor code improvements", "committedDate": "2020-10-01T08:00:11Z", "type": "commit"}]}