{"pr_number": 525, "pr_title": "Add ChunkResolver to partially resolve expressions", "pr_createdAt": "2020-11-05T18:30:09Z", "pr_url": "https://github.com/HubSpot/jinjava/pull/525", "timeline": [{"oid": "d0b136069a76c7e11f92d5c2fca50a9810d5b6bb", "url": "https://github.com/HubSpot/jinjava/commit/d0b136069a76c7e11f92d5c2fca50a9810d5b6bb", "message": "Checkout ChunkResolver from eager-execution-a branch", "committedDate": "2020-11-05T14:50:58Z", "type": "commit"}, {"oid": "09803ac538070002e4ab656c6b6095871cd6b47c", "url": "https://github.com/HubSpot/jinjava/commit/09803ac538070002e4ab656c6b6095871cd6b47c", "message": "Add pyish date serializer to json", "committedDate": "2020-11-05T15:40:55Z", "type": "commit"}, {"oid": "ac5a8a1b54d08e49cfc6e507f4b4d4325481311b", "url": "https://github.com/HubSpot/jinjava/commit/ac5a8a1b54d08e49cfc6e507f4b4d4325481311b", "message": "Add hideInterpreterErrors flag", "committedDate": "2020-11-05T15:44:09Z", "type": "commit"}, {"oid": "ccd1501a7791fd0d841594f8b9cedf5a94aa2f48", "url": "https://github.com/HubSpot/jinjava/commit/ccd1501a7791fd0d841594f8b9cedf5a94aa2f48", "message": "Add dict resolve test", "committedDate": "2020-11-05T15:44:19Z", "type": "commit"}, {"oid": "c309fdb51e441575e910c47d9c03e2ac12f6a68f", "url": "https://github.com/HubSpot/jinjava/commit/c309fdb51e441575e910c47d9c03e2ac12f6a68f", "message": "Remove unnecessary useMiniChunks flag", "committedDate": "2020-11-05T18:10:27Z", "type": "commit"}, {"oid": "560961dfada0a6c5cabf82506c2e9236cb93faa0", "url": "https://github.com/HubSpot/jinjava/commit/560961dfada0a6c5cabf82506c2e9236cb93faa0", "message": "Add date serialization test", "committedDate": "2020-11-05T18:20:49Z", "type": "commit"}, {"oid": "50063a2af4499e41e92567427baac84cdaec8185", "url": "https://github.com/HubSpot/jinjava/commit/50063a2af4499e41e92567427baac84cdaec8185", "message": "Remove incorrectly dated license", "committedDate": "2020-11-05T18:23:02Z", "type": "commit"}, {"oid": "3d50717be34f8879ad0ad78c7fbc65d015d6855f", "url": "https://github.com/HubSpot/jinjava/commit/3d50717be34f8879ad0ad78c7fbc65d015d6855f", "message": "Update comment for splitChunks()", "committedDate": "2020-11-05T18:27:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzOTEyMg==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518339122", "bodyText": "can you reference constants from the tags themselves here?", "author": "boulter", "createdAt": "2020-11-05T20:17:57Z", "path": "src/main/java/com/hubspot/jinjava/util/ChunkResolver.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.hubspot.jinjava.util;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.UnknownTokenException;\n+import com.hubspot.jinjava.objects.date.JsonPyishDateSerializer;\n+import com.hubspot.jinjava.objects.date.PyishDate;\n+import com.hubspot.jinjava.tree.parse.Token;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * This class takes a string and resolves it in chunks. This allows for\n+ * strings with deferred values within them to be partially resolved, as much\n+ * as they can be with a deferred value.\n+ * E.g with foo=3, bar=2:\n+ *   \"range(0,foo)[-1] + deferred/bar\" -> \"2 + deferred/2\"\n+ * This class is not thread-safe. Do not reuse between threads.\n+ */\n+public class ChunkResolver {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+  .registerModule(\n+      new SimpleModule().addSerializer(PyishDate.class, new JsonPyishDateSerializer())\n+    );\n+\n+  private static final Set<String> RESERVED_KEYWORDS = ImmutableSet.of(\n+    \"and\",", "originalCommit": "3d50717be34f8879ad0ad78c7fbc65d015d6855f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzNDY0OQ==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r523234649", "bodyText": "Got a list of reserved keywords from here https://svn.python.org/projects/external/Jinja-1.1/docs/build/designerdoc.html#reserved-keywords though I think it makes sense to not hardcode as many of these as possible. Just don't know where to get a more complete list, but I'll use the constants from tags to remove some of these", "author": "jasmith-hs", "createdAt": "2020-11-13T21:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzOTEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzIzNzg2OA==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r523237868", "bodyText": "Thinking about this some more, this doesn't need to include any of the tag names as we only need to look for words that appear within expressions like in and or, etc.", "author": "jasmith-hs", "createdAt": "2020-11-13T21:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMzOTEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0MDQ3Mw==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518340473", "bodyText": "what do these do?", "author": "boulter", "createdAt": "2020-11-05T20:20:32Z", "path": "src/main/java/com/hubspot/jinjava/util/ChunkResolver.java", "diffHunk": "@@ -0,0 +1,355 @@\n+package com.hubspot.jinjava.util;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.UnknownTokenException;\n+import com.hubspot.jinjava.objects.date.JsonPyishDateSerializer;\n+import com.hubspot.jinjava.objects.date.PyishDate;\n+import com.hubspot.jinjava.tree.parse.Token;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.StringUtils;\n+\n+/**\n+ * This class takes a string and resolves it in chunks. This allows for\n+ * strings with deferred values within them to be partially resolved, as much\n+ * as they can be with a deferred value.\n+ * E.g with foo=3, bar=2:\n+ *   \"range(0,foo)[-1] + deferred/bar\" -> \"2 + deferred/2\"\n+ * This class is not thread-safe. Do not reuse between threads.\n+ */\n+public class ChunkResolver {\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper()\n+  .registerModule(\n+      new SimpleModule().addSerializer(PyishDate.class, new JsonPyishDateSerializer())\n+    );\n+\n+  private static final Set<String> RESERVED_KEYWORDS = ImmutableSet.of(\n+    \"and\",\n+    \"block\",\n+    \"cycle\",\n+    \"elif\",\n+    \"else\",\n+    \"endblock\",\n+    \"endfilter\",\n+    \"endfor\",\n+    \"endif\",\n+    \"endmacro\",\n+    \"endraw\",\n+    \"endtrans\",\n+    \"extends\",\n+    \"filter\",\n+    \"for\",\n+    \"if\",\n+    \"in\",\n+    \"include\",\n+    \"is\",\n+    \"macro\",\n+    \"not\",\n+    \"or\",\n+    \"pluralize\",\n+    \"print\",\n+    \"raw\",\n+    \"recursive\",\n+    \"set\",\n+    \"trans\",\n+    \"call\",\n+    \"endcall\",\n+    \"__macros__\"\n+  );\n+\n+  // ( -> )\n+  // { -> }\n+  // [ -> ]\n+  private static final Map<Character, Character> CHUNK_LEVEL_MARKER_MAP = ImmutableMap.of(\n+    '(',\n+    ')',\n+    '{',\n+    '}',\n+    '[',\n+    ']'\n+  );\n+\n+  private final char[] value;\n+  private final int length;\n+  private final Token token;\n+  private final JinjavaInterpreter interpreter;\n+  private final Set<String> deferredWords;\n+\n+  private int nextPos = 0;\n+  private char prevChar = 0;\n+  private boolean inQuote = false;\n+  private char quoteChar = 0;\n+\n+  public ChunkResolver(String s, Token token, JinjavaInterpreter interpreter) {\n+    value = s.toCharArray();\n+    length = value.length;\n+    this.token = token;\n+    this.interpreter = interpreter;\n+    deferredWords = new HashSet<>();\n+  }\n+\n+  /**\n+   * @return Any deferred words that were encountered.\n+   */\n+  public Set<String> getDeferredWords() {\n+    return deferredWords;\n+  }\n+\n+  /**\n+   * Chunkify and resolve variables and expressions within the string.\n+   * Tokens are resolved within \"chunks\" where a chunk is surrounded by a markers\n+   * of {}, [], (). The contents inside of a chunk are split by whitespace\n+   * and/or comma, and these \"tokens\" resolved individually.\n+   *\n+   * The main chunk itself does not get resolved.\n+   * e.g.\n+   *  `false || (foo), 'bar'` -> `true, 'bar'`\n+   *  `[(foo == bar), deferred, bar]` -> `[true,deferred,'hello']`\n+   * @return String with chunk layers within it being partially or fully resolved.\n+   */\n+  public String resolveChunks() {\n+    nextPos = 0;\n+    boolean isHideInterpreterErrorsStart = interpreter\n+      .getContext()\n+      .isHideInterpreterErrors();\n+    try {\n+      interpreter.getContext().setHideInterpreterErrors(true);\n+      return String.join(\"\", getChunk(null));\n+    } finally {\n+      interpreter.getContext().setHideInterpreterErrors(isHideInterpreterErrorsStart);\n+    }\n+  }\n+\n+  /**\n+   * Chunkify and resolve variables and expressions within the string.\n+   * Rather than concatenating the chunks, they are split by mini-chunks,\n+   * with the comma splitter ommitted from the list of results.\n+   * Therefore an expression of \"1, 1 + 1, 1 + range(deferred)\" becomes a List of [\"1\", \"2\", \"1 + range(deferred)\"].\n+   *\n+   * @return List of the expression chunk which is split into mini-chunks.\n+   */\n+  public List<String> splitChunks() {\n+    nextPos = 0;\n+    boolean isHideInterpreterErrorsStart = interpreter\n+      .getContext()\n+      .isHideInterpreterErrors();\n+    try {\n+      interpreter.getContext().setHideInterpreterErrors(true);\n+      List<String> miniChunks = getChunk(null);\n+      return miniChunks\n+        .stream()\n+        .filter(s -> s.length() > 1 || !isMiniChunkSplitter(s.charAt(0)))\n+        .collect(Collectors.toList());\n+    } finally {\n+      interpreter.getContext().setHideInterpreterErrors(isHideInterpreterErrorsStart);\n+    }\n+  }\n+\n+  /**\n+   *  e.g. `[0, foo + bar]`:\n+   *     `0, foo + bar` is a chunk\n+   *     `0` and `foo + bar` are mini chunks\n+   *     `0`, `,`, ` `, `foo`, ` `, `+`, ` `, and `bar` are the tokens\n+   * @param chunkLevelMarker the marker `(`, `[`, `{` that started this chunk\n+   * @return the resolved chunk\n+   */\n+  private List<String> getChunk(Character chunkLevelMarker) {\n+    List<String> chunks = new ArrayList<>();\n+    // Mini chunks are split by commas.\n+    StringBuilder miniChunkBuilder = new StringBuilder();\n+    StringBuilder tokenBuilder = new StringBuilder();\n+    while (nextPos < length) {\n+      char c = value[nextPos++];\n+      if (inQuote) {\n+        if (c == quoteChar && prevChar != '\\\\') {\n+          inQuote = false;\n+        }\n+      } else if ((c == '\\'' || c == '\"') && prevChar != '\\\\') {\n+        inQuote = true;\n+        quoteChar = c;\n+      } else if (\n+        chunkLevelMarker != null && CHUNK_LEVEL_MARKER_MAP.get(chunkLevelMarker) == c\n+      ) {\n+        prevChar = c;\n+        break;\n+      } else if (CHUNK_LEVEL_MARKER_MAP.containsKey(c)) {\n+        prevChar = c;\n+        tokenBuilder.append(c);\n+        tokenBuilder.append(resolveChunk(String.join(\"\", getChunk(c))));\n+        tokenBuilder.append(prevChar);\n+        continue;\n+      } else if (isTokenSplitter(c)) {\n+        prevChar = c;\n+\n+        miniChunkBuilder.append(resolveToken(tokenBuilder.toString()));\n+        tokenBuilder = new StringBuilder();\n+        if (isMiniChunkSplitter(c)) {\n+          chunks.add(resolveChunk(miniChunkBuilder.toString()));\n+          chunks.add(String.valueOf(c));\n+          miniChunkBuilder = new StringBuilder();\n+        } else {\n+          miniChunkBuilder.append(c);\n+        }\n+        continue;\n+      }\n+      prevChar = c;\n+      tokenBuilder.append(c);\n+    }\n+    miniChunkBuilder.append(resolveToken(tokenBuilder.toString()));\n+    chunks.add(resolveChunk(miniChunkBuilder.toString()));\n+    return chunks;\n+  }\n+\n+  private boolean isTokenSplitter(char c) {\n+    return (!Character.isLetterOrDigit(c) && c != '_' && c != '.');\n+  }\n+\n+  private boolean isMiniChunkSplitter(char c) {\n+    return c == ',';\n+  }\n+\n+  private String resolveToken(String token) {\n+    if (StringUtils.isBlank(token)) {\n+      return \"\";\n+    }\n+    try {\n+      String resolvedToken;\n+      if (WhitespaceUtils.isQuoted(token) || RESERVED_KEYWORDS.contains(token)) {\n+        resolvedToken = token;\n+      } else {\n+        Object val = interpreter.retraceVariable(\n+          token,\n+          this.token.getLineNumber(),\n+          this.token.getStartPosition()\n+        );\n+        if (val == null) {\n+          try {\n+            val = interpreter.resolveELExpression(token, this.token.getLineNumber());\n+          } catch (UnknownTokenException e) {\n+            // val is still null\n+          }\n+        }\n+        if (val == null) {\n+          resolvedToken = token;\n+        } else {\n+          resolvedToken = getValueAsJinjavaString(val);\n+        }\n+      }\n+      return resolvedToken.trim();\n+    } catch (DeferredValueException | JsonProcessingException e) {\n+      deferredWords.addAll(findDeferredWords(token));\n+      return token.trim();\n+    }\n+  }\n+\n+  // Try resolving the chunk/mini chunk as an ELExpression\n+  private String resolveChunk(String chunk) {\n+    if (StringUtils.isBlank(chunk)) {\n+      return \"\";\n+    } else if (RESERVED_KEYWORDS.contains(chunk)) {\n+      return chunk;\n+    }\n+    try {\n+      String resolvedChunk;\n+      Object val = interpreter.resolveELExpression(chunk, token.getLineNumber());\n+      if (val == null) {\n+        resolvedChunk = chunk;\n+      } else {\n+        resolvedChunk = getValueAsJinjavaString(val);\n+      }\n+      return resolvedChunk.trim();\n+    } catch (Exception e) {\n+      deferredWords.addAll(findDeferredWords(chunk));\n+      return chunk.trim();\n+    }\n+  }\n+\n+  public static String getValueAsJinjavaString(Object val)\n+    throws JsonProcessingException {\n+    return OBJECT_MAPPER\n+      .writeValueAsString(val)\n+      .replaceAll(\"(?<!\\\\\\\\)(?:\\\\\\\\\\\\\\\\)*(\\\\\\\\n)\", \"\\n\")", "originalCommit": "3d50717be34f8879ad0ad78c7fbc65d015d6855f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4OTcxOQ==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518389719", "bodyText": "These swap out a couple of characters from the JSON string. Double quotes are replaced with single quotes, and an escaped n is replaced with the newline character, and an escaped \" is replaced with a double-quote character.\nThe n and \" replacements are because if they don't get replaced, when the JSON string is output, it would have literal \\ns and \\\"s in it where we actually would want newlines and \"s", "author": "jasmith-hs", "createdAt": "2020-11-05T21:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0MDQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQwMjYxMA==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r518402610", "bodyText": "OK, adding a comment here would be helpful for non-obvious code like this.", "author": "boulter", "createdAt": "2020-11-05T22:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM0MDQ3Mw=="}], "type": "inlineReview"}, {"oid": "83a4ab649314e1000bc85560f61449c47ee4a2c3", "url": "https://github.com/HubSpot/jinjava/commit/83a4ab649314e1000bc85560f61449c47ee4a2c3", "message": "Comment regex replaceAll", "committedDate": "2020-11-06T18:37:53Z", "type": "commit"}, {"oid": "a7b256e381972bc10338ecb741d6f97168098e4e", "url": "https://github.com/HubSpot/jinjava/commit/a7b256e381972bc10338ecb741d6f97168098e4e", "message": "Remove unnecessary reserved words", "committedDate": "2020-11-13T21:20:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMwMTA1OA==", "url": "https://github.com/HubSpot/jinjava/pull/525#discussion_r525301058", "bodyText": "even though this is a boolean, it would probably be more readable with a get instead of is", "author": "boulter", "createdAt": "2020-11-17T16:29:16Z", "path": "src/main/java/com/hubspot/jinjava/interpret/Context.java", "diffHunk": "@@ -526,4 +527,12 @@ public void addDependencies(SetMultimap<String, String> dependencies) {\n   public SetMultimap<String, String> getDependencies() {\n     return this.dependencies;\n   }\n+\n+  public boolean isHideInterpreterErrors() {", "originalCommit": "a7b256e381972bc10338ecb741d6f97168098e4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad4b922a6087fb27bf1e0a5260906296d1f4a528", "url": "https://github.com/HubSpot/jinjava/commit/ad4b922a6087fb27bf1e0a5260906296d1f4a528", "message": "Change isHide to getHide", "committedDate": "2020-11-17T17:08:33Z", "type": "commit"}]}