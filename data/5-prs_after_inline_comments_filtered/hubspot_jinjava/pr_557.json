{"pr_number": 557, "pr_title": "Implement EagerSetTag", "pr_createdAt": "2020-12-01T21:38:17Z", "pr_url": "https://github.com/HubSpot/jinjava/pull/557", "timeline": [{"oid": "bd0e1cb271390caa2823801172882a9dae238924", "url": "https://github.com/HubSpot/jinjava/commit/bd0e1cb271390caa2823801172882a9dae238924", "message": "Checkout eager set tag functionality from other branch", "committedDate": "2020-11-30T21:17:01Z", "type": "commit"}, {"oid": "522a0af059234b01655f0d05b6415130d0c8d746", "url": "https://github.com/HubSpot/jinjava/commit/522a0af059234b01655f0d05b6415130d0c8d746", "message": "Ignore failing tests", "committedDate": "2020-11-30T22:29:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MDQxOQ==", "url": "https://github.com/HubSpot/jinjava/pull/557#discussion_r534260419", "bodyText": "A more general question here:\nYou probably understand this better than me at this point, but why don't we implement this by manipulating the tree directly?\nThe way most compilers work is by parsing the code up into a tree (which we have), doing n passes through the tree to manipulate nodes and perform evaluation when possible. Then they write out the code in one pass. Could we do that here instead of returning a string as the output?", "author": "boulter", "createdAt": "2020-12-02T15:32:43Z", "path": "src/main/java/com/hubspot/jinjava/lib/tag/eager/EagerSetTag.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package com.hubspot.jinjava.lib.tag.eager;\n+\n+import com.hubspot.jinjava.interpret.Context;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.TemplateSyntaxException;\n+import com.hubspot.jinjava.lib.tag.DoTag;\n+import com.hubspot.jinjava.lib.tag.SetTag;\n+import com.hubspot.jinjava.tree.parse.TagToken;\n+import com.hubspot.jinjava.util.ChunkResolver;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+public class EagerSetTag extends EagerStateChangingTag<SetTag> {\n+\n+  public EagerSetTag() {\n+    super(new SetTag());\n+  }\n+\n+  public EagerSetTag(SetTag setTag) {\n+    super(setTag);\n+  }\n+\n+  @Override\n+  public String getEagerTagImage(TagToken tagToken, JinjavaInterpreter interpreter) {", "originalCommit": "522a0af059234b01655f0d05b6415130d0c8d746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMwMzcwNQ==", "url": "https://github.com/HubSpot/jinjava/pull/557#discussion_r534303705", "bodyText": "The jinjava engine is an interpreter rather than a compiler so it parses one line at a time into its output. Not lines exactly, as it first parses the template into a tree, and then it interprets each node in that tree as it sees it (because unlike python, jinja doesn't have a strong line-based syntax).\nThe way I have this implemented is so that nodes are still evaluated on the fly, but their evaluation is handled differently when a value is deferred. Rather than throwing an error there, a specific output can be generated such that running that output with resolved values will produce the same output as running the original with resolved values, but faster. This approach allows for the sequential node evaluation to be done as normal.\nIn a different rendering engine that's more c-based than python-based, it would probably be done by manipulating the tree", "author": "jasmith-hs", "createdAt": "2020-12-02T16:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MDQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MTY2MA==", "url": "https://github.com/HubSpot/jinjava/pull/557#discussion_r534261660", "bodyText": "did we decide on a different name for isProtectedMode? Every time I see it, I can't remember what it protects from.", "author": "boulter", "createdAt": "2020-12-02T15:34:11Z", "path": "src/main/java/com/hubspot/jinjava/lib/tag/eager/EagerSetTag.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package com.hubspot.jinjava.lib.tag.eager;\n+\n+import com.hubspot.jinjava.interpret.Context;\n+import com.hubspot.jinjava.interpret.DeferredValueException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.interpret.TemplateSyntaxException;\n+import com.hubspot.jinjava.lib.tag.DoTag;\n+import com.hubspot.jinjava.lib.tag.SetTag;\n+import com.hubspot.jinjava.tree.parse.TagToken;\n+import com.hubspot.jinjava.util.ChunkResolver;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import java.util.stream.Collectors;\n+\n+public class EagerSetTag extends EagerStateChangingTag<SetTag> {\n+\n+  public EagerSetTag() {\n+    super(new SetTag());\n+  }\n+\n+  public EagerSetTag(SetTag setTag) {\n+    super(setTag);\n+  }\n+\n+  @Override\n+  public String getEagerTagImage(TagToken tagToken, JinjavaInterpreter interpreter) {\n+    if (!tagToken.getHelpers().contains(\"=\")) {\n+      throw new TemplateSyntaxException(\n+        interpreter,\n+        tagToken.getImage(),\n+        \"Tag 'set' expects an assignment expression with '=', but was: \" +\n+        tagToken.getHelpers()\n+      );\n+    }\n+\n+    int eqPos = tagToken.getHelpers().indexOf('=');\n+    String variables = tagToken.getHelpers().substring(0, eqPos).trim();\n+\n+    String expression = tagToken.getHelpers().substring(eqPos + 1);\n+    if (interpreter.getContext().containsKey(Context.IMPORT_RESOURCE_ALIAS)) {\n+      return interpreter.render(\n+        convertSetToUpdate(variables, expression, tagToken, interpreter)\n+      );\n+    }\n+    ChunkResolver chunkResolver = new ChunkResolver(expression, tagToken, interpreter);\n+    EagerStringResult resolvedExpression = executeInChildContext(\n+      eagerInterpreter -> chunkResolver.resolveChunks(),\n+      interpreter,\n+      true\n+    );\n+    StringJoiner joiner = new StringJoiner(\" \");\n+    joiner\n+      .add(tagToken.getSymbols().getExpressionStartWithTag())\n+      .add(tagToken.getTagName())\n+      .add(variables)\n+      .add(\"=\")\n+      .add(resolvedExpression.getResult())\n+      .add(tagToken.getSymbols().getExpressionEndWithTag());\n+    StringBuilder prefixToPreserveState = new StringBuilder(\n+      interpreter.getContext().isProtectedMode()\n+        ? resolvedExpression.getPrefixToPreserveState()\n+        : \"\"\n+    );\n+    String[] varTokens = variables.split(\",\");\n+\n+    if (\n+      chunkResolver.getDeferredWords().isEmpty() &&\n+      !interpreter.getContext().isProtectedMode()", "originalCommit": "522a0af059234b01655f0d05b6415130d0c8d746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDMxMzMzNg==", "url": "https://github.com/HubSpot/jinjava/pull/557#discussion_r534313336", "bodyText": "I have not yet come up with a better name, and I'm aware that it's not exactly clear what it does by the name.\nI have defined \"protected mode\" as a mode where the surrounding context cannot be modified such that the state of the context before entering \"protected mode\" will be the same as after exiting it. Any changes will result in the values attempted to be modified becoming DeferredValues.\nThis mode is commonly seen in IfTags and ForTags when the children are being rendered but their results need to be protected such that when the if branch/for loop is finally executed normally, the output will be correct.\nSomething like isDeferredExecutionMode might be more understandable as the code being evaluated is being partially deferred, knowing that it's final execution is being deferred", "author": "jasmith-hs", "createdAt": "2020-12-02T16:38:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MTY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYwNDA5MQ==", "url": "https://github.com/HubSpot/jinjava/pull/557#discussion_r537604091", "bodyText": "isDeferredExecutionMode sounds good to me.", "author": "boulter", "createdAt": "2020-12-07T15:38:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDI2MTY2MA=="}], "type": "inlineReview"}, {"oid": "2c49dbeda060d2f423ce026711fd3ebc6ae9d42a", "url": "https://github.com/HubSpot/jinjava/commit/2c49dbeda060d2f423ce026711fd3ebc6ae9d42a", "message": "Merge branch 'eager-expression-node' of github.com:HubSpot/jinjava into eager-set", "committedDate": "2020-12-03T19:34:19Z", "type": "commit"}, {"oid": "00a81f12132b292626be54d0bc1c2fd903e2de45", "url": "https://github.com/HubSpot/jinjava/commit/00a81f12132b292626be54d0bc1c2fd903e2de45", "message": "Merge branch 'eager-expression-node' of github.com:HubSpot/jinjava into eager-set", "committedDate": "2020-12-03T19:38:04Z", "type": "commit"}, {"oid": "7600b82cddfc432f462ac20ef476f2bcdbd9e6b6", "url": "https://github.com/HubSpot/jinjava/commit/7600b82cddfc432f462ac20ef476f2bcdbd9e6b6", "message": "Add length limiting string joiner", "committedDate": "2020-12-03T19:42:17Z", "type": "commit"}, {"oid": "7e50b7068b81d5b626bbb936f71079e3fb70a4b5", "url": "https://github.com/HubSpot/jinjava/commit/7e50b7068b81d5b626bbb936f71079e3fb70a4b5", "message": "Increase max output size for eager set tag test", "committedDate": "2020-12-03T19:45:47Z", "type": "commit"}, {"oid": "4278be5a0ddfb623b60ac80c6f68028928a308cc", "url": "https://github.com/HubSpot/jinjava/commit/4278be5a0ddfb623b60ac80c6f68028928a308cc", "message": "Merge branch 'eager-expression-node' of github.com:HubSpot/jinjava into eager-set", "committedDate": "2020-12-03T21:52:35Z", "type": "commit"}, {"oid": "54c38e6c25733f231b4d108cd7e14c747e72d38f", "url": "https://github.com/HubSpot/jinjava/commit/54c38e6c25733f231b4d108cd7e14c747e72d38f", "message": "Merge branch 'master' of github.com:HubSpot/jinjava into eager-set", "committedDate": "2020-12-09T21:17:49Z", "type": "commit"}, {"oid": "6bbc9e46a8e754a14ce45b6007c79763c604e283", "url": "https://github.com/HubSpot/jinjava/commit/6bbc9e46a8e754a14ce45b6007c79763c604e283", "message": "Fix protected mode name and execution mode singleton usage", "committedDate": "2020-12-09T21:19:42Z", "type": "commit"}]}