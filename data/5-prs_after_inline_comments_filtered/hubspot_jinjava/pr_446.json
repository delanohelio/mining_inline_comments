{"pr_number": 446, "pr_title": "Jinja expression test parity", "pr_createdAt": "2020-05-25T20:15:23Z", "pr_url": "https://github.com/HubSpot/jinjava/pull/446", "timeline": [{"oid": "f0c11bdbdf2f20c90515ceaceb8f3daee5a99dde", "url": "https://github.com/HubSpot/jinjava/commit/f0c11bdbdf2f20c90515ceaceb8f3daee5a99dde", "message": "Support symbols as expression tests", "committedDate": "2020-05-22T17:45:23Z", "type": "commit"}, {"oid": "2663be154ee242f4ba9416dc74b8301a5c356b99", "url": "https://github.com/HubSpot/jinjava/commit/2663be154ee242f4ba9416dc74b8301a5c356b99", "message": "Add equals exp test aliases", "committedDate": "2020-05-22T17:46:25Z", "type": "commit"}, {"oid": "84cb94314845f52c371dde573637319654dadee9", "url": "https://github.com/HubSpot/jinjava/commit/84cb94314845f52c371dde573637319654dadee9", "message": "Test equals exp test aliases", "committedDate": "2020-05-22T17:46:47Z", "type": "commit"}, {"oid": "b158a156a55deedd54c319b53ae93485d323b181", "url": "https://github.com/HubSpot/jinjava/commit/b158a156a55deedd54c319b53ae93485d323b181", "message": "Refactor to support more symbols as expression tests", "committedDate": "2020-05-22T18:32:25Z", "type": "commit"}, {"oid": "6d7aaf00f0b52c12462909236be20eaddd8e638d", "url": "https://github.com/HubSpot/jinjava/commit/6d7aaf00f0b52c12462909236be20eaddd8e638d", "message": "Support lt as exp test", "committedDate": "2020-05-22T18:32:56Z", "type": "commit"}, {"oid": "a98020c2fd2be8b12011d97049fc945ea54c2499", "url": "https://github.com/HubSpot/jinjava/commit/a98020c2fd2be8b12011d97049fc945ea54c2499", "message": "Test comparison exp tests", "committedDate": "2020-05-22T18:33:11Z", "type": "commit"}, {"oid": "059c0f6f6e8a19bff1ac2115659f39f9e0f9722e", "url": "https://github.com/HubSpot/jinjava/commit/059c0f6f6e8a19bff1ac2115659f39f9e0f9722e", "message": "Support lessthan alias", "committedDate": "2020-05-22T18:36:43Z", "type": "commit"}, {"oid": "080b8875e19694c7a9d0fdf4040ef59193252a95", "url": "https://github.com/HubSpot/jinjava/commit/080b8875e19694c7a9d0fdf4040ef59193252a95", "message": "Support < alias", "committedDate": "2020-05-22T18:37:43Z", "type": "commit"}, {"oid": "181bd8249e78f6785ba7c427776695423a10e170", "url": "https://github.com/HubSpot/jinjava/commit/181bd8249e78f6785ba7c427776695423a10e170", "message": "Fix docs", "committedDate": "2020-05-22T18:50:03Z", "type": "commit"}, {"oid": "cbf09ba73b2f0733d74707ccc288ab69add16339", "url": "https://github.com/HubSpot/jinjava/commit/cbf09ba73b2f0733d74707ccc288ab69add16339", "message": "Implement comparison exp tests", "committedDate": "2020-05-22T19:06:51Z", "type": "commit"}, {"oid": "673d93ceef5433b3077fb41e88b5b73b06f43a64", "url": "https://github.com/HubSpot/jinjava/commit/673d93ceef5433b3077fb41e88b5b73b06f43a64", "message": "Fix docs", "committedDate": "2020-05-22T19:07:55Z", "type": "commit"}, {"oid": "c884f339827f93b05c4c581b18387182b0786a54", "url": "https://github.com/HubSpot/jinjava/commit/c884f339827f93b05c4c581b18387182b0786a54", "message": "Implement boolean, integer, float exp tests", "committedDate": "2020-05-22T20:21:31Z", "type": "commit"}, {"oid": "ecbf9143a8a59854ff553e4fc85822607095950b", "url": "https://github.com/HubSpot/jinjava/commit/ecbf9143a8a59854ff553e4fc85822607095950b", "message": "Implement true / false exp tests", "committedDate": "2020-05-22T20:29:58Z", "type": "commit"}, {"oid": "be04a7a0c877266199cf06c60cf09c71e0a550a3", "url": "https://github.com/HubSpot/jinjava/commit/be04a7a0c877266199cf06c60cf09c71e0a550a3", "message": "Make PyMap implement Iterable", "committedDate": "2020-05-25T17:17:07Z", "type": "commit"}, {"oid": "5bf3bcd7cb58b5d16e2d687ec4269ecf75ac8e18", "url": "https://github.com/HubSpot/jinjava/commit/5bf3bcd7cb58b5d16e2d687ec4269ecf75ac8e18", "message": "Rename variables for clarity", "committedDate": "2020-05-25T17:17:44Z", "type": "commit"}, {"oid": "acb58787b6080264b01772b029b84a4f27534c99", "url": "https://github.com/HubSpot/jinjava/commit/acb58787b6080264b01772b029b84a4f27534c99", "message": "Allow membership to work with iterables like dicts", "committedDate": "2020-05-25T18:08:18Z", "type": "commit"}, {"oid": "6a91f2b0051f888da94e22550791274beba4ff95", "url": "https://github.com/HubSpot/jinjava/commit/6a91f2b0051f888da94e22550791274beba4ff95", "message": "Make isIterable, isSequence to accept Strings", "committedDate": "2020-05-25T18:08:55Z", "type": "commit"}, {"oid": "db51ac5a9725f4489d1c8c68c72d0f82b8304fb3", "url": "https://github.com/HubSpot/jinjava/commit/db51ac5a9725f4489d1c8c68c72d0f82b8304fb3", "message": "Make membership operation more tolerant of type", "committedDate": "2020-05-25T18:19:38Z", "type": "commit"}, {"oid": "adbd29bf11d126be05e1146bb5bb91c2fc0aebd6", "url": "https://github.com/HubSpot/jinjava/commit/adbd29bf11d126be05e1146bb5bb91c2fc0aebd6", "message": "Implement in exp test", "committedDate": "2020-05-25T18:25:30Z", "type": "commit"}, {"oid": "01b2c343b79153342d80b0b7e70279050eeee2e3", "url": "https://github.com/HubSpot/jinjava/commit/01b2c343b79153342d80b0b7e70279050eeee2e3", "message": "Make escaping a string make it safe", "committedDate": "2020-05-25T19:14:19Z", "type": "commit"}, {"oid": "41909b0c6b72aa1896432ca82cd23999c4093772", "url": "https://github.com/HubSpot/jinjava/commit/41909b0c6b72aa1896432ca82cd23999c4093772", "message": "Implement is escaped exp test", "committedDate": "2020-05-25T19:14:59Z", "type": "commit"}, {"oid": "e17b08bd046bd0df5a4ad3b9292cc3f51e52638d", "url": "https://github.com/HubSpot/jinjava/commit/e17b08bd046bd0df5a4ad3b9292cc3f51e52638d", "message": "Remove unneeded null checks", "committedDate": "2020-05-25T19:26:56Z", "type": "commit"}, {"oid": "04084de8885a021890af3df5385218f55276696a", "url": "https://github.com/HubSpot/jinjava/commit/04084de8885a021890af3df5385218f55276696a", "message": "Make is within an alias of is in", "committedDate": "2020-05-25T19:44:12Z", "type": "commit"}, {"oid": "0a4657c270a53c4dbbd6b8f388f0299a7c666bfa", "url": "https://github.com/HubSpot/jinjava/commit/0a4657c270a53c4dbbd6b8f388f0299a7c666bfa", "message": "Refactor for clarity", "committedDate": "2020-05-25T19:57:12Z", "type": "commit"}, {"oid": "8a4e36bb944158b19b046c104ab58e648dd2457a", "url": "https://github.com/HubSpot/jinjava/commit/8a4e36bb944158b19b046c104ab58e648dd2457a", "message": "Fix escape tests for type", "committedDate": "2020-05-25T19:57:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NjA4NA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430066084", "bodyText": "What we had before was that we would cast the value to the type of the first element of the collection, and then return on that result. So 2 is in ['one', 2] would fail because 2 gets casted to '2'.", "author": "tectonic8", "createdAt": "2020-05-25T20:22:57Z", "path": "src/main/java/com/hubspot/jinjava/el/ext/CollectionMembershipOperator.java", "diffHunk": "@@ -7,39 +7,43 @@\n import de.odysseus.el.tree.impl.ast.AstBinary;\n import de.odysseus.el.tree.impl.ast.AstBinary.SimpleOperator;\n import de.odysseus.el.tree.impl.ast.AstNode;\n-import java.util.Collection;\n import java.util.Objects;\n import javax.el.ELException;\n import org.apache.commons.lang3.StringUtils;\n \n public class CollectionMembershipOperator extends SimpleOperator {\n \n   @Override\n-  public Object apply(TypeConverter converter, Object o1, Object o2) {\n-    if (o2 == null) {\n+  public Object apply(TypeConverter converter, Object value, Object maybeIterable) {\n+    if (maybeIterable == null) {\n       return Boolean.FALSE;\n     }\n \n-    if (CharSequence.class.isAssignableFrom(o2.getClass())) {\n-      return StringUtils.contains((CharSequence) o2, Objects.toString(o1, \"\"));\n+    if (CharSequence.class.isAssignableFrom(maybeIterable.getClass())) {\n+      return StringUtils.contains(\n+        (CharSequence) maybeIterable,\n+        Objects.toString(value, \"\")\n+      );\n     }\n \n-    if (Collection.class.isAssignableFrom(o2.getClass())) {\n-      Collection<?> collection = (Collection<?>) o2;\n-\n-      for (Object value : collection) {\n-        if (value == null) {\n-          if (o1 == null) {\n-            return Boolean.TRUE;\n+    if (maybeIterable instanceof Iterable) {\n+      for (Object element : (Iterable) maybeIterable) {\n+        if (element == null) {\n+          if (value == null) {\n+            return true;\n           }\n         } else {\n           try {\n-            return collection.contains(converter.convert(o1, value.getClass()));", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyNDg3Nw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r435924877", "bodyText": "Can you check the performance of this? I believe I did this back in https://github.com/HubSpot/jinjava/pull/314/files for performance reasons but would be good to double check. We could also split this into a separate PR to be safe.", "author": "mattcoley", "createdAt": "2020-06-05T13:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NjA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3NzQ2MA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r439577460", "bodyText": "There is a slight performance hit. For checking the existence of a float in a list of 1,000,0000 strings, it takes 2-6 seconds with the current code and 1-2 seconds in the master branch. This code can be slightly optimized by storing the converted values in a type->object map. With that we see closer to the 2 second range. For a list of 100,000 strings, the difference is about 400 ms vs 300 ms. It seems to me that there isn't a huge difference until we reach very large scales. What do you think we should do?", "author": "tectonic8", "createdAt": "2020-06-12T18:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NjYxNA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430066614", "bodyText": "CollectionMembershipOperator.TOKEN.getSymbol() is just EXTENSION which is non-ideal because we really just want to add IN to this set, but we can't add symbols.", "author": "tectonic8", "createdAt": "2020-05-25T20:25:41Z", "path": "src/main/java/com/hubspot/jinjava/el/ext/ExtendedParser.java", "diffHunk": "@@ -53,6 +64,19 @@\n   static final Scanner.ExtensionToken TRUNC_DIV = TruncDivOperator.TOKEN;\n   static final Scanner.ExtensionToken POWER_OF = PowerOfOperator.TOKEN;\n \n+  static final Set<Symbol> VALID_SYMBOLS_FOR_EXP_TEST = Sets.newHashSet(\n+    IDENTIFIER,\n+    EQ,\n+    NE,\n+    LT,\n+    LE,\n+    GT,\n+    GE,\n+    TRUE,\n+    FALSE,\n+    CollectionMembershipOperator.TOKEN.getSymbol()", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2ODE0OA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430068148", "bodyText": "It is questionable to define iterables and sequences as the same thing, but this follows the Jinja spec.", "author": "tectonic8", "createdAt": "2020-05-25T20:33:56Z", "path": "src/main/java/com/hubspot/jinjava/lib/exptest/IsSequenceExpTest.java", "diffHunk": "@@ -25,9 +27,6 @@ public String getName() {\n \n   @Override\n   public boolean evaluate(Object var, JinjavaInterpreter interpreter, Object... args) {\n-    return (\n-      var != null &&\n-      (var.getClass().isArray() || Iterable.class.isAssignableFrom(var.getClass()))\n-    );\n+    return isIterable(var);", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2ODgyOA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430068828", "bodyText": "This is a breaking change. I don't see why this should fail before, and it does not fail in Jinja.", "author": "tectonic8", "createdAt": "2020-05-25T20:37:06Z", "path": "src/test/java/com/hubspot/jinjava/lib/exptest/IsContainingExpTestTest.java", "diffHunk": "@@ -30,14 +30,14 @@ public void itPassesOnContainedValue() {\n   }\n \n   @Test\n-  public void itFailsOnNullContainedValue() {\n+  public void itPassesOnNullContainedValue() {\n     assertThat(\n         jinjava.render(\n           String.format(CONTAINING_TEMPLATE, \"[1, 2, null]\", \"null\"),\n           new HashMap<>()\n         )\n       )\n-      .isEqualTo(\"fail\");\n+      .isEqualTo(\"pass\");", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTEwOQ==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430069109", "bodyText": "Should passing in an object that is not an iterable simply return false or throw an exception?", "author": "tectonic8", "createdAt": "2020-05-25T20:38:21Z", "path": "src/test/java/com/hubspot/jinjava/lib/exptest/IsInExpTestTest.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.hubspot.jinjava.lib.exptest;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.hubspot.jinjava.Jinjava;\n+import java.util.HashMap;\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class IsInExpTestTest {\n+  private Jinjava jinjava;\n+\n+  @Before\n+  public void setup() {\n+    jinjava = new Jinjava();\n+  }\n+\n+  @Test\n+  public void testIsInList() {\n+    assertThat(jinjava.render(\"{{ 2 is in [1, 2] }}\", new HashMap<>())).isEqualTo(\"true\");\n+    assertThat(jinjava.render(\"{{ 2 is in ['one', 2] }}\", new HashMap<>()))\n+      .isEqualTo(\"true\");\n+    assertThat(jinjava.render(\"{{ 2 is in [1] }}\", new HashMap<>())).isEqualTo(\"false\");\n+  }\n+\n+  @Test\n+  public void testIsInString() {\n+    assertThat(jinjava.render(\"{{ 'b' is in 'ab' }}\", new HashMap<>())).isEqualTo(\"true\");\n+    assertThat(jinjava.render(\"{{ 'b' is in 'a' }}\", new HashMap<>())).isEqualTo(\"false\");\n+  }\n+\n+  @Test\n+  public void testIsInDict() {\n+    assertThat(jinjava.render(\"{{ 'k2' is in {'k1':'v1', 'k2':'v2'} }}\", new HashMap<>()))\n+      .isEqualTo(\"true\");\n+    assertThat(jinjava.render(\"{{ 'k2' is in {'k1':'v1'} }}\", new HashMap<>()))\n+      .isEqualTo(\"false\");\n+  }\n+\n+  @Test\n+  public void testNull() {\n+    assertThat(jinjava.render(\"{{ null is in [null] }}\", new HashMap<>()))\n+      .isEqualTo(\"true\");\n+    assertThat(jinjava.render(\"{{ null is in [2] }}\", new HashMap<>()))\n+      .isEqualTo(\"false\");\n+    assertThat(jinjava.render(\"{{ 2 is in [null] }}\", new HashMap<>()))\n+      .isEqualTo(\"false\");\n+    assertThatThrownBy(() -> jinjava.render(\"{{ 2 is in null }}\", new HashMap<>()))\n+      .hasMessageContaining(\"1st argument with value 'null' must be iterable\");", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTU5Mg==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430069592", "bodyText": "This is related to whether we should return false or throw an exception. In Python, 2 in None would throw an exception.", "author": "tectonic8", "createdAt": "2020-05-25T20:40:47Z", "path": "src/test/java/com/hubspot/jinjava/lib/exptest/IsWithinExpTestTest.java", "diffHunk": "@@ -53,12 +53,6 @@ public void itFailsOnNullValueNotInSequence() {\n       .isEqualTo(\"fail\");\n   }\n \n-  @Test\n-  public void itFailsOnNullSequence() {\n-    assertThat(jinjava.render(String.format(IN_TEMPLATE, \"2\", \"null\"), new HashMap<>()))\n-      .isEqualTo(\"fail\");\n-  }\n-", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyOTk1Nw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r435929957", "bodyText": "Escaping is tricky. I would leave out the changes to the escape filter and the addition of the escaped expression test in a separate PR to be safe.", "author": "mattcoley", "createdAt": "2020-06-05T13:43:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk1NjA5Ng==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r435956096", "bodyText": "That makes sense.", "author": "tectonic8", "createdAt": "2020-06-05T14:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3NDQxMw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r439574413", "bodyText": "I removed the escaping, but also this code snippet here is related to the whether searching something that isn't an iterable should return false as it does currently or throw an exception. Can you comment on that?", "author": "tectonic8", "createdAt": "2020-06-12T18:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2OTcwNw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430069707", "bodyText": "This is because the escape filter now returns a SafeString. Is this fine?", "author": "tectonic8", "createdAt": "2020-05-25T20:41:27Z", "path": "src/test/java/com/hubspot/jinjava/lib/filter/EscapeFilterTest.java", "diffHunk": "@@ -20,11 +20,11 @@ public void setup() {\n \n   @Test\n   public void testEscape() {\n-    assertThat(f.filter(\"\", interpreter)).isEqualTo(\"\");\n-    assertThat(f.filter(\"me & you\", interpreter)).isEqualTo(\"me &amp; you\");\n-    assertThat(f.filter(\"jared's & ted's bogus journey\", interpreter))\n+    assertThat(f.filter(\"\", interpreter).toString()).isEqualTo(\"\");\n+    assertThat(f.filter(\"me & you\", interpreter).toString()).isEqualTo(\"me &amp; you\");\n+    assertThat(f.filter(\"jared's & ted's bogus journey\", interpreter).toString())\n       .isEqualTo(\"jared&#39;s &amp; ted&#39;s bogus journey\");\n-    assertThat(f.filter(1, interpreter)).isEqualTo(\"1\");\n+    assertThat(f.filter(1, interpreter).toString()).isEqualTo(\"1\");", "originalCommit": "8a4e36bb944158b19b046c104ab58e648dd2457a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7b76f485c9fdf171d79a9b2ce6d2ce3183dcd84", "url": "https://github.com/HubSpot/jinjava/commit/d7b76f485c9fdf171d79a9b2ce6d2ce3183dcd84", "message": "Stricter access modifier", "committedDate": "2020-05-25T20:45:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3NjU5OA==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430276598", "bodyText": "SafeString is kind of confusing, a string being \"safe\" means that you trust the contents and that it won't be escaped.\nI'm wondering if we should also check the context for interpreter.getContext().isAutoEscape .\nSomething like !(var instanceof SafeString) && interpreter.getContext().isAutoEscape()", "author": "Joeoh", "createdAt": "2020-05-26T09:25:18Z", "path": "src/main/java/com/hubspot/jinjava/lib/exptest/IsEscapedExpTest.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.hubspot.jinjava.lib.exptest;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.doc.annotations.JinjavaSnippet;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import com.hubspot.jinjava.objects.SafeString;\n+\n+@JinjavaDoc(\n+  value = \"Return true if the object is marked as escaped.\",\n+  input = @JinjavaParam(value = \"object\", type = \"object\", required = true),\n+  snippets = {\n+    @JinjavaSnippet(\n+      code = \"{% if 'test' is escaped %}\\n\" +\n+      \"      <!--this code will not render-->\\n\" +\n+      \"{% endif %}\"\n+    ),\n+    @JinjavaSnippet(\n+      code = \"{% if ('test'|escape) is escaped %}\\n\" +\n+      \"      <!--this code will render-->\\n\" +\n+      \"{% endif %}\"\n+    ),\n+    @JinjavaSnippet(\n+      code = \"{% if ('test'|safe) is escaped %}\\n\" +\n+      \"      <!--this code will render-->\\n\" +\n+      \"{% endif %}\"\n+    )\n+  }\n+)\n+public class IsEscapedExpTest implements ExpTest {\n+\n+  @Override\n+  public String getName() {\n+    return \"escaped\";\n+  }\n+\n+  @Override\n+  public boolean evaluate(Object var, JinjavaInterpreter interpreter, Object... args) {\n+    return var instanceof SafeString;", "originalCommit": "d7b76f485c9fdf171d79a9b2ce6d2ce3183dcd84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5MzIzMg==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430493232", "bodyText": "Hi, thanks for reviewing!\nI have it this way because the Jinja implementation just checks for whether the value in the variable is marked safe rather than whether it actually is safe, so whether or not the output enters that if statement you linked might not actually be relevant. Also, the expression test is evaluated before that condition evaluates, so I think it makes sense that the test returns whether the value is marked safe rather than whether its value would get escaped.", "author": "tectonic8", "createdAt": "2020-05-26T15:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3NjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5MzgzNw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430493837", "bodyText": "Here's the Jinja behavior that I modeled this off of.", "author": "tectonic8", "createdAt": "2020-05-26T15:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3NjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUxMzUwMw==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r430513503", "bodyText": "Ok thanks for explaining. I guess it makes sense otherwise we would end up with double escaped strings.", "author": "Joeoh", "createdAt": "2020-05-26T15:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3NjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyNzg3MQ==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r435927871", "bodyText": "I think we need to check BigDecimal as well (see the AddFilter). BigDecimal support was added in the math filters since python supports arbitrary precision and we had to come up with a workaround for Java.", "author": "mattcoley", "createdAt": "2020-06-05T13:40:19Z", "path": "src/main/java/com/hubspot/jinjava/lib/exptest/IsFloatExpTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.hubspot.jinjava.lib.exptest;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.doc.annotations.JinjavaSnippet;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+\n+@JinjavaDoc(\n+  value = \"Return true if object is a float\",\n+  input = @JinjavaParam(value = \"value\", type = \"object\", required = true),\n+  snippets = {\n+    @JinjavaSnippet(\n+      code = \"{% if num is float %}\\n\" +\n+      \"      <!--code to render if num contains an floating point value-->\\n\" +\n+      \"{% endif %}\"\n+    )\n+  }\n+)\n+public class IsFloatExpTest implements ExpTest {\n+\n+  @Override\n+  public String getName() {\n+    return \"float\";\n+  }\n+\n+  @Override\n+  public boolean evaluate(Object var, JinjavaInterpreter interpreter, Object... args) {\n+    return var instanceof Double || var instanceof Float;", "originalCommit": "d7b76f485c9fdf171d79a9b2ce6d2ce3183dcd84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkyODYyMg==", "url": "https://github.com/HubSpot/jinjava/pull/446#discussion_r435928622", "bodyText": "Same here, we will have to handle arbitrarily long numbers.", "author": "mattcoley", "createdAt": "2020-06-05T13:41:32Z", "path": "src/main/java/com/hubspot/jinjava/lib/exptest/IsIntegerExpTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.hubspot.jinjava.lib.exptest;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.doc.annotations.JinjavaSnippet;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+\n+@JinjavaDoc(\n+  value = \"Return true if object is an integer or long\",\n+  input = @JinjavaParam(value = \"value\", type = \"object\", required = true),\n+  snippets = {\n+    @JinjavaSnippet(\n+      code = \"{% if num is integer %}\\n\" +\n+      \"      <!--code to render if num contains an integral value-->\\n\" +\n+      \"{% endif %}\"\n+    )\n+  }\n+)\n+public class IsIntegerExpTest implements ExpTest {\n+\n+  @Override\n+  public String getName() {\n+    return \"integer\";\n+  }\n+\n+  @Override\n+  public boolean evaluate(Object var, JinjavaInterpreter interpreter, Object... args) {\n+    return var instanceof Integer || var instanceof Long;", "originalCommit": "d7b76f485c9fdf171d79a9b2ce6d2ce3183dcd84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63c278c17addfde7eee75e60b242b941fb456c3e", "url": "https://github.com/HubSpot/jinjava/commit/63c278c17addfde7eee75e60b242b941fb456c3e", "message": "Revert \"Fix escape tests for type\"\n\nThis reverts commit 8a4e36bb944158b19b046c104ab58e648dd2457a.", "committedDate": "2020-06-12T07:12:12Z", "type": "commit"}, {"oid": "2f53e5504e44739b547f557e9db62eef278809b7", "url": "https://github.com/HubSpot/jinjava/commit/2f53e5504e44739b547f557e9db62eef278809b7", "message": "Revert \"Implement is escaped exp test\"\n\nThis reverts commit 41909b0c6b72aa1896432ca82cd23999c4093772.", "committedDate": "2020-06-12T07:12:25Z", "type": "commit"}, {"oid": "f92816f3f7c0d5662d116f3f144812db63a85b22", "url": "https://github.com/HubSpot/jinjava/commit/f92816f3f7c0d5662d116f3f144812db63a85b22", "message": "Revert \"Make escaping a string make it safe\"\n\nThis reverts commit 01b2c343b79153342d80b0b7e70279050eeee2e3.", "committedDate": "2020-06-12T07:12:30Z", "type": "commit"}, {"oid": "56e92df1fd32c04d3df98fd6335423e1cd6b32ed", "url": "https://github.com/HubSpot/jinjava/commit/56e92df1fd32c04d3df98fd6335423e1cd6b32ed", "message": "Support BigDecimal in is float and is integer exp tests", "committedDate": "2020-06-12T07:58:59Z", "type": "commit"}, {"oid": "0f53edba0f2f110634e862b2a9282d6723a07dec", "url": "https://github.com/HubSpot/jinjava/commit/0f53edba0f2f110634e862b2a9282d6723a07dec", "message": "Support other integral types", "committedDate": "2020-06-12T17:22:24Z", "type": "commit"}]}