{"pr_number": 1318, "pr_title": "Minor optimizations to JSON Schema", "pr_createdAt": "2020-02-07T15:28:01Z", "pr_url": "https://github.com/confluentinc/schema-registry/pull/1318", "timeline": [{"oid": "80a6c3b9a559511872dda55bcfa0d62dc4e263fb", "url": "https://github.com/confluentinc/schema-registry/commit/80a6c3b9a559511872dda55bcfa0d62dc4e263fb", "message": "Refactor perf tests", "committedDate": "2020-02-07T03:33:38Z", "type": "commit"}, {"oid": "e2735bd220f38ce8e3bca0cf630c5df1d3a464f6", "url": "https://github.com/confluentinc/schema-registry/commit/e2735bd220f38ce8e3bca0cf630c5df1d3a464f6", "message": "Optimizations for JSON Schema", "committedDate": "2020-02-07T05:48:53Z", "type": "commit"}, {"oid": "4aa27589ac389d26628e3440fe0b952da9330853", "url": "https://github.com/confluentinc/schema-registry/commit/4aa27589ac389d26628e3440fe0b952da9330853", "message": "Minor improvement to copy APIs", "committedDate": "2020-02-07T07:26:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376512899", "bodyText": "Is this ever accessed concurrently ? If so, we should protect the 'schemaObj' field when accessing it. This was likely not a problem before since the field was set in the constructor.", "author": "dragosvictor", "createdAt": "2020-02-07T17:27:14Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -66,87 +69,116 @@\n \n   private transient String canonicalString;\n \n-  private final ObjectMapper objectMapper = Jackson.newObjectMapper();\n+  private static final ObjectMapper objectMapper = Jackson.newObjectMapper();\n \n   @VisibleForTesting\n   public JsonSchema(JsonNode jsonNode) throws JsonProcessingException {\n-    this(new ObjectMapper().writeValueAsString(jsonNode));\n+    this(jsonNode, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(String schemaString) {\n     this(schemaString, Collections.emptyList(), Collections.emptyMap(), null);\n   }\n \n   public JsonSchema(\n-      String schemaString,\n+      JsonNode jsonNode,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       Integer version\n   ) {\n-    SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n-    if (resolvedReferences != null) {\n-      try {\n-        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n-          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n-        }\n-      } catch (URISyntaxException e) {\n-        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n-      }\n-    }\n-    builder.schemaJson(new JSONObject(schemaString));\n-    SchemaLoader loader = builder.build();\n-    this.schemaObj = loader.load().build();\n+    this.jsonNode = jsonNode;\n     this.version = version;\n     this.references = Collections.unmodifiableList(references);\n     this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n   }\n \n+  public JsonSchema(\n+      String schemaString,\n+      List<SchemaReference> references,\n+      Map<String, String> resolvedReferences,\n+      Integer version\n+  ) {\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaString);\n+      this.version = version;\n+      this.references = Collections.unmodifiableList(references);\n+      this.resolvedReferences = Collections.unmodifiableMap(resolvedReferences);\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaString, e);\n+    }\n+  }\n+\n   public JsonSchema(Schema schemaObj) {\n     this(schemaObj, null);\n   }\n \n   public JsonSchema(Schema schemaObj, Integer version) {\n-    this.schemaObj = schemaObj;\n-    this.version = version;\n-    this.references = Collections.emptyList();\n-    this.resolvedReferences = Collections.emptyMap();\n+    try {\n+      this.jsonNode = objectMapper.readTree(schemaObj.toString());\n+      this.schemaObj = schemaObj;\n+      this.version = version;\n+      this.references = Collections.emptyList();\n+      this.resolvedReferences = Collections.emptyMap();\n+    } catch (IOException e) {\n+      throw new IllegalArgumentException(\"Invalid JSON \" + schemaObj.toString(), e);\n+    }\n   }\n \n   private JsonSchema(\n+      JsonNode jsonNode,\n       Schema schemaObj,\n       Integer version,\n       List<SchemaReference> references,\n       Map<String, String> resolvedReferences,\n       String canonicalString\n   ) {\n+    this.jsonNode = jsonNode;\n     this.schemaObj = schemaObj;\n     this.version = version;\n     this.references = references;\n     this.resolvedReferences = resolvedReferences;\n     this.canonicalString = canonicalString;\n   }\n \n-  public static JsonSchema copy(JsonSchema schema) {\n+  public JsonSchema copy() {\n     return new JsonSchema(\n-        schema.schemaObj,\n-        schema.version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.jsonNode,\n+        this.schemaObj,\n+        this.version,\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n-  public static JsonSchema copy(JsonSchema schema, Integer version) {\n+  public JsonSchema copy(Integer version) {\n     return new JsonSchema(\n-        schema.schemaObj,\n+        this.jsonNode,\n+        this.schemaObj,\n         version,\n-        schema.references,\n-        schema.resolvedReferences,\n-        schema.canonicalString\n+        this.references,\n+        this.resolvedReferences,\n+        this.canonicalString\n     );\n   }\n \n   public Schema rawSchema() {\n+    if (schemaObj == null) {\n+      try {\n+        SchemaLoader.SchemaLoaderBuilder builder = SchemaLoader.builder();\n+        for (Map.Entry<String, String> dep : resolvedReferences.entrySet()) {\n+          builder.registerSchemaByURI(new URI(dep.getKey()), new JSONObject(dep.getValue()));\n+        }\n+        JSONObject jsonObject = objectMapper.treeToValue((jsonNode), JSONObject.class);\n+        builder.schemaJson(jsonObject);\n+        SchemaLoader loader = builder.build();\n+        schemaObj = loader.load().build();\n+      } catch (URISyntaxException e) {\n+        throw new IllegalArgumentException(\"Invalid dependency name\", e);\n+      } catch (IOException e) {\n+        throw new IllegalArgumentException(\"Invalid JSON\", e);\n+      }\n+    }", "originalCommit": "4aa27589ac389d26628e3440fe0b952da9330853", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUyNzg0MQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376527841", "bodyText": "This class is not meant to be accessed concurrently.", "author": "rayokota", "createdAt": "2020-02-07T18:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUzODM3Nw==", "url": "https://github.com/confluentinc/schema-registry/pull/1318#discussion_r376538377", "bodyText": "Got it !", "author": "dragosvictor", "createdAt": "2020-02-07T18:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxMjg5OQ=="}], "type": "inlineReview"}]}