{"pr_number": 1614, "pr_title": "Add failing compatibility reason in rest response ", "pr_createdAt": "2020-09-02T16:56:51Z", "pr_url": "https://github.com/confluentinc/schema-registry/pull/1614", "timeline": [{"oid": "4edfceaed3e7c6d0dc843491ee09d1870e2e37c2", "url": "https://github.com/confluentinc/schema-registry/commit/4edfceaed3e7c6d0dc843491ee09d1870e2e37c2", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-03T21:52:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMTc4NQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485111785", "bodyText": "nit: other wise -> otherwise", "author": "rayokota", "createdAt": "2020-09-08T18:21:00Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java", "diffHunk": "@@ -34,6 +36,7 @@\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n+   * @return List of error message, other wise empty list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMzY1Nw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485113657", "bodyText": "Change to\nList<String> result = new ArrayList<>();\nresult.addAll(existing.isBackwardCompatible(toValidate);\nresult.addAll(toValidate.isBackwardCompatible(existing);\nreturn result;", "author": "rayokota", "createdAt": "2020-09-08T18:24:33Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java", "diffHunk": "@@ -53,8 +55,21 @@ public SchemaValidatorBuilder canBeReadStrategy() {\n    * and vice-versa, according to the JSON default schema resolution.\n    */\n   public SchemaValidatorBuilder mutualReadStrategy() {\n-    this.strategy = (toValidate, existing) -> existing.isBackwardCompatible(toValidate)\n-        && toValidate.isBackwardCompatible(existing);\n+\n+    this.strategy = (toValidate, existing) -> {\n+      List<String> backward = existing.isBackwardCompatible(toValidate);", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDY0Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114646", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:22Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDY5Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114692", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDgwMw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114803", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:44Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjg2MQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485116861", "bodyText": "This is not the correct usage of String.format, you can replace with\n\"Unexpected exception during compatibility check: \" + e.getMessage()", "author": "rayokota", "createdAt": "2020-09-08T18:30:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\n+              String.format(\"Unexpected exception during compatibility check\", e)));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODAwMA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485118000", "bodyText": "Change public -> default and have the implementation throw new UnsupportedOperationException()", "author": "rayokota", "createdAt": "2020-09-08T18:32:43Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -121,6 +121,9 @@ default boolean testCompatibility(String subject, org.apache.avro.Schema schema)\n   public boolean testCompatibility(String subject, ParsedSchema schema)\n       throws IOException, RestClientException;\n \n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema schema)", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExOTQ3MA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485119470", "bodyText": "Let's call this property \"messages\" and getMessages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:35:22Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -45,6 +50,16 @@ public String toJson() throws IOException {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n+  @JsonProperty(\"error_messages\")", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExOTY0Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485119642", "bodyText": "Let's call this property \"messages\" and getMessages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:35:43Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -45,6 +50,16 @@ public String toJson() throws IOException {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n+  @JsonProperty(\"error_messages\")\n+  public List<String> getErrorMessages() {\n+    return errorMessages;\n+  }\n+\n+  @JsonProperty(\"error_messages\")", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyMzQxNg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485123416", "bodyText": "Let's call this property messages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:43:03Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -16,16 +16,21 @@\n \n package io.confluent.kafka.schemaregistry.client.rest.entities.requests;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n import java.io.IOException;\n \n import io.confluent.kafka.schemaregistry.utils.JacksonMapper;\n+\n+import java.util.List;\n import java.util.Objects;\n \n+@JsonInclude(JsonInclude.Include.NON_NULL)\n public class CompatibilityCheckResponse {\n \n   private boolean isCompatible;\n+  private List<String> errorMessages = null;", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTA4NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125084", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:04Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1281,7 +1282,7 @@ public CompatibilityLevel getCompatibilityLevelInScope(String subject)\n   }\n \n   @Override\n-  public boolean isCompatible(String subject,\n+  public List<String> isCompatible(String subject,\n                               Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTE0OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125148", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:10Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1296,7 +1297,7 @@ public boolean isCompatible(String subject,\n    * @param previousSchemas Full schema history in chronological order\n    */\n   @Override\n-  public boolean isCompatible(String subject,\n+  public List<String> isCompatible(String subject,\n                               Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTIyNA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125224", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:17Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1316,7 +1317,7 @@ public boolean isCompatible(String subject,\n     return isCompatibleWithPrevious(subject, parsedSchema, prevParsedSchemas);\n   }\n \n-  private boolean isCompatibleWithPrevious(String subject,\n+  private List<String> isCompatibleWithPrevious(String subject,\n                                            ParsedSchema parsedSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTI5Mw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125293", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:26Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java", "diffHunk": "@@ -71,11 +71,11 @@ Schema get(String subject, int version, boolean returnDeletedSchema)\n   Schema lookUpSchemaUnderSubject(String subject, Schema schema, boolean lookupDeletedSchema)\n       throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTQ4OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125488", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:47Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java", "diffHunk": "@@ -71,11 +71,11 @@ Schema get(String subject, int version, boolean returnDeletedSchema)\n   Schema lookUpSchemaUnderSubject(String subject, Schema schema, boolean lookupDeletedSchema)\n       throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,\n                        Schema targetSchema) throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTk5NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125994", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-08T18:47:44Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -300,9 +302,9 @@ private static boolean isPrimitive(Object value) {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNjU3Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485126576", "bodyText": "Use ArrayList instead of LinkedList", "author": "rayokota", "createdAt": "2020-09-08T18:48:48Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -314,17 +316,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNzQ4Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485127482", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-08T18:50:18Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -785,9 +787,9 @@ public void validate() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNzU2OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485127568", "bodyText": "Use ArrayList", "author": "rayokota", "createdAt": "2020-09-08T18:50:28Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -798,17 +800,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyODg0Mw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485128843", "bodyText": "Actually RestService is more like an internal class (SchemaRegistryClient wraps it), so we can change this interface by adding a boolean verbose flag to the existing testCompatibility method", "author": "rayokota", "createdAt": "2020-09-08T18:52:56Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -549,6 +549,47 @@ public boolean testCompatibility(Map<String, String> requestProperties,\n     return response.getIsCompatible();\n   }\n \n+  public List<String> testCompatibilityVerbose(String schemaString,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNDM3OQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485134379", "bodyText": "A few lines above this line, we catch InvalidSchemaException.  If verbose is true, instead of throwing an exception, let's put the error message from InvalidSchemaException in a CompatibilityCheckResponse and return that.", "author": "rayokota", "createdAt": "2020-09-08T19:02:57Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java", "diffHunk": "@@ -137,11 +141,22 @@ public void testCompatibilityBySubjectName(\n       throw Errors.schemaRegistryException(", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MTE4Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485051186", "bodyText": "I guess the whole \"if else\" block can be replaced by a single if given the other collection is empty in the else if we change a bit the condition.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!backward.isEmpty() && !forward.isEmpty()) {\n          \n          \n            \n                    backward.addAll(forward);\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else if (!backward.isEmpty()) {\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else if (!forward.isEmpty())  {\n          \n          \n            \n                    return forward;\n          \n          \n            \n                  } else {\n          \n          \n            \n                    return Collections.emptyList();\n          \n          \n            \n                  }\n          \n          \n            \n                  if (!backward.isEmpty() || !forward.isEmpty()) {\n          \n          \n            \n                    backward.addAll(forward);\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else {\n          \n          \n            \n                    return Collections.emptyList();\n          \n          \n            \n                  }", "author": "ImFlog", "createdAt": "2020-09-08T16:31:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java", "diffHunk": "@@ -53,8 +55,21 @@ public SchemaValidatorBuilder canBeReadStrategy() {\n    * and vice-versa, according to the JSON default schema resolution.\n    */\n   public SchemaValidatorBuilder mutualReadStrategy() {\n-    this.strategy = (toValidate, existing) -> existing.isBackwardCompatible(toValidate)\n-        && toValidate.isBackwardCompatible(existing);\n+\n+    this.strategy = (toValidate, existing) -> {\n+      List<String> backward = existing.isBackwardCompatible(toValidate);\n+      List<String> forward = toValidate.isBackwardCompatible(existing);\n+      if (!backward.isEmpty() && !forward.isEmpty()) {\n+        backward.addAll(forward);\n+        return backward;\n+      } else if (!backward.isEmpty()) {\n+        return backward;\n+      } else if (!forward.isEmpty())  {\n+        return forward;\n+      } else {\n+        return Collections.emptyList();\n+      }", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Mjk0NQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485052945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return List of error message, other wise empty list\n          \n          \n            \n               * @return List of error message, otherwise empty list", "author": "ImFlog", "createdAt": "2020-09-08T16:34:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java", "diffHunk": "@@ -34,6 +36,7 @@\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n+   * @return List of error message, other wise empty list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MzEyOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485053128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return empty list if the schema is compatible with the provided schema, other wise the list\n          \n          \n            \n               * @return List of error message, otherwise empty list", "author": "ImFlog", "createdAt": "2020-09-08T16:34:50Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java", "diffHunk": "@@ -42,6 +44,8 @@\n    * @param toValidate The schema to validate\n    * @param existing The schemas to validate against, in order from most recent to latest if\n    *     applicable\n+   * @return empty list if the schema is compatible with the provided schema, other wise the list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NjY4Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485056682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n          \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specified.\"));", "author": "ImFlog", "createdAt": "2020-09-08T16:40:56Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -364,6 +365,29 @@ public boolean testCompatibility(String subject, ParsedSchema newSchema) throws\n           schemaMetadata.getId()));\n     }\n \n+    return newSchema.isCompatible(compatibilityLevel, schemaHistory).isEmpty();\n+  }\n+\n+  @Override\n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema newSchema)\n+          throws IOException, RestClientException {\n+    String compatibility = compatibilityCache.get(subject);\n+    if (compatibility == null) {\n+      compatibility = defaultCompatibility;\n+    }\n+\n+    CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n+    if (compatibilityLevel == null) {\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTU2OQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Arrays.asList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T17:21:25Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTcyOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(e.toString()));\n          \n          \n            \n                  return Arrays.asList(e.toString());", "author": "ImFlog", "createdAt": "2020-09-08T17:21:42Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTk3MQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\n          \n          \n            \n                          String.format(\"Unexpected exception during compatibility check\", e)));\n          \n          \n            \n                  return Arrays.asList(\n          \n          \n            \n                          String.format(\"Unexpected exception during compatibility check\", e));", "author": "ImFlog", "createdAt": "2020-09-08T17:22:09Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\n+              String.format(\"Unexpected exception during compatibility check\", e)));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4MDQwOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485080408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n          \n          \n            \n                  return Arrays.asList(\"Compatibility level not specified.\");", "author": "ImFlog", "createdAt": "2020-09-08T17:22:51Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -364,6 +365,29 @@ public boolean testCompatibility(String subject, ParsedSchema newSchema) throws\n           schemaMetadata.getId()));\n     }\n \n+    return newSchema.isCompatible(compatibilityLevel, schemaHistory).isEmpty();\n+  }\n+\n+  @Override\n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema newSchema)\n+          throws IOException, RestClientException {\n+    String compatibility = compatibilityCache.get(subject);\n+    if (compatibility == null) {\n+      compatibility = defaultCompatibility;\n+    }\n+\n+    CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n+    if (compatibilityLevel == null) {\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485083772", "bodyText": "I guess this could be put in common with the existing compatibility check rest call from the testCompatibility method.\nAlso adding a new field to the response should not break compatibility so maybe we could remove the queryParam. WDYT ?\nCC @rayokota", "author": "ImFlog", "createdAt": "2020-09-08T17:28:47Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -549,6 +549,47 @@ public boolean testCompatibility(Map<String, String> requestProperties,\n     return response.getIsCompatible();\n   }\n \n+  public List<String> testCompatibilityVerbose(String schemaString,\n+                                               String schemaType,\n+                                               List<SchemaReference> references,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    RegisterSchemaRequest request = new RegisterSchemaRequest();\n+    request.setSchema(schemaString);\n+    request.setSchemaType(schemaType);\n+    request.setReferences(references);\n+    return testCompatibilityVerbose(request, subject, version);\n+  }\n+\n+  public List<String> testCompatibilityVerbose(RegisterSchemaRequest registerSchemaRequest,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    return testCompatibilityVerbose(\n+        DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest, subject, version);\n+  }\n+\n+  public List<String> testCompatibilityVerbose(Map<String, String> requestProperties,\n+                                               RegisterSchemaRequest registerSchemaRequest,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    UriBuilder builder =\n+        UriBuilder.fromPath(\"/compatibility/subjects/{subject}/versions/{version}\");\n+    builder.queryParam(\"verbose\", true);\n+    String path = builder.build(subject, version).toString();\n+\n+    CompatibilityCheckResponse response =\n+        httpRequest(\n+            path,\n+            \"POST\",\n+            registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n+            requestProperties,\n+            COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxMjU2Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485212562", "bodyText": "Unfortunately the CompatibilityCheckResponse was not declared with @JsonIgnoreProperties(ignoreUnknown = true) so older clients will break if we add a new field to the response.", "author": "rayokota", "createdAt": "2020-09-08T21:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ2NDYwOQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485464609", "bodyText": "Oh yes, good catch.\nWe could add this annotation in the PR to avoid issues like this in the future ?", "author": "ImFlog", "createdAt": "2020-09-09T09:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4OTcxMA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485089710", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Arrays.asList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T17:39:45Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -300,9 +302,9 @@ private static boolean isPrimitive(Object value) {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MDU2Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485090562", "bodyText": "You can move the two errorMessages.add(..) after the if / else block to remove the duplicated lines.", "author": "ImFlog", "createdAt": "2020-09-08T17:41:16Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -798,17 +800,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();\n       for (Difference incompatibleDiff : incompatibleDiffs) {\n         if (first) {\n           // Log first incompatible change as warning\n           log.warn(\"Found incompatible change: {}\", incompatibleDiff);\n+          errorMessages.add(String.format(\"Found incompatible change: {}\", incompatibleDiff));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNDQ2NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485834464", "bodyText": "Good suggestion", "author": "rayokota", "createdAt": "2020-09-09T18:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTI4NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485141284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                    return Collections.singletonList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T19:16:38Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java", "diffHunk": "@@ -95,13 +97,14 @@ default void validate() {\n    *\n    * @param level the compatibility level\n    * @param previousSchemas full schema history in chronological order\n-   * @return whether this schema is compatible with the previous schemas\n+   * @return an empty list if this schema is backward compatible with the previous schema, otherwise\n+   *         the list of error messages\n    */\n-  default boolean isCompatible(CompatibilityLevel level,\n-                               List<? extends ParsedSchema> previousSchemas) {\n+  default List<String> isCompatible(\n+      CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return false;\n+        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjAzNA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485142034", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Collections.singletonList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T19:18:14Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "url": "https://github.com/confluentinc/schema-registry/commit/1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "message": "typo fix, style fix, add boolean verbose flag to RestService.testCompatibility() and tests update", "committedDate": "2020-09-08T22:06:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyOTk2OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485829968", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-09T18:32:42Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java", "diffHunk": "@@ -95,13 +97,14 @@ default void validate() {\n    *\n    * @param level the compatibility level\n    * @param previousSchemas full schema history in chronological order\n-   * @return whether this schema is compatible with the previous schemas\n+   * @return an empty list if this schema is backward compatible with the previous schema, otherwise\n+   *         the list of error messages\n    */\n-  default boolean isCompatible(CompatibilityLevel level,\n-                               List<? extends ParsedSchema> previousSchemas) {\n+  default List<String> isCompatible(\n+      CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return false;\n+        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMDQyMw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485830423", "bodyText": "e.toString -> e.getMessage", "author": "rayokota", "createdAt": "2020-09-09T18:33:34Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +157,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return Collections.singletonList(e.toString());", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNjM3NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485836374", "bodyText": "Checkstyle is complaining that this has the wrong indentation", "author": "rayokota", "createdAt": "2020-09-09T18:44:45Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java", "diffHunk": "@@ -63,7 +63,9 @@\n   public static final CompatibilityChecker FULL_TRANSITIVE_CHECKER = new CompatibilityChecker(\n       FULL_TRANSITIVE_VALIDATOR);\n \n-  private static final SchemaValidator NO_OP_VALIDATOR = (schema, schemas) -> true;\n+  private static final SchemaValidator NO_OP_VALIDATOR =\n+          (schema, schemas) -> Collections.emptyList();", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "url": "https://github.com/confluentinc/schema-registry/commit/be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "edf5ec6f2a3ffed8a5e339b97bd904e2b637628b", "url": "https://github.com/confluentinc/schema-registry/commit/edf5ec6f2a3ffed8a5e339b97bd904e2b637628b", "message": "bugs fix", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "df0e2046c1acdf5109fd7b704098f75221bb9769", "url": "https://github.com/confluentinc/schema-registry/commit/df0e2046c1acdf5109fd7b704098f75221bb9769", "message": "add ?verbose queryparam to CompatibilityResource.testCompatibilityBySubjectName()", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "0d127c093800206fd6623ad71a71223b0c4b1a0e", "url": "https://github.com/confluentinc/schema-registry/commit/0d127c093800206fd6623ad71a71223b0c4b1a0e", "message": "bug fix", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "a6cb68a6c2a3ba1f9689ebb361137f9ab2c90e6a", "url": "https://github.com/confluentinc/schema-registry/commit/a6cb68a6c2a3ba1f9689ebb361137f9ab2c90e6a", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "785778a438c7589cd3d9e5c1ec7083f7bcc55bae", "url": "https://github.com/confluentinc/schema-registry/commit/785778a438c7589cd3d9e5c1ec7083f7bcc55bae", "message": "add ?verbose queryparam to CompatibilityResource.testCompatibilityBySubjectName()", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "8fd3cebb4c92955a982d8fb6c3358fe9c8ea553b", "url": "https://github.com/confluentinc/schema-registry/commit/8fd3cebb4c92955a982d8fb6c3358fe9c8ea553b", "message": "typo fix, style fix, add boolean verbose flag to RestService.testCompatibility() and tests update", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "url": "https://github.com/confluentinc/schema-registry/commit/bbff6869be4edc038c057c2cfbe9ec21ab724657", "message": "fix indentation, bug fix", "committedDate": "2020-09-09T20:09:08Z", "type": "commit"}, {"oid": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "url": "https://github.com/confluentinc/schema-registry/commit/bbff6869be4edc038c057c2cfbe9ec21ab724657", "message": "fix indentation, bug fix", "committedDate": "2020-09-09T20:09:08Z", "type": "forcePushed"}]}