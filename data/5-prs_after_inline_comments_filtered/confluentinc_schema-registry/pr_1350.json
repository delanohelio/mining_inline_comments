{"pr_number": 1350, "pr_title": "Add REST API to get versions for id", "pr_createdAt": "2020-02-20T20:34:00Z", "pr_url": "https://github.com/confluentinc/schema-registry/pull/1350", "timeline": [{"oid": "45cb0783407678052e188603784f6cf9b0080fe7", "url": "https://github.com/confluentinc/schema-registry/commit/45cb0783407678052e188603784f6cf9b0080fe7", "message": "Add REST API to get versions for id", "committedDate": "2020-02-20T20:32:54Z", "type": "commit"}, {"oid": "203eb85a949f3c2b16d4b47d19dab3f4bde6d57d", "url": "https://github.com/confluentinc/schema-registry/commit/203eb85a949f3c2b16d4b47d19dab3f4bde6d57d", "message": "Fix copyright", "committedDate": "2020-02-20T20:35:22Z", "type": "commit"}, {"oid": "4b6183a69a36c81f1ba48755ee5463825f243c92", "url": "https://github.com/confluentinc/schema-registry/commit/4b6183a69a36c81f1ba48755ee5463825f243c92", "message": "Add default impl for getAllVersionsById\n\nAlso add back some deprecations", "committedDate": "2020-02-24T18:27:22Z", "type": "commit"}, {"oid": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c", "url": "https://github.com/confluentinc/schema-registry/commit/3e69ee4bd38a17cecbe00e5f63e9434198a6018c", "message": "Allow clients to modify schema during compat checks", "committedDate": "2020-02-24T18:28:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MDEyMQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383460121", "bodyText": "Here and below: we already throw, why the log message ?", "author": "dragosvictor", "createdAt": "2020-02-24T19:14:39Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -796,14 +797,18 @@ private void forwardSetModeRequestToMaster(\n   }\n \n   private void canonicalizeSchema(Schema schema) throws InvalidSchemaException {\n-    if (schema == null || schema.getSchema().trim().isEmpty()) {\n+    if (schema == null\n+        || schema.getSchema() == null\n+        || schema.getSchema().trim().isEmpty()) {\n+      log.error(\"Empty schema\");\n       throw new InvalidSchemaException(\"Empty schema\");", "originalCommit": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2ODM2NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383468364", "bodyText": "Just to make sure it appears in the log.", "author": "rayokota", "createdAt": "2020-02-24T19:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MjQ3Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383462472", "bodyText": "Do we know for sure the list has the same order as returned by the underlying map ?", "author": "dragosvictor", "createdAt": "2020-02-24T19:19:21Z", "path": "core/src/test/java/io/confluent/kafka/schemaregistry/rest/RestApiTest.java", "diffHunk": "@@ -590,6 +591,21 @@ public void testGetSubjectsAssociatedWithNotFoundSchemaId() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testGetVersionsAssociatedWithSchemaId() throws Exception {\n+    String subject1 = \"testTopic1\";\n+    String subject2 = \"testTopic2\";\n+\n+    String schema = TestUtils.getRandomCanonicalAvroString(1).get(0);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject1);\n+    TestUtils.registerAndVerifySchema(restApp.restClient, schema, 1, subject2);\n+\n+    List<SubjectVersion> associatedSubjects = restApp.restClient.getAllVersionsById(1);\n+    assertEquals(associatedSubjects.size(), 2);\n+    assertEquals(Arrays.asList(new SubjectVersion(subject1, 1), new SubjectVersion(subject2, 1)),\n+        associatedSubjects);", "originalCommit": "3e69ee4bd38a17cecbe00e5f63e9434198a6018c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2ODM1Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383468352", "bodyText": "Good point, I'll fix it", "author": "rayokota", "createdAt": "2020-02-24T19:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MjQ3Mg=="}], "type": "inlineReview"}, {"oid": "c5db3b83272ab72d40fee33934ab39d3953e2c6f", "url": "https://github.com/confluentinc/schema-registry/commit/c5db3b83272ab72d40fee33934ab39d3953e2c6f", "message": "Fix test to not rely on array order", "committedDate": "2020-02-24T19:31:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4NTgzOQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383485839", "bodyText": "Should we have a copy method for Schema?", "author": "tuvtran", "createdAt": "2020-02-24T20:04:57Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -970,6 +976,38 @@ public SchemaString get(\n     )).allSubjects();\n   }\n \n+  public List<SubjectVersion> listVersionsForId(int id) throws SchemaRegistryException {\n+    SchemaValue schema = null;\n+    try {\n+      SchemaKey subjectVersionKey = lookupCache.schemaKeyById(id);\n+      if (subjectVersionKey == null) {\n+        return null;\n+      }\n+      schema = (SchemaValue) kafkaStore.get(subjectVersionKey);\n+      if (schema == null) {\n+        return null;\n+      }\n+    } catch (StoreException e) {\n+      throw new SchemaRegistryStoreException(\"Error while retrieving schema with id \"\n+                                              + id + \" from the backend Kafka store\", e);\n+    }\n+\n+    return lookupCache.schemaIdAndSubjects(new Schema(", "originalCommit": "c5db3b83272ab72d40fee33934ab39d3953e2c6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383486982", "bodyText": "Since the function only checks compatibility should we avoid adding side effect to newSchema?", "author": "tuvtran", "createdAt": "2020-02-24T20:07:25Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1155,7 +1193,11 @@ public boolean isCompatible(String subject,\n       prevParsedSchemas.add(prevParsedSchema);\n     }\n \n-    return parseSchema(newSchema).isCompatible(compatibility, prevParsedSchemas);\n+    ParsedSchema parsedSchema = parseSchema(newSchema);\n+    boolean isCompatible = parsedSchema.isCompatible(compatibility, prevParsedSchemas);\n+    // Allow schema providers to modify the schema during compatibility checks\n+    newSchema.setSchema(parsedSchema.canonicalString());", "originalCommit": "c5db3b83272ab72d40fee33934ab39d3953e2c6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MDM0NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383490344", "bodyText": "I'm allowing for use cases where the new schema can be merged with the older schema during the compat check.  I added this JavaDoc elsewhere in the PR:\nCustom providers may choose to modify this schema during this check, to ensure that it is compatible with the specified schema.", "author": "rayokota", "createdAt": "2020-02-24T20:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5MTk4NQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1350#discussion_r383491985", "bodyText": "Gotcha. Thanks!", "author": "tuvtran", "createdAt": "2020-02-24T20:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ4Njk4Mg=="}], "type": "inlineReview"}]}