{"pr_number": 1323, "pr_title": "Implement CDateSet as Bitset backed as the original was pretty slow.", "pr_createdAt": "2020-08-24T10:07:33Z", "pr_url": "https://github.com/bakdata/conquery/pull/1323", "timeline": [{"oid": "a2f58264c1ffc40d85b7fa3a284e9f36cdd374b4", "url": "https://github.com/bakdata/conquery/commit/a2f58264c1ffc40d85b7fa3a284e9f36cdd374b4", "message": "First draft of Bitmap backed CDateSet", "committedDate": "2020-08-26T13:47:34Z", "type": "commit"}, {"oid": "90cdcadc6d94c23ced9d2e83d8f403d6d2e53eb6", "url": "https://github.com/bakdata/conquery/commit/90cdcadc6d94c23ced9d2e83d8f403d6d2e53eb6", "message": "Simpler implementation of AsRanges and more tests fopr BitMapCDateSet", "committedDate": "2020-08-26T13:47:35Z", "type": "commit"}, {"oid": "ea72dd41118f1df28760d90dc5c3bd030096da38", "url": "https://github.com/bakdata/conquery/commit/ea72dd41118f1df28760d90dc5c3bd030096da38", "message": "More cases for BitMapCDateSet.java", "committedDate": "2020-08-26T13:47:35Z", "type": "commit"}, {"oid": "e4e5f54d02f0a0a0a751eb64506dc3b12240d24a", "url": "https://github.com/bakdata/conquery/commit/e4e5f54d02f0a0a0a751eb64506dc3b12240d24a", "message": "- Coverage driven test Cases for BitMapCDateSet.java\n- Implementation of intersects\n- Proper implementation of encloses\n- Cleanup of retain", "committedDate": "2020-08-26T13:47:35Z", "type": "commit"}, {"oid": "caf6cf59bd5ab1256f96ad2c59d55f3810557155", "url": "https://github.com/bakdata/conquery/commit/caf6cf59bd5ab1256f96ad2c59d55f3810557155", "message": "WIP: Refactor CDateSet into an interface ICDateSet, make as many as possible classes use ICDateSet if possible towards BitMapCDateset", "committedDate": "2020-08-26T13:47:35Z", "type": "commit"}, {"oid": "23aec4ddd667a7ae0d8a1e77bddba568d536491c", "url": "https://github.com/bakdata/conquery/commit/23aec4ddd667a7ae0d8a1e77bddba568d536491c", "message": "Fix maskedAdd for QueryEngine", "committedDate": "2020-08-26T13:47:35Z", "type": "commit"}, {"oid": "2992f9f480d1cfaaf6e87402a1b36232e9463e26", "url": "https://github.com/bakdata/conquery/commit/2992f9f480d1cfaaf6e87402a1b36232e9463e26", "message": "apply usage of BitMapCDateSet in QueryEngine (this is just WIP to gauge the effectiveness of it!)", "committedDate": "2020-08-26T13:47:36Z", "type": "commit"}, {"oid": "4ba4679c286db30a583986de68ccfd7a4d1ebe2d", "url": "https://github.com/bakdata/conquery/commit/4ba4679c286db30a583986de68ccfd7a4d1ebe2d", "message": "minor improvements and more usage of BitMapCDateSet", "committedDate": "2020-08-26T13:47:36Z", "type": "commit"}, {"oid": "18087082f4ccab344f22aeda881d18144c15c810", "url": "https://github.com/bakdata/conquery/commit/18087082f4ccab344f22aeda881d18144c15c810", "message": "fix clearing out of range values for open ranges", "committedDate": "2020-08-26T14:04:49Z", "type": "commit"}, {"oid": "3d1db533cc3c71d61188324cb1295aa07784bffa", "url": "https://github.com/bakdata/conquery/commit/3d1db533cc3c71d61188324cb1295aa07784bffa", "message": "Fix serialization and retainAll for BitMapCDateSet to fix CQExternal", "committedDate": "2020-08-26T14:43:07Z", "type": "commit"}, {"oid": "3d1db533cc3c71d61188324cb1295aa07784bffa", "url": "https://github.com/bakdata/conquery/commit/3d1db533cc3c71d61188324cb1295aa07784bffa", "message": "Fix serialization and retainAll for BitMapCDateSet to fix CQExternal", "committedDate": "2020-08-26T14:43:07Z", "type": "forcePushed"}, {"oid": "fb545e6978b0aef65c623509ca702daee380b6a1", "url": "https://github.com/bakdata/conquery/commit/fb545e6978b0aef65c623509ca702daee380b6a1", "message": "automatic update to docs", "committedDate": "2020-08-27T08:57:02Z", "type": "commit"}, {"oid": "b7a08b68789bd5093005277ddd699039eff30426", "url": "https://github.com/bakdata/conquery/commit/b7a08b68789bd5093005277ddd699039eff30426", "message": "cleanup, removing unused methods", "committedDate": "2020-08-28T14:52:08Z", "type": "commit"}, {"oid": "e17f1afb07436e9514982b50ab571af0fd243382", "url": "https://github.com/bakdata/conquery/commit/e17f1afb07436e9514982b50ab571af0fd243382", "message": "fix some bugs in BitMapCDateSet.java", "committedDate": "2020-08-28T15:06:35Z", "type": "commit"}, {"oid": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "url": "https://github.com/bakdata/conquery/commit/74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "message": "fix cast mixup in CDatsSetTest", "committedDate": "2020-08-28T15:09:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk0NjM4Ng==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482946386", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tretainAll(((CDateSet) retained));\n          \n          \n            \n            \t\t\tretainAll((CDateSet) retained);", "author": "thoniTUB", "createdAt": "2020-09-03T12:40:44Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/CDateSet.java", "diffHunk": "@@ -301,6 +298,12 @@ public boolean isAll() {\n \t\treturn this.rangesByLowerBound.values().iterator().next().isAll();\n \t}\n \n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif(retained instanceof CDateSet){\n+\t\t\tretainAll(((CDateSet) retained));", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk1MTEyOQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482951129", "bodyText": "ist die methode jetzt noch notwendig, wenn du schon\npublic static CDateSet create(ICDateSet rangeSet)\nhast", "author": "thoniTUB", "createdAt": "2020-09-03T12:48:40Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/CDateSet.java", "diffHunk": "@@ -47,6 +40,10 @@ public static CDateSet createFull() {\n \t\treturn set;\n \t}\n \n+\tpublic static CDateSet create(ICDateSet rangeSet) {\n+\t\treturn create(rangeSet.asRanges());\n+\t}\n+\n \tpublic static CDateSet create(CDateSet rangeSet) {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk2NDI1OQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482964259", "bodyText": "https://github.com/google/guava/wiki/ThrowablesExplained\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\tthrow new RuntimeException(e);\n          \n          \n            \n            \t\t\t\t\t\tThrowables.throwIfUnchecked(t);\n          \n          \n            \n            \t\t\t\t\t\tthrow new RuntimeException(t);", "author": "thoniTUB", "createdAt": "2020-09-03T13:09:20Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/concept/specific/CQExternal.java", "diffHunk": "@@ -84,14 +85,15 @@ public CQElement resolve(QueryResolveContext context) {\n \n \t\t\t//read the dates from the row\n \t\t\ttry {\n-\t\t\t\tCDateSet dates = dateFormat.map(df -> {\n+\t\t\t\tICDateSet dates = dateFormat.map(df -> {\n \t\t\t\t\ttry {\n \t\t\t\t\t\treturn df.readDates(dateIndices, row);\n \t\t\t\t\t}\n \t\t\t\t\tcatch (Exception e) {\n \t\t\t\t\t\tthrow new RuntimeException(e);", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3MzM2MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482973361", "bodyText": "ICDateSet -> DateSet", "author": "thoniTUB", "createdAt": "2020-09-03T13:22:53Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/ICDateSet.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.Collection;\n+\n+import com.bakdata.conquery.io.jackson.serializer.CDateSetDeserializer;\n+import com.bakdata.conquery.io.jackson.serializer.CDateSetSerializer;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+@JsonDeserialize(using= CDateSetDeserializer.class)\n+@JsonSerialize(using = CDateSetSerializer.class)\n+public interface ICDateSet {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NzYwMw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482977603", "bodyText": "Braucht man die Klasse jetzt noch?", "author": "thoniTUB", "createdAt": "2020-09-03T13:28:41Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/CDateSet.java", "diffHunk": "@@ -14,23 +14,16 @@\n import java.util.regex.Pattern;\n import java.util.stream.Collectors;\n \n-import com.bakdata.conquery.io.jackson.serializer.CDateSetDeserializer;\n-import com.bakdata.conquery.io.jackson.serializer.CDateSetSerializer;\n import com.bakdata.conquery.models.common.daterange.CDateRange;\n import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.google.common.base.Joiner;\n import com.google.common.collect.ForwardingCollection;\n import com.google.common.math.IntMath;\n-\n import lombok.EqualsAndHashCode;\n \n @EqualsAndHashCode\n-@JsonSerialize(using=CDateSetSerializer.class)\n-@JsonDeserialize(using=CDateSetDeserializer.class)\n-public class CDateSet {\n+public class CDateSet implements ICDateSet{", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyNTU0OA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483625548", "bodyText": "nein", "author": "awildturtok", "createdAt": "2020-09-04T13:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3NzYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3Nzk4MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482977981", "bodyText": "Geh\u00f6rt das nicht nach ICDateSet", "author": "thoniTUB", "createdAt": "2020-09-03T13:29:14Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyNjM5Mw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483626393", "bodyText": "ICDateSet ist blos als \u00fcbergangsl\u00f6sung gedacht, ich muss das noch komplett l\u00f6schen", "author": "awildturtok", "createdAt": "2020-09-04T13:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk3Nzk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5MzMxNw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482993317", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t// Now handle special cases related to infinities and connectedness of the bitsets\n          \n          \n            \n            \t\t// Now handle special cases related to infinities and connected bitsets", "author": "thoniTUB", "createdAt": "2020-09-03T13:51:04Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk5NTQwNQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r482995405", "bodyText": "trivialer fall. W\u00fcrde ich als erstes testen und dann sofort returnen.", "author": "thoniTUB", "createdAt": "2020-09-03T13:53:48Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwODI2OA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483008268", "bodyText": "cool gel\u00f6st!", "author": "thoniTUB", "createdAt": "2020-09-03T14:11:02Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMzQ3OA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483013478", "bodyText": "der fall sieht mir etwas komisch aus.\ndie condition sieht aus, als w\u00fcrdest du eine isAll() range erwarten.\nder rumpf sieht aber so aus als w\u00fcrdest du etwas haben, dass so aus so aussieht\n[(-\u221e, some_date),(some_later_date,\u221e)]", "author": "thoniTUB", "createdAt": "2020-09-03T14:18:11Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyNzY4NA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483627684", "bodyText": "ja, ich denke auch, dass das kein m\u00f6glicher fall sein d\u00fcrfte, nur eine komischer fehler wenn nicht ordentlich gecleared wird.", "author": "awildturtok", "createdAt": "2020-09-04T13:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAxMzQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyODQ4MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483028481", "bodyText": "Wenn du das normale BitSet benutzt haben wir bei fast allen Daten viel Speicherverbrauch (je weiter weg die grenzen vom 01.01.1970 sind, desto gr\u00f6\u00dfer) Ich dachte du willst RoaringBitMaps(Sets) benutzen.", "author": "thoniTUB", "createdAt": "2020-09-03T14:36:33Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyODQ3MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483628471", "bodyText": "Da es mir hier vor allem um Performance ging wollte ich erstmal BitSets benutzen, RoaringBitSets benutzen auch wieder viel magic um sparse zust\u00e4nde zu beschreiben, das gef\u00e4llt mir nicht weil wir dann wieder fast bei der gleichen logik sind wie davor. Ich sollte es aber echt einfach vergleichen, die interfaces sind fast identisch.", "author": "awildturtok", "createdAt": "2020-09-04T13:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyODQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAzNzQ2MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483037461", "bodyText": "Was ist der \u00e4u\u00dfere unterschied zwischen dieser Funktion und public static BitMapCDateSet createAll() ?", "author": "thoniTUB", "createdAt": "2020-09-03T14:48:45Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0MzI4OQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483043289", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic boolean contains(int value) {\n          \n          \n            \n            \t\tif (openMax && value >= getMaxRealValue()) {\n          \n          \n            \n            \tpublic boolean contains(int value) {\n          \n          \n            \n            \t\t// check trivial cases first so we can safely call getMaxRealValue() and so on\n          \n          \n            \n            \t\tif(isAll()){\n          \n          \n            \n            \t\t\treturn true;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif(isEmpty()){\n          \n          \n            \n            \t\t\treturn false;\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\n          \n          \n            \n            \t\tif (openMax && value >= getMaxRealValue()) {", "author": "thoniTUB", "createdAt": "2020-09-03T14:56:32Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NTY2Mw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483045663", "bodyText": "Ich bin mit dem return 0; nicht zu frieden, weil es nicht stimmt, wenn das set emtpy ist.\nauch wenn das nur eine private methode ist, checke am anfang, dass das dateset !isEmpty() und schmei\u00dfe ansonsten eine IllegalStateException oder so.\nAlso versichere dich, dass die methode nie auf einem leeren set aufgerufen werden kann.", "author": "thoniTUB", "createdAt": "2020-09-03T14:59:39Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA0NjA2Nw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483046067", "bodyText": "Das selbe mit den leeren sets auch hier.", "author": "thoniTUB", "createdAt": "2020-09-03T15:00:09Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1MDQxOA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483050418", "bodyText": "kann korrupte sets erzeugen, wenn diese vorher open waren.", "author": "thoniTUB", "createdAt": "2020-09-03T15:06:08Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1MzAyMg==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483053022", "bodyText": "open wird nicht ber\u00fccksichtigt", "author": "thoniTUB", "createdAt": "2020-09-03T15:09:54Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1MzMxMg==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483053312", "bodyText": "open wird nicht ber\u00fccksichtigt", "author": "thoniTUB", "createdAt": "2020-09-03T15:10:21Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1MzU4Ng==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483053586", "bodyText": "addAll in remove methode", "author": "thoniTUB", "createdAt": "2020-09-03T15:10:44Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1NTIwMQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483055201", "bodyText": "gibt es keine emtpy range, um null nach au\u00dfen hin zu vermeiden?\nave guava ;)", "author": "thoniTUB", "createdAt": "2020-09-03T15:13:02Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMTQxNg==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r492611416", "bodyText": "das haupt problem hier ist, dass sie keine min und max value haben und wir dann \u00fcberall checken m\u00fcssten was das ist wenn wir nach min/max queryen", "author": "awildturtok", "createdAt": "2020-09-22T09:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1NTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1NjYwMA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483056600", "bodyText": "Datumsgrenzen des Datesets dokumentieren", "author": "thoniTUB", "createdAt": "2020-09-03T15:15:03Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjYxMTU5OQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r492611599", "bodyText": "Was meinst du damit?", "author": "awildturtok", "createdAt": "2020-09-22T09:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1NjYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1OTk0Ng==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483059946", "bodyText": "ginge nicht auch\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n          \n          \n            \n            \t\t\tpositiveBits.set(to + 1);", "author": "thoniTUB", "createdAt": "2020-09-03T15:19:25Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyOTY5MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483629691", "bodyText": "set setzt nur ein einzelnes bit, wir wollen ja aber alle setzen um sie dann wieder teilweise zu clearen.", "author": "awildturtok", "createdAt": "2020-09-04T13:53:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA1OTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA2MTg2MA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483061860", "bodyText": "und\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n          \n          \n            \n            \t\t\tnegativeBits.set(-from + 1);", "author": "thoniTUB", "createdAt": "2020-09-03T15:22:06Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA2NDU4Mw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483064583", "bodyText": "Dass to exklusive ist sollte dokumentiert sein", "author": "thoniTUB", "createdAt": "2020-09-03T15:25:56Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA2NTY4MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483065681", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (value >= 0) {\n          \n          \n            \n            \t\t\tpositiveBits.set(value, value + 1);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\telse {\n          \n          \n            \n            \t\t\tnegativeBits.set(-value, -value + 1);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\tif (value >= 0) {\n          \n          \n            \n            \t\t\tpositiveBits.set(value);\n          \n          \n            \n            \t\t}\n          \n          \n            \n            \t\telse {\n          \n          \n            \n            \t\t\tnegativeBits.set(-value);\n          \n          \n            \n            \t\t}", "author": "thoniTUB", "createdAt": "2020-09-03T15:27:03Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3MjIzNQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483072235", "bodyText": "Ich w\u00fcrde vorschlagen, dass du alle add methoden private machst also ein _add draus machen und in dem public add checkst, ob dieses set full/all ist. sonst kannst du dir die sets zerhauen.\nVielleicht m\u00fcssen noch andere checks vorher gemacht werden. bzw nach dem adden muss gepr\u00fcft werden ob aus dem set nicht ein full/all geworden ist.", "author": "thoniTUB", "createdAt": "2020-09-03T15:36:31Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NTE3MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483075171", "bodyText": "Hier sollte eine Execption fliegen, sonst hast du einen ziemlichen sneaky bug", "author": "thoniTUB", "createdAt": "2020-09-03T15:40:47Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMin = true;\n+\t\topenMax = true;\n+\t}\n+\n+\tpublic void add(CDateRangeEnding range) {\n+\n+\t\tfinal int value = range.getMaxValue();\n+\t\topenMin = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\t// TODO: 13.08.2020 this does not look right?\n+\t\t\tnegativeBits.set(-value, Math.max(-value + 1, Math.min(-minValue, negativeBits.size())));\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeStarting range) {\n+\n+\t\tfinal int value = range.getMinValue();\n+\t\topenMax = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\tnegativeBits.set(-value, -minValue);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void add(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tadd(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tadd(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tadd(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tadd(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tadd(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void remove(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tremove(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tremove(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tremove(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tremove(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tremove(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\tpublic void remove(CDateRangeExactly range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeClosed range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMax = false;\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeStarting range) {\n+\t\tif (range.getMinValue() < getMaxRealValue()) {\n+\t\t\tclearRange(range.getMinValue(), getMaxRealValue() + 1);\n+\t\t}\n+\t\topenMax = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeEnding range) {\n+\t\tif (range.getMaxValue() > getMinRealValue()) {\n+\t\t\tclearRange(getMinRealValue(), range.getMaxValue());\n+\t\t}\n+\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic boolean isAll() {\n+\t\treturn openMax && openMin && positiveBits.isEmpty() && negativeBits.isEmpty();\n+\t}\n+\n+\n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif (!(retained instanceof BitMapCDateSet)) {\n+\t\t\treturn;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3NzgyOA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483077828", "bodyText": "f\u00fcr mich sieht der r\u00fcckgabewert hier falsch aus: vorher checken ob hier das set nicht empty ist und dann hier eine execption werfen.", "author": "thoniTUB", "createdAt": "2020-09-03T15:44:42Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMin = true;\n+\t\topenMax = true;\n+\t}\n+\n+\tpublic void add(CDateRangeEnding range) {\n+\n+\t\tfinal int value = range.getMaxValue();\n+\t\topenMin = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\t// TODO: 13.08.2020 this does not look right?\n+\t\t\tnegativeBits.set(-value, Math.max(-value + 1, Math.min(-minValue, negativeBits.size())));\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeStarting range) {\n+\n+\t\tfinal int value = range.getMinValue();\n+\t\topenMax = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\tnegativeBits.set(-value, -minValue);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void add(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tadd(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tadd(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tadd(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tadd(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tadd(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void remove(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tremove(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tremove(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tremove(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tremove(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tremove(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\tpublic void remove(CDateRangeExactly range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeClosed range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMax = false;\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeStarting range) {\n+\t\tif (range.getMinValue() < getMaxRealValue()) {\n+\t\t\tclearRange(range.getMinValue(), getMaxRealValue() + 1);\n+\t\t}\n+\t\topenMax = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeEnding range) {\n+\t\tif (range.getMaxValue() > getMinRealValue()) {\n+\t\t\tclearRange(getMinRealValue(), range.getMaxValue());\n+\t\t}\n+\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic boolean isAll() {\n+\t\treturn openMax && openMin && positiveBits.isEmpty() && negativeBits.isEmpty();\n+\t}\n+\n+\n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif (!(retained instanceof BitMapCDateSet)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal BitMapCDateSet dateSet = (BitMapCDateSet) retained;\n+\n+\t\t// expand both ways to make anding even possible\n+\t\tif(dateSet.getMaxRealValue() > getMaxRealValue() && openMax) {\n+\t\t\tsetRange(getMaxRealValue(), dateSet.getMaxRealValue());\n+\t\t}\n+\n+\t\tif(dateSet.getMinRealValue() < getMinValue() && openMin) {\n+\t\t\tsetRange(dateSet.getMinRealValue(), getMinRealValue());\n+\t\t}\n+\n+\t\tnegativeBits.and(dateSet.negativeBits);\n+\t\tpositiveBits.and(dateSet.positiveBits);\n+\n+\t\topenMin = openMin && dateSet.openMin;\n+\t\topenMax = openMax && dateSet.openMax;\n+\t}\n+\n+\n+\tpublic void retainAll(CDateRange retained) {\n+\t\tremove(CDateRange.atMost(retained.getMinValue()));\n+\t\tremove(CDateRange.atLeast(retained.getMaxValue()));\n+\t}\n+\n+\n+\tprotected int higherSetBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousSetBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextSetBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA3OTU5MQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483079591", "bodyText": "sneaky bug -> Exception", "author": "thoniTUB", "createdAt": "2020-09-03T15:47:12Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMin = true;\n+\t\topenMax = true;\n+\t}\n+\n+\tpublic void add(CDateRangeEnding range) {\n+\n+\t\tfinal int value = range.getMaxValue();\n+\t\topenMin = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\t// TODO: 13.08.2020 this does not look right?\n+\t\t\tnegativeBits.set(-value, Math.max(-value + 1, Math.min(-minValue, negativeBits.size())));\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeStarting range) {\n+\n+\t\tfinal int value = range.getMinValue();\n+\t\topenMax = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\tnegativeBits.set(-value, -minValue);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void add(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tadd(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tadd(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tadd(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tadd(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tadd(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void remove(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tremove(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tremove(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tremove(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tremove(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tremove(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\tpublic void remove(CDateRangeExactly range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeClosed range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMax = false;\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeStarting range) {\n+\t\tif (range.getMinValue() < getMaxRealValue()) {\n+\t\t\tclearRange(range.getMinValue(), getMaxRealValue() + 1);\n+\t\t}\n+\t\topenMax = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeEnding range) {\n+\t\tif (range.getMaxValue() > getMinRealValue()) {\n+\t\t\tclearRange(getMinRealValue(), range.getMaxValue());\n+\t\t}\n+\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic boolean isAll() {\n+\t\treturn openMax && openMin && positiveBits.isEmpty() && negativeBits.isEmpty();\n+\t}\n+\n+\n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif (!(retained instanceof BitMapCDateSet)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal BitMapCDateSet dateSet = (BitMapCDateSet) retained;\n+\n+\t\t// expand both ways to make anding even possible\n+\t\tif(dateSet.getMaxRealValue() > getMaxRealValue() && openMax) {\n+\t\t\tsetRange(getMaxRealValue(), dateSet.getMaxRealValue());\n+\t\t}\n+\n+\t\tif(dateSet.getMinRealValue() < getMinValue() && openMin) {\n+\t\t\tsetRange(dateSet.getMinRealValue(), getMinRealValue());\n+\t\t}\n+\n+\t\tnegativeBits.and(dateSet.negativeBits);\n+\t\tpositiveBits.and(dateSet.positiveBits);\n+\n+\t\topenMin = openMin && dateSet.openMin;\n+\t\topenMax = openMax && dateSet.openMax;\n+\t}\n+\n+\n+\tpublic void retainAll(CDateRange retained) {\n+\t\tremove(CDateRange.atMost(retained.getMinValue()));\n+\t\tremove(CDateRange.atLeast(retained.getMaxValue()));\n+\t}\n+\n+\n+\tprotected int higherSetBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousSetBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextSetBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tfinal int out = positiveBits.nextSetBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprotected int higherClearBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousClearBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextClearBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tint out = positiveBits.nextClearBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\tprotected int lowerSetBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousSetBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextSetBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextSetBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\tprotected int lowerClearBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousClearBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextClearBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextClearBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\n+\tpublic void maskedAdd(@NonNull CDateRange toAdd, @NonNull ICDateSet mask) {\n+\t\tif (toAdd.isOpen()) {\n+\t\t\tthrow new IllegalArgumentException(\"We don't handle open ranges here. (Yet?)\");\n+\t\t}\n+\n+\t\tif (mask instanceof CDateSet) {\n+\t\t\treturn;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4MjMwOA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483082308", "bodyText": "ouh it'se me", "author": "thoniTUB", "createdAt": "2020-09-03T15:51:19Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMin = true;\n+\t\topenMax = true;\n+\t}\n+\n+\tpublic void add(CDateRangeEnding range) {\n+\n+\t\tfinal int value = range.getMaxValue();\n+\t\topenMin = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\t// TODO: 13.08.2020 this does not look right?\n+\t\t\tnegativeBits.set(-value, Math.max(-value + 1, Math.min(-minValue, negativeBits.size())));\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeStarting range) {\n+\n+\t\tfinal int value = range.getMinValue();\n+\t\topenMax = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\tnegativeBits.set(-value, -minValue);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void add(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tadd(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tadd(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tadd(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tadd(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tadd(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void remove(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tremove(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tremove(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tremove(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tremove(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tremove(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\tpublic void remove(CDateRangeExactly range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeClosed range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMax = false;\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeStarting range) {\n+\t\tif (range.getMinValue() < getMaxRealValue()) {\n+\t\t\tclearRange(range.getMinValue(), getMaxRealValue() + 1);\n+\t\t}\n+\t\topenMax = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeEnding range) {\n+\t\tif (range.getMaxValue() > getMinRealValue()) {\n+\t\t\tclearRange(getMinRealValue(), range.getMaxValue());\n+\t\t}\n+\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic boolean isAll() {\n+\t\treturn openMax && openMin && positiveBits.isEmpty() && negativeBits.isEmpty();\n+\t}\n+\n+\n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif (!(retained instanceof BitMapCDateSet)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal BitMapCDateSet dateSet = (BitMapCDateSet) retained;\n+\n+\t\t// expand both ways to make anding even possible\n+\t\tif(dateSet.getMaxRealValue() > getMaxRealValue() && openMax) {\n+\t\t\tsetRange(getMaxRealValue(), dateSet.getMaxRealValue());\n+\t\t}\n+\n+\t\tif(dateSet.getMinRealValue() < getMinValue() && openMin) {\n+\t\t\tsetRange(dateSet.getMinRealValue(), getMinRealValue());\n+\t\t}\n+\n+\t\tnegativeBits.and(dateSet.negativeBits);\n+\t\tpositiveBits.and(dateSet.positiveBits);\n+\n+\t\topenMin = openMin && dateSet.openMin;\n+\t\topenMax = openMax && dateSet.openMax;\n+\t}\n+\n+\n+\tpublic void retainAll(CDateRange retained) {\n+\t\tremove(CDateRange.atMost(retained.getMinValue()));\n+\t\tremove(CDateRange.atLeast(retained.getMaxValue()));\n+\t}\n+\n+\n+\tprotected int higherSetBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousSetBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextSetBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tfinal int out = positiveBits.nextSetBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprotected int higherClearBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousClearBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextClearBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tint out = positiveBits.nextClearBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\tprotected int lowerSetBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousSetBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextSetBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextSetBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\tprotected int lowerClearBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousClearBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextClearBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextClearBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\n+\tpublic void maskedAdd(@NonNull CDateRange toAdd, @NonNull ICDateSet mask) {\n+\t\tif (toAdd.isOpen()) {\n+\t\t\tthrow new IllegalArgumentException(\"We don't handle open ranges here. (Yet?)\");\n+\t\t}\n+\n+\t\tif (mask instanceof CDateSet) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (mask.isAll()) {\n+\t\t\tadd(toAdd);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (mask.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// trivial but common case\n+\t\tif (toAdd instanceof CDateRangeExactly && mask.contains(toAdd.getMinValue())) {\n+\t\t\tadd(toAdd);\n+\t\t\treturn;\n+\t\t}\n+\n+\n+\t\tBitMapCDateSet _mask = (BitMapCDateSet) mask;\n+\n+\n+\t\t// from min\n+\t\t{\n+\t\t\t// is min partially contained?\n+\t\t\t// if yes, we can insert the intersecting range\n+\t\t\t// if not, we need to find the range that's between that and max\n+\t\t\tfinal int minFromMin = _mask.contains(toAdd.getMinValue()) ?\n+\t\t\t\t\t\t\t\t   toAdd.getMinValue() :\n+\t\t\t\t\t\t\t\t   _mask.higherSetBit(toAdd.getMinValue());\n+\n+\t\t\tif (minFromMin != Integer.MIN_VALUE) {\n+\t\t\t\tfinal int maxFromMin = _mask.higherClearBit(minFromMin) - 1;\n+\n+\t\t\t\tif (maxFromMin != Integer.MIN_VALUE) {\n+\t\t\t\t\tif (maxFromMin < toAdd.getMaxValue()) {\n+\t\t\t\t\t\tadd(CDateRange.of(minFromMin, maxFromMin));\n+\t\t\t\t\t}\n+\t\t\t\t\t// it's fully contained\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tadd(CDateRange.of(minFromMin, toAdd.getMaxValue()));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// from max", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4NDQyMw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483084423", "bodyText": "Das finde ich nicht gut. Der Anwender sollte vorher checken ob das set leer ist. Wenn es das ist und die methode trotzdem aufruft: boom exception", "author": "thoniTUB", "createdAt": "2020-09-03T15:54:37Z", "path": "backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java", "diffHunk": "@@ -0,0 +1,761 @@\n+package com.bakdata.conquery.models.common;\n+\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeClosed;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeEnding;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeExactly;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeOpen;\n+import com.bakdata.conquery.models.common.daterange.CDateRangeStarting;\n+import com.bakdata.conquery.models.types.parser.specific.DateRangeParser;\n+import com.google.common.base.Joiner;\n+import lombok.NonNull;\n+\n+\n+public class BitMapCDateSet implements ICDateSet {\n+\n+\tprivate BitMapCDateSet(BitSet positiveBits, BitSet negativeBits) {\n+\t\tthis.positiveBits = positiveBits;\n+\t\tthis.negativeBits = negativeBits;\n+\t}\n+\n+\tprivate BitMapCDateSet() {\n+\t\tthis(new BitSet(), new BitSet());\n+\t}\n+\n+\tpublic static BitMapCDateSet create() {\n+\t\treturn new BitMapCDateSet();\n+\t}\n+\n+\tpublic static BitMapCDateSet createFull() {\n+\t\tfinal BitMapCDateSet set = new BitMapCDateSet();\n+\t\tset.add(CDateRange.all());\n+\t\treturn set;\n+\t}\n+\n+\tprivate static final Pattern PARSE_PATTERN = Pattern.compile(\"(\\\\{|,\\\\s*)((\\\\d{4}-\\\\d{2}-\\\\d{2})?/(\\\\d{4}-\\\\d{2}-\\\\d{2})?)\");\n+\n+\tpublic static BitMapCDateSet parse(String value) {\n+\t\tList<CDateRange> ranges = PARSE_PATTERN\n+\t\t\t\t\t\t\t\t\t\t  .matcher(value)\n+\t\t\t\t\t\t\t\t\t\t  .results()\n+\t\t\t\t\t\t\t\t\t\t  .map(mr -> {\n+\t\t\t\t\t\t\t\t\t\t\t  try {\n+\t\t\t\t\t\t\t\t\t\t\t\t  return DateRangeParser.parseISORange(mr.group(2));\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t\t  catch (Exception e) {\n+\t\t\t\t\t\t\t\t\t\t\t\t  throw new RuntimeException(e);\n+\t\t\t\t\t\t\t\t\t\t\t  }\n+\t\t\t\t\t\t\t\t\t\t  })\n+\t\t\t\t\t\t\t\t\t\t  .collect(Collectors.toList());\n+\t\treturn BitMapCDateSet.create(ranges);\n+\t}\n+\n+\tpublic static BitMapCDateSet create(BitMapCDateSet orig) {\n+\t\tfinal BitMapCDateSet set = create(orig.negativeBits.length(), orig.positiveBits.length());\n+\n+\t\tset.positiveBits.or(orig.positiveBits);\n+\t\tset.negativeBits.or(orig.negativeBits);\n+\n+\t\tset.openMax = orig.openMax;\n+\t\tset.openMin = orig.openMin;\n+\n+\t\treturn set;\n+\t}\n+\n+\tpublic static BitMapCDateSet createAll() {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\t\tout.openMin = true;\n+\t\tout.openMax = true;\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(int min, int max) {\n+\t\treturn new BitMapCDateSet(new BitSet(Math.abs(min)), new BitSet(max));\n+\t}\n+\n+\tpublic static BitMapCDateSet create(CDateRange... dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tpublic static BitMapCDateSet create(Iterable<CDateRange> dates) {\n+\t\tfinal BitMapCDateSet out = new BitMapCDateSet();\n+\n+\t\tfor (CDateRange date : dates) {\n+\t\t\tout.add(date);\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprivate boolean openMin = false;\n+\tprivate boolean openMax = false;\n+\n+\tprivate final BitSet positiveBits;\n+\t/**\n+\t * @implNote bit 0 is never set as it overlaps with bit 0 of positiveBits. This is a waste of 1 bit to make code easier to read.\n+\t */\n+\tprivate final BitSet negativeBits;\n+\n+\n+\tpublic Collection<CDateRange> asRanges() {\n+\t\tfinal List<CDateRange> out = new ArrayList<>();\n+\n+\t\t//TODO implement this using higherSetBit etc.\n+\n+\t\t// Iterate negative ranges first\n+\t\tif (!negativeBits.isEmpty()) {\n+\t\t\tint start = negativeBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = negativeBits.nextClearBit(start);\n+\n+\t\t\t\tout.add(CDateRange.of(-(end - 1), -start));\n+\n+\t\t\t\tstart = negativeBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Then reverse their order as they are starting at zero\n+\t\tCollections.reverse(out);\n+\n+\t\t// this is the Range in the middle, we might need this if negative and positive bits are connected.\n+\t\tint center = out.size() - 1;\n+\n+\t\t// Then iterate positive ranges\n+\t\tif (!positiveBits.isEmpty()) {\n+\t\t\tint start = positiveBits.nextSetBit(0);\n+\n+\t\t\twhile (start != -1) {\n+\t\t\t\tint end = positiveBits.nextClearBit(start);\n+\t\t\t\tout.add(CDateRange.of(start, end - 1));\n+\n+\t\t\t\tstart = positiveBits.nextSetBit(end);\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Now handle special cases related to infinities and connectedness of the bitsets\n+\n+\t\t// they are indeed connected\n+\t\tif (positiveBits.get(0) && negativeBits.get(1)) {\n+\t\t\tfinal CDateRange centerFromLeft = out.get(center);\n+\t\t\tfinal CDateRange centerFromRight = out.get(center + 1);\n+\n+\t\t\t// remove centerFromLeft, then replaceCenterFromRight which is now at centerFromLeft\n+\t\t\tout.remove(center);\n+\t\t\tout.set(center, CDateRange.of(centerFromLeft.getMinValue(), centerFromRight.getMaxValue()));\n+\t\t}\n+\n+\n+\t\tif (isAll()) {\n+\t\t\tout.add(CDateRange.all());\n+\t\t}\n+\t\telse if (openMin && openMax && out.size() == 1) {\n+\t\t\tfinal CDateRange middle = out.get(0);\n+\t\t\t//todo I think  this might actually be an invalid range\n+\t\t\tout.clear();\n+\t\t\tout.add(CDateRange.atMost(middle.getMinValue()));\n+\t\t\tout.add(CDateRange.atLeast(middle.getMaxValue()));\n+\t\t}\n+\t\telse {\n+\t\t\tif (openMin) {\n+\t\t\t\tout.set(0, CDateRange.atMost(out.get(0).getMaxValue()));\n+\t\t\t}\n+\t\t\tif (openMax) {\n+\t\t\t\tfinal int last = out.size() - 1;\n+\n+\t\t\t\tout.set(last, CDateRange.atLeast(out.get(last).getMinValue()));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\n+\n+\n+\tpublic boolean contains(LocalDate value) {\n+\t\treturn contains(CDate.ofLocalDate(value));\n+\t}\n+\n+\n+\tprivate int getMaxRealValue() {\n+\t\tint positiveMax = positiveBits.length();\n+\n+\t\tif(positiveMax != 0){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\n+\t\tint negativeMax = negativeBits.nextSetBit(1);\n+\n+\t\tif(negativeMax != -1) {\n+\t\t\treturn -negativeMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tprivate int getMinRealValue() {\n+\t\tint negativeMin = negativeBits.length();\n+\n+\t\tif(negativeMin != 0) {\n+\t\t\treturn -negativeMin;\n+\t\t}\n+\n+\t\tint positiveMax = positiveBits.nextSetBit(0);\n+\n+\t\tif(positiveMax != -1){\n+\t\t\treturn positiveMax;\n+\t\t}\n+\n+\t\treturn 0;\n+\t}\n+\n+\tpublic boolean contains(int value) {\n+\t\tif (openMax && value >= getMaxRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (openMin && value <= getMinRealValue()) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif(value == Integer.MIN_VALUE || value == Integer.MAX_VALUE){\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (value >= 0 && positiveBits.get(value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value < 0 && negativeBits.get(-value)) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn positiveBits.isEmpty() && negativeBits.isEmpty() && !openMin && !openMax;\n+\t}\n+\n+\n+\tpublic void clear() {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t}\n+\n+\n+\tpublic void addAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.or(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.or(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void removeAll(ICDateSet other) {\n+\t\tif (other instanceof BitMapCDateSet) {\n+\t\t\tpositiveBits.andNot(((BitMapCDateSet) other).positiveBits);\n+\t\t\tnegativeBits.andNot(((BitMapCDateSet) other).negativeBits);\n+\t\t}\n+\t\telse if (other instanceof CDateSet) {\n+\t\t\taddAll(other.asRanges());\n+\t\t}\n+\t}\n+\n+\n+\tpublic void addAll(Iterable<CDateRange> ranges) {\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tadd(range);\n+\t\t}\n+\t}\n+\n+\n+\n+\tpublic boolean intersects(CDateRange range) {\n+\t\t// trivial case\n+\t\tif (contains(range.getMinValue()) || contains(range.getMaxValue())) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (range.getMinValue() < 0) {\n+\t\t\tint intersection = negativeBits.previousSetBit(-range.getMinValue());\n+\n+\t\t\tif (intersection != -1) {\n+\t\t\t\treturn -intersection <= range.getMaxValue();\n+\t\t\t}\n+\n+\t\t\tintersection = positiveBits.nextSetBit(0);\n+\n+\t\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t\t}\n+\n+\t\tint intersection = positiveBits.nextSetBit(range.getMinValue());\n+\n+\t\treturn intersection != -1 && intersection <= range.getMaxValue();\n+\t}\n+\n+\n+\tpublic CDateRange span() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn CDateRange.of(getMinValue(), getMaxValue());\n+\t}\n+\n+\n+\tprivate void setRange(int from, int to) {\n+\t\tpositiveBits.set(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.set(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tprivate void clearRange(int from, int to) {\n+\n+\t\t// if that range is beyond our highest bit but inside the range, we need to extend it first\n+\t\tif (openMax && to >= positiveBits.length()) {\n+\t\t\tpositiveBits.set(positiveBits.length(), to + 1);\n+\t\t}\n+\n+\t\tif (openMin && from <= 0 && -from >= negativeBits.length()) {\n+\t\t\tnegativeBits.set(Math.max(1, negativeBits.length()), -from + 2);\n+\t\t}\n+\n+\t\tpositiveBits.clear(Math.max(0, from), Math.max(0, to));\n+\n+\t\tif (from < 0) {\n+\t\t\tfrom = -from;\n+\t\t\tto = Math.max(1, -to);\n+\n+\t\t\tnegativeBits.clear(to, from + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeClosed range) {\n+\t\tsetRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\n+\tpublic void add(CDateRangeExactly range) {\n+\t\tfinal int value = range.getMinValue();\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value, value + 1);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value, -value + 1);\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMin = true;\n+\t\topenMax = true;\n+\t}\n+\n+\tpublic void add(CDateRangeEnding range) {\n+\n+\t\tfinal int value = range.getMaxValue();\n+\t\topenMin = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\t// TODO: 13.08.2020 this does not look right?\n+\t\t\tnegativeBits.set(-value, Math.max(-value + 1, Math.min(-minValue, negativeBits.size())));\n+\t\t}\n+\t}\n+\n+\tpublic void add(CDateRangeStarting range) {\n+\n+\t\tfinal int value = range.getMinValue();\n+\t\topenMax = true;\n+\n+\t\tfinal int maxValue = getMaxValue();\n+\t\tfinal int minValue = getMinValue();\n+\n+\n+\t\tif (value >= 0) {\n+\t\t\tpositiveBits.set(value);\n+\t\t}\n+\t\telse {\n+\t\t\tnegativeBits.set(-value);\n+\t\t}\n+\n+\t\tif (value >= 0 && value < maxValue) {\n+\t\t\tpositiveBits.set(value, maxValue);\n+\t\t}\n+\t\telse if (value < 0 && value > minValue) {\n+\t\t\tnegativeBits.set(-value, -minValue);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void add(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tadd(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tadd(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tadd(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tadd(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tadd(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void remove(CDateRange rangeToAdd) {\n+\t\tif (rangeToAdd instanceof CDateRangeClosed) {\n+\t\t\tremove(((CDateRangeClosed) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeExactly) {\n+\t\t\tremove(((CDateRangeExactly) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeStarting) {\n+\t\t\tremove(((CDateRangeStarting) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeEnding) {\n+\t\t\tremove(((CDateRangeEnding) rangeToAdd));\n+\t\t}\n+\t\telse if (rangeToAdd instanceof CDateRangeOpen) {\n+\t\t\tremove(((CDateRangeOpen) rangeToAdd));\n+\t\t}\n+\t}\n+\n+\tpublic void remove(CDateRangeExactly range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeClosed range) {\n+\t\tclearRange(range.getMinValue(), range.getMaxValue() + 1);\n+\t}\n+\n+\tpublic void remove(CDateRangeOpen range) {\n+\t\tpositiveBits.clear();\n+\t\tnegativeBits.clear();\n+\t\topenMax = false;\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeStarting range) {\n+\t\tif (range.getMinValue() < getMaxRealValue()) {\n+\t\t\tclearRange(range.getMinValue(), getMaxRealValue() + 1);\n+\t\t}\n+\t\topenMax = false;\n+\t}\n+\n+\tpublic void remove(CDateRangeEnding range) {\n+\t\tif (range.getMaxValue() > getMinRealValue()) {\n+\t\t\tclearRange(getMinRealValue(), range.getMaxValue());\n+\t\t}\n+\n+\t\topenMin = false;\n+\t}\n+\n+\tpublic boolean isAll() {\n+\t\treturn openMax && openMin && positiveBits.isEmpty() && negativeBits.isEmpty();\n+\t}\n+\n+\n+\tpublic void retainAll(ICDateSet retained) {\n+\t\tif (!(retained instanceof BitMapCDateSet)) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tfinal BitMapCDateSet dateSet = (BitMapCDateSet) retained;\n+\n+\t\t// expand both ways to make anding even possible\n+\t\tif(dateSet.getMaxRealValue() > getMaxRealValue() && openMax) {\n+\t\t\tsetRange(getMaxRealValue(), dateSet.getMaxRealValue());\n+\t\t}\n+\n+\t\tif(dateSet.getMinRealValue() < getMinValue() && openMin) {\n+\t\t\tsetRange(dateSet.getMinRealValue(), getMinRealValue());\n+\t\t}\n+\n+\t\tnegativeBits.and(dateSet.negativeBits);\n+\t\tpositiveBits.and(dateSet.positiveBits);\n+\n+\t\topenMin = openMin && dateSet.openMin;\n+\t\topenMax = openMax && dateSet.openMax;\n+\t}\n+\n+\n+\tpublic void retainAll(CDateRange retained) {\n+\t\tremove(CDateRange.atMost(retained.getMinValue()));\n+\t\tremove(CDateRange.atLeast(retained.getMaxValue()));\n+\t}\n+\n+\n+\tprotected int higherSetBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousSetBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextSetBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tfinal int out = positiveBits.nextSetBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\treturn out;\n+\t}\n+\n+\tprotected int higherClearBit(int value) {\n+\t\tif (value < 0) {\n+\t\t\tint out = negativeBits.previousClearBit(-value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\tout = positiveBits.nextClearBit(0);\n+\n+\t\t\tif (out == -1) {\n+\t\t\t\treturn Integer.MIN_VALUE;\n+\t\t\t}\n+\n+\t\t\treturn out;\n+\t\t}\n+\n+\t\tint out = positiveBits.nextClearBit(value);\n+\n+\t\tif (out == -1) {\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\t\treturn out;\n+\t}\n+\n+\tprotected int lowerSetBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousSetBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextSetBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextSetBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\tprotected int lowerClearBit(int value) {\n+\t\tif (value >= 0) {\n+\t\t\tint out = positiveBits.previousClearBit(value);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn out;\n+\t\t\t}\n+\n+\t\t\tout = negativeBits.nextClearBit(1);\n+\n+\t\t\tif (out != -1) {\n+\t\t\t\treturn -out;\n+\t\t\t}\n+\n+\t\t\treturn Integer.MIN_VALUE;\n+\t\t}\n+\n+\t\tint out = negativeBits.nextClearBit(1);\n+\n+\t\tif (out != -1) {\n+\t\t\treturn -out;\n+\t\t}\n+\n+\t\treturn Integer.MIN_VALUE;\n+\t}\n+\n+\n+\tpublic void maskedAdd(@NonNull CDateRange toAdd, @NonNull ICDateSet mask) {\n+\t\tif (toAdd.isOpen()) {\n+\t\t\tthrow new IllegalArgumentException(\"We don't handle open ranges here. (Yet?)\");\n+\t\t}\n+\n+\t\tif (mask instanceof CDateSet) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (mask.isAll()) {\n+\t\t\tadd(toAdd);\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tif (mask.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// trivial but common case\n+\t\tif (toAdd instanceof CDateRangeExactly && mask.contains(toAdd.getMinValue())) {\n+\t\t\tadd(toAdd);\n+\t\t\treturn;\n+\t\t}\n+\n+\n+\t\tBitMapCDateSet _mask = (BitMapCDateSet) mask;\n+\n+\n+\t\t// from min\n+\t\t{\n+\t\t\t// is min partially contained?\n+\t\t\t// if yes, we can insert the intersecting range\n+\t\t\t// if not, we need to find the range that's between that and max\n+\t\t\tfinal int minFromMin = _mask.contains(toAdd.getMinValue()) ?\n+\t\t\t\t\t\t\t\t   toAdd.getMinValue() :\n+\t\t\t\t\t\t\t\t   _mask.higherSetBit(toAdd.getMinValue());\n+\n+\t\t\tif (minFromMin != Integer.MIN_VALUE) {\n+\t\t\t\tfinal int maxFromMin = _mask.higherClearBit(minFromMin) - 1;\n+\n+\t\t\t\tif (maxFromMin != Integer.MIN_VALUE) {\n+\t\t\t\t\tif (maxFromMin < toAdd.getMaxValue()) {\n+\t\t\t\t\t\tadd(CDateRange.of(minFromMin, maxFromMin));\n+\t\t\t\t\t}\n+\t\t\t\t\t// it's fully contained\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tadd(CDateRange.of(minFromMin, toAdd.getMaxValue()));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// from max\n+\t\t{\n+\t\t\tfinal int maxFromMax = _mask.contains(toAdd.getMaxValue()) ?\n+\t\t\t\t\t\t\t\t   toAdd.getMaxValue() :\n+\t\t\t\t\t\t\t\t   _mask.lowerSetBit(toAdd.getMinValue());\n+\n+\t\t\tif (maxFromMax != Integer.MIN_VALUE) {\n+\t\t\t\tfinal int minFromMax = _mask.lowerClearBit(maxFromMax) - 1;\n+\n+\t\t\t\tif (minFromMax != Integer.MIN_VALUE) {\n+\t\t\t\t\tif (minFromMax > toAdd.getMinValue()) {\n+\t\t\t\t\t\tadd(CDateRange.of(minFromMax, maxFromMax));\n+\t\t\t\t\t}\n+\t\t\t\t\t// it's fully contained\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tadd(CDateRange.of(toAdd.getMinValue(), maxFromMax));\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic Long countDays() {\n+\t\treturn (long) (negativeBits.cardinality() + positiveBits.cardinality());\n+\t}\n+\n+\n+\tpublic int getMinValue() {\n+\t\tif (isEmpty()) {\n+\t\t\treturn Integer.MAX_VALUE;", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4NzMwNQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483087305", "bodyText": "The numbers Mason... What do they mean?\n\ud83e\udd14", "author": "thoniTUB", "createdAt": "2020-09-03T15:58:48Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/aggregators/specific/EventDateUnionAggregator.java", "diffHunk": "@@ -22,10 +25,15 @@\n @RequiredArgsConstructor\n public class EventDateUnionAggregator implements Aggregator<String> {\n \n+\tprivate BitMapCDateSet set = BitMapCDateSet.create(\n+\t\t\tCDate.ofLocalDate(LocalDate.of(1950, 01, 01)),\n+\t\t\tCDate.ofLocalDate(LocalDate.now())\n+\t);", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA4ODgzNw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483088837", "bodyText": "again", "author": "thoniTUB", "createdAt": "2020-09-03T16:01:00Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/aggregators/specific/SpecialDateUnion.java", "diffHunk": "@@ -17,10 +21,14 @@\n @RequiredArgsConstructor\n public class SpecialDateUnion implements Aggregator<String> {\n \n-\tprivate CDateSet set = CDateSet.create();\n+\tprivate BitMapCDateSet set = BitMapCDateSet.create(\n+\t\t\tCDate.ofLocalDate(LocalDate.of(1950, 01, 01)),", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5MTQ4Nw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483091487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t.matches(set -> set.contains(-1000));\n          \n          \n            \n            \t\t\t\t.matches(set -> set.contains(-1000))\n          \n          \n            \n            \t\t\t\t.matches(set -> set.isAll());", "author": "thoniTUB", "createdAt": "2020-09-03T16:04:17Z", "path": "backend/src/test/java/com/bakdata/conquery/integration/common/BitMapCDateSetTest.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package com.bakdata.conquery.integration.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.time.LocalDate;\n+import java.util.stream.Stream;\n+\n+import com.bakdata.conquery.models.common.BitMapCDateSet;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class BitMapCDateSetTest {\n+\n+\tpublic static Stream<Arguments> arguments() {\n+\t\treturn Stream\n+\t\t\t\t\t   .of(\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-02/1970-01-02, 1970-04-11/1970-04-12}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(1, 1),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(100, 101)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11, 1970-01-16/1970-01-17}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(15, 16)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2004-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2004, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 02)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 03)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-02, 2000-01-04/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-01/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   null\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02))\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02, 2012-01-04/2012-01-04}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2012, 01, 04), LocalDate.of(2012, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2011-01-04/2011-01-04, 2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atLeast(LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2011, 01, 04), LocalDate.of(2011, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(-10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.exactly(-10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.exactly(-10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-01/1970-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(0, 0)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1969-12-31}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-1)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(9, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t   );\n+\t}\n+\n+\t@ParameterizedTest(name = \"{0}\")\n+\t@MethodSource(\"arguments\")\n+\tpublic void testAddMerging(String expected, CDateRange[] ranges) {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tset.add(range);\n+\t\t}\n+\t\tassertThat(set).hasToString(expected);\n+\t}\n+\n+\t@Test\n+\tpublic void testRemove() {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tset.add(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 01, 01),\n+\t\t\t\tLocalDate.of(2000, 12, 31)\n+\t\t));\n+\t\tset.remove(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 06, 01),\n+\t\t\t\tLocalDate.of(2000, 06, 20)\n+\t\t));\n+\t\tassertThat(set).hasToString(\"{2000-01-01/2000-05-31, 2000-06-21/2000-12-31}\");\n+\t}\n+\n+\t@Test\n+\tpublic void testRetain() {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tset.add(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 01, 01),\n+\t\t\t\tLocalDate.of(2000, 12, 31)\n+\t\t));\n+\n+\t\tBitMapCDateSet retain = BitMapCDateSet.create();\n+\t\tretain.add(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 06, 01),\n+\t\t\t\tLocalDate.of(2000, 06, 20)\n+\t\t));\n+\t\tretain.add(CDateRange.atLeast(LocalDate.of(2000, 12, 01)));\n+\n+\t\tset.retainAll(retain);\n+\n+\t\tassertThat(set).hasToString(\"{2000-06-01/2000-06-20, 2000-12-01/2000-12-31}\");\n+\t}\n+\n+\t@Test\n+\tpublic void remove() {\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(10, 10));\n+\t\t\tset.remove(CDateRange.of(10, 10));\n+\n+\t\t\tassertThat(set.asRanges()).isEmpty();\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.all());\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\t\tset.remove(CDateRange.of(10, 10));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, 9));\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\t\tset.remove(CDateRange.of(-1, 1));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, -2), CDateRange.of(2, 10));\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\t\tset.remove(CDateRange.atMost(-5));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-4, 10));\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\t\tset.remove(CDateRange.atLeast(5));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, 4));\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\t\tset.remove(CDateRange.all());\n+\n+\t\t\tassertThat(set.asRanges()).isEmpty();\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\t\tset.remove(CDateRange.of(-1, 1));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(-2), CDateRange.atLeast(2));\n+\t\t}\n+\n+\t\t{\n+\t\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\t\tset.remove(CDateRange.exactly(0));\n+\n+\t\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(-1), CDateRange.atLeast(1));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void contains() {\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.of(1, 1)))\n+\t\t\t\t.matches(set -> set.contains(1))\n+\t\t\t\t.matches(set -> !set.contains(-1));\n+\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.atLeast(1)))\n+\t\t\t\t.matches(set -> set.contains(1))\n+\t\t\t\t.matches(set -> set.contains(2))\n+\t\t\t\t.matches(set -> !set.contains(-1));\n+\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.atMost(1)))\n+\t\t\t\t.matches(set -> set.contains(1))\n+\t\t\t\t.matches(set -> !set.contains(2))\n+\t\t\t\t.matches(set -> set.contains(-1))\n+\t\t\t\t.matches(set -> set.contains(-1000))\n+\t\t;\n+\n+\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.atMost(1), CDateRange.atLeast(1)))\n+\t\t\t\t.matches(set -> set.contains(1))\n+\t\t\t\t.matches(set -> set.contains(2))\n+\t\t\t\t.matches(set -> set.contains(-1))\n+\t\t\t\t.matches(set -> set.contains(-1000));", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIzODMxOQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r492238319", "bodyText": "gute idee, habe das schon angegangen, werde ich aber noch weiter anfassen.", "author": "awildturtok", "createdAt": "2020-09-21T17:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5MTQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzA5MzY0Mw==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r483093643", "bodyText": "auch open, full und empty testen nach diesen operationen.", "author": "thoniTUB", "createdAt": "2020-09-03T16:07:32Z", "path": "backend/src/test/java/com/bakdata/conquery/integration/common/BitMapCDateSetTest.java", "diffHunk": "@@ -0,0 +1,382 @@\n+package com.bakdata.conquery.integration.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.time.LocalDate;\n+import java.util.stream.Stream;\n+\n+import com.bakdata.conquery.models.common.BitMapCDateSet;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class BitMapCDateSetTest {\n+\n+\tpublic static Stream<Arguments> arguments() {\n+\t\treturn Stream\n+\t\t\t\t\t   .of(\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-02/1970-01-02, 1970-04-11/1970-04-12}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(1, 1),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(100, 101)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11, 1970-01-16/1970-01-17}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(15, 16)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2004-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2004, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 02)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 03)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-02, 2000-01-04/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-01/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   null\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02))\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02, 2012-01-04/2012-01-04}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2012, 01, 04), LocalDate.of(2012, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2011-01-04/2011-01-04, 2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atLeast(LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2011, 01, 04), LocalDate.of(2011, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(-10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.exactly(-10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.exactly(-10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-01/1970-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(0, 0)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1969-12-31}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-1)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(9, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t   );\n+\t}\n+\n+\t@ParameterizedTest(name = \"{0}\")\n+\t@MethodSource(\"arguments\")\n+\tpublic void testAddMerging(String expected, CDateRange[] ranges) {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tset.add(range);\n+\t\t}\n+\t\tassertThat(set).hasToString(expected);\n+\t}\n+\n+\t@Test\n+\tpublic void testRemove() {", "originalCommit": "74aef42af5b67b4f2e2e61874a3592e1cd6f0b0d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1bf4c78c392d2c2fb02d6a40d8b1bbac877c1f2f", "url": "https://github.com/bakdata/conquery/commit/1bf4c78c392d2c2fb02d6a40d8b1bbac877c1f2f", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-09-17T12:26:26Z", "type": "commit"}, {"oid": "06b686a2f4b454873e979f8b38b9de02715c205b", "url": "https://github.com/bakdata/conquery/commit/06b686a2f4b454873e979f8b38b9de02715c205b", "message": "automatic update to docs", "committedDate": "2020-09-17T12:28:32Z", "type": "commit"}, {"oid": "fa7e9933498c2a43014f3f4db2e7e4a107339e99", "url": "https://github.com/bakdata/conquery/commit/fa7e9933498c2a43014f3f4db2e7e4a107339e99", "message": "Fix BitMapCDateSet::retainAll(CDateRange)\nCreate appropriate tests and cleanup others.", "committedDate": "2020-09-21T10:33:17Z", "type": "commit"}, {"oid": "085209c80156d4dc5bbf17d1d08324ebbe3fabae", "url": "https://github.com/bakdata/conquery/commit/085209c80156d4dc5bbf17d1d08324ebbe3fabae", "message": "cleanup BitMapCDateSetTest", "committedDate": "2020-09-21T12:10:04Z", "type": "commit"}, {"oid": "db6e1eb013e0cd57cee7db324b5e4ce31ca61cac", "url": "https://github.com/bakdata/conquery/commit/db6e1eb013e0cd57cee7db324b5e4ce31ca61cac", "message": "more cleanup", "committedDate": "2020-09-21T12:36:41Z", "type": "commit"}, {"oid": "23491a6a3fb324ad30be76be40f088e644132fc0", "url": "https://github.com/bakdata/conquery/commit/23491a6a3fb324ad30be76be40f088e644132fc0", "message": "Cleanup renaming of CDateSet and apply usage of DateSetSerialize", "committedDate": "2020-09-21T13:09:59Z", "type": "commit"}, {"oid": "c8944276d92a8c0726bd255b2b9a7f3d30ad73a7", "url": "https://github.com/bakdata/conquery/commit/c8944276d92a8c0726bd255b2b9a7f3d30ad73a7", "message": "fix isAll", "committedDate": "2020-09-21T13:31:00Z", "type": "commit"}, {"oid": "5b64033bfa7964be7ca4fda7fbf4bfa0480b6cf9", "url": "https://github.com/bakdata/conquery/commit/5b64033bfa7964be7ca4fda7fbf4bfa0480b6cf9", "message": "fix isAll", "committedDate": "2020-09-21T15:29:27Z", "type": "commit"}, {"oid": "8fdb1ceb9bc52e8f85eec6df1d45609a415c0ac4", "url": "https://github.com/bakdata/conquery/commit/8fdb1ceb9bc52e8f85eec6df1d45609a415c0ac4", "message": "fix getMaxRealValue", "committedDate": "2020-09-21T15:44:03Z", "type": "commit"}, {"oid": "4d6d3dc4f92c7e407e273bcd15a82a4e48b859aa", "url": "https://github.com/bakdata/conquery/commit/4d6d3dc4f92c7e407e273bcd15a82a4e48b859aa", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-09-21T17:02:07Z", "type": "commit"}, {"oid": "0f9ced071e6b5a1a88b839ed288712d1a16bf3d3", "url": "https://github.com/bakdata/conquery/commit/0f9ced071e6b5a1a88b839ed288712d1a16bf3d3", "message": "automatic update to docs", "committedDate": "2020-09-21T17:04:16Z", "type": "commit"}, {"oid": "a123acc7ed6e2c7c0bd3f22a7f5206c93305628f", "url": "https://github.com/bakdata/conquery/commit/a123acc7ed6e2c7c0bd3f22a7f5206c93305628f", "message": "Update backend/src/main/java/com/bakdata/conquery/models/common/BitMapCDateSet.java\n\nCo-authored-by: MT <12283268+thoniTUB@users.noreply.github.com>", "committedDate": "2020-09-22T07:25:50Z", "type": "commit"}, {"oid": "c717892d1dfd38cdfb362ff1f379fdcea2d8b0b5", "url": "https://github.com/bakdata/conquery/commit/c717892d1dfd38cdfb362ff1f379fdcea2d8b0b5", "message": "Refactor createPreAllocatedDateSet and add more explicit empty/all tests to BitMapCDateSetTest.java", "committedDate": "2020-09-22T13:06:13Z", "type": "commit"}, {"oid": "f8aac07fb560ba4fedf756964a9a5f194ed8d5f6", "url": "https://github.com/bakdata/conquery/commit/f8aac07fb560ba4fedf756964a9a5f194ed8d5f6", "message": "cleanup", "committedDate": "2020-09-22T13:06:13Z", "type": "commit"}, {"oid": "dc5518cfe7d258f8e91e6b106eb62524442446ce", "url": "https://github.com/bakdata/conquery/commit/dc5518cfe7d258f8e91e6b106eb62524442446ce", "message": "documentation and code style fixes", "committedDate": "2020-09-22T13:06:14Z", "type": "commit"}, {"oid": "c4eedba40568ffe863351a46706e24fba933de95", "url": "https://github.com/bakdata/conquery/commit/c4eedba40568ffe863351a46706e24fba933de95", "message": "Cleanup and some documentaion", "committedDate": "2020-09-22T13:23:27Z", "type": "commit"}, {"oid": "54da5c1ad3799809fd318c52d1b839790ea10809", "url": "https://github.com/bakdata/conquery/commit/54da5c1ad3799809fd318c52d1b839790ea10809", "message": "add tests for isAll/isEmpty at the beginning of contains to simplify logic", "committedDate": "2020-09-22T14:20:42Z", "type": "commit"}, {"oid": "7aaa9ee0ba8b41a8718aefa415a5c25d62c8fb59", "url": "https://github.com/bakdata/conquery/commit/7aaa9ee0ba8b41a8718aefa415a5c25d62c8fb59", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-09-23T11:51:08Z", "type": "commit"}, {"oid": "ccf9dcc4e73007dedab908930e8a24e18720d29e", "url": "https://github.com/bakdata/conquery/commit/ccf9dcc4e73007dedab908930e8a24e18720d29e", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-09-29T13:57:28Z", "type": "commit"}, {"oid": "116f6f9df2374c519216a4a6d470929eb19ff6c3", "url": "https://github.com/bakdata/conquery/commit/116f6f9df2374c519216a4a6d470929eb19ff6c3", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-09-30T12:58:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgwODk1Ng==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r498808956", "bodyText": "Warum gibt es noch CDateSet, wenn jetzt alles an der BitMapCDateSet implementierung h\u00e4ngt, das sollte doch eigentlich nicht sein.", "author": "thoniTUB", "createdAt": "2020-10-02T13:06:44Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/queryplan/aggregators/specific/DurationSumAggregator.java", "diffHunk": "@@ -1,6 +1,6 @@\n package com.bakdata.conquery.models.query.queryplan.aggregators.specific;\n \n-import com.bakdata.conquery.models.common.CDateSet;\n+import com.bakdata.conquery.models.common.BitMapCDateSet;", "originalCommit": "116f6f9df2374c519216a4a6d470929eb19ff6c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1Mjk0MA==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r498852940", "bodyText": "gibt es nicht mehr", "author": "awildturtok", "createdAt": "2020-10-02T14:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgwODk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg1NDkxMg==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r498854912", "bodyText": "Mi blind, habe es mit CDateRange verwechselt", "author": "thoniTUB", "createdAt": "2020-10-02T14:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgwODk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxNDE3NQ==", "url": "https://github.com/bakdata/conquery/pull/1323#discussion_r498814175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic void containsAtLeas() {\n          \n          \n            \n            \tpublic void containsAtLeast() {", "author": "thoniTUB", "createdAt": "2020-10-02T13:16:26Z", "path": "backend/src/test/java/com/bakdata/conquery/integration/common/BitMapCDateSetTest.java", "diffHunk": "@@ -0,0 +1,639 @@\n+package com.bakdata.conquery.integration.common;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.time.LocalDate;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import com.bakdata.conquery.models.common.BitMapCDateSet;\n+import com.bakdata.conquery.models.common.daterange.CDateRange;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+public class BitMapCDateSetTest {\n+\n+\tpublic static Stream<Arguments> arguments() {\n+\t\treturn Stream\n+\t\t\t\t\t   .of(\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-02/1970-01-02, 1970-04-11/1970-04-12}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(1, 1),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(100, 101)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11, 1970-01-16/1970-01-17}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(15, 16)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2004-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2004, 01, 01)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2002, 01, 02)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 03)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2000-01-01/2000-01-02, 2000-01-04/2000-01-07}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 04),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2000, 01, 07)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-01/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02)\n+\t\t\t\t\t\t\t\t\t\t\t   ), CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01),\n+\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 01)\n+\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   LocalDate.of(2012, 01, 02),\n+\t\t\t\t\t\t\t\t\t\t\t\t\t   null\n+\t\t\t\t\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02))\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/2012-01-02, 2012-01-04/2012-01-04}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(null, LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2012, 01, 04), LocalDate.of(2012, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{2011-01-04/2011-01-04, 2012-01-02/+\u221e}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atLeast(LocalDate.of(2012, 01, 02)),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(LocalDate.of(2011, 01, 04), LocalDate.of(2011, 01, 04))\n+\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(-10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.exactly(-10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.exactly(-10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   String.format(\"{%s}\", CDateRange.of(10, 10)),\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(10, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{1970-01-01/1970-01-01}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(0, 0)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   ),\n+\t\t\t\t\t\t\t   Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(Integer.MIN_VALUE, 10)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1969-12-31}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-1)\n+\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(9, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\n+\t\t\t\t\t\t\t   , Arguments.of(\n+\t\t\t\t\t\t\t\t\t   \"{-\u221e/1970-01-11}\",\n+\t\t\t\t\t\t\t\t\t   new CDateRange[]{\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.of(-10, 10),\n+\t\t\t\t\t\t\t\t\t\t\t   CDateRange.atMost(-5),\n+\t\t\t\t\t\t\t\t\t\t\t   }\n+\t\t\t\t\t\t\t   )\n+\t\t\t\t\t   );\n+\t}\n+\n+\t@ParameterizedTest(name = \"{0}\")\n+\t@MethodSource(\"arguments\")\n+\tpublic void testAddMerging(String expected, CDateRange[] ranges) {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tfor (CDateRange range : ranges) {\n+\t\t\tset.add(range);\n+\t\t}\n+\t\tassertThat(set).hasToString(expected);\n+\t}\n+\n+\t@Test\n+\tpublic void testRemove() {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create();\n+\t\tset.add(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 01, 01),\n+\t\t\t\tLocalDate.of(2000, 12, 31)\n+\t\t));\n+\t\tset.remove(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 06, 01),\n+\t\t\t\tLocalDate.of(2000, 06, 20)\n+\t\t));\n+\t\tassertThat(set).hasToString(\"{2000-01-01/2000-05-31, 2000-06-21/2000-12-31}\");\n+\t}\n+\n+\t@Test\n+\tpublic void testAddMakingAll() {\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.atMost(1), CDateRange.atLeast(1)).asRanges())\n+\t\t\t\t.containsExactly(CDateRange.all())\n+\t\t;\n+\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.atMost(1), CDateRange.atLeast(1)))\n+\t\t\t\t.matches(BitMapCDateSet::isAll)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void testRetain() {\n+\t\tBitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(\n+\t\t\t\tLocalDate.of(2000, 01, 01),\n+\t\t\t\tLocalDate.of(2000, 12, 31)\n+\t\t));\n+\n+\t\tBitMapCDateSet retain = BitMapCDateSet.create(\n+\t\t\t\tCDateRange.of(\n+\t\t\t\t\t\tLocalDate.of(2000, 06, 01),\n+\t\t\t\t\t\tLocalDate.of(2000, 06, 20)\n+\t\t\t\t),\n+\t\t\t\tCDateRange.atLeast(LocalDate.of(2000, 12, 01))\n+\t\t);\n+\n+\t\tset.retainAll(retain);\n+\n+\t\tassertThat(set.asRanges()).containsExactly(\n+\t\t\t\tCDateRange.of(\n+\t\t\t\t\t\tLocalDate.of(2000, 06, 01),\n+\t\t\t\t\t\tLocalDate.of(2000, 06, 20)\n+\t\t\t\t),\n+\t\t\t\tCDateRange.of(\n+\t\t\t\t\t\tLocalDate.of(2000, 12, 01),\n+\t\t\t\t\t\tLocalDate.of(2000, 12, 31)\n+\t\t\t\t)\n+\t\t);\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveSpanFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.of(10, 20));\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(10, 20));\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveExactlyFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.exactly(10));\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.exactly(10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveAtMostFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.atMost(10));\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveAtLeastFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.atLeast(10));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atLeast(10));\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveNegativeAtLeastFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.atLeast(-10));\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atLeast(-10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testRetainRemoveNegativeAtMostFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.retainAll(CDateRange.atMost(-10));\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(-10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\t}\n+\n+\t@Test\n+\tpublic void removeAtMostFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.remove(CDateRange.atMost(10));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atLeast(11));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\t}\n+\n+\t@Test\n+\tpublic void removeAtLeastFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.remove(CDateRange.atLeast(10));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(9));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\n+\t}\n+\n+\t@Test\n+\tpublic void removeExactlyFromItself() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.exactly(10));\n+\t\tset.remove(CDateRange.exactly(10));\n+\n+\t\tassertThat(set.asRanges()).isEmpty();\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(BitMapCDateSet::isEmpty)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\n+\t}\n+\n+\t@Test\n+\tpublic void removeExactlyFromAnother() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.exactly(10));\n+\t\tset.remove(CDateRange.exactly(11));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.exactly(10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\n+\t@Test\n+\tpublic void removeAllFromFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.all());\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(BitMapCDateSet::isAll)\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeExactlyFromRangeOverNegativeAxis() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\tset.remove(CDateRange.exactly(10));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, 9));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeSpanFromRangeOverNegativAxis() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\tset.remove(CDateRange.of(-1, 1));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, -2), CDateRange.of(2, 10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeNegativeAtMostFromSpanOverNegativeAxis() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\tset.remove(CDateRange.atMost(-5));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-4, 10));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removePositiveAtLeastFromSpanOverNegativeAxis() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\tset.remove(CDateRange.atLeast(5));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.of(-10, 4));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeAllFromSpanOverNegativeAxis() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.of(-10, 10));\n+\t\tset.remove(CDateRange.all());\n+\n+\t\tassertThat(set.asRanges()).isEmpty();\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(BitMapCDateSet::isEmpty)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeSpanOverNegativeAxisFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.remove(CDateRange.of(-1, 1));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(-2), CDateRange.atLeast(2));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void removeExactlyZeroFromAll() {\n+\t\tfinal BitMapCDateSet set = BitMapCDateSet.create(CDateRange.all());\n+\t\tset.remove(CDateRange.exactly(0));\n+\n+\t\tassertThat(set.asRanges()).containsExactly(CDateRange.atMost(-1), CDateRange.atLeast(1));\n+\n+\t\tassertThat(set)\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isEmpty))\n+\t\t\t\t.matches(Predicate.not(BitMapCDateSet::isAll))\n+\t\t;\n+\t}\n+\n+\t@Test\n+\tpublic void containsExactly() {\n+\t\tassertThat(BitMapCDateSet.create(CDateRange.of(1, 1)))\n+\t\t\t\t.matches(set -> set.contains(1))\n+\t\t\t\t.matches(set -> !set.contains(-1));\n+\n+\t}\n+\n+\t@Test\n+\tpublic void containsAtLeas() {", "originalCommit": "116f6f9df2374c519216a4a6d470929eb19ff6c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c7b87134e33a3ee49236a5d15c6becf8cb0c9b90", "url": "https://github.com/bakdata/conquery/commit/c7b87134e33a3ee49236a5d15c6becf8cb0c9b90", "message": "Update backend/src/test/java/com/bakdata/conquery/integration/common/BitMapCDateSetTest.java\n\nCo-authored-by: MT <12283268+thoniTUB@users.noreply.github.com>", "committedDate": "2020-10-02T14:21:37Z", "type": "commit"}, {"oid": "7a5072a2f763d1c33fcfe7c34c1203291623dff5", "url": "https://github.com/bakdata/conquery/commit/7a5072a2f763d1c33fcfe7c34c1203291623dff5", "message": "Merge branch 'develop' into feature/dateset-as-bitmap", "committedDate": "2020-10-02T14:22:17Z", "type": "commit"}]}