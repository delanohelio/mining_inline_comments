{"pr_number": 1389, "pr_title": "fix empty result cells from EXISTS aggregator", "pr_createdAt": "2020-10-12T14:24:13Z", "pr_url": "https://github.com/bakdata/conquery/pull/1389", "timeline": [{"oid": "c212ef2b2269783f655e623ebb17eb7f1bcd57ca", "url": "https://github.com/bakdata/conquery/commit/c212ef2b2269783f655e623ebb17eb7f1bcd57ca", "message": "fix returning of wronly sized empty result", "committedDate": "2020-10-13T14:45:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Mzc0NA==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r507673744", "bodyText": "W\u00fcrdest du hier nicht lieber die Funktion von oben wieder verwenden?", "author": "awildturtok", "createdAt": "2020-10-19T11:31:36Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/managed/RelativeFormQueryPlan.java", "diffHunk": "@@ -48,24 +57,35 @@ public EntityResult execute(QueryExecutionContext ctx, Entity entity) {\n \t\tif (preResult.isFailed() || !preResult.isContained()) {\n \t\t\treturn preResult;\n \t\t}\n-\n+\t\tint size = calculateCompleteLength();\n \t\tSinglelineContainedEntityResult contained = (SinglelineContainedEntityResult) preResult;\n+\t\t\n+\t\t// generate date contexts \n \t\tBitMapCDateSet dateSet = BitMapCDateSet.parse(Objects.toString(contained.getValues()[0]));\n \t\tfinal OptionalInt sampled = indexSelector.sample(dateSet);\n-\n+\t\t\n \t\t// dateset is empty or sampling failed.\n \t\tif (sampled.isEmpty()) {\n \t\t\tlog.warn(\"Sampled empty result for Entity[{}]: `{}({})`\", contained.getEntityId(), indexSelector, dateSet);\n-\t\t\treturn preResult;\n+\t\t\tList<Object[]> results = new ArrayList<>();", "originalCommit": "f665e3b59b6481dd84bf5b0cf781cb5a7d424033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NDAyOQ==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r508454029", "bodyText": "@awildturtok  Welche Funktion meinst du genau?", "author": "thoniTUB", "createdAt": "2020-10-20T12:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3Mzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NTEzNw==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r507675137", "bodyText": "del", "author": "awildturtok", "createdAt": "2020-10-19T11:34:18Z", "path": "backend/src/main/java/com/bakdata/conquery/models/forms/util/ResultModifier.java", "diffHunk": "@@ -1,143 +1,76 @@\n package com.bakdata.conquery.models.forms.util;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import java.util.OptionalInt;\n import java.util.function.UnaryOperator;\n \n-import com.bakdata.conquery.models.query.queryplan.ArrayConceptQueryPlan;\n-import com.bakdata.conquery.models.query.queryplan.ConceptQueryPlan;\n import com.bakdata.conquery.models.query.queryplan.aggregators.Aggregator;\n import com.bakdata.conquery.models.query.queryplan.aggregators.specific.ExistsAggregator;\n-import com.bakdata.conquery.models.query.results.EntityResult;\n-import com.bakdata.conquery.models.query.results.MultilineContainedEntityResult;\n-import com.bakdata.conquery.models.query.results.SinglelineContainedEntityResult;\n+import com.bakdata.conquery.models.query.results.ContainedEntityResult;\n+import com.bakdata.conquery.util.functions.ChainableUnaryOperator;\n \n public class ResultModifier {\n-\n \t/**\n \t * Modifies the given result lines with the given function.\n \t * \n \t * If the result is not contained this method creates a default result row anyways.\n \t */\n-\tpublic static List<Object[]> modify(EntityResult inResult, ConceptQueryPlan subPlan, UnaryOperator<Object[]> modification) {\n-\t\tif(inResult.isFailed()) {\n-\t\t\tthrow new RuntimeException(\"failed result can't be modified: \"+inResult);\n-\t\t}\n-\t\tif(!inResult.isContained()) {\n-\t\t\tObject[] result = new Object[subPlan.getAggregatorSize()];\n-\t\t\tint aggIdx = 0;\n-\t\t\tfor(Aggregator<?> agg : subPlan.getAggregators()) {\n-\t\t\t\t// Fill with null, except for EXIST aggregators\n-\t\t\t\tif(agg instanceof ExistsAggregator) {\n-\t\t\t\t\tresult[aggIdx] = false;\n-\t\t\t\t}\n-\t\t\t\taggIdx++;\n-\t\t\t}\n-\t\t\treturn Collections.singletonList(modification.apply(result));\n-\t\t}\n-\t\tif(inResult instanceof SinglelineContainedEntityResult) {\n-\t\t\treturn Collections.singletonList(\n-\t\t\t\tmodification.apply(\n-\t\t\t\t\t((SinglelineContainedEntityResult) inResult).getValues()\n-\t\t\t\t)\n-\t\t\t);\n-\t\t}\n-\t\telse if(inResult instanceof MultilineContainedEntityResult) {\n-\t\t\tvar values = ((MultilineContainedEntityResult) inResult).getValues();\n-\t\t\tList<Object[]> result = new ArrayList<>(values);\n-\t\t\tresult.replaceAll(modification);\n-\t\t\treturn result;\n-\t\t}\n-\t\tthrow new UnsupportedOperationException();\n+\tpublic static <T extends ContainedEntityResult> T modify(T inResult, UnaryOperator<Object[]> modification) {\n+\t\t\n+\t\tinResult.modifyResultLinesInplace(modification);\n+\t\t\n+\t\treturn inResult;\n \t}\n \t\n-\t/**\n-\t * Modifies the given result lines with the given function.\n-\t * \n-\t * If the result is not contained this method creates a default result row anyways.\n-\t */\n-\t// TODO We can maybe refactor this by using the method above. But this might require a new result type (ArrayContainedEntityResult?)\n-\tpublic static List<Object[]> modify(EntityResult inResult, ArrayConceptQueryPlan arrayPlan, UnaryOperator<Object[]> modification) {\n-\t\tif(inResult.isFailed()) {\n-\t\t\tthrow new RuntimeException(\"failed result can't be modified: \"+inResult);\n-\t\t}\n-\t\tif(!inResult.isContained()) {\n-\t\t\tObject[] result = new Object[arrayPlan.getAggregatorSize()];\n-\t\t\tint aggIdx = 0;\n-\t\t\tfor(ConceptQueryPlan subPlan : arrayPlan.getChildPlans()) {\n-\t\t\t\tfor(Aggregator<?> agg : subPlan.getAggregators()) {\n-\t\t\t\t\t// Fill with null, except for EXIST aggregators\n-\t\t\t\t\tif(agg instanceof ExistsAggregator) {\n-\t\t\t\t\t\tresult[aggIdx] = false;\n-\t\t\t\t\t}\n-\t\t\t\t\taggIdx++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn Collections.singletonList(modification.apply(result));\n-\t\t}\n-\t\tif(inResult instanceof SinglelineContainedEntityResult) {\n-\t\t\tObject[] result = ((SinglelineContainedEntityResult) inResult).getValues();\n-\t\t\tint aggIdx = 0;\n-\t\t\t/* Special handling here aswell because a subquery might not be contained but has an EXIST select.\n-\t\t\t * This would cause null (empty cell), so we fetch all EXIST result and put them to the end result.\n-\t\t\t */\n-\t\t\tfor(ConceptQueryPlan subPlan : arrayPlan.getChildPlans()) {\n-\t\t\t\tfor(Aggregator<?> agg : subPlan.getAggregators()) {\n-\t\t\t\t\t// Fill EXIST aggregators with false which evaluated to 'null'\n-\t\t\t\t\tif(agg instanceof ExistsAggregator && Objects.isNull(result[aggIdx])) {\n-\t\t\t\t\t\tresult[aggIdx] = false;\n-\t\t\t\t\t}\n-\t\t\t\t\taggIdx++;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\t\n-\t\t\treturn Collections.singletonList(\n-\t\t\t\tmodification.apply(\n-\t\t\t\t\tresult\n-\t\t\t\t)\n-\t\t\t);\n-\t\t}\n-\t\telse if(inResult instanceof MultilineContainedEntityResult) {\n-\t\t\t List<Object[]> values = ((MultilineContainedEntityResult) inResult).getValues();\n-\t\t\tList<Object[]> result = new ArrayList<>(values);\n-\t\t\tresult.replaceAll(modification);\n-\t\t\treturn result;\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new UnsupportedOperationException();\n-\t\t}\n+\tpublic static ChainableUnaryOperator<Object[]> existAggValuesSetterFor(List<Aggregator<?>> aggregators, OptionalInt firstAggPos) {\n+\t\treturn (result) -> setExistAggValues(aggregators, result, firstAggPos);\n \t}\n \t\n-\t/**\n-\t * Modifies the given result lines with the given function.\n-\t * \n-\t * If the result is not contained this method returns an empty list\n-\t */\n-\tpublic static List<Object[]> modify(EntityResult inResult, UnaryOperator<Object[]> modification) {\n-\t\tif(inResult.isFailed()) {\n-\t\t\tthrow new RuntimeException(\"failed result can't be modified: \"+inResult);\n-\t\t}\n-\t\tif(!inResult.isContained()) {\n-\t\t\treturn Collections.emptyList();\n-\t\t}\n-\t\tif(inResult instanceof SinglelineContainedEntityResult) {\n-\t\t\treturn Collections.singletonList(\n-\t\t\t\tmodification.apply(\n-\t\t\t\t\t((SinglelineContainedEntityResult) inResult).getValues()\n-\t\t\t\t)\n-\t\t\t);\n-\t\t}\n-\t\telse if(inResult instanceof MultilineContainedEntityResult) {\n-\t\t\tvar values = ((MultilineContainedEntityResult) inResult).getValues();\n-\t\t\tList<Object[]> result = new ArrayList<>(values);\n-\t\t\tresult.replaceAll(modification);\n-\t\t\treturn result;\n-\t\t}\n-\t\telse {\n-\t\t\tthrow new UnsupportedOperationException();\n+\tprivate static Object[] setExistAggValues(List<Aggregator<?>> aggregators, Object[] result, OptionalInt firstAggPos){\n+\t\tint aggIdx = firstAggPos.orElse(0);\n+\t\t/* Special handling here, because a subquery might not be contained but has an EXIST select.\n+\t\t * This would cause null (empty cell), so we fetch all EXIST result and put them to the end result.\n+\t\t */\n+\t\tfor(Aggregator<?> agg : aggregators) {\n+\t\t\t// Fill EXIST aggregators with false which evaluated to 'null'\n+\t\t\tif(agg instanceof ExistsAggregator && Objects.isNull(result[aggIdx])) {\n+\t\t\t\tresult[aggIdx] = false;\n+\t\t\t}\n+\t\t\taggIdx++;\n \t\t}\n+\t\treturn result;\n \t}\n+\t\n+//\t/**", "originalCommit": "f665e3b59b6481dd84bf5b0cf781cb5a7d424033", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzAyMA==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r507677020", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tvoid modifyResultLinesInplace(UnaryOperator<Object[]> lineModifier);\n          \n          \n            \n            \tvoid applyModifiers(UnaryOperator<Object[]> lineModifier);\n          \n      \n    \n    \n  \n\nAber brauchst du denn extra eine Funtkion, die ide Verkettung macht f\u00fcr dich?\nWenn ich das richtig verstehe l\u00f6st du damit das Problem von\na = []\na.replaceAll(f)\na.replaceAll(g)\n\nzu\na.replaceAll(x -> g(f(x)))\n\n\n?", "author": "awildturtok", "createdAt": "2020-10-19T11:37:46Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/results/ContainedEntityResult.java", "diffHunk": "@@ -22,4 +24,17 @@\n \tdefault ContainedEntityResult asContained() {\n \t\treturn this;\n \t}\n+\t\n+\t/**\n+\t * Returns a list of the computed result line for this entity on the query.\n+\t */\n+\tList<Object[]> listResultLines();\n+\t\n+\t/**\n+\t * Allows to modify the underlying result directly. The return value of the line modifier is the new line.\n+\t * So the modifier can change the array without reallocation by return the reference it received. Alternative it can \n+\t * allocate a new result line and return that reference instead. \n+\t * @param lineModifier A modifier(-chain) for a result line.\n+\t */\n+\tvoid modifyResultLinesInplace(UnaryOperator<Object[]> lineModifier);", "originalCommit": "f665e3b59b6481dd84bf5b0cf781cb5a7d424033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NzEzOA==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r508457138", "bodyText": "Genau, dann muss nur ein einziges mal \u00fcber das ergebnis iteriert werden und die Modifiers bleiben unabh\u00e4nging von einander.", "author": "thoniTUB", "createdAt": "2020-10-20T12:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzIxMA==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r507677210", "bodyText": "\u00fcps", "author": "awildturtok", "createdAt": "2020-10-19T11:38:08Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/results/MultilineContainedEntityResult.java", "diffHunk": "@@ -48,4 +49,15 @@ public int columnCount() {\n \t\t// We look at the first result line to determine the number of columns\n \t\treturn values.get(0).length;\n \t}\n+\n+\t@Override\n+\tpublic void modifyResultLinesInplace(UnaryOperator<Object[]> lineModifier) {\n+\t\tvalues.replaceAll(lineModifier);\n+\t}\n+\n+\t@Override\n+\tpublic List<Object[]> listResultLines() {\n+\t\t// TODO Auto-generated method stub", "originalCommit": "f665e3b59b6481dd84bf5b0cf781cb5a7d424033", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzU3Mg==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r507677572", "bodyText": "das reassignment kannst du dir ja genau sparen weil der contract inPlace verlangt?", "author": "awildturtok", "createdAt": "2020-10-19T11:38:52Z", "path": "backend/src/main/java/com/bakdata/conquery/models/query/results/SinglelineContainedEntityResult.java", "diffHunk": "@@ -36,4 +39,14 @@ public boolean isContained() {\n \tpublic int columnCount() {\n \t\treturn values.length;\n \t}\n+\n+\t@Override\n+\tpublic void modifyResultLinesInplace(UnaryOperator<Object[]> lineModifier) {\n+\t\tvalues = lineModifier.apply(values);", "originalCommit": "f665e3b59b6481dd84bf5b0cf781cb5a7d424033", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1OTU1NA==", "url": "https://github.com/bakdata/conquery/pull/1389#discussion_r508459554", "bodyText": "Mit inplace meine ich, dass das ContainedEntityResult modifiziert wird. Die Modifier haben volle kontrolle \u00fcber die ResultLine und k\u00f6nnen sie vollkommen ersetzten, so wie das der addConstants Modifier macht. Der allozierert ein neues Array. Diese Referenz muss ich werder zur\u00fcck geben.", "author": "thoniTUB", "createdAt": "2020-10-20T12:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY3NzU3Mg=="}], "type": "inlineReview"}, {"oid": "eed9db2c58e06567ec25d89e296c3033fb7ec155", "url": "https://github.com/bakdata/conquery/commit/eed9db2c58e06567ec25d89e296c3033fb7ec155", "message": "simplify modification code", "committedDate": "2020-10-23T07:22:18Z", "type": "commit"}, {"oid": "b0e32247e182f11290a634ef9f6a2941be47c1c8", "url": "https://github.com/bakdata/conquery/commit/b0e32247e182f11290a634ef9f6a2941be47c1c8", "message": "fix returning of wronly sized empty result", "committedDate": "2020-10-23T07:22:19Z", "type": "commit"}, {"oid": "0aebd6bbecb0b79bfb7ebe405903afc01d2450f2", "url": "https://github.com/bakdata/conquery/commit/0aebd6bbecb0b79bfb7ebe405903afc01d2450f2", "message": "handle queries without reference date", "committedDate": "2020-10-23T07:22:20Z", "type": "commit"}, {"oid": "36e842e1d35601a92e9886e324a7c8c0967dcbed", "url": "https://github.com/bakdata/conquery/commit/36e842e1d35601a92e9886e324a7c8c0967dcbed", "message": "set exists select values in vor entities that are actually empty", "committedDate": "2020-10-23T07:22:21Z", "type": "commit"}, {"oid": "e8d0a4808eb14f8f505c7f4e79207b7d5e980ca2", "url": "https://github.com/bakdata/conquery/commit/e8d0a4808eb14f8f505c7f4e79207b7d5e980ca2", "message": "handle not contained results to generate a result line with EXISTS selects set", "committedDate": "2020-10-23T07:22:22Z", "type": "commit"}, {"oid": "72650d22a70ea82e0993aa30fd9c0f9b32200beb", "url": "https://github.com/bakdata/conquery/commit/72650d22a70ea82e0993aa30fd9c0f9b32200beb", "message": "remove commented code block", "committedDate": "2020-10-23T07:22:23Z", "type": "commit"}, {"oid": "bc7ecc37c5e7f85e6a1701498206ef4385647513", "url": "https://github.com/bakdata/conquery/commit/bc7ecc37c5e7f85e6a1701498206ef4385647513", "message": "remove todo", "committedDate": "2020-10-23T07:22:24Z", "type": "commit"}, {"oid": "48022b7a49341e8f9b67773f2036a2786ac713fe", "url": "https://github.com/bakdata/conquery/commit/48022b7a49341e8f9b67773f2036a2786ac713fe", "message": "format test data", "committedDate": "2020-10-23T07:22:25Z", "type": "commit"}, {"oid": "48022b7a49341e8f9b67773f2036a2786ac713fe", "url": "https://github.com/bakdata/conquery/commit/48022b7a49341e8f9b67773f2036a2786ac713fe", "message": "format test data", "committedDate": "2020-10-23T07:22:25Z", "type": "forcePushed"}]}