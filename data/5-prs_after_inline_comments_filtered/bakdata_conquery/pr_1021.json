{"pr_number": 1021, "pr_title": "Local basic authentication", "pr_createdAt": "2020-02-06T13:52:16Z", "pr_url": "https://github.com/bakdata/conquery/pull/1021", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5NDEzMg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377594132", "bodyText": "Doku bitte", "author": "awildturtok", "createdAt": "2020-02-11T12:05:24Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/ApiV1.java", "diffHunk": "@@ -30,18 +28,13 @@ public void registerResources(MasterCommand master) {\n \t\t\t@Override\n \t\t\tprotected void configure() {\n \t\t\t\tbind(new ConceptsProcessor(master.getNamespaces())).to(ConceptsProcessor.class);\n-\t\t\t\tbind(new QueryProcessor(namespaces, master.getStorage())).to(QueryProcessor.class);\n-\t\t\t\tbind(new MeProcessor(namespaces.getMetaStorage())).to(MeProcessor.class);\n+\t\t\t\tbind(new MeProcessor(master.getStorage())).to(MeProcessor.class);\n+\t\t\t\tbind(new QueryProcessor(namespaces,master.getStorage())).to(QueryProcessor.class);\n \t\t\t}\n \t\t});\n \t\t\n-\t\tenvironment.register(new TokenExtractorFilter(ConqueryConfig.getInstance().getAuthentication().getTokenExtractor()));\n-\t\t/*\n-\t\t * register CORS-Preflight filter inbetween token extraction and authentication\n-\t\t * to intercept unauthenticated OPTIONS requests\n-\t\t */\n \t\tenvironment.register(new CORSPreflightRequestFilter());\n-\t\tenvironment.register(master.getAuthDynamicFeature());\n+\t\tenvironment.register(master.getAuthController().getAuthenticationFilter());", "originalCommit": "2a424583e934b7766b9b2f7493568d908fb19ae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5NTcwNQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377595705", "bodyText": "Wenn du die Felder final machst, tauchen die im RequiredArgsCtor von @DaTa auf", "author": "awildturtok", "createdAt": "2020-02-11T12:09:16Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/auth/PasswordCredential.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.bakdata.conquery.apiv1.auth;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.auth.basic.LocalAuthenticationRealm;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import lombok.AllArgsConstructor;\n+import lombok.Getter;\n+import lombok.NoArgsConstructor;\n+\n+/**\n+ * Container for holding a password. This credential type is used by the\n+ * {@link LocalAuthenticationRealm}.\n+ */\n+@CPSType(base = CredentialType.class, id = \"PASSWORD\")\n+@Getter\n+@NoArgsConstructor(onConstructor = @__({ @JsonCreator }))\n+@AllArgsConstructor\n+public class PasswordCredential implements CredentialType {", "originalCommit": "2a424583e934b7766b9b2f7493568d908fb19ae3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5ODQyMw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377598423", "bodyText": "cool!", "author": "awildturtok", "createdAt": "2020-02-11T12:15:40Z", "path": "backend/src/main/java/com/bakdata/conquery/commands/MasterCommand.java", "diffHunk": "@@ -121,7 +121,14 @@ public void run(ConqueryConfig config, Environment environment) throws IOExcepti\n \t\t}\n \n \t\tadmin = new AdminServlet();\n-\t\tadmin.register(this);\n+\t\tadmin.register(this, authController);\n+\t\t\n+\t\t// Register an unprotected servlet for logins on the app port\n+\t\tAuthServlet.registerUnprotectedApiResources(authController, environment.metrics(), config, environment.servlets(), environment.getObjectMapper());", "originalCommit": "2a424583e934b7766b9b2f7493568d908fb19ae3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5ODU2OQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377598569", "bodyText": "Kannst du da evtl auch sowas wie progressive timeout installieren?", "author": "awildturtok", "createdAt": "2020-02-11T12:15:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5ODQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4NDk0Mg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377684942", "bodyText": "Ja das w\u00fcrde gehen, man m\u00fcsste dann nur \u00fcberlegen wie man den user \u00fcber verschiedene requests tracked oder ob man eine Sperre f\u00fcr den verwendeten Username einrichtet mit dem sich der Nutzer versucht hat einzuloggen", "author": "thoniTUB", "createdAt": "2020-02-11T14:55:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5ODQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzU5OTM1OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377599358", "bodyText": "Du musst noch deine Doku aufr\u00e4umen", "author": "awildturtok", "createdAt": "2020-02-11T12:17:52Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/MasterMetaStorage.java", "diffHunk": "@@ -86,14 +86,14 @@\n \t * @param role The role, which holds the values, to be updated.\n \t * @throws JSONException Is throw on a JSON related failure.\n \t */\n-\tvoid updateRole(Role role) throws JSONException;\n+\tvoid updateRole(Role role) ;\n \t\n \t/**\n \t * Adds a role to the storage.\n \t * @param role The role to add.\n \t * @throws JSONException Is throw on a JSON related failure.", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwMDE4Nw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377600187", "bodyText": "https://projectlombok.org/features/SneakyThrows\nUnd dann auch noch undokumentiert, und nicht im Utility :oprah winfrey no.gif:", "author": "awildturtok", "createdAt": "2020-02-11T12:19:40Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/MasterMetaStorageImpl.java", "diffHunk": "@@ -214,7 +215,16 @@ public void removeGroup(GroupId id) {\n \t}\n \n \t@Override\n-\tpublic void updateGroup(Group group) throws JSONException {\n-\t\tauthGroup.update(group);\n+\tpublic void updateGroup(Group group) {\n+\t\tasRuntimeException(() -> authGroup.update(group));\n+\t}\n+\t\n+\tpublic static void asRuntimeException(ThrowingRunnable runnable) {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwMDg1NA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377600854", "bodyText": "K\u00f6nnen wir noch ne Funktion einbauen, die die InitialUser deaktiviert? Das w\u00e4re toll zum bootstrappen!", "author": "awildturtok", "createdAt": "2020-02-11T12:21:05Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationConfig.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.auth.ProtoUser;\n+import com.bakdata.conquery.io.cps.CPSBase;\n+import com.bakdata.conquery.models.auth.permissions.QueryPermission;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+/**\n+ * Configurations of this type define the initial users with their permissions\n+ * and optional credentials that might be registered by realm that are\n+ * {@link UserManageable}.\n+ */\n+@JsonTypeInfo(use = JsonTypeInfo.Id.CUSTOM, property = \"type\")\n+@CPSBase\n+public interface AuthorizationConfig {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNjY0OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377606648", "bodyText": "Ist das ne gute Idee mehrere Realms anzubieten? Es klingt f\u00fcr mich so ein bisschen nach the Worst of both worlds", "author": "awildturtok", "createdAt": "2020-02-11T12:34:05Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationController.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.auth.ProtoUser;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.web.DefaultAuthFilter;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import io.dropwizard.auth.AuthFilter;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.SecurityUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.mgt.DefaultSecurityManager;\n+import org.apache.shiro.mgt.SecurityManager;\n+import org.apache.shiro.realm.AuthorizingRealm;\n+import org.apache.shiro.realm.Realm;\n+import org.apache.shiro.util.LifecycleUtils;\n+\n+/**\n+ * The central class for the initialization of authorization and authentication.\n+ * Conquery uses a permission based authorization and supports different type of\n+ * authentication. For each authentication type a\n+ * {@link ConqueryAuthenticationRealm} must be defined and its configuration\n+ * needs to be appended in the {@link ConqueryConfig}. A single\n+ * {@link ConqueryAuthorizationRealm} handles the mapping of the authenticated\n+ * {@link UserId}s to the permissions they hold.\n+ */\n+@Slf4j\n+public final class AuthorizationController {\n+\n+\t@Getter\n+\tprivate MasterMetaStorage storage;\n+\t@Getter\n+\tprivate List<ConqueryAuthenticationRealm> authenticationRealms = new ArrayList<>();", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI3NTU5NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378275595", "bodyText": "Das ist der mechanismus von Shiro unterschiedliche Authentifizierungsmethoden anzubieten", "author": "thoniTUB", "createdAt": "2020-02-12T14:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNjkzNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377606934", "bodyText": "Bitte keine Logik in nem Konstruktor, daf\u00fcr lieber eine Statische Funktion verwenden", "author": "awildturtok", "createdAt": "2020-02-11T12:34:47Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationController.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import com.bakdata.conquery.apiv1.auth.ProtoUser;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.web.DefaultAuthFilter;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import io.dropwizard.auth.AuthFilter;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.SecurityUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.mgt.DefaultSecurityManager;\n+import org.apache.shiro.mgt.SecurityManager;\n+import org.apache.shiro.realm.AuthorizingRealm;\n+import org.apache.shiro.realm.Realm;\n+import org.apache.shiro.util.LifecycleUtils;\n+\n+/**\n+ * The central class for the initialization of authorization and authentication.\n+ * Conquery uses a permission based authorization and supports different type of\n+ * authentication. For each authentication type a\n+ * {@link ConqueryAuthenticationRealm} must be defined and its configuration\n+ * needs to be appended in the {@link ConqueryConfig}. A single\n+ * {@link ConqueryAuthorizationRealm} handles the mapping of the authenticated\n+ * {@link UserId}s to the permissions they hold.\n+ */\n+@Slf4j\n+public final class AuthorizationController {\n+\n+\t@Getter\n+\tprivate MasterMetaStorage storage;\n+\t@Getter\n+\tprivate List<ConqueryAuthenticationRealm> authenticationRealms = new ArrayList<>();\n+\t@Getter\n+\tAuthFilter<AuthenticationToken, User> authenticationFilter;\n+\t@Getter\n+\tprivate List<Realm> realms = new ArrayList<>();\n+\n+\tpublic AuthorizationController(MasterMetaStorage storage, ConqueryConfig config) {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNzY0Ng==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377607646", "bodyText": "Die Config speicherst du zB auch gar nicht.", "author": "awildturtok", "createdAt": "2020-02-11T12:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI5MzY1MQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378293651", "bodyText": "Hab eine init Funktion hinzugef\u00fcgt, die das kapselt", "author": "thoniTUB", "createdAt": "2020-02-12T14:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwNzkzMQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377607931", "bodyText": "Die Doku aufr\u00e4umen", "author": "awildturtok", "createdAt": "2020-02-11T12:36:57Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationHelper.java", "diffHunk": "@@ -118,7 +123,7 @@ public static void authorize(@NonNull User user, @NonNull ConqueryPermission toB\n \t * @param storage A storage where the permission are added for persistence.\n \t * @throws JSONException When the permission object could not be formed in to the appropriate JSON format.", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwODEzNg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377608136", "bodyText": "requireNonNull kann auch Nachrichten schicken ,f\u00e4nde ich hier ganz gut", "author": "awildturtok", "createdAt": "2020-02-11T12:37:26Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationHelper.java", "diffHunk": "@@ -190,6 +195,53 @@ public static void removePermission(@NonNull PermissionOwner<?> owner, @NonNull\n \t}\n \t\n \n+\t\n+\tpublic static <P extends PermissionOwner<?>> void addRoleTo(MasterMetaStorage storage, PermissionOwnerId<P> ownerId, RoleId roleId) {\n+\t\tRole role = Objects.requireNonNull(roleId.getPermissionOwner(storage));", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwODIwNQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377608205", "bodyText": "\"supplied Role is null\" oder so", "author": "awildturtok", "createdAt": "2020-02-11T12:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwODEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwMTc5NA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378301794", "bodyText": "Oki :)", "author": "thoniTUB", "createdAt": "2020-02-12T14:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwODEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwOTE2Ng==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377609166", "bodyText": "W\u00e4re das hier nicht schon au\u00dferhalb der Methode m\u00f6glich? Dann s\u00e4he sie sauberer aus. Und du kannst P doch auch direkt noch bounden an RoleOwner", "author": "awildturtok", "createdAt": "2020-02-11T12:39:55Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/AuthorizationHelper.java", "diffHunk": "@@ -190,6 +195,53 @@ public static void removePermission(@NonNull PermissionOwner<?> owner, @NonNull\n \t}\n \t\n \n+\t\n+\tpublic static <P extends PermissionOwner<?>> void addRoleTo(MasterMetaStorage storage, PermissionOwnerId<P> ownerId, RoleId roleId) {\n+\t\tRole role = Objects.requireNonNull(roleId.getPermissionOwner(storage));\n+\t\tP owner = Objects.requireNonNull(ownerId.getPermissionOwner(storage));", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwOTM3NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377609375", "bodyText": "also P extends PermOwner<?> & RoleOwner", "author": "awildturtok", "createdAt": "2020-02-11T12:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwOTE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI5NTYyOA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378295628", "bodyText": "Ich wusste nicht das man das einfach so verunden kann", "author": "thoniTUB", "createdAt": "2020-02-12T14:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYwOTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMDEyNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377610124", "bodyText": "Was sind die Credentials und wie langlebig sind die? Also sind die encrypted etc?", "author": "awildturtok", "createdAt": "2020-02-11T12:42:13Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/ConqueryAuthenticationInfo.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import lombok.Getter;\n+import org.apache.shiro.authc.AuthenticationInfo;\n+import org.apache.shiro.realm.Realm;\n+import org.apache.shiro.subject.SimplePrincipalCollection;\n+\n+/**\n+ * Specialization class of the {@link AuthenticationInfo} that enforces the use\n+ * of a {@link UserId} as primary principal.\n+ */\n+@SuppressWarnings(\"serial\")\n+@Getter\n+public class ConqueryAuthenticationInfo implements AuthenticationInfo {\n+\n+\tprivate final SimplePrincipalCollection principals = new SimplePrincipalCollection();\n+\tprivate final Object credentials;", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwNzc2OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378307768", "bodyText": "Die werden von uns nicht so wirklich benutzt, da wir signierte tokens benutzen", "author": "thoniTUB", "createdAt": "2020-02-12T15:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMDEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMTA4NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377611085", "bodyText": "Die Funktion throwed wenn das nicht funktioniert?", "author": "awildturtok", "createdAt": "2020-02-11T12:44:28Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/ConqueryAuthenticator.java", "diffHunk": "@@ -25,27 +22,27 @@\n  * We need this authenticator to plug in the security, and hereby shiro, into the AuthFilter.\n  */\n @Slf4j\n-public class ConqueryAuthenticator implements Authenticator<ConqueryToken, User>{\n+@RequiredArgsConstructor\n+public class ConqueryAuthenticator implements Authenticator<AuthenticationToken, User>{\n \t\n \tprivate final MasterMetaStorage storage;\n-\t\n-\tpublic ConqueryAuthenticator(MasterMetaStorage storage, Realm realm) {\n-\t\tthis.storage = storage;\n-\t\t\n-\t\tSecurityManager securityManager = new DefaultSecurityManager(realm);\n-\t\tSecurityUtils.setSecurityManager(securityManager);\n-\t\tlog.debug(\"Security manager registered\");\n-\t}\n \n \t@Override\n-\tpublic Optional<User> authenticate(ConqueryToken token) throws AuthenticationException {\n-\t\t\n+\tpublic Optional<User> authenticate(AuthenticationToken token) throws AuthenticationException {\n+\t\n+\t\t// Submit the token to Shiro (to all realms that were registered)\n \t\tAuthenticationInfo info = SecurityUtils.getSecurityManager().authenticate(token);", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwODcyOQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378308729", "bodyText": "jep", "author": "thoniTUB", "createdAt": "2020-02-12T15:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMTA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMjE5Nw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377612197", "bodyText": "Gibt die Methode nicht schon nen Immutable wert zur\u00fcck?", "author": "awildturtok", "createdAt": "2020-02-11T12:46:51Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/ConqueryAuthorizationRealm.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import lombok.RequiredArgsConstructor;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationInfo;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authz.AuthorizationInfo;\n+import org.apache.shiro.authz.Permission;\n+import org.apache.shiro.authz.SimpleAuthorizationInfo;\n+import org.apache.shiro.realm.AuthorizingRealm;\n+import org.apache.shiro.subject.PrincipalCollection;\n+\n+/**\n+ * This realms only provides authorization information for a given {@link UserId}.\n+ * For now there is only one such authorizing realm. This queries the {@link MasterMetaStorage}.\n+ */\n+@RequiredArgsConstructor\n+public class ConqueryAuthorizationRealm extends AuthorizingRealm {\n+\t\n+\tpublic final MasterMetaStorage storage;\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\t/*\n+\t\t * We don't handle authentication here, thus no token is supported. However we\n+\t\t * need to provide a TokenClass (that is used nowhere else), to not cause a\n+\t\t * NullPointerException (see AuthenticatingRealm#supports).\n+\t\t */\n+\t\tthis.setAuthenticationTokenClass(UnusedAuthenticationToken.class);\n+\t}\n+\n+\t@Override\n+\tprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n+\t\tObjects.requireNonNull(principals, \"No principal info was provided\");\n+\t\tUserId userId = UserId.class.cast(principals.getPrimaryPrincipal());\n+\t\tSimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n+\t\t\n+\t\tinfo.addObjectPermissions(new HashSet<Permission>(AuthorizationHelper.getEffectiveUserPermissions(userId, storage)));", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNTAxMA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378315010", "bodyText": "Ja aber der Elementtyp f\u00fcr addObjectPermissions muss vom SuperTyp Permission sein und nicht ConqueryPermission", "author": "thoniTUB", "createdAt": "2020-02-12T15:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMjM2NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377612365", "bodyText": "Warum kein normaler cast?", "author": "awildturtok", "createdAt": "2020-02-11T12:47:14Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/ConqueryAuthorizationRealm.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import java.util.HashSet;\n+import java.util.Objects;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import lombok.RequiredArgsConstructor;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationInfo;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authz.AuthorizationInfo;\n+import org.apache.shiro.authz.Permission;\n+import org.apache.shiro.authz.SimpleAuthorizationInfo;\n+import org.apache.shiro.realm.AuthorizingRealm;\n+import org.apache.shiro.subject.PrincipalCollection;\n+\n+/**\n+ * This realms only provides authorization information for a given {@link UserId}.\n+ * For now there is only one such authorizing realm. This queries the {@link MasterMetaStorage}.\n+ */\n+@RequiredArgsConstructor\n+public class ConqueryAuthorizationRealm extends AuthorizingRealm {\n+\t\n+\tpublic final MasterMetaStorage storage;\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\t/*\n+\t\t * We don't handle authentication here, thus no token is supported. However we\n+\t\t * need to provide a TokenClass (that is used nowhere else), to not cause a\n+\t\t * NullPointerException (see AuthenticatingRealm#supports).\n+\t\t */\n+\t\tthis.setAuthenticationTokenClass(UnusedAuthenticationToken.class);\n+\t}\n+\n+\t@Override\n+\tprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n+\t\tObjects.requireNonNull(principals, \"No principal info was provided\");\n+\t\tUserId userId = UserId.class.cast(principals.getPrimaryPrincipal());", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwOTIwNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378309204", "bodyText": "habs zu einem normalen cast gemacht", "author": "thoniTUB", "createdAt": "2020-02-12T15:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxMjM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxNDM1OQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377614359", "bodyText": "Warum nicht auch hier byteArray?", "author": "awildturtok", "createdAt": "2020-02-11T12:51:32Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationConfig.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.security.SecureRandom;\n+import java.util.Random;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.AuthenticationConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+@CPSType(base = AuthenticationConfig.class, id = \"LOCAL_AUTHENTICATION\")\n+@Getter\n+@Setter\n+public class LocalAuthenticationConfig implements AuthenticationConfig {\n+\t\n+\tprivate static final Random RANDOM = new SecureRandom();\n+\t/**\n+\t * The secret to sign the created JWTs.\n+\t */\n+\t@NotEmpty\n+\tprivate String tokenSecret = generateToken();", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxNDgwNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377614804", "bodyText": "W\u00fcrde ich fast nicht anbieten, weil das ja nicht in den Logs oder irgendwo auftauchen soll, dementsprechend relativ schwer ist wieder rauszubekommen. Da sollte Conquery einfach nicht starten d\u00fcrfen", "author": "awildturtok", "createdAt": "2020-02-11T12:52:31Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationConfig.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.security.SecureRandom;\n+import java.util.Random;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.AuthenticationConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+@CPSType(base = AuthenticationConfig.class, id = \"LOCAL_AUTHENTICATION\")\n+@Getter\n+@Setter\n+public class LocalAuthenticationConfig implements AuthenticationConfig {\n+\t\n+\tprivate static final Random RANDOM = new SecureRandom();\n+\t/**\n+\t * The secret to sign the created JWTs.\n+\t */\n+\t@NotEmpty\n+\tprivate String tokenSecret = generateToken();\n+\t\n+\t/**\n+\t * Configuration for the password store. An encryption for the store it self might be set here.\n+\t */\n+\t@NotNull\n+\tprivate XodusConfig passwordStoreConfig = new XodusConfig();\n+\t\n+\t/**\n+\t * The name of the folder the store lives in.\n+\t */\n+\t@NotEmpty\n+\tprivate String storeName = \"authenticationStore\";\n+\t\n+\t@Override\n+\tpublic LocalAuthenticationRealm createRealm(MasterMetaStorage storage) {\n+\t\treturn new LocalAuthenticationRealm(storage, this);\n+\t}\n+\t\n+\t/**\n+\t * Generate a random default token.\n+\t * @return The token as a {@link String}\n+\t */\n+\tprivate static String generateToken() {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxNTM1NA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377615354", "bodyText": "Das sollte aus der Config kommen", "author": "awildturtok", "createdAt": "2020-02-11T12:53:40Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationRealm.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.Conquery;\n+import com.bakdata.conquery.apiv1.auth.CredentialType;\n+import com.bakdata.conquery.apiv1.auth.PasswordCredential;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.io.xodus.stores.IStoreInfo;\n+import com.bakdata.conquery.io.xodus.stores.XodusStore;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.UserManageable;\n+import com.bakdata.conquery.models.auth.basic.PasswordHasher.HashedEntry;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.admin.AdminServlet.AuthAdminResourceProvider;\n+import com.bakdata.conquery.resources.admin.rest.UserAuthenticationManagementResource;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.MoreCollectors;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import jetbrains.exodus.ArrayByteIterable;\n+import jetbrains.exodus.ByteIterable;\n+import jetbrains.exodus.bindings.StringBinding;\n+import jetbrains.exodus.env.Environment;\n+import jetbrains.exodus.env.Environments;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+import org.glassfish.hk2.utilities.binding.AbstractBinder;\n+\n+/**\n+ * This realm stores credentials in a local database ({@link XodusStore}). Upon\n+ * successful authentication using username and password the authenticated user\n+ * is given a signed JWT for further authentication over following requests. The\n+ * realm offers a basic user management, which is decoupled form the\n+ * authorization related user information that is saved in the\n+ * {@link MasterMetaStorage}. So adding or removing a user in this realm does\n+ * not change the {@link MasterMetaStorage}. {@link Conquery} interacts with\n+ * this realm using the Shiro frame work. However, endusers can interface it\n+ * through specific endpoints that are registerd by this realm.\n+ */\n+@Slf4j\n+public class LocalAuthenticationRealm extends ConqueryAuthenticationRealm implements UserManageable, AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, AuthAdminResourceProvider {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\tprivate static final int EXPIRATION_PERIOD = 12; // Hours for JWTs", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxODk0Mg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377618942", "bodyText": "inlinen", "author": "awildturtok", "createdAt": "2020-02-11T13:00:56Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationRealm.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.Conquery;\n+import com.bakdata.conquery.apiv1.auth.CredentialType;\n+import com.bakdata.conquery.apiv1.auth.PasswordCredential;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.io.xodus.stores.IStoreInfo;\n+import com.bakdata.conquery.io.xodus.stores.XodusStore;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.UserManageable;\n+import com.bakdata.conquery.models.auth.basic.PasswordHasher.HashedEntry;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.admin.AdminServlet.AuthAdminResourceProvider;\n+import com.bakdata.conquery.resources.admin.rest.UserAuthenticationManagementResource;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.MoreCollectors;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import jetbrains.exodus.ArrayByteIterable;\n+import jetbrains.exodus.ByteIterable;\n+import jetbrains.exodus.bindings.StringBinding;\n+import jetbrains.exodus.env.Environment;\n+import jetbrains.exodus.env.Environments;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+import org.glassfish.hk2.utilities.binding.AbstractBinder;\n+\n+/**\n+ * This realm stores credentials in a local database ({@link XodusStore}). Upon\n+ * successful authentication using username and password the authenticated user\n+ * is given a signed JWT for further authentication over following requests. The\n+ * realm offers a basic user management, which is decoupled form the\n+ * authorization related user information that is saved in the\n+ * {@link MasterMetaStorage}. So adding or removing a user in this realm does\n+ * not change the {@link MasterMetaStorage}. {@link Conquery} interacts with\n+ * this realm using the Shiro frame work. However, endusers can interface it\n+ * through specific endpoints that are registerd by this realm.\n+ */\n+@Slf4j\n+public class LocalAuthenticationRealm extends ConqueryAuthenticationRealm implements UserManageable, AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, AuthAdminResourceProvider {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\tprivate static final int EXPIRATION_PERIOD = 12; // Hours for JWTs\n+\n+\tprivate final XodusConfig passwordStoreConfig;\n+\tprivate final String storeName;\n+\n+\t@JsonIgnore\n+\tprivate Environment passwordEnvironment;\n+\t@JsonIgnore\n+\tprivate XodusStore passwordStore;\n+\n+\t@JsonIgnore\n+\tprivate Algorithm tokenSignAlgorithm;\n+\t@JsonIgnore\n+\tprivate JWTVerifier oauthTokenVerifier;\n+\t@JsonIgnore\n+\tprivate MasterMetaStorage storage;\n+\n+\t@RequiredArgsConstructor\n+\t@Getter\n+\tprivate static class StoreInfo implements IStoreInfo {\n+\n+\t\tprivate final String xodusName;\n+\t\t// Not used\n+\t\tprivate final Class<?> keyType = String.class;\n+\t\t// Not used\n+\t\tprivate final Class<?> valueType = HashedEntry.class;\n+\n+\t}\n+\n+\t//////////////////// INITIALIZATION ////////////////////\n+\n+\tpublic LocalAuthenticationRealm(MasterMetaStorage storage, LocalAuthenticationConfig config) {\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.storage = storage;\n+\t\tthis.storeName = config.getStoreName();\n+\t\tthis.passwordStoreConfig = config.getPasswordStoreConfig();\n+\n+\t\ttokenSignAlgorithm = Algorithm.HMAC256(config.getTokenSecret());\n+\t\toauthTokenVerifier = JWT.require(tokenSignAlgorithm).withIssuer(getName()).build();\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\t// Open/create the database/store\n+\t\tFile passwordStoreFile = new File(ConqueryConfig.getInstance().getStorage().getDirectory(), storeName);\n+\t\tpasswordEnvironment = Environments.newInstance(passwordStoreFile, passwordStoreConfig.createConfig());\n+\t\tpasswordStore = new XodusStore(passwordEnvironment, new StoreInfo(\"passwords\"));\n+\t}\n+\n+\t//////////////////// AUTHENTICATION ////////////////////\n+\n+\t//////////////////// FOR JWT\n+\t@Override\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\tif (!(TOKEN_CLASS.isAssignableFrom(token.getClass()))) {\n+\t\t\t// Incompatible token\n+\t\t\treturn null;\n+\t\t}\n+\t\tDecodedJWT decodedToken = null;\n+\t\ttry {\n+\t\t\tdecodedToken = oauthTokenVerifier.verify((String) token.getCredentials());\n+\t\t}\n+\t\tcatch (TokenExpiredException e) {\n+\t\t\tlog.trace(\"The provided token is expired.\");\n+\t\t\tthrow new ExpiredCredentialsException(e);\n+\t\t}\n+\t\tcatch (SignatureVerificationException | InvalidClaimException e) {\n+\t\t\tlog.trace(\"The provided token was not successfully verified against its signature or claims.\");\n+\t\t\tthrow new IncorrectCredentialsException(e);\n+\t\t}\n+\t\tcatch (JWTVerificationException e) {\n+\t\t\tlog.trace(\"The provided token could not be verified.\");\n+\t\t\tthrow new AuthenticationException(e);\n+\t\t}\n+\n+\t\tString username = decodedToken.getSubject();\n+\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tlog.warn(\n+\t\t\t\t\"Provided credentials were valid, but a corresponding user was not found in the System. You need to add a user to the system with the id: {}\",\n+\t\t\t\tuserId);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(userId, token, this);\n+\t}\n+\n+\t//////////////////// FOR USERNAME/PASSWORD\n+\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\t// Check the password which is afterwards cleared\n+\t\tif (!CredentialChecker.validUsernamePassword(username, password, passwordStore)) {\n+\t\t\tthrow new AuthenticationException(\"Provided username or password was not valid.\");\n+\t\t}\n+\t\treturn TokenHandler.createToken(username, EXPIRATION_PERIOD, getName(), tokenSignAlgorithm);\n+\t}\n+\n+\t/**\n+\t * Converts the provided password to a Xodus compatible hash.\n+\t * \n+\t * @param optPassword\n+\t * @return\n+\t */\n+\tprivate static ByteIterable passwordToHashedEntry(Optional<PasswordCredential> optPassword) {\n+\t\treturn HashedEntry.asByteIterable(PasswordHasher.generateHashedEntry(optPassword.get().getPassword()));\n+\t}\n+\n+\t/**\n+\t * Checks the provided credentials for the realm-compatible\n+\t * {@link PasswordCredential}. However only one credential of this type is\n+\t * allowed to be provided.\n+\t * \n+\t * @param credentials\n+\t *            A list of possible credentials.\n+\t * @return The password credential.\n+\t */\n+\tprivate static Optional<PasswordCredential> getTypePassword(List<CredentialType> credentials) {\n+\t\tOptional<PasswordCredential> optPassword = credentials.stream().filter(PasswordCredential.class::isInstance)", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNDAxMw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377624013", "bodyText": "ein bisschen Doku w\u00fcrde mir hier gefallen, das sieht nach krasser magic aus", "author": "awildturtok", "createdAt": "2020-02-11T13:11:45Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationRealm.java", "diffHunk": "@@ -0,0 +1,273 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.JWTVerifier;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import com.auth0.jwt.exceptions.InvalidClaimException;\n+import com.auth0.jwt.exceptions.JWTVerificationException;\n+import com.auth0.jwt.exceptions.SignatureVerificationException;\n+import com.auth0.jwt.exceptions.TokenExpiredException;\n+import com.auth0.jwt.interfaces.DecodedJWT;\n+import com.bakdata.conquery.Conquery;\n+import com.bakdata.conquery.apiv1.auth.CredentialType;\n+import com.bakdata.conquery.apiv1.auth.PasswordCredential;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.io.xodus.stores.IStoreInfo;\n+import com.bakdata.conquery.io.xodus.stores.XodusStore;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.UserManageable;\n+import com.bakdata.conquery.models.auth.basic.PasswordHasher.HashedEntry;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.admin.AdminServlet.AuthAdminResourceProvider;\n+import com.bakdata.conquery.resources.admin.rest.UserAuthenticationManagementResource;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.google.common.collect.MoreCollectors;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import jetbrains.exodus.ArrayByteIterable;\n+import jetbrains.exodus.ByteIterable;\n+import jetbrains.exodus.bindings.StringBinding;\n+import jetbrains.exodus.env.Environment;\n+import jetbrains.exodus.env.Environments;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+import org.glassfish.hk2.utilities.binding.AbstractBinder;\n+\n+/**\n+ * This realm stores credentials in a local database ({@link XodusStore}). Upon\n+ * successful authentication using username and password the authenticated user\n+ * is given a signed JWT for further authentication over following requests. The\n+ * realm offers a basic user management, which is decoupled form the\n+ * authorization related user information that is saved in the\n+ * {@link MasterMetaStorage}. So adding or removing a user in this realm does\n+ * not change the {@link MasterMetaStorage}. {@link Conquery} interacts with\n+ * this realm using the Shiro frame work. However, endusers can interface it\n+ * through specific endpoints that are registerd by this realm.\n+ */\n+@Slf4j\n+public class LocalAuthenticationRealm extends ConqueryAuthenticationRealm implements UserManageable, AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, AuthAdminResourceProvider {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\tprivate static final int EXPIRATION_PERIOD = 12; // Hours for JWTs\n+\n+\tprivate final XodusConfig passwordStoreConfig;\n+\tprivate final String storeName;\n+\n+\t@JsonIgnore\n+\tprivate Environment passwordEnvironment;\n+\t@JsonIgnore\n+\tprivate XodusStore passwordStore;\n+\n+\t@JsonIgnore\n+\tprivate Algorithm tokenSignAlgorithm;\n+\t@JsonIgnore\n+\tprivate JWTVerifier oauthTokenVerifier;\n+\t@JsonIgnore\n+\tprivate MasterMetaStorage storage;\n+\n+\t@RequiredArgsConstructor\n+\t@Getter\n+\tprivate static class StoreInfo implements IStoreInfo {\n+\n+\t\tprivate final String xodusName;\n+\t\t// Not used\n+\t\tprivate final Class<?> keyType = String.class;\n+\t\t// Not used\n+\t\tprivate final Class<?> valueType = HashedEntry.class;\n+\n+\t}\n+\n+\t//////////////////// INITIALIZATION ////////////////////\n+\n+\tpublic LocalAuthenticationRealm(MasterMetaStorage storage, LocalAuthenticationConfig config) {\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.storage = storage;\n+\t\tthis.storeName = config.getStoreName();\n+\t\tthis.passwordStoreConfig = config.getPasswordStoreConfig();\n+\n+\t\ttokenSignAlgorithm = Algorithm.HMAC256(config.getTokenSecret());\n+\t\toauthTokenVerifier = JWT.require(tokenSignAlgorithm).withIssuer(getName()).build();\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\t// Open/create the database/store\n+\t\tFile passwordStoreFile = new File(ConqueryConfig.getInstance().getStorage().getDirectory(), storeName);\n+\t\tpasswordEnvironment = Environments.newInstance(passwordStoreFile, passwordStoreConfig.createConfig());\n+\t\tpasswordStore = new XodusStore(passwordEnvironment, new StoreInfo(\"passwords\"));\n+\t}\n+\n+\t//////////////////// AUTHENTICATION ////////////////////\n+\n+\t//////////////////// FOR JWT\n+\t@Override\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\tif (!(TOKEN_CLASS.isAssignableFrom(token.getClass()))) {\n+\t\t\t// Incompatible token\n+\t\t\treturn null;\n+\t\t}\n+\t\tDecodedJWT decodedToken = null;\n+\t\ttry {\n+\t\t\tdecodedToken = oauthTokenVerifier.verify((String) token.getCredentials());\n+\t\t}\n+\t\tcatch (TokenExpiredException e) {\n+\t\t\tlog.trace(\"The provided token is expired.\");\n+\t\t\tthrow new ExpiredCredentialsException(e);\n+\t\t}\n+\t\tcatch (SignatureVerificationException | InvalidClaimException e) {\n+\t\t\tlog.trace(\"The provided token was not successfully verified against its signature or claims.\");\n+\t\t\tthrow new IncorrectCredentialsException(e);\n+\t\t}\n+\t\tcatch (JWTVerificationException e) {\n+\t\t\tlog.trace(\"The provided token could not be verified.\");\n+\t\t\tthrow new AuthenticationException(e);\n+\t\t}\n+\n+\t\tString username = decodedToken.getSubject();\n+\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tlog.warn(\n+\t\t\t\t\"Provided credentials were valid, but a corresponding user was not found in the System. You need to add a user to the system with the id: {}\",\n+\t\t\t\tuserId);\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(userId, token, this);\n+\t}\n+\n+\t//////////////////// FOR USERNAME/PASSWORD\n+\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\t// Check the password which is afterwards cleared\n+\t\tif (!CredentialChecker.validUsernamePassword(username, password, passwordStore)) {\n+\t\t\tthrow new AuthenticationException(\"Provided username or password was not valid.\");\n+\t\t}\n+\t\treturn TokenHandler.createToken(username, EXPIRATION_PERIOD, getName(), tokenSignAlgorithm);\n+\t}\n+\n+\t/**\n+\t * Converts the provided password to a Xodus compatible hash.\n+\t * \n+\t * @param optPassword\n+\t * @return\n+\t */\n+\tprivate static ByteIterable passwordToHashedEntry(Optional<PasswordCredential> optPassword) {\n+\t\treturn HashedEntry.asByteIterable(PasswordHasher.generateHashedEntry(optPassword.get().getPassword()));\n+\t}\n+\n+\t/**\n+\t * Checks the provided credentials for the realm-compatible\n+\t * {@link PasswordCredential}. However only one credential of this type is\n+\t * allowed to be provided.\n+\t * \n+\t * @param credentials\n+\t *            A list of possible credentials.\n+\t * @return The password credential.\n+\t */\n+\tprivate static Optional<PasswordCredential> getTypePassword(List<CredentialType> credentials) {\n+\t\tOptional<PasswordCredential> optPassword = credentials.stream().filter(PasswordCredential.class::isInstance)\n+\t\t\t.map(PasswordCredential.class::cast).collect(MoreCollectors.toOptional());\n+\t\treturn optPassword;\n+\t}\n+\n+\t@Override\n+\tpublic AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\treturn TokenHandler.extractToken(request);\n+\t}\n+\n+\t//////////////////// USER MANAGEMENT ////////////////////\n+\n+\t@Override\n+\tpublic boolean addUser(User user, List<CredentialType> credentials) {\n+\t\tOptional<PasswordCredential> optPassword = getTypePassword(credentials);\n+\t\tif (!optPassword.isPresent()) {\n+\t\t\tlog.trace(\"No password credential provided. Not adding {} to {}\", user.getName(), getName());\n+\t\t\treturn false;\n+\t\t}\n+\t\tArrayByteIterable usernameByteIt = StringBinding.stringToEntry(user.getName());\n+\t\tByteIterable passwordByteIt = passwordToHashedEntry(optPassword);\n+\n+\t\treturn passwordStore.add(usernameByteIt, passwordByteIt);\n+\t}\n+\n+\t@Override\n+\tpublic boolean updateUser(User user, List<CredentialType> credentials) {\n+\t\tOptional<PasswordCredential> optPassword = getTypePassword(credentials);\n+\t\tif (!optPassword.isPresent()) {\n+\t\t\tlog.trace(\"No password credential provided. Not adding {} to {}\", user.getName(), getName());\n+\t\t\treturn false;\n+\t\t}\n+\t\tArrayByteIterable usernameByteIt = StringBinding.stringToEntry(user.getName());\n+\t\tByteIterable passwordByteIt = passwordToHashedEntry(optPassword);\n+\n+\t\treturn passwordStore.update(usernameByteIt, passwordByteIt);\n+\n+\t}\n+\n+\t@Override\n+\tpublic boolean removeUser(User user) {\n+\t\treturn passwordStore.remove(StringBinding.stringToEntry(user.getName()));\n+\t}\n+\n+\t@Override\n+\tpublic List<UserId> getAllUsers() {\n+\t\tList<String> listId = new ArrayList<>();\n+\t\tpasswordStore.forEach((k, v) -> listId.add(StringBinding.entryToString(k)));", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNDgzNg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377624836", "bodyText": "Kannst du in einem static block die Parameter (nat\u00fcrlich ohne Random) ins log schreiben?", "author": "awildturtok", "createdAt": "2020-02-11T13:13:27Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/PasswordHasher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import com.bakdata.conquery.io.jackson.Jackson;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import jetbrains.exodus.ArrayByteIterable;\n+import jetbrains.exodus.ByteIterable;\n+import lombok.Data;\n+import lombok.experimental.UtilityClass;\n+\n+/**\n+ * Inspired by @see <a href=\n+ * \"https://stackoverflow.com/questions/18142745/how-do-i-generate-a-salt-in-java-for-salted-hash\">https://stackoverflow.com/questions/18142745/how-do-i-generate-a-salt-in-java-for-salted-hash</a>.\n+ *\n+ */\n+@UtilityClass\n+public class PasswordHasher {\n+\n+\tprivate static final SecureRandom RANDOM = new SecureRandom();\n+\tprivate static final String ALGORITHM = \"PBKDF2WithHmacSHA1\";", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNTUxNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377625514", "bodyText": "Reinziehen und return hash?", "author": "awildturtok", "createdAt": "2020-02-11T13:14:47Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/PasswordHasher.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.io.IOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n+import com.bakdata.conquery.io.jackson.Jackson;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import jetbrains.exodus.ArrayByteIterable;\n+import jetbrains.exodus.ByteIterable;\n+import lombok.Data;\n+import lombok.experimental.UtilityClass;\n+\n+/**\n+ * Inspired by @see <a href=\n+ * \"https://stackoverflow.com/questions/18142745/how-do-i-generate-a-salt-in-java-for-salted-hash\">https://stackoverflow.com/questions/18142745/how-do-i-generate-a-salt-in-java-for-salted-hash</a>.\n+ *\n+ */\n+@UtilityClass\n+public class PasswordHasher {\n+\n+\tprivate static final SecureRandom RANDOM = new SecureRandom();\n+\tprivate static final String ALGORITHM = \"PBKDF2WithHmacSHA1\";\n+\tprivate static final int ITERATIONS = 10000;\n+\tprivate static final int KEY_LENGTH = 256;\n+\n+\t/**\n+\t * Returns a random salt to be used to hash a password.\n+\t *\n+\t * @return a 16 bytes random salt\n+\t */\n+\tprivate static byte[] getNextSalt() {\n+\t\tbyte[] salt = new byte[16];\n+\t\tRANDOM.nextBytes(salt);\n+\t\treturn salt;\n+\t}\n+\t\n+\tpublic static HashedEntry generateHashedEntry(char[] password) {\n+\t\tHashedEntry entry = new HashedEntry();\n+\t\tentry.setSalt(getNextSalt());\n+\t\t\n+\t\tentry.setHash(generateHash(password, entry.getSalt()));\n+\t\treturn entry;\n+\t}\n+\n+\tpublic static byte[] generateHash(char[] password, byte[] salt) {\n+\t\tPBEKeySpec spec = new PBEKeySpec(password, salt, ITERATIONS, KEY_LENGTH);\n+\t\tSecretKeyFactory f = null;\n+\t\tbyte[] hash = null;\n+\t\ttry {\n+\t\t\t f = SecretKeyFactory.getInstance(ALGORITHM);", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNzIyOA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377627228", "bodyText": "W\u00e4re es nicht besser die Zugrunde liegende JWT Bibliothek daf\u00fcr zu benutzen, und ihr einfach mal das Token zu geben und schauen was passiert anstatt das (fehleranf\u00e4llig weil selber gemacht) hier mit nem regex zu testen?", "author": "awildturtok", "createdAt": "2020-02-11T13:18:05Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.util.Date;\n+\n+import javax.annotation.Nullable;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import io.dropwizard.auth.oauth.OAuthCredentialAuthFilter;\n+import lombok.AllArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+\n+@UtilityClass\n+@Slf4j\n+public class TokenHandler {\n+\tprivate static final String PREFIX =  \"Bearer\";\n+\tprivate static final String OAUTH_ACCESS_TOKEN_PARAM = \"access_token\";\n+\t// Pattern from https://www.regextester.com/105777\n+\tpublic static final String JWT_PATTERN = \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.?[A-Za-z0-9-_.+/=]*$\";\n+\n+\t/**\n+\t * Creates a signed JWT token for the authentication with the {@link LocalAuthenticationRealm}.\n+\t */\n+\tpublic String createToken(String username, int expiration, String issuer, Algorithm algorithm) {\n+\t\tDate issueDate = new Date();\n+\t\tDate expDate = DateUtils.addHours(issueDate, expiration);\n+\t\tString token = JWT.create()\n+\t\t\t.withIssuer(issuer)\n+\t\t\t.withSubject(username)\n+\t\t\t.withIssuedAt(issueDate)\n+\t\t\t.withExpiresAt(expDate)\n+\t\t\t.sign(algorithm);\n+\t\treturn token;\n+\t}\n+\t\n+\t/**\n+\t * Tries to extract a JWT form a request according to <a href=\"https://tools.ietf.org/html/rfc6750\">https://tools.ietf.org/html/rfc6750</a>.\n+\t * @param request\n+\t * @return\n+\t */\n+\t@Nullable\n+\tpublic static AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\tString token = null;\n+\t\tString tokenHeader = extractTokenFromHeader(request);\n+\t\tString tokenQuery = extractTokenFromQuery(request);\n+\t\tif(tokenHeader == null && tokenQuery == null) {\n+\t\t\t// No token could be parsed\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null && tokenQuery != null) {\n+\t\t\tlog.warn(\"There were tokens in the request header and query string provided, which is forbidden. See: https://tools.ietf.org/html/rfc6750#section-2\");\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null) {\n+\t\t\tlog.trace(\"Extraced the request header token\");\n+\t\t\ttoken = tokenHeader;\n+\t\t} else {\n+\t\t\tlog.trace(\"Extraced the query string token\");\n+\t\t\ttoken = tokenQuery;\n+\t\t}\n+\t\t\n+\t\tif(token.matches(JWT_PATTERN)) {\t\t\t", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyODEyOA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377628128", "bodyText": "https://auth0.com/docs/tokens/guides/validate-jwts", "author": "awildturtok", "createdAt": "2020-02-11T13:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNzIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyOTI3Mg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377629272", "bodyText": "https://github.com/auth0/java-jwt#decode-a-token", "author": "awildturtok", "createdAt": "2020-02-11T13:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyNzIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyOTU0OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377629548", "bodyText": "deine whitespaces sind bananas", "author": "awildturtok", "createdAt": "2020-02-11T13:22:24Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.util.Date;\n+\n+import javax.annotation.Nullable;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import io.dropwizard.auth.oauth.OAuthCredentialAuthFilter;\n+import lombok.AllArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+\n+@UtilityClass\n+@Slf4j\n+public class TokenHandler {\n+\tprivate static final String PREFIX =  \"Bearer\";\n+\tprivate static final String OAUTH_ACCESS_TOKEN_PARAM = \"access_token\";\n+\t// Pattern from https://www.regextester.com/105777\n+\tpublic static final String JWT_PATTERN = \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.?[A-Za-z0-9-_.+/=]*$\";\n+\n+\t/**\n+\t * Creates a signed JWT token for the authentication with the {@link LocalAuthenticationRealm}.\n+\t */\n+\tpublic String createToken(String username, int expiration, String issuer, Algorithm algorithm) {\n+\t\tDate issueDate = new Date();\n+\t\tDate expDate = DateUtils.addHours(issueDate, expiration);\n+\t\tString token = JWT.create()\n+\t\t\t.withIssuer(issuer)\n+\t\t\t.withSubject(username)\n+\t\t\t.withIssuedAt(issueDate)\n+\t\t\t.withExpiresAt(expDate)\n+\t\t\t.sign(algorithm);\n+\t\treturn token;\n+\t}\n+\t\n+\t/**\n+\t * Tries to extract a JWT form a request according to <a href=\"https://tools.ietf.org/html/rfc6750\">https://tools.ietf.org/html/rfc6750</a>.\n+\t * @param request\n+\t * @return\n+\t */\n+\t@Nullable\n+\tpublic static AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\tString token = null;\n+\t\tString tokenHeader = extractTokenFromHeader(request);\n+\t\tString tokenQuery = extractTokenFromQuery(request);\n+\t\tif(tokenHeader == null && tokenQuery == null) {\n+\t\t\t// No token could be parsed\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null && tokenQuery != null) {\n+\t\t\tlog.warn(\"There were tokens in the request header and query string provided, which is forbidden. See: https://tools.ietf.org/html/rfc6750#section-2\");\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null) {\n+\t\t\tlog.trace(\"Extraced the request header token\");\n+\t\t\ttoken = tokenHeader;\n+\t\t} else {\n+\t\t\tlog.trace(\"Extraced the query string token\");\n+\t\t\ttoken = tokenQuery;\n+\t\t}\n+\t\t\n+\t\tif(token.matches(JWT_PATTERN)) {\t\t\t\n+\t\t\treturn new JwtToken(token);\n+\t\t}\n+\t\treturn null;\t\t\n+\t}\n+\t\n+\t/**\n+\t * Code obtained from the Dropwizard project {@link OAuthCredentialAuthFilter}.\n+\t * \n+\t * Parses a value of the `Authorization` header in the form of `Bearer a892bf3e284da9bb40648ab10`.\n+\t *\n+\t * @param header the value of the `Authorization` header\n+\t * @return a token\n+\t */\n+\t@Nullable\n+\tprivate static String extractTokenFromHeader(ContainerRequestContext request) {\n+\n+        final String header = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);\n+        \n+\t\tif (header == null) {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyOTc1Mg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377629752", "bodyText": "Was macht das?", "author": "awildturtok", "createdAt": "2020-02-11T13:22:48Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.util.Date;\n+\n+import javax.annotation.Nullable;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import io.dropwizard.auth.oauth.OAuthCredentialAuthFilter;\n+import lombok.AllArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+\n+@UtilityClass\n+@Slf4j\n+public class TokenHandler {\n+\tprivate static final String PREFIX =  \"Bearer\";\n+\tprivate static final String OAUTH_ACCESS_TOKEN_PARAM = \"access_token\";\n+\t// Pattern from https://www.regextester.com/105777\n+\tpublic static final String JWT_PATTERN = \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.?[A-Za-z0-9-_.+/=]*$\";\n+\n+\t/**\n+\t * Creates a signed JWT token for the authentication with the {@link LocalAuthenticationRealm}.\n+\t */\n+\tpublic String createToken(String username, int expiration, String issuer, Algorithm algorithm) {\n+\t\tDate issueDate = new Date();\n+\t\tDate expDate = DateUtils.addHours(issueDate, expiration);\n+\t\tString token = JWT.create()\n+\t\t\t.withIssuer(issuer)\n+\t\t\t.withSubject(username)\n+\t\t\t.withIssuedAt(issueDate)\n+\t\t\t.withExpiresAt(expDate)\n+\t\t\t.sign(algorithm);\n+\t\treturn token;\n+\t}\n+\t\n+\t/**\n+\t * Tries to extract a JWT form a request according to <a href=\"https://tools.ietf.org/html/rfc6750\">https://tools.ietf.org/html/rfc6750</a>.\n+\t * @param request\n+\t * @return\n+\t */\n+\t@Nullable\n+\tpublic static AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\tString token = null;\n+\t\tString tokenHeader = extractTokenFromHeader(request);\n+\t\tString tokenQuery = extractTokenFromQuery(request);\n+\t\tif(tokenHeader == null && tokenQuery == null) {\n+\t\t\t// No token could be parsed\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null && tokenQuery != null) {\n+\t\t\tlog.warn(\"There were tokens in the request header and query string provided, which is forbidden. See: https://tools.ietf.org/html/rfc6750#section-2\");\n+\t\t\treturn null;\n+\t\t} else if (tokenHeader != null) {\n+\t\t\tlog.trace(\"Extraced the request header token\");\n+\t\t\ttoken = tokenHeader;\n+\t\t} else {\n+\t\t\tlog.trace(\"Extraced the query string token\");\n+\t\t\ttoken = tokenQuery;\n+\t\t}\n+\t\t\n+\t\tif(token.matches(JWT_PATTERN)) {\t\t\t\n+\t\t\treturn new JwtToken(token);\n+\t\t}\n+\t\treturn null;\t\t\n+\t}\n+\t\n+\t/**\n+\t * Code obtained from the Dropwizard project {@link OAuthCredentialAuthFilter}.\n+\t * \n+\t * Parses a value of the `Authorization` header in the form of `Bearer a892bf3e284da9bb40648ab10`.\n+\t *\n+\t * @param header the value of the `Authorization` header\n+\t * @return a token\n+\t */\n+\t@Nullable\n+\tprivate static String extractTokenFromHeader(ContainerRequestContext request) {\n+\n+        final String header = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);\n+        \n+\t\tif (header == null) {\n+            return null;\n+        }\n+\n+\n+        final int space = header.indexOf(' ');", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYzMDAwNw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377630007", "bodyText": "Kannst du nicht einfach split(' ') machen und die l\u00e4nge testen?", "author": "awildturtok", "createdAt": "2020-02-11T13:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyOTc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NTQyNQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377695425", "bodyText": "Ich glaube dropwizard verzichtet hier auf ein split aus performance gr\u00fcnden, da split ein regex macht", "author": "thoniTUB", "createdAt": "2020-02-11T15:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYyOTc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYzOTQ4MA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377639480", "bodyText": "Das else fehlt", "author": "awildturtok", "createdAt": "2020-02-11T13:40:33Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/web/DefaultAuthFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.bakdata.conquery.models.auth.web;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.container.PreMatching;\n+import javax.ws.rs.core.SecurityContext;\n+\n+import com.bakdata.conquery.models.auth.AuthorizationController;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticator;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.google.common.base.Preconditions;\n+import io.dropwizard.auth.AuthFilter;\n+import io.dropwizard.auth.DefaultUnauthorizedHandler;\n+import lombok.AccessLevel;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.realm.Realm;\n+\n+/**\n+ * This filter hooks into dropwizard's request handling to extract and process\n+ * security relevant information for protected resources. The request is first\n+ * submitted to the registered {@link ConqueryAuthenticationRealm}s for the\n+ * token extraction, then the extracted tokens are submitted these realms\n+ * through Dropwizards {@link AuthFilter} and Shiro.\n+ */\n+@Slf4j\n+@PreMatching\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+public class DefaultAuthFilter extends AuthFilter<AuthenticationToken, User> {\n+\n+\tprivate final AuthorizationController controller;\n+\n+\t@Override\n+\tpublic void filter(final ContainerRequestContext requestContext) throws IOException {\n+\n+\t\t// The token extraction process\n+\t\tList<AuthenticationToken> tokens = new ArrayList<>();\n+\t\tfor (ConqueryAuthenticationRealm realm : controller.getAuthenticationRealms()) {\n+\t\t\tAuthenticationToken token = null;\n+\t\t\tif ((token = realm.extractToken(requestContext)) != null) {\n+\t\t\t\tlog.trace(\"Realm {} extracted a token form the request: {}\", ((Realm) realm).getName(), token);\n+\t\t\t\ttokens.add(token);\n+\t\t\t}", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MDI4NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377640285", "bodyText": "Musst du hier nicht eher ein Continue machen? Sonst authentifizierst du ja nur das erste Token", "author": "awildturtok", "createdAt": "2020-02-11T13:42:00Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/web/DefaultAuthFilter.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.bakdata.conquery.models.auth.web;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.container.PreMatching;\n+import javax.ws.rs.core.SecurityContext;\n+\n+import com.bakdata.conquery.models.auth.AuthorizationController;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticator;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.google.common.base.Preconditions;\n+import io.dropwizard.auth.AuthFilter;\n+import io.dropwizard.auth.DefaultUnauthorizedHandler;\n+import lombok.AccessLevel;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.realm.Realm;\n+\n+/**\n+ * This filter hooks into dropwizard's request handling to extract and process\n+ * security relevant information for protected resources. The request is first\n+ * submitted to the registered {@link ConqueryAuthenticationRealm}s for the\n+ * token extraction, then the extracted tokens are submitted these realms\n+ * through Dropwizards {@link AuthFilter} and Shiro.\n+ */\n+@Slf4j\n+@PreMatching\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+public class DefaultAuthFilter extends AuthFilter<AuthenticationToken, User> {\n+\n+\tprivate final AuthorizationController controller;\n+\n+\t@Override\n+\tpublic void filter(final ContainerRequestContext requestContext) throws IOException {\n+\n+\t\t// The token extraction process\n+\t\tList<AuthenticationToken> tokens = new ArrayList<>();\n+\t\tfor (ConqueryAuthenticationRealm realm : controller.getAuthenticationRealms()) {\n+\t\t\tAuthenticationToken token = null;\n+\t\t\tif ((token = realm.extractToken(requestContext)) != null) {\n+\t\t\t\tlog.trace(\"Realm {} extracted a token form the request: {}\", ((Realm) realm).getName(), token);\n+\t\t\t\ttokens.add(token);\n+\t\t\t}\n+\t\t\tlog.trace(\"Realm {} did not extract a token form the request.\", ((Realm) realm).getName());\n+\t\t}\n+\n+\t\tif (tokens.isEmpty()) {\n+\t\t\tlog.warn(\"No tokens could be parsed from the request\");\n+\t\t\tthrow new NotAuthorizedException(\"Failed to authenticate request. The cause has been logged.\");\n+\t\t}\n+\n+\t\tList<AuthenticationToken> failedAuthentications = new ArrayList<>();\n+\n+\t\t// The authentication process\n+\t\tfor (AuthenticationToken token : tokens) {\n+\t\t\ttry {\n+\t\t\t\t// Submit the token to dropwizard which forwards it to Shiro\n+\t\t\t\tif (!authenticate(requestContext, token, SecurityContext.BASIC_AUTH)) {\n+\t\t\t\t\tthrow new NotAuthorizedException(\"Authentication failed\", \"Bearer\");", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcxMTE0OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377711148", "bodyText": "Die for-Schleife \u00fcber die Token ist um das try-catch. Generell sollte bei einem validen Token aber keine Exception geworfen werden.", "author": "thoniTUB", "createdAt": "2020-02-11T15:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MDI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MzU5Ng==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377643596", "bodyText": "Du k\u00f6nntest die tests die du hier machst einzeln machen und den Kontext in @BeforeAll bereitstellen", "author": "awildturtok", "createdAt": "2020-02-11T13:48:09Z", "path": "backend/src/test/java/com/bakdata/conquery/models/auth/LocalAuthRealmTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package com.bakdata.conquery.models.auth;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+import com.bakdata.conquery.apiv1.auth.PasswordCredential;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.basic.LocalAuthenticationConfig;\n+import com.bakdata.conquery.models.auth.basic.LocalAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.config.ConqueryConfig;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.google.common.io.Files;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.IncorrectCredentialsException;\n+import org.apache.shiro.util.LifecycleUtils;\n+import org.junit.jupiter.api.Test;\n+\n+/**\n+ * Tests the basic functionality of the LocalAuthenticationRealm, which stores\n+ * the credential data in a local database and offers simple user management\n+ * (add/update/delete).\n+ */\n+public class LocalAuthRealmTest {\n+\n+\t@Test\n+\tpublic void test() {", "originalCommit": "6dfa7a35c99dd26e4dae1da2a3cef39a8c2645f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzcyNDkzMg==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377724932", "bodyText": "Done ;)", "author": "thoniTUB", "createdAt": "2020-02-11T15:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY0MzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczODk1OA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377738958", "bodyText": "Kann man das Closeable machen und da das Passwort unsetten?", "author": "awildturtok", "createdAt": "2020-02-11T16:14:23Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/auth/PasswordCredential.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.bakdata.conquery.apiv1.auth;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.models.auth.basic.LocalAuthenticationRealm;\n+import lombok.Data;\n+\n+/**\n+ * Container for holding a password. This credential type is used by the\n+ * {@link LocalAuthenticationRealm}.\n+ */\n+@CPSType(base = CredentialType.class, id = \"PASSWORD\")", "originalCommit": "d9a99bffa88224dee68b020c0b3ed0bd5d25454c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzY3NQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378097675", "bodyText": "Closable ist schon sehr auf IO bezogen (can auch eine IOException werfen), deshalb w\u00fcrde ich es hier doch nicht verwenden", "author": "thoniTUB", "createdAt": "2020-02-12T08:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzczODk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MTE1NA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377741154", "bodyText": "Aus der Config raus", "author": "awildturtok", "createdAt": "2020-02-11T16:17:46Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/LocalAuthenticationConfig.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.security.SecureRandom;\n+import java.util.Random;\n+\n+import javax.validation.constraints.NotNull;\n+\n+import com.bakdata.conquery.io.cps.CPSType;\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.AuthenticationConfig;\n+import com.bakdata.conquery.models.config.XodusConfig;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.hibernate.validator.constraints.NotEmpty;\n+\n+@CPSType(base = AuthenticationConfig.class, id = \"LOCAL_AUTHENTICATION\")\n+@Getter\n+@Setter\n+public class LocalAuthenticationConfig implements AuthenticationConfig {\n+\t\n+\tprivate static final Random RANDOM = new SecureRandom();\n+\t/**\n+\t * The secret to sign the created JWTs.\n+\t */\n+\tprivate String tokenSecret = null;", "originalCommit": "d9a99bffa88224dee68b020c0b3ed0bd5d25454c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MzIwOA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377743208", "bodyText": "l\u00f6schen", "author": "awildturtok", "createdAt": "2020-02-11T16:20:56Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.util.Date;\n+\n+import javax.annotation.Nullable;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import io.dropwizard.auth.oauth.OAuthCredentialAuthFilter;\n+import lombok.AllArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+\n+@UtilityClass\n+@Slf4j\n+public class TokenHandler {\n+\n+\tprivate static final String PREFIX = \"Bearer\";\n+\tprivate static final String OAUTH_ACCESS_TOKEN_PARAM = \"access_token\";\n+\t// Pattern from https://www.regextester.com/105777\n+\tpublic static final String JWT_PATTERN = \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.?[A-Za-z0-9-_.+/=]*$\";", "originalCommit": "d9a99bffa88224dee68b020c0b3ed0bd5d25454c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5OTgwNw==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378099807", "bodyText": "Warum soll das gel\u00f6scht werden?", "author": "thoniTUB", "createdAt": "2020-02-12T08:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0MzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc0NDE4OQ==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r377744189", "bodyText": "Direkt in die Liste sammeln stattdessen", "author": "awildturtok", "createdAt": "2020-02-11T16:22:28Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/web/DefaultAuthFilter.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package com.bakdata.conquery.models.auth.web;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.ws.rs.NotAuthorizedException;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.container.PreMatching;\n+import javax.ws.rs.core.SecurityContext;\n+\n+import com.bakdata.conquery.models.auth.AuthorizationController;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticator;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.google.common.base.Preconditions;\n+import io.dropwizard.auth.AuthFilter;\n+import io.dropwizard.auth.DefaultUnauthorizedHandler;\n+import lombok.AccessLevel;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.experimental.Accessors;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.realm.Realm;\n+\n+/**\n+ * This filter hooks into dropwizard's request handling to extract and process\n+ * security relevant information for protected resources. The request is first\n+ * submitted to the registered {@link ConqueryAuthenticationRealm}s for the\n+ * token extraction, then the extracted tokens are submitted these realms\n+ * through Dropwizards {@link AuthFilter} and Shiro.\n+ */\n+@Slf4j\n+@PreMatching\n+@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+public class DefaultAuthFilter extends AuthFilter<AuthenticationToken, User> {\n+\n+\tprivate final AuthorizationController controller;\n+\n+\t@Override\n+\tpublic void filter(final ContainerRequestContext requestContext) throws IOException {\n+\n+\t\t// The token extraction process\n+\t\tList<AuthenticationToken> tokens = new ArrayList<>();\n+\t\tfor (ConqueryAuthenticationRealm realm : controller.getAuthenticationRealms()) {\n+\t\t\tAuthenticationToken token = null;\n+\t\t\tif ((token = realm.extractToken(requestContext)) != null) {\n+\t\t\t\tlog.trace(\"Realm {} extracted a token form the request: {}\", ((Realm) realm).getName(), token);\n+\t\t\t\ttokens.add(token);\n+\t\t\t} else {\t\t\t\t\n+\t\t\t\tlog.trace(\"Realm {} did not extract a token form the request.\", ((Realm) realm).getName());\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (tokens.isEmpty()) {\n+\t\t\tlog.warn(\"No tokens could be parsed from the request\");\n+\t\t\tthrow new NotAuthorizedException(\"Failed to authenticate request. The cause has been logged.\");\n+\t\t}\n+\n+\t\tList<AuthenticationToken> failedAuthentications = new ArrayList<>();\n+\n+\t\t// The authentication process\n+\t\tfor (AuthenticationToken token : tokens) {\n+\t\t\ttry {\n+\t\t\t\t// Submit the token to dropwizard which forwards it to Shiro\n+\t\t\t\tif (!authenticate(requestContext, token, SecurityContext.BASIC_AUTH)) {\n+\t\t\t\t\tthrow new NotAuthorizedException(\"Authentication failed\", \"Bearer\");", "originalCommit": "d9a99bffa88224dee68b020c0b3ed0bd5d25454c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "771af06b7468130060633a63330eeaec23f83e5f", "url": "https://github.com/bakdata/conquery/commit/771af06b7468130060633a63330eeaec23f83e5f", "message": "WIP refactor storing of auth data", "committedDate": "2020-02-12T10:29:45Z", "type": "commit"}, {"oid": "1782d724d8680273bc2ae7e196b43c80ea389c28", "url": "https://github.com/bakdata/conquery/commit/1782d724d8680273bc2ae7e196b43c80ea389c28", "message": "wip local auth storage", "committedDate": "2020-02-12T10:31:49Z", "type": "commit"}, {"oid": "42cda98f8d2ea6755b8c90a165f12c84e5b9cdc8", "url": "https://github.com/bakdata/conquery/commit/42cda98f8d2ea6755b8c90a165f12c84e5b9cdc8", "message": "revert localauthstorage", "committedDate": "2020-02-12T10:32:06Z", "type": "commit"}, {"oid": "33c0d113d3c4a13adef8bb040853c153947c00a3", "url": "https://github.com/bakdata/conquery/commit/33c0d113d3c4a13adef8bb040853c153947c00a3", "message": "WIP uses JWT", "committedDate": "2020-02-12T10:32:07Z", "type": "commit"}, {"oid": "4bdbbe651a20288c99cedc8fa2d7efb7a9727de1", "url": "https://github.com/bakdata/conquery/commit/4bdbbe651a20288c99cedc8fa2d7efb7a9727de1", "message": "WIP splited authorization config and authentication config", "committedDate": "2020-02-12T10:32:17Z", "type": "commit"}, {"oid": "a314f1fa1e611b6f0cbd5daed8ff69ebc5359578", "url": "https://github.com/bakdata/conquery/commit/a314f1fa1e611b6f0cbd5daed8ff69ebc5359578", "message": "rework initial user", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "e7598099392035831da799b4c4f5899f67c0a51f", "url": "https://github.com/bakdata/conquery/commit/e7598099392035831da799b4c4f5899f67c0a51f", "message": "fixes tests", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "9e67574377747fbae8054047453d74189126e6ff", "url": "https://github.com/bakdata/conquery/commit/9e67574377747fbae8054047453d74189126e6ff", "message": "fix test user reference", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "300a4eec2b6e53012c7e08f0c5e4daf801fd0d38", "url": "https://github.com/bakdata/conquery/commit/300a4eec2b6e53012c7e08f0c5e4daf801fd0d38", "message": "clean up template", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "aac636b9cdc360983fcfe5c15c8a55496459c380", "url": "https://github.com/bakdata/conquery/commit/aac636b9cdc360983fcfe5c15c8a55496459c380", "message": "fixes the cookie filter", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "7356d1ba9b6189f4ae38d1499d90831436265429", "url": "https://github.com/bakdata/conquery/commit/7356d1ba9b6189f4ae38d1499d90831436265429", "message": "allowes to register extra resources to the admin end for authentication purposes", "committedDate": "2020-02-12T10:32:18Z", "type": "commit"}, {"oid": "9d5ea649b4195e392a87ed145ff3e4388b82e955", "url": "https://github.com/bakdata/conquery/commit/9d5ea649b4195e392a87ed145ff3e4388b82e955", "message": "makes local realm use the XodusStore Class", "committedDate": "2020-02-12T10:32:19Z", "type": "commit"}, {"oid": "9db6b4d0ad153d8cac684a25f2bde7ec5b6bca63", "url": "https://github.com/bakdata/conquery/commit/9db6b4d0ad153d8cac684a25f2bde7ec5b6bca63", "message": "adds validations to auth config", "committedDate": "2020-02-12T10:32:19Z", "type": "commit"}, {"oid": "5e14581f0f3c3d3e9c421a94d4b8420f8f9adfb5", "url": "https://github.com/bakdata/conquery/commit/5e14581f0f3c3d3e9c421a94d4b8420f8f9adfb5", "message": "adds endpoint for local realm functionality to add, update, and remove", "committedDate": "2020-02-12T10:32:19Z", "type": "commit"}, {"oid": "6d3b95aabb1d7951856c0ca01aa9a079fb9d5742", "url": "https://github.com/bakdata/conquery/commit/6d3b95aabb1d7951856c0ca01aa9a079fb9d5742", "message": "fixes missing function arguments", "committedDate": "2020-02-12T10:32:20Z", "type": "commit"}, {"oid": "4506f3df210d9e074e75a9bf79514ec0f7667311", "url": "https://github.com/bakdata/conquery/commit/4506f3df210d9e074e75a9bf79514ec0f7667311", "message": "adapt to frontend request", "committedDate": "2020-02-12T10:32:20Z", "type": "commit"}, {"oid": "6afdab5e607e347516515ac5bf6a0aeb93a0256b", "url": "https://github.com/bakdata/conquery/commit/6afdab5e607e347516515ac5bf6a0aeb93a0256b", "message": "clean up", "committedDate": "2020-02-12T10:32:20Z", "type": "commit"}, {"oid": "36733d74dd3641e5a8755daf680d212e8b905aff", "url": "https://github.com/bakdata/conquery/commit/36733d74dd3641e5a8755daf680d212e8b905aff", "message": "adds null check", "committedDate": "2020-02-12T10:32:20Z", "type": "commit"}, {"oid": "7b3da74f822deb04cf7bbf5e566462f82574f3f7", "url": "https://github.com/bakdata/conquery/commit/7b3da74f822deb04cf7bbf5e566462f82574f3f7", "message": "adds cors filters to unprotected resource", "committedDate": "2020-02-12T10:32:21Z", "type": "commit"}, {"oid": "89b39c88cd7bea89a4406f6a414ef27bf2fdfdeb", "url": "https://github.com/bakdata/conquery/commit/89b39c88cd7bea89a4406f6a414ef27bf2fdfdeb", "message": "fixes token identification of filter", "committedDate": "2020-02-12T10:32:21Z", "type": "commit"}, {"oid": "dfe91084553e758a455581904f4a3fa91aa292a5", "url": "https://github.com/bakdata/conquery/commit/dfe91084553e758a455581904f4a3fa91aa292a5", "message": "adds an login for the admin end", "committedDate": "2020-02-12T10:32:21Z", "type": "commit"}, {"oid": "b44853c77afa853a9ce1aad960e592e6605335cc", "url": "https://github.com/bakdata/conquery/commit/b44853c77afa853a9ce1aad960e592e6605335cc", "message": "clean up", "committedDate": "2020-02-12T10:32:21Z", "type": "commit"}, {"oid": "34f565824721c360efa3b7e0f2801d9d55d57c25", "url": "https://github.com/bakdata/conquery/commit/34f565824721c360efa3b7e0f2801d9d55d57c25", "message": "improves jwt token handling", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "b95d8c083b5fef5d2825bc6d09ae2b915c9076a9", "url": "https://github.com/bakdata/conquery/commit/b95d8c083b5fef5d2825bc6d09ae2b915c9076a9", "message": "makes request filter generation based on class instead of object", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "d17dd44d3d2eed869a39ee7b9ee9f18e00e317c6", "url": "https://github.com/bakdata/conquery/commit/d17dd44d3d2eed869a39ee7b9ee9f18e00e317c6", "message": "makes admin port and app port have different resources registered on their /auth endpoint", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "d171560fa5c9a04e337e8f779b888ec3978a18c1", "url": "https://github.com/bakdata/conquery/commit/d171560fa5c9a04e337e8f779b888ec3978a18c1", "message": "removes unnessecary comment", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "4e5c24e7de0a0044003f6f7ec689d175977896ac", "url": "https://github.com/bakdata/conquery/commit/4e5c24e7de0a0044003f6f7ec689d175977896ac", "message": "adds realm test", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "e5d2942e2ab8b6154882723f2ec620b3224ba890", "url": "https://github.com/bakdata/conquery/commit/e5d2942e2ab8b6154882723f2ec620b3224ba890", "message": "adds doku", "committedDate": "2020-02-12T10:32:22Z", "type": "commit"}, {"oid": "fb7d59c72a9bfd08d196c0d78ef0a3d1a3d5e62a", "url": "https://github.com/bakdata/conquery/commit/fb7d59c72a9bfd08d196c0d78ef0a3d1a3d5e62a", "message": "adds comments", "committedDate": "2020-02-12T10:32:23Z", "type": "commit"}, {"oid": "c5bd2092df5fa5a0b2bf9665f0b69078ac04ba43", "url": "https://github.com/bakdata/conquery/commit/c5bd2092df5fa5a0b2bf9665f0b69078ac04ba43", "message": "removes unnecessary throws", "committedDate": "2020-02-12T10:32:23Z", "type": "commit"}, {"oid": "9c229c22c383b9bf57db9a75d805e1dcc2a503dd", "url": "https://github.com/bakdata/conquery/commit/9c229c22c383b9bf57db9a75d805e1dcc2a503dd", "message": "moves random token generation to realm initialization", "committedDate": "2020-02-12T10:32:23Z", "type": "commit"}, {"oid": "eacf543c12e559e6e1d5149b4bed46a3371ed0d4", "url": "https://github.com/bakdata/conquery/commit/eacf543c12e559e6e1d5149b4bed46a3371ed0d4", "message": "review changes", "committedDate": "2020-02-12T10:32:24Z", "type": "commit"}, {"oid": "85f8f3b0f545780920c719a230b2a8b0fa76201f", "url": "https://github.com/bakdata/conquery/commit/85f8f3b0f545780920c719a230b2a8b0fa76201f", "message": "review changes", "committedDate": "2020-02-12T10:58:14Z", "type": "commit"}, {"oid": "d6d5db3b26250dd552105b7b2075804e6212de1c", "url": "https://github.com/bakdata/conquery/commit/d6d5db3b26250dd552105b7b2075804e6212de1c", "message": "fixes after rebase", "committedDate": "2020-02-12T12:12:08Z", "type": "commit"}, {"oid": "d6d5db3b26250dd552105b7b2075804e6212de1c", "url": "https://github.com/bakdata/conquery/commit/d6d5db3b26250dd552105b7b2075804e6212de1c", "message": "fixes after rebase", "committedDate": "2020-02-12T12:12:08Z", "type": "forcePushed"}, {"oid": "b6d38b3798cb83cc2a3337e8b9d34961671588be", "url": "https://github.com/bakdata/conquery/commit/b6d38b3798cb83cc2a3337e8b9d34961671588be", "message": "Merge d6d5db3b26250dd552105b7b2075804e6212de1c into a62c8319d95b583d968e55690c3e31699f773a7b", "committedDate": "2020-02-12T12:14:05Z", "type": "commit"}, {"oid": "76440a4dc86435f65653061fbcb000ce190ba58d", "url": "https://github.com/bakdata/conquery/commit/76440a4dc86435f65653061fbcb000ce190ba58d", "message": "automatic update to docs", "committedDate": "2020-02-12T12:15:55Z", "type": "commit"}, {"oid": "7ebdb76947065e66206d88e835a3b98f7e251fe3", "url": "https://github.com/bakdata/conquery/commit/7ebdb76947065e66206d88e835a3b98f7e251fe3", "message": "fixes test", "committedDate": "2020-02-12T12:22:33Z", "type": "commit"}, {"oid": "37ebb3c8c941ac4cbf4d9e121e535c82a3d6e5e9", "url": "https://github.com/bakdata/conquery/commit/37ebb3c8c941ac4cbf4d9e121e535c82a3d6e5e9", "message": "review changes", "committedDate": "2020-02-12T15:30:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwOTIyNA==", "url": "https://github.com/bakdata/conquery/pull/1021#discussion_r378109224", "bodyText": "https://github.com/auth0/java-jwt#decode-a-token", "author": "awildturtok", "createdAt": "2020-02-12T08:48:33Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/basic/TokenHandler.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package com.bakdata.conquery.models.auth.basic;\n+\n+import java.util.Date;\n+\n+import javax.annotation.Nullable;\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.HttpHeaders;\n+\n+import com.auth0.jwt.JWT;\n+import com.auth0.jwt.algorithms.Algorithm;\n+import io.dropwizard.auth.oauth.OAuthCredentialAuthFilter;\n+import lombok.AllArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.time.DateUtils;\n+import org.apache.shiro.authc.AuthenticationToken;\n+\n+@UtilityClass\n+@Slf4j\n+public class TokenHandler {\n+\n+\tprivate static final String PREFIX = \"Bearer\";\n+\tprivate static final String OAUTH_ACCESS_TOKEN_PARAM = \"access_token\";\n+\t// Pattern from https://www.regextester.com/105777\n+\tpublic static final String JWT_PATTERN = \"^[A-Za-z0-9-_=]+\\\\.[A-Za-z0-9-_=]+\\\\.?[A-Za-z0-9-_.+/=]*$\";\n+\n+\t/**\n+\t * Creates a signed JWT token for the authentication with the\n+\t * {@link LocalAuthenticationRealm}.\n+\t */\n+\tpublic String createToken(String username, int expiration, String issuer, Algorithm algorithm) {\n+\t\tDate issueDate = new Date();\n+\t\tDate expDate = DateUtils.addHours(issueDate, expiration);\n+\t\tString token = JWT.create().withIssuer(issuer).withSubject(username).withIssuedAt(issueDate).withExpiresAt(expDate).sign(algorithm);\n+\t\treturn token;\n+\t}\n+\n+\t/**\n+\t * Tries to extract a JWT form a request according to <a href=\n+\t * \"https://tools.ietf.org/html/rfc6750\">https://tools.ietf.org/html/rfc6750</a>.\n+\t * \n+\t * @param request\n+\t * @return\n+\t */\n+\t@Nullable\n+\tpublic static AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\tString token = null;\n+\t\tString tokenHeader = extractTokenFromHeader(request);\n+\t\tString tokenQuery = extractTokenFromQuery(request);\n+\t\tif (tokenHeader == null && tokenQuery == null) {\n+\t\t\t// No token could be parsed\n+\t\t\treturn null;\n+\t\t}\n+\t\telse if (tokenHeader != null && tokenQuery != null) {\n+\t\t\tlog.warn(\n+\t\t\t\t\"There were tokens in the request header and query string provided, which is forbidden. See: https://tools.ietf.org/html/rfc6750#section-2\");\n+\t\t\treturn null;\n+\t\t}\n+\t\telse if (tokenHeader != null) {\n+\t\t\tlog.trace(\"Extraced the request header token\");\n+\t\t\ttoken = tokenHeader;\n+\t\t}\n+\t\telse {\n+\t\t\tlog.trace(\"Extraced the query string token\");\n+\t\t\ttoken = tokenQuery;\n+\t\t}\n+\n+\t\tif (token.matches(JWT_PATTERN)) {", "originalCommit": "d9a99bffa88224dee68b020c0b3ed0bd5d25454c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3767ab8bc85c14bb9f58f33dc9a05c44d1c2431f", "url": "https://github.com/bakdata/conquery/commit/3767ab8bc85c14bb9f58f33dc9a05c44d1c2431f", "message": "fixes serialization of password credential", "committedDate": "2020-02-12T15:51:56Z", "type": "commit"}, {"oid": "282d7580f5964ac40704fa02fbab15dbfab156a7", "url": "https://github.com/bakdata/conquery/commit/282d7580f5964ac40704fa02fbab15dbfab156a7", "message": "revert generic intersection changes", "committedDate": "2020-02-13T10:29:40Z", "type": "commit"}, {"oid": "634b26a4a025ce1b3476f2fad0cc4acb6b064b96", "url": "https://github.com/bakdata/conquery/commit/634b26a4a025ce1b3476f2fad0cc4acb6b064b96", "message": "Adds realms to the lifecycle", "committedDate": "2020-02-13T13:24:31Z", "type": "commit"}, {"oid": "1429df0ab3bed1945c1ee6aff4670ccc8d66cb57", "url": "https://github.com/bakdata/conquery/commit/1429df0ab3bed1945c1ee6aff4670ccc8d66cb57", "message": "Merge branch 'develop' into feature/basic-auth", "committedDate": "2020-02-13T13:25:59Z", "type": "commit"}]}