{"pr_number": 1290, "pr_title": "Flag Logout-Button visibility in Me-Endpoint", "pr_createdAt": "2020-07-22T10:50:49Z", "pr_url": "https://github.com/bakdata/conquery/pull/1290", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTM4MA==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458765380", "bodyText": "kannst du das boolean flag invertieren auf displayLogout finde so invertierte Namen/Semantiken ungeschickt", "author": "awildturtok", "createdAt": "2020-07-22T12:48:00Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "diffHunk": "@@ -33,6 +33,7 @@\n \tpublic FEMeInformation getUserInformation(@NonNull User user){\n \t\treturn FEMeInformation.builder()\n \t\t\t.userName(user.getLabel())\n+\t\t\t.hideUserLogout(user.isHideUserLogout())", "originalCommit": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458765910", "bodyText": "Warum ist das pro User?", "author": "awildturtok", "createdAt": "2020-07-22T12:49:00Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java", "diffHunk": "@@ -36,6 +37,9 @@\n \tprivate String name;\n \t@Getter @Setter @NonNull @NotNull\n \tprivate String label;\n+\t\n+\t@Getter @Setter @JsonIgnore\n+\tprivate transient boolean hideUserLogout = false;", "originalCommit": "aa6d2c6a90b85d3c6715da893097cb503b90d1c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODg4NjUyNg==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458886526", "bodyText": "Weil User auf unterschiedlichen wegen authentifiziert werden k\u00f6nnen. Abh\u00e4ngig davon wie sie authentifiziert wurden, soll der Logout sichtbar sein.", "author": "thoniTUB", "createdAt": "2020-07-22T15:37:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkwMTExOQ==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r458901119", "bodyText": "Wenn ich mich mit RealmA einlogge (der nicht ausloggen kann), und dann mit RealmB einlogge der ausloggen kann, was steht dann im User?", "author": "awildturtok", "createdAt": "2020-07-22T15:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1NjIyOQ==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r459556229", "bodyText": "In der Reihenfolge steht dort, dass dir der logout button angezeigt werden soll", "author": "thoniTUB", "createdAt": "2020-07-23T15:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODc2NTkxMA=="}], "type": "inlineReview"}, {"oid": "1e60d65be032e3017af6ebfce081d8cfd3ca0799", "url": "https://github.com/bakdata/conquery/commit/1e60d65be032e3017af6ebfce081d8cfd3ca0799", "message": "negate internal meaning of logout flag", "committedDate": "2020-07-27T12:56:20Z", "type": "forcePushed"}, {"oid": "d81b4982796b9854e6ad0c24bafdfcd10bb09952", "url": "https://github.com/bakdata/conquery/commit/d81b4982796b9854e6ad0c24bafdfcd10bb09952", "message": "adds flag to signal if logout button should be hidden", "committedDate": "2020-07-27T16:24:04Z", "type": "commit"}, {"oid": "f6cd07e00edd3fd549dfd833a63b87ad7d406d1f", "url": "https://github.com/bakdata/conquery/commit/f6cd07e00edd3fd549dfd833a63b87ad7d406d1f", "message": "change authentication strategy to avoid info merging", "committedDate": "2020-07-27T16:24:04Z", "type": "commit"}, {"oid": "0298965642b12f5f2fec7a1e50410bc50d84fde8", "url": "https://github.com/bakdata/conquery/commit/0298965642b12f5f2fec7a1e50410bc50d84fde8", "message": "negate internal meaning of logout flag", "committedDate": "2020-07-27T16:24:04Z", "type": "commit"}, {"oid": "993c53a034137937d93fe9307fb8d8214093fb7a", "url": "https://github.com/bakdata/conquery/commit/993c53a034137937d93fe9307fb8d8214093fb7a", "message": "authenticates user through keycloak", "committedDate": "2020-07-27T16:24:16Z", "type": "commit"}, {"oid": "fa120748c486899bcbf746e4c1cc4adb98bfadc0", "url": "https://github.com/bakdata/conquery/commit/fa120748c486899bcbf746e4c1cc4adb98bfadc0", "message": "comment out failing authz lib statement", "committedDate": "2020-07-27T16:24:16Z", "type": "commit"}, {"oid": "ecbd5102294e72f80e6bceed3dd9164c5b81dec8", "url": "https://github.com/bakdata/conquery/commit/ecbd5102294e72f80e6bceed3dd9164c5b81dec8", "message": "update to new method interface", "committedDate": "2020-07-27T16:24:16Z", "type": "commit"}, {"oid": "9e5adc74afd4fd80ef37d9f7c78b4b63f02f5b57", "url": "https://github.com/bakdata/conquery/commit/9e5adc74afd4fd80ef37d9f7c78b4b63f02f5b57", "message": "trying keycloak lib", "committedDate": "2020-07-27T16:24:16Z", "type": "commit"}, {"oid": "b0868a157dda6cfbc514763ebdcb44ec4fc60468", "url": "https://github.com/bakdata/conquery/commit/b0868a157dda6cfbc514763ebdcb44ec4fc60468", "message": "sets hideUserLogout flag", "committedDate": "2020-07-27T16:24:16Z", "type": "commit"}, {"oid": "1dae3efaebc96958ba48f6e229027b0a34806f14", "url": "https://github.com/bakdata/conquery/commit/1dae3efaebc96958ba48f6e229027b0a34806f14", "message": "caches validated tokens", "committedDate": "2020-07-27T16:24:17Z", "type": "commit"}, {"oid": "ed44c493d269ba206f7f3923da15f2a4deab8607", "url": "https://github.com/bakdata/conquery/commit/ed44c493d269ba206f7f3923da15f2a4deab8607", "message": "automatic update to docs", "committedDate": "2020-07-27T16:24:17Z", "type": "commit"}, {"oid": "f8e27c86b0f04bb630eeb2078be6fa020fda63a2", "url": "https://github.com/bakdata/conquery/commit/f8e27c86b0f04bb630eeb2078be6fa020fda63a2", "message": "negate internal meaning of logout flag", "committedDate": "2020-07-27T16:24:17Z", "type": "commit"}, {"oid": "919341776f8bf94f321af0261ed613d1c7150ec0", "url": "https://github.com/bakdata/conquery/commit/919341776f8bf94f321af0261ed613d1c7150ec0", "message": "get URIs from well-known endpoint", "committedDate": "2020-07-27T16:24:17Z", "type": "commit"}, {"oid": "0cea3dad1f1d8a5e37028fd77bbbda6b8864a039", "url": "https://github.com/bakdata/conquery/commit/0cea3dad1f1d8a5e37028fd77bbbda6b8864a039", "message": "fixes typo", "committedDate": "2020-07-27T16:24:17Z", "type": "commit"}, {"oid": "e41d787e7070473aebfd94a03179cf9ed3dc41d3", "url": "https://github.com/bakdata/conquery/commit/e41d787e7070473aebfd94a03179cf9ed3dc41d3", "message": "automatic update to docs", "committedDate": "2020-07-27T16:24:18Z", "type": "commit"}, {"oid": "54ae2247a95aa05210d80a8bfbe105dfb3eefa07", "url": "https://github.com/bakdata/conquery/commit/54ae2247a95aa05210d80a8bfbe105dfb3eefa07", "message": "check expiration of cached token", "committedDate": "2020-07-27T16:24:18Z", "type": "commit"}, {"oid": "832ac48d46abaa343235fa12d2567ba1d11ddf7a", "url": "https://github.com/bakdata/conquery/commit/832ac48d46abaa343235fa12d2567ba1d11ddf7a", "message": "uses more specific authentication exception type", "committedDate": "2020-07-27T16:24:18Z", "type": "commit"}, {"oid": "0298965642b12f5f2fec7a1e50410bc50d84fde8", "url": "https://github.com/bakdata/conquery/commit/0298965642b12f5f2fec7a1e50410bc50d84fde8", "message": "negate internal meaning of logout flag", "committedDate": "2020-07-27T16:24:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4NjcyNg==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462886726", "bodyText": "hast du den Namen der Variable vergessen anzupassen?", "author": "awildturtok", "createdAt": "2020-07-30T09:57:30Z", "path": "backend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java", "diffHunk": "@@ -65,6 +66,7 @@ public static FEGroup from(@NonNull Group group) {\n \t@Builder\n \tpublic static class FEMeInformation {\n \t\tString userName;\n+\t\tboolean hideUserLogout;", "originalCommit": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NDAzMQ==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462894031", "bodyText": "Das Frontend nimmt das zur Zeit so", "author": "thoniTUB", "createdAt": "2020-07-30T10:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4NjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzc0OQ==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462887749", "bodyText": "eine zeile", "author": "awildturtok", "createdAt": "2020-07-30T09:59:20Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(", "originalCommit": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzk3Ng==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462887976", "bodyText": "inline", "author": "awildturtok", "createdAt": "2020-07-30T09:59:44Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {", "originalCommit": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODEzNg==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462888136", "bodyText": "return true/return false", "author": "awildturtok", "createdAt": "2020-07-30T10:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4Nzk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODcxMA==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462888710", "bodyText": "K\u00f6nntest du das ErrorObject nicht als Cause in die Exception stecken?", "author": "awildturtok", "createdAt": "2020-07-30T10:01:07Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());", "originalCommit": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ5MTAwNg==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r463491006", "bodyText": "Das ist leider kein Throwable", "author": "thoniTUB", "createdAt": "2020-07-31T08:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg4ODcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5MDE1MA==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r462890150", "bodyText": "javax.ws.rs.core.UriBuilder\ngerade entdeckt, vlt ist das sinnvoller heir?", "author": "awildturtok", "createdAt": "2020-07-30T10:03:52Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\n+\t\t\t\t\"Created new user: {}\",\n+\t\t\t\tuser);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tboolean result = expTime.isBefore(now);\n+\t\tif(result) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());\n+\t\t\tthrow new AuthenticationException(\"Unable to retrieve access token from auth server.\");\n+\t\t}\n+\t\telse if (!(response instanceof TokenIntrospectionSuccessResponse)) {\n+\t\t\tlog.error(\"Unknown token response {}.\", response.getClass().getName());\n+\t\t\tthrow new AuthenticationException(\"Unknown token response. See log.\");\n+\t\t}\n+\n+\t\tTokenIntrospectionSuccessResponse successResponse = response.toSuccessResponse();\n+\t\tif(!successResponse.isActive()) {\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\t\treturn successResponse;\n+\t}\n+\n+\t@Override\n+\tpublic AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\treturn TokenHandler.extractToken(request);\n+\t}\n+\t\n+\t@Override\n+\tpublic void registerAdminUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t\tjerseyConfig.register(LoginResource.class);\n+\t}\n+\n+\t@Override\n+\tpublic void registerApiUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t}\n+\n+\t@Override\n+\t@SneakyThrows\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\tSecret passwordSecret = new Secret(new String(password));\n+\n+\t\tAuthorizationGrant  grant = new ResourceOwnerPasswordCredentialsGrant(username, passwordSecret);\n+\t\t\t\t\n+\t\tURI tokenEndpoint =  new URL(new URL(config.getAuthServerUrl()), serverConf.getTokenEndpoint()).toURI();", "originalCommit": "ec5640974d50a30a8923cfc9b7e9a5fe80d540ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3bdc8fe1d646741ba3bed78f304c5f8c2eec7633", "url": "https://github.com/bakdata/conquery/commit/3bdc8fe1d646741ba3bed78f304c5f8c2eec7633", "message": "review changes", "committedDate": "2020-07-31T09:03:32Z", "type": "forcePushed"}, {"oid": "de3ecdf77dd69547c5c6f7677a92c54f1f45ba31", "url": "https://github.com/bakdata/conquery/commit/de3ecdf77dd69547c5c6f7677a92c54f1f45ba31", "message": "review changes", "committedDate": "2020-08-06T07:45:06Z", "type": "forcePushed"}, {"oid": "75e9a342d8268857a7a4629486616d4ef9a1df7b", "url": "https://github.com/bakdata/conquery/commit/75e9a342d8268857a7a4629486616d4ef9a1df7b", "message": "changes flag name to adapt to frontend", "committedDate": "2020-08-06T08:14:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODA4OQ==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r468558089", "bodyText": "die booleans sind falschrum?", "author": "awildturtok", "createdAt": "2020-08-11T12:56:46Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.UriBuilder;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\"Created new user: {}\", user);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tif(expTime.isBefore(now)) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);", "originalCommit": "75e9a342d8268857a7a4629486616d4ef9a1df7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTMwNDk1Mg==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r469304952", "bodyText": "Haben wir gekl\u00e4rt ;)", "author": "thoniTUB", "createdAt": "2020-08-12T14:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1ODkzMA==", "url": "https://github.com/bakdata/conquery/pull/1290#discussion_r468558930", "bodyText": "Die newlines sind ganz nach meinem Geschmack! :D", "author": "awildturtok", "createdAt": "2020-08-11T12:58:15Z", "path": "backend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "diffHunk": "@@ -0,0 +1,220 @@\n+package com.bakdata.conquery.models.auth.oidc.passwordflow;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.ws.rs.container.ContainerRequestContext;\n+import javax.ws.rs.core.UriBuilder;\n+\n+import com.bakdata.conquery.io.xodus.MasterMetaStorage;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationInfo;\n+import com.bakdata.conquery.models.auth.ConqueryAuthenticationRealm;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler;\n+import com.bakdata.conquery.models.auth.basic.TokenHandler.JwtToken;\n+import com.bakdata.conquery.models.auth.basic.UsernamePasswordChecker;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.auth.util.SkippingCredentialsMatcher;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthAdminUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.AuthServlet.AuthApiUnprotectedResourceProvider;\n+import com.bakdata.conquery.resources.unprotected.LoginResource;\n+import com.bakdata.conquery.resources.unprotected.TokenResource;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.CacheLoader;\n+import com.google.common.cache.LoadingCache;\n+import com.nimbusds.oauth2.sdk.AccessTokenResponse;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.ResourceOwnerPasswordCredentialsGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionRequest;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionResponse;\n+import com.nimbusds.oauth2.sdk.TokenIntrospectionSuccessResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.AccessToken;\n+import com.nimbusds.oauth2.sdk.token.TypelessAccessToken;\n+import io.dropwizard.jersey.DropwizardResourceConfig;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.shiro.authc.AuthenticationException;\n+import org.apache.shiro.authc.AuthenticationToken;\n+import org.apache.shiro.authc.ExpiredCredentialsException;\n+import org.keycloak.authorization.client.AuthzClient;\n+import org.keycloak.authorization.client.representation.ServerConfiguration;\n+\n+/**\n+ * Realm that supports the Open ID Connect Resource-Owner-Password-Credential-Flow with a Keycloak IdP.\n+ */\n+@Slf4j\n+@Getter\n+@Setter\n+@RequiredArgsConstructor\n+public class OIDCResourceOwnerPasswordCredentialRealm extends ConqueryAuthenticationRealm implements AuthApiUnprotectedResourceProvider, AuthAdminUnprotectedResourceProvider, UsernamePasswordChecker {\n+\n+\tprivate static final Class<? extends AuthenticationToken> TOKEN_CLASS = JwtToken.class;\n+\t\n+\tprivate final MasterMetaStorage storage;\n+\tprivate final OIDCResourceOwnerPasswordCredentialRealmFactory config;\n+\t\n+\tprivate ClientAuthentication clientAuthentication;\n+\tprivate AuthzClient authzClient;\n+\t\n+\tprivate ServerConfiguration serverConf;\n+\t\n+\t/**\n+\t * We only hold validated Tokens for some minutes to recheck them regulary with Keycloak.\n+\t */\n+\tprivate LoadingCache<JwtToken, TokenIntrospectionSuccessResponse> tokenCache = CacheBuilder.newBuilder()\n+\t\t.expireAfterWrite(10, TimeUnit.MINUTES)\n+\t\t.build(new TokenValidator());\n+\t\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.setCredentialsMatcher(new SkippingCredentialsMatcher());\n+\t\tthis.setAuthenticationTokenClass(TOKEN_CLASS);\n+\t\tthis.clientAuthentication = new ClientSecretBasic(new ClientID(config.getResource()), new Secret((String)config.getCredentials().get(\"secret\")));\n+\t\t\n+\t\tauthzClient = AuthzClient.create(config);\n+\t\tserverConf = authzClient.getServerConfiguration();\n+\t}\n+\t\n+\t@Override\n+\t@SneakyThrows\n+\tprotected ConqueryAuthenticationInfo doGetConqueryAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n+\t\t\n+\t\tTokenIntrospectionSuccessResponse successResponse = tokenCache.get((JwtToken) token);\n+\t\t\n+\t\t\n+\t\tif(isExpired(successResponse)){\n+\t\t\ttokenCache.invalidate(token);\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\n+\t\tString username = successResponse.getUsername();\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tusername = successResponse.getStringParameter(\"preferred_username\");\n+\t\t}\n+\t\tif(StringUtils.isBlank(username)) {\n+\t\t\tthrow new IllegalStateException(\"Unable to retrieve a user identifier from validated token. Dismissing the token.\");\n+\t\t}\n+\t\t\n+\t\tUserId userId = new UserId(username);\n+\t\tUser user = storage.getUser(userId);\n+\t\t// try to construct a new User if none could be found in the storage\n+\t\tif (user == null) {\n+\t\t\tString userLabel = successResponse.getStringParameter(\"name\");\n+\t\t\tuser = new User(username, userLabel != null ?  userLabel : username);\n+\t\t\tstorage.addUser(user);\n+\t\t\tlog.info(\"Created new user: {}\", user);\n+\t\t}\n+\n+\t\treturn new ConqueryAuthenticationInfo(user.getId(), token, this, true);\n+\t}\n+\t\n+\tprivate boolean isExpired(TokenIntrospectionSuccessResponse tokenInstrospection) {\n+\t\tLocalDateTime expTime = tokenInstrospection.getExpirationTime().toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();\n+\t\tLocalDateTime now = LocalDateTime.now();\n+\t\t\n+\t\tif(expTime.isBefore(now)) {\n+\t\t\tlog.debug(\"Provided token expired at {} ( now is {})\", expTime, now);\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t/**\n+\t * Is called by the CacheLoader, so the Token is not validated on every request.\n+\t */\n+\tprivate TokenIntrospectionSuccessResponse validateToken(AuthenticationToken token) throws ParseException, IOException {\n+\t\tTokenIntrospectionRequest request = new TokenIntrospectionRequest(URI.create(serverConf.getTokenIntrospectionEndpoint()) , clientAuthentication, new TypelessAccessToken((String) token.getCredentials()));\n+\t\t\t\t\n+\t\tTokenIntrospectionResponse response = TokenIntrospectionResponse.parse(request.toHTTPRequest().send());\n+\t\t\n+\t\tif (!response.indicatesSuccess()) {\n+\t\t\tlog.error(response.toErrorResponse().getErrorObject().toString());\n+\t\t\tthrow new AuthenticationException(\"Unable to retrieve access token from auth server.\");\n+\t\t}\n+\t\telse if (!(response instanceof TokenIntrospectionSuccessResponse)) {\n+\t\t\tlog.error(\"Unknown token response {}.\", response.getClass().getName());\n+\t\t\tthrow new AuthenticationException(\"Unknown token response. See log.\");\n+\t\t}\n+\n+\t\tTokenIntrospectionSuccessResponse successResponse = response.toSuccessResponse();\n+\t\tif(!successResponse.isActive()) {\n+\t\t\tthrow new ExpiredCredentialsException();\n+\t\t}\n+\t\treturn successResponse;\n+\t}\n+\n+\t@Override\n+\tpublic AuthenticationToken extractToken(ContainerRequestContext request) {\n+\t\treturn TokenHandler.extractToken(request);\n+\t}\n+\t\n+\t@Override\n+\tpublic void registerAdminUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t\tjerseyConfig.register(LoginResource.class);\n+\t}\n+\n+\t@Override\n+\tpublic void registerApiUnprotectedAuthenticationResources(DropwizardResourceConfig jerseyConfig) {\n+\t\tjerseyConfig.register(new TokenResource(this));\n+\t}\n+\n+\t@Override\n+\t@SneakyThrows\n+\tpublic String checkCredentialsAndCreateJWT(String username, char[] password) {\n+\t\tSecret passwordSecret = new Secret(new String(password));", "originalCommit": "75e9a342d8268857a7a4629486616d4ef9a1df7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "01d02f02b0c42e10e4e45590bd0adf93592f5018", "url": "https://github.com/bakdata/conquery/commit/01d02f02b0c42e10e4e45590bd0adf93592f5018", "message": "fix formating", "committedDate": "2020-09-14T12:18:41Z", "type": "forcePushed"}, {"oid": "4f8f86334bf1eddb134c86d4dfe0dbd29b13d401", "url": "https://github.com/bakdata/conquery/commit/4f8f86334bf1eddb134c86d4dfe0dbd29b13d401", "message": "fixes NullPtrExp in ConceptsProcessor::resolveFilterValues", "committedDate": "2020-09-15T07:03:49Z", "type": "commit"}, {"oid": "c667aaad212bfb1f5949ec131027a5b3f7a69029", "url": "https://github.com/bakdata/conquery/commit/c667aaad212bfb1f5949ec131027a5b3f7a69029", "message": "find all results for a filter search with a list", "committedDate": "2020-09-15T07:03:49Z", "type": "commit"}, {"oid": "4e050a20894d5a5813f996b0cdf83aadbf196519", "url": "https://github.com/bakdata/conquery/commit/4e050a20894d5a5813f996b0cdf83aadbf196519", "message": "add dw-task to delete filter source search mapping", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "9376d0270803586a29c0c85a1868bbf6bfb57e30", "url": "https://github.com/bakdata/conquery/commit/9376d0270803586a29c0c85a1868bbf6bfb57e30", "message": "automatic update to docs", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "813e202a3cb31884b0c7366f0601370c41b9e78e", "url": "https://github.com/bakdata/conquery/commit/813e202a3cb31884b0c7366f0601370c41b9e78e", "message": "adapt method signature to older dw version", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "e137f486ecd45424259eff7eb2aca281ffd9ce4b", "url": "https://github.com/bakdata/conquery/commit/e137f486ecd45424259eff7eb2aca281ffd9ce4b", "message": "authenticates user through keycloak", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "7f1d56bf54120208ca1d546a2f1b09a5766c64af", "url": "https://github.com/bakdata/conquery/commit/7f1d56bf54120208ca1d546a2f1b09a5766c64af", "message": "comment out failing authz lib statement", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "2b25ac3a6984a01e359cd276135e0d26bcd000a4", "url": "https://github.com/bakdata/conquery/commit/2b25ac3a6984a01e359cd276135e0d26bcd000a4", "message": "update to new method interface", "committedDate": "2020-09-15T07:03:50Z", "type": "commit"}, {"oid": "74b5a3d19b1a3021398d405796bc094c6f04f733", "url": "https://github.com/bakdata/conquery/commit/74b5a3d19b1a3021398d405796bc094c6f04f733", "message": "trying keycloak lib", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "c59e5769469350ff008388db1b1fb58e38184572", "url": "https://github.com/bakdata/conquery/commit/c59e5769469350ff008388db1b1fb58e38184572", "message": "sets hideUserLogout flag", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "5e2f858ececd69cbee35e269394026305c7e221e", "url": "https://github.com/bakdata/conquery/commit/5e2f858ececd69cbee35e269394026305c7e221e", "message": "caches validated tokens", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "12582444e3b04babac410ba065c12b15010b320a", "url": "https://github.com/bakdata/conquery/commit/12582444e3b04babac410ba065c12b15010b320a", "message": "automatic update to docs", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "6314c24bdfb78f1b82d959d0b26c411474660c9a", "url": "https://github.com/bakdata/conquery/commit/6314c24bdfb78f1b82d959d0b26c411474660c9a", "message": "negate internal meaning of logout flag", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "39fa137a0c107f7bb76334191a299abea0f2b8ac", "url": "https://github.com/bakdata/conquery/commit/39fa137a0c107f7bb76334191a299abea0f2b8ac", "message": "get URIs from well-known endpoint", "committedDate": "2020-09-15T07:03:51Z", "type": "commit"}, {"oid": "b565d12d567f6d7a814fadda0cf37efa47d6b210", "url": "https://github.com/bakdata/conquery/commit/b565d12d567f6d7a814fadda0cf37efa47d6b210", "message": "fixes typo", "committedDate": "2020-09-15T07:03:52Z", "type": "commit"}, {"oid": "e13a32a7650487844a13553e1e4771614cd7222d", "url": "https://github.com/bakdata/conquery/commit/e13a32a7650487844a13553e1e4771614cd7222d", "message": "automatic update to docs", "committedDate": "2020-09-15T07:03:52Z", "type": "commit"}, {"oid": "b8a37fd87a65cffb9793f654a1656900622c6c80", "url": "https://github.com/bakdata/conquery/commit/b8a37fd87a65cffb9793f654a1656900622c6c80", "message": "check expiration of cached token", "committedDate": "2020-09-15T07:03:52Z", "type": "commit"}, {"oid": "94701d109fde33d0564563fc2c363f166951a5cf", "url": "https://github.com/bakdata/conquery/commit/94701d109fde33d0564563fc2c363f166951a5cf", "message": "uses more specific authentication exception type", "committedDate": "2020-09-15T07:03:52Z", "type": "commit"}, {"oid": "81a08340d219a043a5899b7d8dddbc8594fce4f5", "url": "https://github.com/bakdata/conquery/commit/81a08340d219a043a5899b7d8dddbc8594fce4f5", "message": "review changes", "committedDate": "2020-09-15T07:03:53Z", "type": "commit"}, {"oid": "14bc3cd096b290db3219754d3442f50fb4b9f46e", "url": "https://github.com/bakdata/conquery/commit/14bc3cd096b290db3219754d3442f50fb4b9f46e", "message": "changes flag name to adapt to frontend", "committedDate": "2020-09-15T07:03:53Z", "type": "commit"}, {"oid": "9a810b9bf40d83406bfa2bd2e58505ce28bbf9fa", "url": "https://github.com/bakdata/conquery/commit/9a810b9bf40d83406bfa2bd2e58505ce28bbf9fa", "message": "fix formating", "committedDate": "2020-09-15T07:03:53Z", "type": "commit"}, {"oid": "9a810b9bf40d83406bfa2bd2e58505ce28bbf9fa", "url": "https://github.com/bakdata/conquery/commit/9a810b9bf40d83406bfa2bd2e58505ce28bbf9fa", "message": "fix formating", "committedDate": "2020-09-15T07:03:53Z", "type": "forcePushed"}, {"oid": "27e702814c69dc518a8d0624466603a23ab50563", "url": "https://github.com/bakdata/conquery/commit/27e702814c69dc518a8d0624466603a23ab50563", "message": "Merge branch 'feature/oicd-Resource-Owner-Password-Credential-Grant' into feature/propagate-if-logout-button-should-be-shown\n\n# Conflicts:\n#\tbackend/pom.xml\n#\tbackend/src/main/java/com/bakdata/conquery/apiv1/MeProcessor.java\n#\tbackend/src/main/java/com/bakdata/conquery/models/auth/entities/User.java\n#\tbackend/src/main/java/com/bakdata/conquery/models/auth/oidc/passwordflow/OIDCResourceOwnerPasswordCredentialRealm.java", "committedDate": "2020-09-15T09:26:39Z", "type": "commit"}]}