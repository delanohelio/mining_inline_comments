{"pr_number": 1833, "pr_title": "Get the grains that we check on every startup from the start event", "pr_createdAt": "2020-01-27T10:03:44Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/1833", "timeline": [{"oid": "d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "url": "https://github.com/uyuni-project/uyuni/commit/d9b2fbf8704d6696a712ff7e36031a74ab559a0f", "message": "get the machine-id grain from the start up event", "committedDate": "2020-01-27T10:10:07Z", "type": "forcePushed"}, {"oid": "7e1dc28f317807510325438ed1d501893b088cb8", "url": "https://github.com/uyuni-project/uyuni/commit/7e1dc28f317807510325438ed1d501893b088cb8", "message": "add a helper sls file to update the minion config to make use of minion_start_grains", "committedDate": "2020-01-27T10:47:04Z", "type": "forcePushed"}, {"oid": "4a8bbece5243c368e9466840e93d55206ffece72", "url": "https://github.com/uyuni-project/uyuni/commit/4a8bbece5243c368e9466840e93d55206ffece72", "message": "add a helper sls file to update the minion config to make use of minion_start_grains", "committedDate": "2020-01-27T12:10:48Z", "type": "forcePushed"}, {"oid": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "url": "https://github.com/uyuni-project/uyuni/commit/3eeecaaeee83c6f158eeea1a5f9789945813abb3", "message": "add a helper sls file to update the minion config to make use of minion_start_grains", "committedDate": "2020-01-27T12:46:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MDAyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371250025", "bodyText": "A nitpick, but as this is completely new file, I'm not sure it is possible to claim copyright since 2015.", "author": "aaannz", "createdAt": "2020-01-27T13:52:05Z", "path": "java/code/src/com/suse/manager/reactor/messaging/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2015--2019 SUSE LLC", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzUwNw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371253507", "bodyText": "Another nitpick, but rMinEMessage variable name makes it difficult to read for me :D", "author": "aaannz", "createdAt": "2020-01-27T13:58:37Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -115,8 +115,9 @@ public RegisterMinionEventMessageAction(SaltService saltService) {\n      */\n     @Override\n     public void execute(EventMessage msg) {\n-        registerMinion(((RegisterMinionEventMessage) msg).getMinionId(), false,\n-                empty(), empty());\n+        RegisterMinionEventMessage rMinEMessage = ((RegisterMinionEventMessage) msg);", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzYzMg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371257632", "bodyText": "The same as before. New file, but copyright retroactive to 2015", "author": "aaannz", "createdAt": "2020-01-27T14:06:34Z", "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartEvent.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2015--2019 SUSE LLC", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MDg5NA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371270894", "bodyText": "I'm confused. Previously it was possible to reactive system with the same minionId. This line will now prevents it. Is this intentional?", "author": "aaannz", "createdAt": "2020-01-27T14:29:37Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI4ODM5OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371288399", "bodyText": "and you are right :). I will change it.", "author": "admd", "createdAt": "2020-01-27T14:58:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MzI3NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371273275", "bodyText": "Now I'm wondering what is the purpose of having startup grains. Because up until this point machine id is not used anywhere. Couldn't we just refactored registerMinion routing to check for machingID only after this grain call?\nOr should we instead put all the necessary grains needed for registration to the startup grains and after the registration schedule hardware refresh to get the rest of the grains?\nOr am I missing something?", "author": "aaannz", "createdAt": "2020-01-27T14:33:34Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {\n+            boolean isReactivation = false;\n+            ActivationKey ak = null;\n+            ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI5MTg5MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371291890", "bodyText": "I have moved machin_id check outside of this function. Control will only move to this function if we will have a valid machine_id.", "author": "admd", "createdAt": "2020-01-27T15:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3MzI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjY4OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r371276689", "bodyText": "I would really put grains required to detect reactivation 'susemanager:management_key' as startup grains as well. So we can ask for the rest of grains either here or directly in finalizeMinionRegistration.\nWe will then skip the grains call for all already registered minions only having their salt minions restarted.\nCould that work?", "author": "aaannz", "createdAt": "2020-01-27T14:39:03Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,69 +128,67 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        getMachineId(minionId, empty())\n+                .ifPresent(machineId-> registerMinion(minionId, true, proxyId, activationKeyOverride, machineId));\n     }\n \n+     /**\n+     * Return the machine Id, it looks up start_event_grains & if it doesn't exist then fall back to the salt call\n+     * @param minionId minion id\n+     * @param startupGrains start up grains start_event_grains\n+     * @return Machine Id\n+     */\n+    private Optional<String> getMachineId(String minionId, Optional<MinionStartupGrains> startupGrains) {\n+        Optional<String> machineId =\n+                Opt.or(startupGrains.flatMap(msg -> msg.getMachineId()), ()-> SALT_SERVICE.getMachineId(minionId));\n+        if (!machineId.isPresent()) {\n+            LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+        }\n+        return machineId;\n+    }\n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n-            () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId) {\n+        if (!duplicateMinionNamePresent(minionId)) {\n+            boolean isReactivation = false;\n+            ActivationKey ak = null;\n+            ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+            Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+            if (managmentKeyLabel.isPresent()) {\n+                ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n+                if (ak != null && ak.getKickstartSession() != null) {\n+                    ak.getKickstartSession().markComplete(\"Installation completed.\");\n                 }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n+                if (ak == null) {\n+                    LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n                 }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n+                else if (ak.getServer() == null) {\n+                    LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+                else {\n+                    isReactivation = true;\n                 }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n             }\n-        );\n+            Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+            if (!isReactivation &&\n+                    checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n+                return;\n+            }\n+            if (isReactivation) {\n+                reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+            }\n+            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,", "originalCommit": "3eeecaaeee83c6f158eeea1a5f9789945813abb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3NDQ2OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r372874469", "bodyText": "Ok thought about that but then reverted it back. The reason behind was that management_key is only needed for the new systems for 1st time registration and in that case, we needed a lot of grains and we are fine with making one salt call which returns all the grains. Of course, we can add all the grains in the startup event which are needed for the  registration but that involved a lot of grains.\nWe can refactor but that should probably be in a separate PR and will need a lot more time and testing, it was bit risky. Here in this PR, main idea was to avoid any salt calls for the already registered systems and for that, we only needed machine_id and saltboot_initrd grains.", "author": "admd", "createdAt": "2020-01-30T10:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI3NjY4OQ=="}], "type": "inlineReview"}, {"oid": "e400c307d401427d14f339fead52a74ed1a02918", "url": "https://github.com/uyuni-project/uyuni/commit/e400c307d401427d14f339fead52a74ed1a02918", "message": "add a helper sls file to update the minion config to make use of minion_start_grains", "committedDate": "2020-01-28T13:41:22Z", "type": "forcePushed"}, {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "url": "https://github.com/uyuni-project/uyuni/commit/69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "message": "update units test & some more refactoring", "committedDate": "2020-01-30T10:31:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3NzM2Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374077363", "bodyText": "Do we have a plan to move this class in salt-netapi-library?", "author": "moio", "createdAt": "2020-02-03T12:34:19Z", "path": "java/code/src/com/suse/manager/webui/utils/salt/Grains.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.reflect.TypeToken;\n+import com.suse.salt.netapi.calls.LocalCall;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+/**\n+ * salt.modules.grains\n+ */\n+public class Grains {", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MTcxMA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374791710", "bodyText": "yes", "author": "admd", "createdAt": "2020-02-04T16:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3NzM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTIwMA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374079200", "bodyText": "Do we have a plan to move this class in salt-netapi-library?", "author": "moio", "createdAt": "2020-02-03T12:39:04Z", "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartEvent.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonElement;\n+import com.google.gson.reflect.TypeToken;\n+import com.suse.salt.netapi.datatypes.Event;\n+import com.suse.salt.netapi.parser.JsonParser;\n+import com.suse.utils.Json;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Represents an event fired when a minion connects to the salt master\n+ */\n+public class MinionStartEvent {", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MTc4Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374791783", "bodyText": "yes", "author": "admd", "createdAt": "2020-02-04T16:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTgzNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374079835", "bodyText": "Do we plan to use this new Grains class also elsewhere, eg. in the singular getGrain?", "author": "moio", "createdAt": "2020-02-03T12:40:47Z", "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -416,6 +417,18 @@ public boolean keyExists(String id, KeyStatus... statusIn) {\n                 .orElseThrow(() -> new RuntimeException(\"no wheel results\"));\n     }\n \n+    /**\n+     * Get the specified grains for a given minion.\n+     * @param minionId id of the target minion\n+     * @param type  class type, result should be parsed into\n+     * @param grainNames list of grains names\n+     * @param <T> Type result should be parsed into\n+     * @return Optional containing the grains parsed into specified type\n+     */\n+    public <T> Optional<T> getGrains(String minionId, TypeToken<T> type, String... grainNames) {\n+       return callSync(com.suse.manager.webui.utils.salt.Grains.item(false, type, grainNames), minionId);", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjcyMg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374792722", "bodyText": "We better. Problem was that there was no method which gives me a list of grains that I am interested in. It was either all or just one.", "author": "admd", "createdAt": "2020-02-04T16:49:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA3OTgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4MDI0MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374080240", "bodyText": "Indentation seems off here and in other places in this file, please double check them all.", "author": "moio", "createdAt": "2020-02-03T12:41:41Z", "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -664,6 +680,8 @@ public void testRegisterMinionWithActivationKeySUSEManagerDefault() throws Excep\n                 will(returnValue(Optional.of(MINION_ID)));\n                 allowing(saltServiceMock).getMachineId(MINION_ID);\n                 will(returnValue(Optional.of(MACHINE_ID)));\n+                    allowing(saltServiceMock).getGrains(with(any(String.class)), with(any(TypeToken.class)),with(any(String[].class)));", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5Mjk5Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374792993", "bodyText": "fixed.", "author": "admd", "createdAt": "2020-02-04T16:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4MDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4NjkxMg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374086912", "bodyText": "Looks like this method is unused.", "author": "moio", "createdAt": "2020-02-03T12:57:30Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);\n+                   finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,\n+                                grains);\n+                     }\n+               },\n+            registeredMinion -> {\n+                updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+             });\n+    }\n \n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n-        );\n+        }\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    private Optional<MinionServer> getRegisteredMinion(String machineId) {", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MjkyNg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374792926", "bodyText": "removed", "author": "admd", "createdAt": "2020-02-04T16:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA4NjkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5OTQyMw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374099423", "bodyText": "It seems like the meaning of this method has changed significantly: before it used to mean \"set minion and machine ids according to the reactivation key, if we have one\" - now it means \"conclude the kickstart session, if any, check that we have a Activation Key, that it is actually a reactivation key and only in that case then set minion and machine ids\". I think those are conceptually separate now and we should either keep the original name and meaning or change both, or rearrange code in some other way.", "author": "moio", "createdAt": "2020-02-03T13:26:07Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);\n+                   finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH,\n+                                grains);\n+                     }\n+               },\n+            registeredMinion -> {\n+                updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+             });\n+    }\n \n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n-        );\n+        }\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    private Optional<MinionServer> getRegisteredMinion(String machineId) {\n+        return  MinionServerFactory.findByMachineId(machineId);\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n-     * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param managmentKeyLabel managment_key grain\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n+    private void reactivateSystem(String minionId, String machineId, Optional<String> managmentKeyLabel) {", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MzI0MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374793240", "bodyText": "You are right, I missed some part. I have changed it now.", "author": "admd", "createdAt": "2020-02-04T16:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA5OTQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEwMzMwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374103301", "bodyText": "I have a hard time following if and why the logic has changed here.\nOld code called reactivateSystem only if a reactivation key is used (a managmentKeyLabel is set in grains, it actually corresponds to an existing Activation Key, that Activation Key has an attached Server). It does not care whatever duplicateMinionNamePresent returns, in fact it does not call that method at all in case of a reactivation key (isReactivation == true).\nNew code seems to rule out that a reactivation may happen if a duplicate minion name is present - but that is a possibility.\nAm I missing anything?", "author": "moio", "createdAt": "2020-02-03T13:34:07Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +132,131 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration.\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, machineId,\n+                            saltbootInitrd));\n+            });\n     }\n \n \n     /**\n      * Performs minion registration.\n-     *\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, String machineId, boolean saltbootInitrd) {\n+        Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+        Opt.consume(registeredMinionOpt,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n-            },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n+               if (!duplicateMinionNamePresent(minionId)) {\n+                   ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n+                   Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n+                   Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+                   reactivateSystem(minionId, machineId, managmentKeyLabel);", "originalCommit": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc5MzQwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374793401", "bodyText": "Again correct. It should be better and correct now.", "author": "admd", "createdAt": "2020-02-04T16:50:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEwMzMwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3NzM3MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r374977371", "bodyText": "As you are touching this code, can you take a look at #1835, please.", "author": "aaannz", "createdAt": "2020-02-04T23:13:15Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride,\n+                                    isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n+            //Case-2 : Reactivation\n+            mk -> {\n+                reactivateSystem(minionId, machineId, mk);\n+                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+            }\n+        );\n+    }\n+\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param managmentKeyLabel managment_key grain\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String managmentKeyLabel) {\n+        Optional<ActivationKey> akey = ofNullable(ActivationKeyFactory.lookupByKey(managmentKeyLabel));\n+        Opt.consume(akey,\n+                () -> LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel),\n+                ak -> {\n+                    if (Objects.nonNull(ak.getKickstartSession())) {\n                         ak.getKickstartSession().markComplete(\"Installation completed.\");\n                     }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n+                    if (Objects.isNull(ak.getServer())) {\n+                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel);\n                     }\n                     else {\n-                        isReactivation = true;\n+                        // The machine id may have changed, but we know from the reactivation key\n+                        // which system should become this one\n+                        ak.getServer().asMinionServer().ifPresent(minion -> {\n+                            minion.setMachineId(machineId);\n+                            minion.setMinionId(minionId);\n+                        });\n                     }\n                 }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n-            }\n         );\n-    }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n+     * Update information of already registered minion, in case minion_id is different.\n      * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * @param registeredMinion existing registered minion\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n-            }\n-\n-            // Saltboot treatment\n-            // HACK: try to guess if the minion is a retail minion based on its groups.\n-            // This way we don't need to call grains for each register minion event.\n-            if (isRetailMinion(registeredMinion)) {\n-                if (grains.getOptionalAsBoolean(\"saltboot_initrd\").orElse(false)) {\n-                    // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n-                    LOG.info(\"Applying saltboot for minion \" + minionId);\n-                    applySaltboot(registeredMinion);\n-                }\n-            }\n-            return true;\n+    public void updateAlreadyRegisteredInfo(String minionId, MinionServer registeredMinion) {\n+        String oldMinionId = registeredMinion.getMinionId();\n+        if (!minionId.equals(oldMinionId)) {\n+            LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n+                    \"profile to '\" + minionId + \"' [\" + registeredMinion.getMachineId() + \"]\");\n+            registeredMinion.setName(minionId);\n+            registeredMinion.setMinionId(minionId);\n+            ServerFactory.save(registeredMinion);\n+            SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n+                    oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n+\n+            SALT_SERVICE.deleteKey(oldMinionId);", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3OTQwMw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375079403", "bodyText": "Can't startupGrains just be passed as-is?", "author": "moio", "createdAt": "2020-02-05T06:32:48Z", "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -285,7 +300,12 @@ public void executeTest(ExpectationsFunction expectations, ActivationKeySupplier\n         }\n \n         RegisterMinionEventMessageAction action = new RegisterMinionEventMessageAction(saltServiceMock);\n-        action.execute(new RegisterMinionEventMessage(MINION_ID));\n+        if (startupGrains.isPresent()) {", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA3OTUwNA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375079504", "bodyText": "Please remove this comment if not necessary", "author": "moio", "createdAt": "2020-02-05T06:33:11Z", "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -330,6 +350,75 @@ public void testRegisterDuplicateMinionId() throws Exception {\n         }, null, DEFAULT_CONTACT_METHOD);\n     }\n \n+    public void testAlreadyRegisteredMinionWithSameMachineId() throws Exception {\n+        MinionServer server = MinionServerFactoryTest.createTestMinionServer(user);\n+        server.setMinionId(MINION_ID);\n+        server.setMachineId(MACHINE_ID);\n+        //ServerFactory.save(server);", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4MDQ5OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375080499", "bodyText": "Style question: why is this class singular (SuseManagerGrain) while the parent is plural (MinionStartupGrains)? Shouldn't they both be either singular or plural?", "author": "moio", "createdAt": "2020-02-05T06:37:35Z", "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Class to represent grains defined against 'start_event_grains'\n+ */\n+public class MinionStartupGrains {\n+    @SerializedName(\"machine_id\")\n+    private Optional<String> machineId = Optional.empty();\n+    @SerializedName(\"saltboot_initrd\")\n+    private boolean saltbootInitrd = false;\n+    @SerializedName(\"susemanager\")\n+    private Optional<SuseManagerGrain> suseManagerGrain = Optional.empty();\n+\n+    /**\n+     * no-arg constructor\n+     */\n+    public MinionStartupGrains() { }\n+\n+    /**\n+     * Constructor which accepts MinionStartupGrainsBuilder and use it to build object\n+     * @param builder MinionStartupGrainsBuilder\n+     */\n+    private MinionStartupGrains(MinionStartupGrainsBuilder builder) {\n+        this.machineId = Optional.ofNullable(builder.machineId);\n+        this.saltbootInitrd = builder.saltbootInitrd;\n+        this.suseManagerGrain = Optional.ofNullable(builder.suseManagerGrain);\n+    }\n+\n+    public Optional<String> getMachineId() {\n+        return machineId;\n+    }\n+\n+    public boolean getSaltbootInitrd() {\n+        return saltbootInitrd;\n+    }\n+\n+    public Optional<SuseManagerGrain> getSuseManagerGrain() {\n+        return suseManagerGrain;\n+    }\n+\n+    /**\n+     * Class to represent `susemanager grain\n+     */\n+    public static class SuseManagerGrain {", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2Nzk5Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375367992", "bodyText": "The reason behind this was that SuseManagerGrain only represents singular susemanager grain while MinionStartupGrains otherwise.", "author": "admd", "createdAt": "2020-02-05T16:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA4MDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5ODI2NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375098265", "bodyText": "Correct me if I am wrong: with this PR we get an improvement even in the case startup grains are not configured, as we call grains.items just once instead of:\n\ncalling grains.item to get the machine ID first and then\ncalling grains.items again to get all grains (only to filter out management_key and, possibly, saltboot_initrd)", "author": "moio", "createdAt": "2020-02-05T07:40:12Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -115,8 +118,11 @@ public RegisterMinionEventMessageAction(SaltService saltService) {\n      */\n     @Override\n     public void execute(EventMessage msg) {\n-        registerMinion(((RegisterMinionEventMessage) msg).getMinionId(), false,\n-                empty(), empty());\n+        RegisterMinionEventMessage registerMinionEventMessage = ((RegisterMinionEventMessage) msg);\n+        Optional<MinionStartupGrains> startupGrainsOpt = Opt.or(registerMinionEventMessage.getMinionStartupGrains(),\n+                () -> SALT_SERVICE.getGrains(registerMinionEventMessage.getMinionId(),", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2Nzg1OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375367859", "bodyText": "That's correct. We save 1 salt call in case of already registered minions, even if startup grains are not configured.\nSo if start-up grains are supported, with this PR number of salt sync calls are following\n\n\n\nTest\nBefore\nAfter\n\n\n\n\nNew registration\n2\n1\n\n\nRegistered minion startup\n2\n0\n\n\n\nIf start-up grains are not supported, with this PR number of salt sync calls are following\n\n\n\nTest\nBefore\nAfter\n\n\n\n\nNew registration\n2\n2\n\n\nRegistered minion startup\n2\n1", "author": "admd", "createdAt": "2020-02-05T16:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5ODI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcwNzE3MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375707170", "bodyText": "Please add this relevant information in the PR description, so it does not get lost!", "author": "moio", "createdAt": "2020-02-06T08:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA5ODI2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE3ODI3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375178279", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Performs minion registration/reactivation..\n          \n          \n            \n                 * Performs minion registration or reactivation.", "author": "moio", "createdAt": "2020-02-05T10:36:43Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTE4MzI4NA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375183284", "bodyText": "Comment does not agree with code here", "author": "moio", "createdAt": "2020-02-05T10:46:41Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIwMjgzMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375202831", "bodyText": "IIUC this variable is only and exclusively used by finalizeMinionRegistration, please move it inside of that method (so that getCreator does not get called if a minion is just being restarted and no reregistration/reactivation should actually happen).", "author": "moio", "createdAt": "2020-02-05T11:30:33Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDc1Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375214753", "bodyText": "Corner case: if there is a management key but it is not a valid reactivation key, old code still checked whether the minion was already registered and if it was, it would update its name/id, possibly apply saltboot states, and move on without finalization.\nIIUC, new code will always perform finalization whenever management_key is set, which is not expected (think about a minion originally onboarded with an activation key and simply being restarted).\nWhat we might need is a method that tries to extract the management key from grains and directly checks if it is a valid reactivation key before entering this method.", "author": "moio", "createdAt": "2020-02-05T11:59:36Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,128 +133,141 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration/reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration/reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        //Case-1 Reactivation\n+        Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride,\n+                                    isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n+            //Case-2 : Reactivation\n+            mk -> {\n+                reactivateSystem(minionId, machineId, mk);\n+                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId, actKeyOverride, isSaltSSH);", "originalCommit": "b43a8a6f0c30d9900ff66086731ded43294e2f2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTM2Nzc0Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375367743", "bodyText": "Phew, very good catch. Thank you. There is this reason why I always prefer to have review from you :)", "author": "admd", "createdAt": "2020-02-05T16:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTIxNDc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxMzg0Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375713843", "bodyText": "Sorry for being picky but I am still not convinced. Lines 199-201 are basically the same as 180+187-189: would it be possible to move isValidReactivationKey after line 155 so that we only enter the \"Case-2 branch\" if we have a key and we are also sure it's a reactivation key?\n(please double check my logic, I might be missing something as well!!!)", "author": "moio", "createdAt": "2020-02-06T09:09:58Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,180 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> managementKey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride, managementKey,\n+                            machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> managementKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(managementKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n+            //Case-2 : Reactivation\n+            mk -> {\n+                if (isValidReactivationKey(mk, minionId)) {\n+                    reactivateSystem(minionId, machineId, mk);\n+                    finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n+                else {\n+                    MinionServerFactory.findByMachineId(machineId).ifPresent(rm -> {", "originalCommit": "d8089f267c12a5149ab355f815c5897750fcec81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1MTIyOA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r375751228", "bodyText": "@moio  ha, no need to be sorry. This was really good. I didn't like my change for this corner case either. Your suggestion is good and it looks much cleaner now. I have pushed a commit.", "author": "admd", "createdAt": "2020-02-06T10:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTcxMzg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzNjk3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r376236977", "bodyText": "One extra twist: in original code, the Kickstart session is marked complete as soon as the activation key is found in the database and has a session. In your code, this is done only if the activation key is a reactivation key.\nThinking about it a bit, completing a Kickstart session has nothing to do with reactivations, and actually nothing to do with registration either. It has more to do with normal rebooting / minion start event: if we see a minion that was being autoinstalled come up, then the autoinstallation has ended!\nI guess this if block has to be moved outside this method.", "author": "moio", "createdAt": "2020-02-07T06:49:54Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,175 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<String> validReactivationKey =\n+                        mkey.flatMap(mk -> isValidReactivationKey(mk, minionId) ? mkey : empty());\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride,\n+                            validReactivationKey, machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param reActivationKey valid reactivation key\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n-\n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> reActivationKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(reActivationKey,\n+            //Case-1 Registration\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n-                return false;\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n-                    return false;\n-                }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n-                return true;\n+            //Case-2 : Reactivation\n+            rk -> {\n+                reactivateSystem(minionId, machineId, rk);\n+                finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n             }\n         );\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n-        // The machine id may have changed, but we know from the reactivation key\n-        // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+    /**\n+     * Check if the specified management_key is valid reactivation key or not\n+     * @param managmentKeyLabel management_key\n+     * @param minionId minion Id\n+     * @return\n+     */\n+    private boolean isValidReactivationKey(String managmentKeyLabel, String minionId) {\n+        Optional<ActivationKey> akey = ofNullable(ActivationKeyFactory.lookupByKey(managmentKeyLabel));\n+        Boolean isValid =\n+            Opt.fold(akey,\n+                () -> {\n+                    LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel);\n+                    return false;\n+                },\n+                ak -> {\n+                    if (Objects.isNull(ak.getServer())) {\n+                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel);\n+                        return false;\n+                    }\n+                    //considered valid reactivation key only in this case\n+                    return true;\n+                }\n+            );\n+        return isValid;\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n-     * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-\n-                if (!minionId.equals(oldMinionId)) {\n-                    SALT_SERVICE.deleteKey(oldMinionId);\n-                }\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n             }\n+        }\n+    }\n \n-            // Saltboot treatment\n-            // HACK: try to guess if the minion is a retail minion based on its groups.\n-            // This way we don't need to call grains for each register minion event.\n-            if (isRetailMinion(registeredMinion)) {\n-                if (grains.getOptionalAsBoolean(\"saltboot_initrd\").orElse(false)) {\n-                    // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n-                    LOG.info(\"Applying saltboot for minion \" + minionId);\n-                    applySaltboot(registeredMinion);\n-                }\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param reActivationKey valid Reaction key\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String reActivationKey) {\n+        of(ActivationKeyFactory.lookupByKey(reActivationKey)).ifPresent(ak -> {\n+            if (Objects.nonNull(ak.getKickstartSession())) {\n+                ak.getKickstartSession().markComplete(\"Installation completed.\");", "originalCommit": "83fee18da7b6acf205bbe0e9d61ecdb21f65a5da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjUxOTYwMg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r376519602", "bodyText": "Thank you very much @moio. I would have surely introduced some bugs after this change without your review. I have added a new commit, please have a look.", "author": "admd", "createdAt": "2020-02-07T17:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjIzNjk3Nw=="}], "type": "inlineReview"}, {"oid": "d5917f6bba29ac61a334a74bf373186600f54557", "url": "https://github.com/uyuni-project/uyuni/commit/d5917f6bba29ac61a334a74bf373186600f54557", "message": "another forgotten corner case", "committedDate": "2020-02-07T17:45:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODQ5Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r380268497", "bodyText": "Style nitpick: Optional supports filter", "author": "moio", "createdAt": "2020-02-17T16:12:46Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -127,147 +133,182 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.flatMap(mk -> isValidReactivationKey(activationKey, minionId) ? mkey : empty());", "originalCommit": "d5917f6bba29ac61a334a74bf373186600f54557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2NTM5NA==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r380565394", "bodyText": "Changed it.  \ud83d\udc4d", "author": "admd", "createdAt": "2020-02-18T09:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2ODQ5Nw=="}], "type": "inlineReview"}, {"oid": "ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "url": "https://github.com/uyuni-project/uyuni/commit/ae33f6b6679c16d65f9d1d83a66daa8f2aca4faa", "message": "another forgotten corner case", "committedDate": "2020-02-18T09:52:28Z", "type": "forcePushed"}, {"oid": "483e566773644da185800ef4356a7bda5b583b15", "url": "https://github.com/uyuni-project/uyuni/commit/483e566773644da185800ef4356a7bda5b583b15", "message": "more suggested changes", "committedDate": "2020-02-21T10:30:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU1NzExNw==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r382557117", "bodyText": "typo in method name. One 'k' too much.", "author": "mcalmer", "createdAt": "2020-02-21T12:32:31Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -128,152 +134,187 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.filter(mk -> isValidReactivationKey(activationKey, minionId));\n+                updatekKickStartSession(activationKey);", "originalCommit": "483e566773644da185800ef4356a7bda5b583b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU2NzU1Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r382567556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +\n          \n          \n            \n                        SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Minion ID\", \"Minion '\" +", "author": "aaannz", "createdAt": "2020-02-21T12:58:20Z", "path": "java/code/src/com/suse/manager/reactor/messaging/RegisterMinionEventMessageAction.java", "diffHunk": "@@ -128,152 +134,187 @@ public void execute(EventMessage msg) {\n      *                              If left empty, activation key from grains will be used.\n      * @param proxyId the proxy to which the minion connects, if any\n      */\n-    public void registerSSHMinion(String minionId, Optional<Long> proxyId,\n-                                  Optional<String> activationKeyOverride) {\n-        registerMinion(minionId, true, proxyId, activationKeyOverride);\n+    public void registerSSHMinion(String minionId, Optional<Long> proxyId, Optional<String> activationKeyOverride) {\n+        Optional<MinionStartupGrains> startupGrainsOpt = SALT_SERVICE.getGrains(minionId,\n+                new TypeToken<MinionStartupGrains>() { }, \"machine_id\", \"saltboot_initrd\", \"susemanager\");\n+        registerMinion(minionId, true, proxyId, activationKeyOverride, startupGrainsOpt);\n+    }\n+    /**\n+     * Performs minion registration or reactivation..\n+     * @param minionId minion id\n+     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n+     * @param activationKeyOverride label of activation key to be applied to the system.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param startupGrains Grains needed for initial phase of registration\n+     */\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> proxyId,\n+                                Optional<String> activationKeyOverride, Optional<MinionStartupGrains> startupGrains) {\n+        Opt.consume(startupGrains,\n+            ()-> LOG.error(\"Aborting: needed grains are not found for minion: \" + minionId),\n+            grains-> {\n+                boolean saltbootInitrd = grains.getSaltbootInitrd();\n+                Optional<String> mkey = grains.getSuseManagerGrain().flatMap(sm -> sm.getManagementKey());\n+                Optional<ActivationKey> activationKey =\n+                        mkey.flatMap(mk -> ofNullable(ActivationKeyFactory.lookupByKey(mk)));\n+                Optional<String> validReactivationKey =\n+                        mkey.filter(mk -> isValidReactivationKey(activationKey, minionId));\n+                updatekKickStartSession(activationKey);\n+                Optional<String> machineIdOpt = grains.getMachineId();\n+                Opt.consume(machineIdOpt,\n+                    ()-> LOG.error(\"Aborting: cannot find machine id for minion: \" + minionId),\n+                    machineId -> registerMinion(minionId, isSaltSSH, proxyId, activationKeyOverride,\n+                            validReactivationKey, machineId, saltbootInitrd));\n+            });\n     }\n \n \n     /**\n-     * Performs minion registration.\n-     *\n+     * Performs minion registration or reactivation.\n      * @param minionId minion id\n      * @param isSaltSSH true if a salt-ssh system is bootstrapped\n      * @param actKeyOverride label of activation key to be applied to the system.\n-     *                              If left empty, activation key from grains will be used.\n+     *                       If left empty, activation key from grains will be used.\n+     * @param reActivationKey valid reactivation key\n+     * @param machineId Machine Id of the minion\n+     * @param saltbootInitrd saltboot_initrd, to be used for retail minions\n      */\n-    private void registerMinion(String minionId, boolean isSaltSSH,\n-                                Optional<Long> saltSSHProxyId,\n-                                Optional<String> actKeyOverride) {\n+    private void registerMinion(String minionId, boolean isSaltSSH, Optional<Long> saltSSHProxyId,\n+                                Optional<String> actKeyOverride, Optional<String> reActivationKey, String machineId,\n+                                boolean saltbootInitrd) {\n+        Opt.consume(reActivationKey,\n+            //Case-1 Registration\n+            () -> {\n+                Optional<MinionServer> registeredMinionOpt = MinionServerFactory.findByMachineId(machineId);\n+                Opt.consume(registeredMinionOpt,\n+                    () -> {\n+                        if (!duplicateMinionNamePresent(minionId)) {\n+                            finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+                        }\n+                    },\n+                    registeredMinion -> {\n+                        updateAlreadyRegisteredInfo(minionId, registeredMinion);\n+                        applySaltBootStates(minionId, registeredMinion, saltbootInitrd);\n+                    });\n+            },\n+            //Case-2 : Reactivation\n+            rk -> {\n+                reactivateSystem(minionId, machineId, rk);\n+                finalizeMinionRegistration(minionId, machineId, saltSSHProxyId, actKeyOverride, isSaltSSH);\n+            }\n+        );\n+    }\n \n-        // Match minions via their machine id\n-        Opt.fold(SALT_SERVICE.getMachineId(minionId),\n+    /**\n+     * Check if the specified management_key is valid reactivation key or not\n+     * @param activationKey activationKey\n+     * @param minionId minion Id\n+     * @return true/false based on if activation is a valid reaction key or not\n+     */\n+    private boolean isValidReactivationKey(Optional<ActivationKey> activationKey, String minionId) {\n+        return Opt.fold(activationKey,\n             () -> {\n-                LOG.info(\"Cannot find machine id for minion: \" + minionId);\n+                LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + activationKey);\n                 return false;\n             },\n-            machineId -> {\n-                boolean isReactivation = false;\n-                ActivationKey ak = null;\n-                ValueMap grains = new ValueMap(SALT_SERVICE.getGrains(minionId).orElseGet(HashMap::new));\n-                Optional<String> managmentKeyLabel = getManagementKeyLabelFromGrains(grains);\n-                if (managmentKeyLabel.isPresent()) {\n-                    ak = ActivationKeyFactory.lookupByKey(managmentKeyLabel.get());\n-                    if (ak != null && ak.getKickstartSession() != null) {\n-                        ak.getKickstartSession().markComplete(\"Installation completed.\");\n-                    }\n-                    if (ak == null) {\n-                        LOG.info(\"Outdated Management Key defined for \" + minionId + \": \" + managmentKeyLabel.get());\n-                    }\n-                    else if (ak.getServer() == null) {\n-                        LOG.error(\"Management Key is not a reactivation key: \" + managmentKeyLabel.get());\n-                    }\n-                    else {\n-                        isReactivation = true;\n-                    }\n-                }\n-\n-                Optional<User> creator = MinionPendingRegistrationService.getCreator(minionId);\n-                if (!isReactivation &&\n-                        checkIfMinionAlreadyRegistered(minionId, machineId, creator, isSaltSSH, grains)) {\n-                    return true;\n-                }\n-                // Check if this minion id already exists\n-                if (!isReactivation && duplicateMinionNamePresent(minionId)) {\n+            ak -> {\n+                if (Objects.isNull(ak.getServer())) {\n+                    LOG.error(\"Management Key is not a reactivation key: \" + ak.getKey());\n                     return false;\n                 }\n-                if (isReactivation) {\n-                    reactivateSystem(minionId, machineId, creator, grains, Optional.ofNullable(ak));\n-                }\n-                finalizeMinionRegistration(minionId, machineId, creator, saltSSHProxyId,\n-                        actKeyOverride.isPresent() ? actKeyOverride : Optional.empty(),\n-                        isSaltSSH, grains);\n+                //considered valid reactivation key only in this case\n                 return true;\n             }\n         );\n     }\n \n-    private void reactivateSystem(String minionId, String machineId, Optional<User> creator,\n-            ValueMap grains, Optional<ActivationKey> reactivationKey) {\n+    /**\n+     * Apply the states needed for the retail minion\n+     * @param minionId\n+     * @param registeredMinion\n+     * @param saltbootInitrd\n+     */\n+    private void applySaltBootStates(String minionId, MinionServer registeredMinion, boolean saltbootInitrd) {\n+        // Saltboot treatment\n+        // HACK: try to guess if the minion is a retail minion based on its groups.\n+        // This way we don't need to call grains for each register minion event.\n+        if (isRetailMinion(registeredMinion)) {\n+            if (saltbootInitrd) {\n+                // if we have the \"saltboot_initrd\" grain we want to re-deploy an image via saltboot,\n+                LOG.info(\"Applying saltboot for minion \" + minionId);\n+                applySaltboot(registeredMinion);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Reactivate the system\n+     * @param minionId minion id of the minion\n+     * @param machineId machine_id of the minion\n+     * @param reActivationKey valid Reaction key\n+     */\n+    private void reactivateSystem(String minionId, String machineId, String reActivationKey) {\n         // The machine id may have changed, but we know from the reactivation key\n         // which system should become this one\n-        reactivationKey\n-            .flatMap(rak -> rak.getServer().asMinionServer())\n-            .ifPresent(minion -> {\n-                minion.setMachineId(machineId);\n-                minion.setMinionId(minionId);\n-            });\n+        of(ActivationKeyFactory.lookupByKey(reActivationKey))\n+                .flatMap(ak -> ak.getServer().asMinionServer())\n+                .ifPresent(minion -> {\n+                    minion.setMachineId(machineId);\n+                    minion.setMinionId(minionId);\n+        });\n     }\n \n     /**\n-     * Check if a minion is already registered and update it in case so\n+     * Update information of already registered minion, in case minion_id is different.\n      * @param minionId the minion id\n-     * @param machineId the machine id that we are trying to register\n-     * @param creator the optional User that created the minion\n-     * @param isSaltSSH true if a salt-ssh system is bootstrapped\n-     * @param grains grains of the minion\n-     * @return true if minion already registered, false otherwise\n+     * @param registeredMinion existing registered minion\n      */\n-    public boolean checkIfMinionAlreadyRegistered(String minionId,\n-                                                  String machineId,\n-                                                  Optional<User> creator,\n-                                                  boolean isSaltSSH, ValueMap grains) {\n-        Optional<MinionServer> optMinion = MinionServerFactory.findByMachineId(machineId);\n-        if (optMinion.isPresent()) {\n-            MinionServer registeredMinion = optMinion.get();\n-            String oldMinionId = registeredMinion.getMinionId();\n-\n-            if (!minionId.equals(oldMinionId)) {\n-                LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n-                        \"profile to '\" + minionId + \"' [\" + machineId + \"]\");\n-\n-                registeredMinion.setName(minionId);\n-                registeredMinion.setMinionId(minionId);\n-                ServerFactory.save(registeredMinion);\n-\n-                MinionPillarManager.INSTANCE.generatePillar(registeredMinion);\n-                MinionPillarManager.INSTANCE.removePillar(oldMinionId);\n-\n-                migrateMinionFormula(minionId, Optional.of(oldMinionId));\n-\n-                SALT_SERVICE.deleteKey(oldMinionId);\n-\n-                SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Minion ID\", \"Minion '\" +\n-                        oldMinionId + \"' has been updated to '\" + minionId + \"'\");\n-            }\n+    public void updateAlreadyRegisteredInfo(String minionId, MinionServer registeredMinion) {\n+        String oldMinionId = registeredMinion.getMinionId();\n+        if (!minionId.equals(oldMinionId)) {\n+            LOG.warn(\"Minion '\" + oldMinionId + \"' already registered, updating \" +\n+                    \"profile to '\" + minionId + \"' [\" + registeredMinion.getMachineId() + \"]\");\n+            registeredMinion.setName(minionId);\n+            registeredMinion.setMinionId(minionId);\n+            ServerFactory.save(registeredMinion);\n+\n+            MinionPillarManager.INSTANCE.generatePillar(registeredMinion);\n+            MinionPillarManager.INSTANCE.removePillar(oldMinionId);\n+\n+            migrateMinionFormula(minionId, Optional.of(oldMinionId));\n+\n+            SALT_SERVICE.deleteKey(oldMinionId);\n+            SystemManager.addHistoryEvent(registeredMinion, \"Duplicate Machine ID\", \"Minion '\" +", "originalCommit": "483e566773644da185800ef4356a7bda5b583b15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "url": "https://github.com/uyuni-project/uyuni/commit/acb0b9a6a1e9d3ee9cc57819bb137bfbbe6a7ade", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script", "committedDate": "2020-02-21T14:11:01Z", "type": "forcePushed"}, {"oid": "8cddc596dd7703970ddaa0b352c0c6722816b1cf", "url": "https://github.com/uyuni-project/uyuni/commit/8cddc596dd7703970ddaa0b352c0c6722816b1cf", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script", "committedDate": "2020-02-21T15:14:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTI1NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r383221255", "bodyText": "I'm missing something, but why here suseManagerGrain is serialized as 'susemanager', but later as 'management_key'?", "author": "aaannz", "createdAt": "2020-02-24T11:49:39Z", "path": "java/code/src/com/suse/manager/webui/utils/salt/MinionStartupGrains.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2019 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.salt;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Class to represent grains defined against 'start_event_grains'\n+ */\n+public class MinionStartupGrains {\n+    @SerializedName(\"machine_id\")\n+    private Optional<String> machineId = Optional.empty();\n+    @SerializedName(\"saltboot_initrd\")\n+    private boolean saltbootInitrd = false;\n+    @SerializedName(\"susemanager\")\n+    private Optional<SuseManagerGrain> suseManagerGrain = Optional.empty();", "originalCommit": "8cddc596dd7703970ddaa0b352c0c6722816b1cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyODg0Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r383228842", "bodyText": "@aaannz idea was to reflect the structure of data that we get from the salt. management_key grain is not a root level pillar, like machine_id, it's rather part of the 'susemanager` grains.", "author": "admd", "createdAt": "2020-02-24T12:08:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIzNTU2Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/1833#discussion_r383235566", "bodyText": "Ah, that makes sense. Thanks for explaining it.", "author": "aaannz", "createdAt": "2020-02-24T12:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzIyMTI1NQ=="}], "type": "inlineReview"}, {"oid": "84e419e2155cfd0b7bbf74b83b4ae2ad0ed9140a", "url": "https://github.com/uyuni-project/uyuni/commit/84e419e2155cfd0b7bbf74b83b4ae2ad0ed9140a", "message": "get the machine-id grain from the start up event", "committedDate": "2020-02-25T07:57:07Z", "type": "commit"}, {"oid": "35a8f1486b75929e5a595f22fd85d41973c8c9c9", "url": "https://github.com/uyuni-project/uyuni/commit/35a8f1486b75929e5a595f22fd85d41973c8c9c9", "message": "add a helper sls file to update the minion config to make use of minion_start_grains", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "40b88f2af8f5910a180ad7d89acf4aa9f91b4f2c", "url": "https://github.com/uyuni-project/uyuni/commit/40b88f2af8f5910a180ad7d89acf4aa9f91b4f2c", "message": "Provided builder to construct object easily for testing", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "e31ed92c3cf2c8c471f72cb39f811b78b8ccb56f", "url": "https://github.com/uyuni-project/uyuni/commit/e31ed92c3cf2c8c471f72cb39f811b78b8ccb56f", "message": "added new tests to cover scenerios when startup grains are passed", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "df0ea59c510fe179d94a8e18fbe3fa354fb57195", "url": "https://github.com/uyuni-project/uyuni/commit/df0ea59c510fe179d94a8e18fbe3fa354fb57195", "message": "Modify existings tests to make use of new builder", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "2f58e220c1b153274d50e8de5cec0547d6e449ca", "url": "https://github.com/uyuni-project/uyuni/commit/2f58e220c1b153274d50e8de5cec0547d6e449ca", "message": "added susemanager and saltboot_initrd grains to the state file", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "6fbc34b555dd59d163e4318cb6a4e1b14e1987bd", "url": "https://github.com/uyuni-project/uyuni/commit/6fbc34b555dd59d163e4318cb6a4e1b14e1987bd", "message": "added config so new bootsrapped minions can get the config automatically", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "a0d897bf3a488e41784fd46030d6edcd7ee0e513", "url": "https://github.com/uyuni-project/uyuni/commit/a0d897bf3a488e41784fd46030d6edcd7ee0e513", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script", "committedDate": "2020-02-25T07:57:08Z", "type": "commit"}, {"oid": "69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "url": "https://github.com/uyuni-project/uyuni/commit/69307d1fa31aea1654c28a8a1ee5d25e61212ae4", "message": "update units test & some more refactoring", "committedDate": "2020-01-30T10:31:53Z", "type": "forcePushed"}, {"oid": "a0d897bf3a488e41784fd46030d6edcd7ee0e513", "url": "https://github.com/uyuni-project/uyuni/commit/a0d897bf3a488e41784fd46030d6edcd7ee0e513", "message": "Add 'start_event_grains' minion option to configfile when generated by bootstrap script", "committedDate": "2020-02-25T07:57:08Z", "type": "forcePushed"}]}