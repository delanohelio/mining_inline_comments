{"pr_number": 2271, "pr_title": "Highstate on bootstrap with entitlements", "pr_createdAt": "2020-06-02T10:09:57Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2271", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3Mzg5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2271#discussion_r433873896", "bodyText": "I would be happy about ideas for better testing it.\nI also have no idea why the first state.apply seems to be \"executed\" and not be anymore in the queue,\nbut the hightstate stay in the queue.", "author": "mcalmer", "createdAt": "2020-06-02T13:28:02Z", "path": "java/code/src/com/suse/manager/reactor/test/RegisterMinionActionTest.java", "diffHunk": "@@ -1905,6 +1911,72 @@ public void testMinionWithUsedReActivationKeyWithStartUpGrains() throws Exceptio\n                 Optional.of(minionStartUpGrains));\n     }\n \n+    public void testRegisterMinionWithActivationKeyAndAddOns() throws Exception {\n+        MessageQueue.registerAction(new ApplyStatesEventMessageAction(),\n+                ApplyStatesEventMessage.class);\n+        MessageQueue.startMessaging();\n+        ChannelFamily channelFamily = createTestChannelFamily();\n+        SUSEProduct product = SUSEProductTestUtils.createTestSUSEProduct(channelFamily);\n+        Channel baseChannelX8664 = setupBaseAndRequiredChannels(channelFamily, product);\n+        HibernateFactory.getSession().flush();\n+        executeTest(\n+                (saltServiceMock, key) -> new Expectations() {{\n+                    allowing(saltServiceMock).getMasterHostname(MINION_ID);\n+                    will(returnValue(Optional.of(MINION_ID)));\n+                    allowing(saltServiceMock).getMachineId(MINION_ID);\n+                    will(returnValue(Optional.of(MACHINE_ID)));\n+                    MinionStartupGrains.SuseManagerGrain suseManagerGrain = new MinionStartupGrains.SuseManagerGrain(Optional.of(key));\n+                    MinionStartupGrains minionStartUpGrains =  new MinionStartupGrains.MinionStartupGrainsBuilder()\n+                            .machineId(MACHINE_ID).saltbootInitrd(false).susemanagerGrain(suseManagerGrain)\n+                            .createMinionStartUpGrains();\n+                    allowing(saltServiceMock).getGrains(with(any(String.class)), with(any(TypeToken.class)),with(any(String[].class)));\n+                    will(returnValue(Optional.of(minionStartUpGrains)));\n+                    allowing(saltServiceMock).syncGrains(with(any(MinionList.class)));\n+                    allowing(saltServiceMock).syncModules(with(any(MinionList.class)));\n+                    allowing(saltServiceMock).getGrains(MINION_ID);\n+                    will(returnValue(getGrains(MINION_ID, null, key)));\n+                }},\n+                (contactMethod) -> {\n+                    ActivationKey key = ActivationKeyTest.createTestActivationKey(user);\n+                    key.setBaseChannel(baseChannelX8664);\n+                    baseChannelX8664.getAccessibleChildrenFor(user)\n+                            .forEach(channel -> key.addChannel(channel));\n+                    key.setOrg(user.getOrg());\n+\n+                    Set<ServerGroupType> entitlementsIn = key.getEntitlements();\n+                    entitlementsIn.add(ServerConstants.getServerGroupTypeContainerBuildHostEntitled());\n+                    key.setEntitlements(entitlementsIn);\n+\n+                    ActivationKeyFactory.save(key);\n+                    return key.getKey();\n+                },\n+                (optMinion, machineId, key) -> {\n+                    assertTrue(optMinion.isPresent());\n+                    MinionServer minion = optMinion.get();\n+                    assertEquals(MINION_ID, minion.getName());\n+\n+                    // only channel associated with Activation Key and child\n+                    // channels associated with it must be present\n+                    assertNotNull(minion.getBaseChannel());\n+                    HashSet<Channel> channels = new HashSet<>();\n+                    channels.add(baseChannelX8664);\n+                    baseChannelX8664.getAccessibleChildrenFor(user)\n+                    .forEach(channel -> channels.add(channel));\n+                    assertEquals(baseChannelX8664, minion.getBaseChannel());\n+                    assertEquals(channels.size(), minion.getChannels().size());\n+                    assertTrue(minion.getChannels().containsAll(channels));\n+\n+                    assertTrue(minion.getFqdns().isEmpty());\n+                    // the first ApplyStatesEvent with channels is executed.\n+                    // the second (highstate) stay in the queue and can be counted\n+                    assertEquals(1, MessageQueue.getMessageCount());", "originalCommit": "99af08c7d71c9052e3bd15f6424b279c3346f64d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM1NDQwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2271#discussion_r434354401", "bodyText": "Hm, although it would be nice to have this tested, testing it this way looks quite dangerous to me. The reason, why we only get 1 message here is that the previous ApplyStatesEvent was processed by another thread (RHN dispatcher thread). The tests run in \"main\" thread, which could potentially bring some race conditions (e.g. if you put Thread.sleep(10000L); in the MessageQueue.popEventMessage on line 144, your test starts failing, as there will be 2 messages in the queue (this simulates the behavior, when the first ApplyStatesEvent \"would take longer\")).\nI think that testability of the MessageQueue is part of a bigger problem, which should be solved separately and properly, therefore I'd suggest removing this test.", "author": "hustodemon", "createdAt": "2020-06-03T07:12:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3Mzg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3NjUxMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2271#discussion_r434376513", "bodyText": "removed", "author": "mcalmer", "createdAt": "2020-06-03T07:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3Mzg5Ng=="}], "type": "inlineReview"}, {"oid": "cd78b6c6c73a2036b397247236335ae66c1e045f", "url": "https://github.com/uyuni-project/uyuni/commit/cd78b6c6c73a2036b397247236335ae66c1e045f", "message": "unit test: addOns should cause a highstate when onboarding a system", "committedDate": "2020-06-02T15:49:41Z", "type": "forcePushed"}, {"oid": "6660548145a1860a0e8ed4ca9d7fa67a4058c5b5", "url": "https://github.com/uyuni-project/uyuni/commit/6660548145a1860a0e8ed4ca9d7fa67a4058c5b5", "message": "update changelog", "committedDate": "2020-06-02T15:49:41Z", "type": "forcePushed"}, {"oid": "87948a7af22d6e1bb1b1c3fedcb321ec6300f451", "url": "https://github.com/uyuni-project/uyuni/commit/87948a7af22d6e1bb1b1c3fedcb321ec6300f451", "message": "update changelog", "committedDate": "2020-06-03T15:07:36Z", "type": "forcePushed"}, {"oid": "10f567f2c73d215f27276135ebbcf66f26fd8e42", "url": "https://github.com/uyuni-project/uyuni/commit/10f567f2c73d215f27276135ebbcf66f26fd8e42", "message": "apply highstate when add-on system types should be applied to the on bootstrapping (bsc#1172190)", "committedDate": "2020-06-04T08:21:11Z", "type": "commit"}, {"oid": "ae406b9afbf3b2a559e4196c4a75a5087c0ff940", "url": "https://github.com/uyuni-project/uyuni/commit/ae406b9afbf3b2a559e4196c4a75a5087c0ff940", "message": "update changelog", "committedDate": "2020-06-04T08:21:43Z", "type": "commit"}, {"oid": "ae406b9afbf3b2a559e4196c4a75a5087c0ff940", "url": "https://github.com/uyuni-project/uyuni/commit/ae406b9afbf3b2a559e4196c4a75a5087c0ff940", "message": "update changelog", "committedDate": "2020-06-04T08:21:43Z", "type": "forcePushed"}]}