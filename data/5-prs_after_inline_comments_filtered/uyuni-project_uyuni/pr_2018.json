{"pr_number": 2018, "pr_title": "Recurring Actions XMLRPC API", "pr_createdAt": "2020-03-16T11:08:14Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2018", "timeline": [{"oid": "995f300b919f3e5067383d9fad41d3760901cc2c", "url": "https://github.com/uyuni-project/uyuni/commit/995f300b919f3e5067383d9fad41d3760901cc2c", "message": "Add recurring action creation\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-16T14:32:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3NDQ2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393074462", "bodyText": "It's a good practice to throw a FaultException from the handlers. The FaultExceptions have an errorCode attribute, which can make it easier for the API consumers to reason about the error. For some well-known backend exceptions we even have their Fault counterparts. In case of listing recurring actions, it'd be good to catch the PermissionException and rethrow a PermissionCheckFailureException with correctly set cause.", "author": "hustodemon", "createdAt": "2020-03-16T14:39:16Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/org/OrgHandler.java", "diffHunk": "@@ -868,4 +870,23 @@ public Integer setContentStaging(User loggedInUser, Integer orgId,\n \n         return 1;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for the given organization.\n+     *\n+     * @param loggedInUser The current user\n+     * @param orgId id of the organization\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for the given organization.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"orgId\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<OrgRecurringAction> listRecurringActions(User loggedInUser, Integer orgId) {\n+        return RecurringActionManager.listOrgRecurringActions(orgId, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3ODQ0Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393078446", "bodyText": "I think that displaying user login would be enough in this case (action.getCreator().getLogin()) as there is no need to display the whole user data (enabled flag, uppercase version of the login.). Displaying login only would also be consistent with other API endpoints.\nPlease change also the @xmlrpc.doc tag above.", "author": "hustodemon", "createdAt": "2020-03-16T14:44:43Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/serializer/RecurringActionSerializer.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.serializer;\n+\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.frontend.xmlrpc.serializer.util.SerializerHelper;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+import redstone.xmlrpc.XmlRpcException;\n+import redstone.xmlrpc.XmlRpcSerializer;\n+\n+/**\n+ * Serializer for {@link com.redhat.rhn.domain.recurringactions.RecurringAction} class and subclasses\n+ *\n+ * @xmlrpc.doc\n+ * #struct(\"Recurring Action information\")\n+ *   #prop(\"string\", \"name\")\n+ *   #prop(\"int\", \"entityId\")\n+ *   #prop(\"string\", \"type\")\n+ *   #prop(\"string\", \"frequency\")\n+ *   #prop(\"string\", \"created\")\n+ *   #prop(\"UserImpl\", \"creator\")\n+ *   #prop(\"boolean\", \"testMode\")\n+ *   #prop(\"boolean\", \"active\")\n+ * #struct_end()\n+ */\n+public class RecurringActionSerializer extends RhnXmlRpcCustomSerializer {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Class getSupportedClass() {\n+        return RecurringAction.class;\n+    }\n+\n+    @Override\n+    protected void doSerialize(Object obj, Writer writer, XmlRpcSerializer serializer)\n+            throws XmlRpcException, IOException {\n+        RecurringAction action = (RecurringAction) obj;\n+        SerializerHelper helper = new SerializerHelper(serializer);\n+\n+        helper.add(\"name\", action.getName());\n+        helper.add(\"entityId\", action.getEntityId());\n+        helper.add(\"type\", action.getType().toString());\n+        helper.add(\"frequency\", action.getCronExpr());\n+        helper.add(\"created\", action.getCreated());\n+        helper.add(\"creator\", action.getCreator());", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTUwMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079502", "bodyText": "Same as in the OrgHandler.listRecurringActions.", "author": "hustodemon", "createdAt": "2020-03-16T14:46:07Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/system/SystemHandler.java", "diffHunk": "@@ -7066,4 +7068,23 @@ public Long scheduleApplyHighstate(User loggedInUser, Integer sid, Date earliest\n     public TaskomaticApi getTaskomaticApi() {\n         return taskomaticApi;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system.\n+     *\n+     * @param loggedInUser The current user\n+     * @param sid the id of the system\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"server_id)\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<MinionRecurringAction> listRecurringActions(User loggedInUser, Integer sid) {\n+        return RecurringActionManager.listMinionRecurringActions(sid, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTY3NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079674", "bodyText": "Same as in the OrgHandler.listRecurringActions.", "author": "hustodemon", "createdAt": "2020-03-16T14:46:22Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/systemgroup/ServerGroupHandler.java", "diffHunk": "@@ -513,4 +515,23 @@ private ServerGroup lookup(Integer id, User user) {\n             throw new TaskomaticApiException(e.getMessage());\n         }\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system group.\n+     *\n+     * @param loggedInUser The current user\n+     * @param systemGroupId the id of the system group\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system group.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"systemGroupId\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<GroupRecurringAction> listRecurringActions(User loggedInUser, Integer systemGroupId) {\n+        return RecurringActionManager.listGroupRecurringActions(systemGroupId, loggedInUser);", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3OTg4Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r393079883", "bodyText": "Should be \"sid\".\nMoreover, if you want this to be a bit more user friendly, you can:\n\neither rename sid to something more auto-descriptive (serverId),\nor provide a description via param_desc (instead of the param): #param_desc(\"int\", \"sid\", \"Server ID\")", "author": "hustodemon", "createdAt": "2020-03-16T14:46:39Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/system/SystemHandler.java", "diffHunk": "@@ -7066,4 +7068,23 @@ public Long scheduleApplyHighstate(User loggedInUser, Integer sid, Date earliest\n     public TaskomaticApi getTaskomaticApi() {\n         return taskomaticApi;\n     }\n+\n+    /**\n+     * Return a list of recurring actions for a given system.\n+     *\n+     * @param loggedInUser The current user\n+     * @param sid the id of the system\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given system.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param(\"int\", \"server_id)", "originalCommit": "13219bc31e2e31d9a348de017c584af84612e529", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "114e0fe781f85a64e040d787bbd77fe439971cc2", "url": "https://github.com/uyuni-project/uyuni/commit/114e0fe781f85a64e040d787bbd77fe439971cc2", "message": "Add list recurring action by id\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-17T16:12:05Z", "type": "forcePushed"}, {"oid": "b9c72e360b9034172a71e8cde45cc668a34b8c48", "url": "https://github.com/uyuni-project/uyuni/commit/b9c72e360b9034172a71e8cde45cc668a34b8c48", "message": "Support deleting of actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-17T17:33:14Z", "type": "forcePushed"}, {"oid": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "url": "https://github.com/uyuni-project/uyuni/commit/4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "message": "Extract save method from create/update\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-18T07:59:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwMDY2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394200662", "bodyText": "It would be nice to mention the possible values MINION, GROUP, ORG. The docs are the only place where the user can see these values.", "author": "hustodemon", "createdAt": "2020-03-18T09:15:30Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwNDgzNw==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394204837", "bodyText": "You can return the result here (and in the GROUP and ORG case) directly. This way you can get rid of breaks and the schedules variable.", "author": "hustodemon", "createdAt": "2020-03-18T09:22:37Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwNTA5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394205096", "bodyText": "This looks like a C&P error.", "author": "hustodemon", "createdAt": "2020-03-18T09:23:05Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIwODIzNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394208235", "bodyText": "Nitpick: this should be actionId.", "author": "hustodemon", "createdAt": "2020-03-18T09:28:14Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMDkwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394210906", "bodyText": "This looks like improper use of Optional (accessing it and checking for NoSuchElementException).\nInstead of that, something like this could replace the whole method body:\nRecurringActionFactory.lookupById(actionId)\n    .filter(a -> a.canAccess(loggedInUser))\n    .orElseThrow(() -> new EntityNotExistsFaultException(\"Action blabla doesnt exist or is not accessible\"));", "author": "hustodemon", "createdAt": "2020-03-18T09:32:25Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjIwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212201", "bodyText": "entity_id should be passed as \"int\". This'd be better since the serializer returns the entity IDs as numbers (so that data returned from the list/lookup can be reused for creating/updating actions.).", "author": "hustodemon", "createdAt": "2020-03-18T09:34:36Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjM4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212381", "bodyText": "Please also mention this that this field is optional.", "author": "hustodemon", "createdAt": "2020-03-18T09:34:54Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMjY2NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394212664", "bodyText": "The declaration could be moved to the initialization below.", "author": "hustodemon", "createdAt": "2020-03-18T09:35:25Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394213596", "bodyText": "There is already a method for validating such props maps: validateMap. It's even inherited from the BaseHandler.\nI think it does precisely this, so you could simply write:\nvalidateMap(Set.of(\"id\", \"entity_type\", \"entity_id\", ...), actionProps);", "author": "hustodemon", "createdAt": "2020-03-18T09:36:58Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDI4MDIxMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394280212", "bodyText": "Right, but this does only check if only valid keys are provided, not if valid keys are actually there. E.g. you could just omit the entity_id in your call and it would not complain.", "author": "parlt91", "createdAt": "2020-03-18T11:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDMxMjUyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394312525", "bodyText": "Ah, I see. It works the other way around: validating that the given map doesn't contain an \"invalid\" key.", "author": "hustodemon", "createdAt": "2020-03-18T12:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxMzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNDcyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394214725", "bodyText": "It'd be nice to catch the EntityNotExistsException here and translate it to its Fault counterpart.", "author": "hustodemon", "createdAt": "2020-03-18T09:38:55Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNTMwMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394215300", "bodyText": "If you pass the entity_id as \"int\" (see above), you can just do something like this ((Integer) actionProps.get(\"entity_id\")).longValue().", "author": "hustodemon", "createdAt": "2020-03-18T09:39:59Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNTYyMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394215621", "bodyText": "Similar case as the entity_id: this should be \"int\".", "author": "hustodemon", "createdAt": "2020-03-18T09:40:31Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNjc5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394216796", "bodyText": "The action_Id looks a bit weird. But anyway: neither type, nor name is needed here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @xmlrpc.returntype int action_Id - The action id of the recurring action\n          \n          \n            \n                 * @xmlrpc.returntype The id of the recurring action", "author": "hustodemon", "createdAt": "2020-03-18T09:42:26Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxNzIzMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394217232", "bodyText": "Similar as entity_id, this could be typecast as Integer.", "author": "hustodemon", "createdAt": "2020-03-18T09:43:09Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODA4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394218081", "bodyText": "I've just checked and it seems that this line is not needed. The XMLRPC backend seems not to swallow certain exceptions (the UI does it, apparently), so if we just rethrow the exception on the line below, the transaction will be rolled back automatically :)", "author": "hustodemon", "createdAt": "2020-03-18T09:44:33Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));\n+        RecurringAction action = lookupById(user, id);\n+\n+        if (actionProps.containsKey(\"name\")) {\n+            action.setName((String) actionProps.get(\"name\"));\n+        }\n+        if (actionProps.containsKey(\"cron_expr\")) {\n+            action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        }\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        if (actionProps.containsKey(\"active\")) {\n+            action.setActive(Boolean.parseBoolean(actionProps.get(\"active\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /* Helper method */\n+    private Long save(User loggedInUser, RecurringAction action) {\n+        try {\n+            RecurringActionManager.saveAndSchedule(action, loggedInUser);\n+        }\n+        catch (ValidatorException e) {\n+            throw new ValidationException(e.getMessage());\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIxODE4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r394218185", "bodyText": "Same as above ^^^.", "author": "hustodemon", "createdAt": "2020-03-18T09:44:44Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/recurringaction/RecurringActionHandler.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.frontend.xmlrpc.recurringaction;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.common.validator.ValidatorException;\n+import com.redhat.rhn.domain.recurringactions.RecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.frontend.xmlrpc.BaseHandler;\n+import com.redhat.rhn.frontend.xmlrpc.EntityNotExistsFaultException;\n+import com.redhat.rhn.frontend.xmlrpc.InvalidArgsException;\n+import com.redhat.rhn.frontend.xmlrpc.PermissionCheckFailureException;\n+import com.redhat.rhn.frontend.xmlrpc.TaskomaticApiException;\n+import com.redhat.rhn.frontend.xmlrpc.ValidationException;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class RecurringActionHandler extends BaseHandler {\n+\n+    /* helper method */\n+    private RecurringAction.Type getEntityType(String entityType) {\n+        try {\n+            return RecurringAction.Type.valueOf(entityType.toUpperCase());\n+        }\n+        catch (IllegalArgumentException e) {\n+            throw new InvalidArgsException(\"Type \\\"\" + entityType + \"\\\" does not exist\");\n+        }\n+    }\n+\n+    /**\n+     * Return a list of recurring actions for a given entity.\n+     *\n+     * @param loggedInUser The current user\n+     * @param entityId the id of the entity\n+     * @param entityType type of the entity\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return a list of recurring actions for a given entity.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"string\", \"entityType\", \"Type of the target entity\")\n+     * @xmlrpc.param #param_desc(\"int\", \"entityId\", \"Id of the target entity\")\n+     * @xmlrpc.returntype\n+     *      #array()\n+     *          $RecurringActionSerializer\n+     *      #array_end()\n+     */\n+    public List<? extends RecurringAction> listByEntity(User loggedInUser, String entityType, Integer entityId) {\n+        List<? extends RecurringAction> schedules;\n+        try {\n+            switch (getEntityType(entityType)) {\n+                case MINION:\n+                    schedules = RecurringActionManager.listMinionRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case GROUP:\n+                    schedules = RecurringActionManager.listGroupRecurringActions(entityId, loggedInUser);\n+                    break;\n+                case ORG:\n+                    schedules = RecurringActionManager.listOrgRecurringActions(entityId, loggedInUser);\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unsupported type \" + entityType);\n+            }\n+            return schedules;\n+        }\n+        catch (PermissionException e) {\n+            throw new PermissionCheckFailureException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Return recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return the list of recurring actions\n+     *\n+     * @xmlrpc.doc Return recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype $RecurringActionSerializer\n+     */\n+    public RecurringAction lookupById(User loggedInUser, Integer actionId) {\n+        try {\n+            RecurringAction action = RecurringActionFactory.lookupById(actionId).orElseThrow();\n+            if (action.canAccess(loggedInUser)) {\n+                return action;\n+            }\n+        }\n+        catch (NoSuchElementException e) {\n+            throw new EntityNotExistsFaultException(\"Action with id: \" + actionId + \" does not exist\");\n+        }\n+        throw new PermissionCheckFailureException(\"Action not accessible to user: \" + loggedInUser);\n+    }\n+\n+    /**\n+     * Create a new recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing action properties\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Create a new recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"entity_type\", \"The type of the target entity\")\n+     *      #prop_desc(\"string\", \"entity_id\", \"The id of the target entity\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long create(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = createAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private RecurringAction createAction(Map<String, Object> actionProps, User user) {\n+        RecurringAction action;\n+        if (actionProps.containsKey(\"id\") || !actionProps.containsKey(\"entity_type\") ||\n+                !actionProps.containsKey(\"entity_id\") || !actionProps.containsKey(\"cron_expr\") ||\n+                !actionProps.containsKey(\"name\")) {\n+            throw new InvalidArgsException(\"Incomplete action props\");\n+        }\n+        action = RecurringActionManager.createRecurringAction(\n+                getEntityType((String) actionProps.get(\"entity_type\")),\n+                Long.parseLong((String) actionProps.get(\"entity_id\")),\n+                user\n+        );\n+        action.setName((String) actionProps.get(\"name\"));\n+        action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /**\n+     * Update a recurring action.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionProps Map containing properties to update\n+     * @return action id or exception thrown otherwise\n+     *\n+     * @xmlrpc.doc Update a recurring action.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param\n+     *  #struct(\"actionProps\")\n+     *      #prop_desc(\"string\", \"id\", \"The id of the action to update\")\n+     *      #prop_desc(\"string\", \"name\", \"The name of the action (optional)\")\n+     *      #prop_desc(\"string\", \"cron_expr\", \"The execution frequency of the action (optional)\")\n+     *      #prop_desc(\"boolean\", \"test\", \"Whether the action should be executed in test mode (optional)\")\n+     *      #prop_desc(\"boolean\", \"active\", \"Whether the action should be active (optional)\")\n+     *  #struct_end()\n+     * @xmlrpc.returntype int action_Id - The action id of the recurring action\n+     */\n+    public Long update(User loggedInUser, Map<String, Object> actionProps) {\n+        RecurringAction action = updateAction(actionProps, loggedInUser);\n+        return save(loggedInUser, action);\n+    }\n+\n+    /* Helper method */\n+    private  RecurringAction updateAction(Map<String, Object> actionProps, User user) {\n+        if (!actionProps.containsKey(\"id\")) {\n+            throw new InvalidArgsException(\"No action id provided\");\n+        }\n+        Integer id = Integer.parseInt((String) actionProps.get(\"id\"));\n+        RecurringAction action = lookupById(user, id);\n+\n+        if (actionProps.containsKey(\"name\")) {\n+            action.setName((String) actionProps.get(\"name\"));\n+        }\n+        if (actionProps.containsKey(\"cron_expr\")) {\n+            action.setCronExpr((String) actionProps.get(\"cron_expr\"));\n+        }\n+        if (actionProps.containsKey(\"test\")) {\n+            action.setTestMode(Boolean.parseBoolean(actionProps.get(\"test\").toString()));\n+        }\n+        if (actionProps.containsKey(\"active\")) {\n+            action.setActive(Boolean.parseBoolean(actionProps.get(\"active\").toString()));\n+        }\n+        return action;\n+    }\n+\n+    /* Helper method */\n+    private Long save(User loggedInUser, RecurringAction action) {\n+        try {\n+            RecurringActionManager.saveAndSchedule(action, loggedInUser);\n+        }\n+        catch (ValidatorException e) {\n+            throw new ValidationException(e.getMessage());\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();\n+            throw new TaskomaticApiException(e.getMessage());\n+        }\n+        return action.getId();\n+    }\n+\n+    /**\n+     * Delete recurring action with given action id.\n+     *\n+     * @param loggedInUser The current user\n+     * @param actionId id of the action\n+     * @return id of deleted action otherwise exception thrown\n+     *\n+     * @xmlrpc.doc Delete recurring action with given action id.\n+     * @xmlrpc.param #session_key()\n+     * @xmlrpc.param #param_desc(\"int\", \"action_id\", \"Id of the action\")\n+     * @xmlrpc.returntype int action_id - The action id of the recurring action\n+     */\n+    public Long delete(User loggedInUser, Integer actionId) {\n+        RecurringAction action = lookupById(loggedInUser, actionId);\n+        try {\n+            RecurringActionManager.deleteAndUnschedule(action, loggedInUser);\n+        }\n+        catch (com.redhat.rhn.taskomatic.TaskomaticApiException e) {\n+            HibernateFactory.rollbackTransaction();", "originalCommit": "4ea16e3ebcee00b06fa4fc6027756690ce2b14ef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a80860ecd6c852580233c9a46101511319cb544", "url": "https://github.com/uyuni-project/uyuni/commit/7a80860ecd6c852580233c9a46101511319cb544", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-18T12:03:19Z", "type": "forcePushed"}, {"oid": "dff197fd073d2f9ba6312fc398092e2d77d96f17", "url": "https://github.com/uyuni-project/uyuni/commit/dff197fd073d2f9ba6312fc398092e2d77d96f17", "message": "Recurring Actions: Test for XMLRPC handler and Web controller", "committedDate": "2020-03-19T09:42:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTAxMTA5OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2018#discussion_r395011098", "bodyText": "I really like this approach a lot more \ud83d\udc4d", "author": "parlt91", "createdAt": "2020-03-19T13:08:07Z", "path": "java/code/src/com/suse/manager/webui/controllers/RecurringActionController.java", "diffHunk": "@@ -193,8 +193,8 @@ public static String save(Request request, Response response, User user) {\n         RecurringStateScheduleJson json = GSON.fromJson(request.body(), RecurringStateScheduleJson.class);\n \n         try {\n-            validate(json, user);\n             RecurringAction action = createOrGetAction(user, json);\n+            RecurringActionFactory.getSession().evict(action); // entity -> detached, prevent hibernate flushes", "originalCommit": "01ecc69454c749ccb766958b14374f9654a6f0db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f93373422dda35d746c6973957ccfd9244df13e4", "url": "https://github.com/uyuni-project/uyuni/commit/f93373422dda35d746c6973957ccfd9244df13e4", "message": "Fix checkstyle", "committedDate": "2020-03-20T07:52:11Z", "type": "forcePushed"}, {"oid": "e32bd0e8595ed60fdf10a16e5cc4bb370e1abfb2", "url": "https://github.com/uyuni-project/uyuni/commit/e32bd0e8595ed60fdf10a16e5cc4bb370e1abfb2", "message": "Fix checkstyle", "committedDate": "2020-03-23T10:16:55Z", "type": "forcePushed"}, {"oid": "a95563bf4224512e26129ae139c0fbd72f909601", "url": "https://github.com/uyuni-project/uyuni/commit/a95563bf4224512e26129ae139c0fbd72f909601", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-23T14:33:36Z", "type": "forcePushed"}, {"oid": "b55438dbd1e7a1a5752958c4f713d55c83d22a2a", "url": "https://github.com/uyuni-project/uyuni/commit/b55438dbd1e7a1a5752958c4f713d55c83d22a2a", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-23T14:51:37Z", "type": "forcePushed"}, {"oid": "4035ec10ff71837a1ad05c55b826b6a6083cac6d", "url": "https://github.com/uyuni-project/uyuni/commit/4035ec10ff71837a1ad05c55b826b6a6083cac6d", "message": "Add RecurringActionSerializer\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "d807d2f3e1b727c40f90517c1d1d1f7b0a65c3a2", "url": "https://github.com/uyuni-project/uyuni/commit/d807d2f3e1b727c40f90517c1d1d1f7b0a65c3a2", "message": "Add RecurringActionHandler\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "ca7f7e0fc6a1a6e05564fe7a571e53a04b453f6c", "url": "https://github.com/uyuni-project/uyuni/commit/ca7f7e0fc6a1a6e05564fe7a571e53a04b453f6c", "message": "Add listing actions by entity\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "33f308b9b0f4677a25d267bef212243d20556f49", "url": "https://github.com/uyuni-project/uyuni/commit/33f308b9b0f4677a25d267bef212243d20556f49", "message": "Create new action for given entity\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "c4be8d41265be6f1167b543fa5537b3da91fe494", "url": "https://github.com/uyuni-project/uyuni/commit/c4be8d41265be6f1167b543fa5537b3da91fe494", "message": "Updating recurring actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "8a4e48d8e8efe01c49f5bc16b935bbbb753e7511", "url": "https://github.com/uyuni-project/uyuni/commit/8a4e48d8e8efe01c49f5bc16b935bbbb753e7511", "message": "Add list recurring action by id\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "f61cf5d8c2e3555ccdbe659eb9d2e3783035b10b", "url": "https://github.com/uyuni-project/uyuni/commit/f61cf5d8c2e3555ccdbe659eb9d2e3783035b10b", "message": "Support deleting of actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "be08bd41516e67d9322f362fad5758b9b80d5b80", "url": "https://github.com/uyuni-project/uyuni/commit/be08bd41516e67d9322f362fad5758b9b80d5b80", "message": "Extract save method from create/update\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "86bea541f12f529b84aeae78b9009e14918f705f", "url": "https://github.com/uyuni-project/uyuni/commit/86bea541f12f529b84aeae78b9009e14918f705f", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "b5e3e53529ed70f0811e4e4022dbc6ed27bb9ccc", "url": "https://github.com/uyuni-project/uyuni/commit/b5e3e53529ed70f0811e4e4022dbc6ed27bb9ccc", "message": "Minor fix: check for null when looking up for Org", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "61e74c0ef8565b9e87cd6c0babed2c074a00920a", "url": "https://github.com/uyuni-project/uyuni/commit/61e74c0ef8565b9e87cd6c0babed2c074a00920a", "message": "Recurring Actions XMLRPC: Small improvement in the docs", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "b5e63b1b47d8719395d35745c2dd564ff8bfd381", "url": "https://github.com/uyuni-project/uyuni/commit/b5e63b1b47d8719395d35745c2dd564ff8bfd381", "message": "Recurring Actions: Forbid blank cron expression", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "fab991184f323b7498f9ce2d289c1c09e2ddf22e", "url": "https://github.com/uyuni-project/uyuni/commit/fab991184f323b7498f9ce2d289c1c09e2ddf22e", "message": "Recurring Actions XMLRPC: Return int instead of long as action identifier\n\nPreviously, on out-of-int-range values, the silent overflow happened.\nNow an exception is thrown on backend.", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "8770b0ad09c3a3645290d8ed6b144fa9cf1edc23", "url": "https://github.com/uyuni-project/uyuni/commit/8770b0ad09c3a3645290d8ed6b144fa9cf1edc23", "message": "Recurring Actions: Improve validation mechanism\n\nPreviously on validating updated recurring actions in the web UI, a\ntransient entity was created to check the updated values.\n\nNow the same entity (which is turned to the detached state beforehand)\nis used for the validation. This approach is now uniform for both the\nweb UI and XMLRPC API.", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "5091bbc80e3da91024348ca4c32512403b5d5322", "url": "https://github.com/uyuni-project/uyuni/commit/5091bbc80e3da91024348ca4c32512403b5d5322", "message": "Recurring Actions: Test for XMLRPC handler and Web controller", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "9a6f19749bdf566fb2fd0cc6394c058e82d29fb5", "url": "https://github.com/uyuni-project/uyuni/commit/9a6f19749bdf566fb2fd0cc6394c058e82d29fb5", "message": "Fix checkstyle", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "0fae407a3c62634d7c2866c0581ba7c81ec3e9e0", "url": "https://github.com/uyuni-project/uyuni/commit/0fae407a3c62634d7c2866c0581ba7c81ec3e9e0", "message": "Fix RecurringActionHandler XMLRPC doc", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "3d203eda0eba29234d948ef7e58238f24fd2c569", "url": "https://github.com/uyuni-project/uyuni/commit/3d203eda0eba29234d948ef7e58238f24fd2c569", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "commit"}, {"oid": "3d203eda0eba29234d948ef7e58238f24fd2c569", "url": "https://github.com/uyuni-project/uyuni/commit/3d203eda0eba29234d948ef7e58238f24fd2c569", "message": "Add changelog\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-24T09:34:57Z", "type": "forcePushed"}]}