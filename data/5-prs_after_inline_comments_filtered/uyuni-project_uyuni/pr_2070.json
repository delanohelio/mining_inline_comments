{"pr_number": 2070, "pr_title": "Cluster management (MVP)", "pr_createdAt": "2020-03-27T17:51:49Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2070", "timeline": [{"oid": "c574053b34c428bec4aabb0f252d078af0441b84", "url": "https://github.com/uyuni-project/uyuni/commit/c574053b34c428bec4aabb0f252d078af0441b84", "message": "cluster UI: select mgmt node and finalize import page", "committedDate": "2020-04-16T22:31:47Z", "type": "forcePushed"}, {"oid": "bb99e00da43170fd80dc9cde4bb16a13d97d5973", "url": "https://github.com/uyuni-project/uyuni/commit/bb99e00da43170fd80dc9cde4bb16a13d97d5973", "message": "after rebase fixes", "committedDate": "2020-04-16T23:01:38Z", "type": "forcePushed"}, {"oid": "2551d373d6c57c1850bebb37faa89ed372914c76", "url": "https://github.com/uyuni-project/uyuni/commit/2551d373d6c57c1850bebb37faa89ed372914c76", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas", "committedDate": "2020-04-29T14:12:05Z", "type": "forcePushed"}, {"oid": "4db1c989ea9cc5f0ada3f2b81732a0eb9025ce9b", "url": "https://github.com/uyuni-project/uyuni/commit/4db1c989ea9cc5f0ada3f2b81732a0eb9025ce9b", "message": "cluster UI improvements\n\n- renamed import to add\n- changed last step of add flow to add without scheduling action\n- initial boilerplate code for saving cluster formulas", "committedDate": "2020-05-05T19:55:30Z", "type": "forcePushed"}, {"oid": "08662a9241cf3932b942cfdbc9f9003b58d422dd", "url": "https://github.com/uyuni-project/uyuni/commit/08662a9241cf3932b942cfdbc9f9003b58d422dd", "message": "show cluster provider name in overview page", "committedDate": "2020-05-11T10:40:23Z", "type": "forcePushed"}, {"oid": "de73030bafc18fee3f6c706c06b05535534e3c7a", "url": "https://github.com/uyuni-project/uyuni/commit/de73030bafc18fee3f6c706c06b05535534e3c7a", "message": "Fix: match parameters with the example", "committedDate": "2020-05-14T15:34:57Z", "type": "forcePushed"}, {"oid": "7b3fe7a032e4914cf65464d93625b14762937fcd", "url": "https://github.com/uyuni-project/uyuni/commit/7b3fe7a032e4914cf65464d93625b14762937fcd", "message": "Use toast messages container component in cluster UI", "committedDate": "2020-05-22T11:34:36Z", "type": "forcePushed"}, {"oid": "ba4ca73b0e675ab1f486463244aa73f53c389967", "url": "https://github.com/uyuni-project/uyuni/commit/ba4ca73b0e675ab1f486463244aa73f53c389967", "message": "make commons-jexl a build dep", "committedDate": "2020-05-24T12:49:38Z", "type": "forcePushed"}, {"oid": "fa455aaf3d257a380ba9f5e96a740afd61d6884a", "url": "https://github.com/uyuni-project/uyuni/commit/fa455aaf3d257a380ba9f5e96a740afd61d6884a", "message": "Checkstyle fixes and java code cleanup", "committedDate": "2020-05-26T14:28:19Z", "type": "forcePushed"}, {"oid": "f9fb103dbc9572f9e0cabfd1287bfbbf383dacc8", "url": "https://github.com/uyuni-project/uyuni/commit/f9fb103dbc9572f9e0cabfd1287bfbbf383dacc8", "message": "Feat: add/remove nodes with the API", "committedDate": "2020-05-27T08:31:09Z", "type": "forcePushed"}, {"oid": "cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "url": "https://github.com/uyuni-project/uyuni/commit/cfc0b7a079bf081bc5428733e8e8c9bb8d9440c6", "message": "Chore: announce changes", "committedDate": "2020-05-28T13:01:27Z", "type": "forcePushed"}, {"oid": "4e5610b65d50ab7a08c47a4a559e8893f41a7722", "url": "https://github.com/uyuni-project/uyuni/commit/4e5610b65d50ab7a08c47a4a559e8893f41a7722", "message": "Chore: announce changes", "committedDate": "2020-05-28T13:19:42Z", "type": "forcePushed"}, {"oid": "e2f035917738aa5d6b7d8c392150bd369f8914d1", "url": "https://github.com/uyuni-project/uyuni/commit/e2f035917738aa5d6b7d8c392150bd369f8914d1", "message": "Chore: announce changes", "committedDate": "2020-05-28T13:53:02Z", "type": "forcePushed"}, {"oid": "3a2026737073af00b3f3715298f9418626a7df89", "url": "https://github.com/uyuni-project/uyuni/commit/3a2026737073af00b3f3715298f9418626a7df89", "message": "Chore: announce changes", "committedDate": "2020-05-28T14:37:07Z", "type": "forcePushed"}, {"oid": "10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "url": "https://github.com/uyuni-project/uyuni/commit/10d9a3a7b7f1a41c578fbd98fd0498e5f14ba7d1", "message": "Fix: avoid route clashing", "committedDate": "2020-05-28T20:04:47Z", "type": "forcePushed"}, {"oid": "137451134b0f6cbd4a6db28b69fda1f8fffcefb0", "url": "https://github.com/uyuni-project/uyuni/commit/137451134b0f6cbd4a6db28b69fda1f8fffcefb0", "message": "Fix: avoid route clashing", "committedDate": "2020-05-28T20:39:16Z", "type": "forcePushed"}, {"oid": "01c05ac3bc5de21e6381fa00aaa0656d65a11ec6", "url": "https://github.com/uyuni-project/uyuni/commit/01c05ac3bc5de21e6381fa00aaa0656d65a11ec6", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a.", "committedDate": "2020-05-29T10:51:13Z", "type": "forcePushed"}, {"oid": "019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "url": "https://github.com/uyuni-project/uyuni/commit/019e1e09be3230456b7ddb29d3e75aad08cb3fb0", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a.", "committedDate": "2020-05-29T13:46:01Z", "type": "forcePushed"}, {"oid": "e0ae30e884c22ca8cb73a774d3b17a50ed2edf98", "url": "https://github.com/uyuni-project/uyuni/commit/e0ae30e884c22ca8cb73a774d3b17a50ed2edf98", "message": "Revert \"Feat: backend: XMLRPC for clusters\"\n\nThis reverts commit a53ffd7af7275b3d2b0589ea02cac5dccc67b30a.", "committedDate": "2020-05-29T14:15:50Z", "type": "forcePushed"}, {"oid": "9217e3b9fc719f7cd00d7427537089d49bb4e3fa", "url": "https://github.com/uyuni-project/uyuni/commit/9217e3b9fc719f7cd00d7427537089d49bb4e3fa", "message": "jslint fixes", "committedDate": "2020-05-29T15:44:33Z", "type": "forcePushed"}, {"oid": "49df912ae34148fe3bbf011ecb3fab0d2f195a09", "url": "https://github.com/uyuni-project/uyuni/commit/49df912ae34148fe3bbf011ecb3fab0d2f195a09", "message": "upgrade cluster fixes", "committedDate": "2020-06-01T15:09:12Z", "type": "forcePushed"}, {"oid": "fa654dc663f88179d84fb24e9879c79deb6c39e2", "url": "https://github.com/uyuni-project/uyuni/commit/fa654dc663f88179d84fb24e9879c79deb6c39e2", "message": "package build files for caasp formulas", "committedDate": "2020-06-02T16:05:02Z", "type": "forcePushed"}, {"oid": "61f09c325da2f7f960d930d9b16526f575a32431", "url": "https://github.com/uyuni-project/uyuni/commit/61f09c325da2f7f960d930d9b16526f575a32431", "message": "Chore: announce changes", "committedDate": "2020-06-03T15:48:46Z", "type": "forcePushed"}, {"oid": "a7225fa3241441601f57f1f6a4ac7b81489fb639", "url": "https://github.com/uyuni-project/uyuni/commit/a7225fa3241441601f57f1f6a4ac7b81489fb639", "message": "Chore: announce changes", "committedDate": "2020-06-03T15:54:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4Mzk5Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434483996", "bodyText": "We need to add all cluster related subdirectories with .withAltUrl() or .withDir() to any of these children so the active menu item and the breadcrumbs are displayed correctly with all pages.\n.withVisibility() can also be appended to hide the section for non-admins, if that's what we want.", "author": "cbbayburt", "createdAt": "2020-06-03T11:00:44Z", "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "diffHunk": "@@ -169,6 +170,11 @@\n                     .withDir(\"/rhn/manager/vhms\")\n                     .withVisibility(adminRoles.get(\"org\"))));\n \n+            // Clusters\n+            nodes.add(new MenuItem(\"clusters.nav.title\").withIcon(\"spacewalk-icon-clusters\")\n+                    .addChild(new MenuItem(\"clusters.nav.overview\").withPrimaryUrl(\"/rhn/manager/clusters\"))\n+                    .addChild(new MenuItem(\"clusters.nav.add\").withPrimaryUrl(\"/rhn/manager/clusters/add\")));", "originalCommit": "c21e07c3459702a055618719665ef92abe6fc526", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584662", "bodyText": "I think this method shouldn't be static", "author": "cbbayburt", "createdAt": "2020-06-03T13:53:57Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {", "originalCommit": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MjYzNw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435772637", "bodyText": "Why? It should return the list of all installed clustd providers known to Uyuni/SUSE Manager, so it should not be tied to any cluster.", "author": "mbologna", "createdAt": "2020-06-05T08:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMjE2Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435832163", "bodyText": "My thought was that it's still called from the instance, but anyway it's not dependent on any class members, so ok, I guess either way is fine.\n\n  \n    \n      uyuni/java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java\n    \n    \n        Lines 702 to 708\n      in\n      af48d2b\n    \n    \n    \n    \n\n        \n          \n           private static ClusterProvider getClusterProvider(String label) { \n        \n\n        \n          \n               Optional<ClusterProvider> provider = clusterManager.findClusterProvider(label); \n        \n\n        \n          \n               if (provider.isEmpty()) { \n        \n\n        \n          \n                   halt(HttpStatus.SC_NOT_FOUND, \"Provider \" + label + \" not found\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return provider.get(); \n        \n\n        \n          \n           }", "author": "cbbayburt", "createdAt": "2020-06-05T10:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDk3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434584977", "bodyText": "Also, shouldn't be static", "author": "cbbayburt", "createdAt": "2020-06-03T13:54:24Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {", "originalCommit": "d64b9dbb951e5011a3a6331f4535014ffff0a4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc3MzE1Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435773153", "bodyText": "Can you please detail the reason?", "author": "mbologna", "createdAt": "2020-06-05T08:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NDYxMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434594611", "bodyText": "Question: are transactions not auto-committed with save()?", "author": "cbbayburt", "createdAt": "2020-06-03T14:07:15Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();", "originalCommit": "19df63f9966f029850eb336b8df98fb1901febc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwNDcxOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434604719", "bodyText": "Thinking out loud: I think we'll have to break up this class according to different logical domains at some point.", "author": "cbbayburt", "createdAt": "2020-06-03T14:20:34Z", "path": "java/code/src/com/suse/manager/webui/services/impl/SaltService.java", "diffHunk": "@@ -1172,6 +1206,20 @@ private void changeGroupAndPerms(Path dir, GroupPrincipal group) {\n         ).map(s -> s.getContainers());\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Optional<Map<String, Map<String, Object>>> listClusterNodes(\n+            MinionServer managementNode, ClusterProviderParameters clusterProviderParameters) {\n+        Map<String, Object> pillar = new HashMap<>();\n+        pillar.put(\"cluster_type\", clusterProviderParameters.getClusterProvider());\n+        clusterProviderParameters.getClusterParams().ifPresent(cpp -> pillar.put(\"params\", cpp));\n+        return callSync(State.apply(Arrays.asList(\"clusters.listnodes\"), Optional.of(pillar),\n+                Optional.of(true), Optional.empty(), ClusterOperationsSlsResult.class),\n+                managementNode.getMinionId()).map(ret -> ret.listNodesResult().getChanges().getRet());\n+    }\n+", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg3OTY4OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435879689", "bodyText": "Dully noted.", "author": "mateiw", "createdAt": "2020-06-05T12:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwNDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTk0MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434615941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n          \n          \n            \n                    if (!allMatch) {\n          \n          \n            \n                    if (!clusterNodeHostnames.containsAll(nodes)) {", "author": "cbbayburt", "createdAt": "2020-06-03T14:35:12Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NTcwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436155706", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDUzOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434624539", "bodyText": "Another nested class like AddClusterRequest would be useful here", "author": "cbbayburt", "createdAt": "2020-06-03T14:47:01Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODM0Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435398347", "bodyText": "done", "author": "mateiw", "createdAt": "2020-06-04T16:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyNDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDcxOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434634719", "bodyText": "Heads up: It might be a potential performance issue to use this query in a loop", "author": "cbbayburt", "createdAt": "2020-06-03T15:00:37Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg4MDkyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435880925", "bodyText": "The number of management nodes is going to be quit small probably. For now I think we'll keep it like this.", "author": "mateiw", "createdAt": "2020-06-05T12:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjAxOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642019", "bodyText": "I guess the message here is wrong", "author": "cbbayburt", "createdAt": "2020-06-03T15:10:30Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MDcwNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435790704", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T09:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjYwMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434642600", "bodyText": "We must take the user org into account too", "author": "cbbayburt", "createdAt": "2020-06-03T15:11:17Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));\n+        return json(response, ResultJson.success());\n+    }\n+\n+    public static class ModifyNodesRequest extends ScheduledRequestJson {\n+        private List<Long> serverIds;\n+        private Map<String, Object> formula;\n+\n+        /**\n+         * @return serverId to get\n+         */\n+        public List<Long> getServerIds() {\n+            return serverIds;\n+        }\n+\n+        /**\n+         * @return joinConfig to get\n+         */\n+        public Map<String, Object> getFormula() {\n+            return formula;\n+        }\n+\n+    }\n+\n+    private static Object joinNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_JOIN_NODE, request, response, user);\n+    }\n+\n+    private static Object removeNode(Request request, Response response, User user) {\n+        return modifyClusterNodes(ActionFactory.TYPE_CLUSTER_REMOVE_NODE, request, response, user);\n+    }\n+\n+    private static Object upgradeCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(ActionFactory.TYPE_CLUSTER_UPGRADE_CLUSTER,\n+                    cluster, Collections.emptyList(),\n+                    new HashMap<>(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling cluster upgrade failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Object modifyClusterNodes(ActionType actionType, Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        ModifyNodesRequest nodesRequest;\n+        try {\n+            nodesRequest = GSON.fromJson(request.body(), ModifyNodesRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error());\n+        }\n+        Date scheduleDate = MinionActionUtils.getScheduleDate(nodesRequest.getEarliest());\n+        long actionId;\n+        try {\n+            actionId = clusterManager.modifyClusterNodes(actionType,\n+                    cluster, nodesRequest.getServerIds(),\n+                    nodesRequest.getFormula(), scheduleDate, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling join or remove node to cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(\"Internal error \" + e.getClass()));\n+        }\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Optional<Map<String, Object>> parseJson(Request request, Response response) {\n+        Map<String, Object> jsonRequest;\n+        try {\n+            jsonRequest = GSON.fromJson(request.body(), new TypeToken<Map<String, Object>>() {\n+            }.getType());\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing JSON body\", e);\n+            return Optional.empty();\n+        }\n+        return Optional.ofNullable(jsonRequest);\n+    }\n+\n+    private static String providerManagementNodes(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        // TODO validate provider\n+        List<String> minionIds = clusterManager.findManagementNodeByProvider(provider);\n+        List<ServerResponse> data = minionIds.stream()\n+                .map(minionId -> MinionServerFactory.findByMinionId(minionId))\n+                .filter(minion -> minion.isPresent())\n+                .map(minion -> minion.get())\n+                .map(ResponseMappers::toServerResponse)\n+                .collect(Collectors.toList());\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static ModelAndView showAddCluster(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterProviderResponse> types =\n+                clusterManager.findClusterProviders().stream()\n+                        .map(ResponseMappers::toClusterProviderResponse)\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentAdd\", GSON.toJson(types));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/add.jade\");\n+    }\n+\n+    private static Object listNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        Optional<List<String>> fields = clusterManager.getNodesListFields(cluster.getProvider());\n+        data.put(\"fields\", fields.orElse(Collections.emptyList()));\n+        List<ClusterNodeResponse> nodes = clusterManager.listClusterNodes(cluster)\n+                .stream().map(node -> toClusterNodeResponse(node, fields))\n+                .collect(Collectors.toList());\n+        data.put(\"nodes\", nodes);\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    private static Object listNodesToJoin(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        var servers = clusterManager.getNodesAvailableForJoining(cluster, user);\n+        List<ServerResponse> data = servers.entrySet().stream()\n+                .map(entry -> toServerResponse(entry.getKey(), Optional.ofNullable(entry.getValue())))\n+                .collect(Collectors.toList());\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Show list of clusters.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showList(Request request, Response response, User user) {\n+        Map<String, Object> data = new HashMap<>();\n+        List<ClusterResponse> clusters =\n+                ClusterFactory.findClustersByOrg(user.getOrg().getId()).stream()\n+                        .map(cluster -> toClusterResponse(cluster,\n+                                getClusterProvider(cluster.getProvider())))\n+                        .collect(Collectors.toList());\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentClusters\", GSON.toJson(clusters));\n+        return new ModelAndView(data, \"controllers/clusters/templates/list.jade\");\n+    }\n+\n+    /**\n+     * Show cluster details.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return ModelAndView for page\n+     */\n+    public static ModelAndView showCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\",\n+                GSON.toJson(toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        return new ModelAndView(data, \"controllers/clusters/templates/cluster.jade\");\n+    }\n+\n+    /**\n+     * Get cluster formula form.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String providerFormulaForm(Request request, Response response, User user) {\n+        String provider = request.params(\"provider\");\n+        String formula = request.params(\"formula\");\n+\n+        // TODO assert parameters not empty and valid\n+        // TODO validate provider\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"form\",\n+                FormulaFactory.getClusterProviderFormulaLayout(provider, formula)\n+                        .orElseGet(Collections::emptyMap));\n+\n+        Optional<Map<String, Object>> bodyJson = parseJson(request, response);\n+        if (bodyJson.isPresent()) {\n+            Map<String, Object> initialData = clusterManager.initialFormulaData(provider, formula, bodyJson.get());\n+            data.put(\"params\", initialData);\n+        }\n+\n+        return json(response, ResultJson.success(data));\n+    }\n+\n+    /**\n+     * Get cluster formula data.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the formula form as Json\n+     */\n+    public static String getFormulaData(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        Optional<Map<String, Object>> data = FormulaManager.getInstance().getClusterFormulaData(cluster, formula);\n+        return json(response, ResultJson.success(data.orElse(Collections.emptyMap())));\n+    }\n+\n+    /**\n+     * Schedules refreshing the system group of a cluster.\n+     * @param request http request\n+     * @param response http response\n+     * @param user the user\n+     * @return the outcome as Json\n+     */\n+    public static String refreshGroupNodes(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        long actionId;\n+        try {\n+            actionId = clusterManager.refreshGroup(cluster, user).getId();\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Scheduling remove node from cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Scheduled action to remove the node from the cluster\");\n+        return json(response, ResultJson.success(actionId));\n+    }\n+\n+    private static Long getId(Request request) {\n+        String idStr = request.params(\"id\");\n+        Long id = null;\n+        try {\n+            id = Long.parseLong(idStr);\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Id '\" + idStr + \"' is not a number.\");\n+            halt(HttpStatus.SC_BAD_REQUEST, \"id is not a number\");\n+        }\n+        return id;\n+    }\n+\n+    private static Cluster getCluster(Request request) {\n+        Long id = getId(request);\n+        Optional<Cluster> cluster = ClusterFactory.findClusterById(id);", "originalCommit": "8ceba6525f6d0bb8aa20908885320c7939a26dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM5ODg0Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435398842", "bodyText": "done", "author": "mateiw", "createdAt": "2020-06-04T16:41:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MjYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Mzg4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434653881", "bodyText": "To unify the messages with delete:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been added successfully\", name));", "author": "cbbayburt", "createdAt": "2020-06-03T15:26:32Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");", "originalCommit": "19df63f9966f029850eb336b8df98fb1901febc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MTIzMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435791233", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T09:09:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Mzg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDEwOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434654109", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));\n          \n          \n            \n                    FlashScopeHelper.flash(request, String.format(\"Cluster '%s' has been deleted successfully\", cluster.getName()));", "author": "cbbayburt", "createdAt": "2020-06-03T15:26:49Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        get(\"/manager/cluster/:id/remove/:node\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        String node = request.params(\"node\"); // minion id\n+\n+        Optional<ClusterNode> toRemove = clusterManager.listClusterNodes(cluster)\n+                .stream().filter(n -> node.equals(n.getHostname()))\n+                .findFirst();\n+        if (toRemove.isEmpty()) {\n+            LOG.error(\"Node to remove '\" + node + \"' is not part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"node\", GSON.toJson(node));\n+        data.put(\"serverId\", GSON.toJson(toRemove\n+                .flatMap(n -> n.getServer())\n+                .map(s -> s.getId())\n+                .orElse(null)));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s'deleted successfully\", cluster.getName()));", "originalCommit": "19df63f9966f029850eb336b8df98fb1901febc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5MjAyNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435792024", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T09:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1NDEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1Njk2OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r434656968", "bodyText": "In the controller, some of the endpoint methods are public and some are private. I wouldn't mind either way but it's better if they all are the same.\nAlso, the checkstyle wouldn't complain about the private ones, but we could use some javadocs for all of the endpoint methods anyway.", "author": "cbbayburt", "createdAt": "2020-06-03T15:30:29Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,598 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterNode;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {", "originalCommit": "19df63f9966f029850eb336b8df98fb1901febc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ0Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435332443", "bodyText": "This applies to all usages of the flash scope:\nThese messages should be shown as \"success\" (green) instead of \"info\" (blue).\nWe can push MessageResponse objects to the scope instead. Otherwise, we have only one type of message that is interpreted as info on the frontend.\nInstead, we should deserialize the message objects with the types, and render them with toastr, etc. accordingly.", "author": "cbbayburt", "createdAt": "2020-06-04T15:07:47Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -0,0 +1,595 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.reflect.TypeToken;\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.suse.manager.clusters.ClusterFactory;\n+import com.suse.manager.clusters.ClusterManager;\n+import com.suse.manager.clusters.ClusterProvider;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.webui.controllers.MinionController;\n+import com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterNodeResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterProviderResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ClusterResponse;\n+import com.suse.manager.webui.controllers.clusters.response.ServerResponse;\n+import com.suse.manager.webui.utils.FlashScopeHelper;\n+import com.suse.manager.webui.utils.MinionActionUtils;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import com.suse.manager.webui.utils.gson.ScheduledRequestJson;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.http.HttpStatus;\n+import org.apache.log4j.Logger;\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterNodeResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toClusterResponse;\n+import static com.suse.manager.webui.controllers.clusters.mappers.ResponseMappers.toServerResponse;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withOrgAdmin;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withRolesTemplate;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.halt;\n+import static spark.Spark.post;\n+\n+/**\n+ * Controller for clusters UI.\n+ */\n+public class ClustersController {\n+\n+    private static final Logger LOG = Logger.getLogger(ClustersController.class);\n+\n+    private static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+    private static ClusterManager clusterManager = ClusterManager.instance();\n+\n+    private ClustersController() { }\n+\n+    /**\n+     * Called from Router. Initializes Spark routes.\n+     * @param jade the Jade engine to use to render the pages\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/clusters\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showList))), jade);\n+        get(\"/manager/clusters/add\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showAddCluster))), jade);\n+        get(\"/manager/cluster/:id\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showCluster))), jade);\n+        get(\"/manager/cluster/:id/join\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showJoinCluster))), jade);\n+        post(\"/manager/cluster/:id/remove\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showRemoveNode))), jade);\n+        get(\"/manager/cluster/:id/upgrade\",\n+                withCsrfToken(withUserPreferences(withRolesTemplate(ClustersController::showClusterUpgrade))), jade);\n+\n+        get(\"/manager/api/cluster/:id/nodes\",\n+                withUser(ClustersController::listNodes));\n+        get(\"/manager/api/cluster/:id/nodes-to-join\",\n+                withUser(ClustersController::listNodesToJoin));\n+        post(\"/manager/api/cluster/:id/refresh-group-nodes\",\n+                withUser(ClustersController::refreshGroupNodes));\n+        get(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::getFormulaData));\n+        post(\"/manager/api/cluster/:id/formula/:formula/data\",\n+                withUser(ClustersController::saveFormulaData));\n+        post(\"/manager/api/cluster/:id/join\",\n+                withOrgAdmin(ClustersController::joinNode));\n+        post(\"/manager/api/cluster/:id/remove-node\",\n+                withOrgAdmin(ClustersController::removeNode));\n+        post(\"/manager/api/cluster/:id/upgrade\",\n+                withOrgAdmin(ClustersController::upgradeCluster));\n+        get(\"/manager/api/cluster/:id\",\n+                withUser(ClustersController::getClusterProps));\n+        post(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::updateCluster));\n+        delete(\"/manager/api/cluster/:id\",\n+                withOrgAdmin(ClustersController::deleteCluster));\n+\n+        post(\"/manager/api/cluster/provider/:provider/formula/:formula/form\",\n+                withUser(ClustersController::providerFormulaForm));\n+        get(\"/manager/api/cluster/provider/:provider/management-nodes\",\n+                withUser(ClustersController::providerManagementNodes));\n+\n+        post(\"/manager/api/cluster/new/add\",\n+                withOrgAdmin(ClustersController::addCluster));\n+\n+    }\n+\n+    private static Object getClusterProps(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        return json(response,\n+                ResultJson.success(toClusterResponse(cluster,\n+                        getClusterProvider(cluster.getProvider()))));\n+\n+    }\n+\n+    private static class UpdateClusterRequest {\n+        private String name;\n+        private String description;\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+    }\n+\n+    private static Object updateCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        UpdateClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), UpdateClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+        // TODO validate name, description\n+        try {\n+            clusterManager.update(cluster, clusterRequest.getName(), clusterRequest.getDescription());\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Updating cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showRemoveNode(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        List<String> nodes = Arrays.asList(request.queryParamsValues(\"nodes\"));\n+\n+        var clusterNodes = clusterManager.listClusterNodes(cluster);\n+        var clusterNodeHostnames = clusterNodes.stream()\n+                .map(n -> n.getHostname())\n+                .collect(Collectors.toList());\n+        var allMatch = nodes.stream().allMatch(n -> clusterNodeHostnames.contains(n));\n+        if (!allMatch) {\n+            LOG.error(\"Not all nodes '\" + nodes + \"' are part of the cluster\");\n+            halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        var nodesToRemove = clusterNodes.stream()\n+                .filter(cn -> nodes.contains(cn.getHostname()))\n+                .collect(Collectors.toList());\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        data.put(\"nodes\", GSON.toJson(nodesToRemove.stream()\n+                .map(n -> toClusterNodeResponse(n, Optional.empty())).collect(Collectors.toList())));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/remove-node.jade\");\n+\n+    }\n+\n+    private static Object saveFormulaData(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> formulaData = parseJson(request, response);\n+        if (formulaData.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+        Cluster cluster = getCluster(request);\n+\n+        String formula = request.params(\"formula\");\n+        if (StringUtils.isBlank(formula)) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Formula parameter is empty\"));\n+        }\n+        try {\n+            clusterManager.saveFormulaData(cluster, formula, formulaData.get(), user);\n+        }\n+        catch (PermissionException | LookupException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_FORBIDDEN,\n+                    ResultJson.error(\"No permission to save formula\"));\n+        }\n+        catch (IOException | RuntimeException e) {\n+            LOG.error(\"Error saving formula\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR,\n+                    ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Saved successfully\");\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static ModelAndView showJoinCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/join.jade\");\n+    }\n+\n+    private static ModelAndView showClusterUpgrade(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"flashMessage\", FlashScopeHelper.flash(request));\n+        data.put(\"contentCluster\", GSON.toJson(\n+                toClusterResponse(cluster, getClusterProvider(cluster.getProvider()))));\n+        MinionController.addActionChains(user, data);\n+        return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n+    }\n+\n+    private static String addCluster(Request request, Response response, User user) {\n+        Optional<Map<String, Object>> json = parseJson(request, response);\n+        if (json.isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"request_error\"));\n+        }\n+\n+        // TODO validate input\n+        String name = (String)json.get().get(\"name\");\n+        String label = (String)json.get().get(\"label\");\n+        String description = (String)json.get().get(\"description\");\n+        String provider = (String)json.get().get(\"provider\");\n+        long managementNodeId = ((Number)json.get().get(\"managementNodeId\")).longValue();\n+        Map<String, Object> managementSettings = (Map<String, Object>)json.get().get(\"managementSettings\");\n+        Cluster cluster;\n+        try {\n+            cluster = clusterManager.addCluster(name, label, description,\n+                    managementNodeId, provider, managementSettings, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Adding cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, \"Cluster has been added successfully\");\n+        return json(response, ResultJson.success(cluster.getId()));\n+    }\n+\n+    private static Object deleteCluster(Request request, Response response, User user) {\n+        Cluster cluster = getCluster(request);\n+\n+        try {\n+            clusterManager.deleteCluster(cluster, user);\n+            HibernateFactory.getSession().getTransaction().commit();\n+        }\n+        catch (Exception e) {\n+            LOG.error(\"Deleting cluster failed\", e);\n+            return json(response, HttpStatus.SC_INTERNAL_SERVER_ERROR, ResultJson.error(e.getMessage()));\n+        }\n+        FlashScopeHelper.flash(request, String.format(\"Cluster '%s' deleted successfully\", cluster.getName()));", "originalCommit": "4e03de938b7e3dcdfedd8cc38456e1c39898d0d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTQzMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435861431", "bodyText": "Good point. Will address this in the next iterations.", "author": "mateiw", "createdAt": "2020-06-05T11:32:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMjQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4Mjg4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435482885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 /**\n          \n          \n            \n                /**", "author": "cbbayburt", "createdAt": "2020-06-04T18:56:53Z", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -446,7 +453,7 @@ else if (layoutFileCustom.exists()) {\n         }\n     }\n \n-    /**\n+     /**", "originalCommit": "ab08f8e591253ab09ff397ac46e4f2ed31d2acef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NTQ5NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435795494", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T09:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ4Mjg4NQ=="}], "type": "inlineReview"}, {"oid": "e246b839a56e58e6409c3553234ca3a0ce59b5c9", "url": "https://github.com/uyuni-project/uyuni/commit/e246b839a56e58e6409c3553234ca3a0ce59b5c9", "message": "Chore: announce changes", "committedDate": "2020-06-05T08:59:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1NA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435852354", "bodyText": "Can be exported into a separate method", "author": "cbbayburt", "createdAt": "2020-06-05T11:10:51Z", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -499,8 +506,40 @@ else if (layoutFileCustom.exists()) {\n                 groupId + \"_\" + name + \".\" + PILLAR_FILE_EXTENSION);\n         try {\n             if (dataFile.exists()) {\n-                return Optional.of((Map<String, Object>) GSON.fromJson(\n-                        new BufferedReader(new FileReader(dataFile)), Map.class));\n+                Map<String, Object> data = (Map<String, Object>) GSON.fromJson(\n+                        new BufferedReader(new FileReader(dataFile)), Map.class);\n+\n+                if (formulaHasType(name, \"cluster-formula\")) {\n+                    // find cluster for this group\n+                    Optional<Cluster> cluster = ClusterFactory.findClusterByGroupId(groupId);\n+                    if (cluster.isPresent()) {\n+                        // load cluster provider metadata and look for the key of this formula\n+                        Map<String, Object> metadata = getClusterProviderMetadata(cluster.get().getProvider());\n+                        Map<String, Object> formulas = (Map<String, Object>) metadata.get(\"formulas\");\n+                        Optional<String> formulaKey = formulas.entrySet().stream()\n+                                .filter(e -> e.getValue() instanceof Map)\n+                                .filter(e -> ((Map) e.getValue()).get(\"name\").equals(name))\n+                                .map(e -> e.getKey())\n+                                .findFirst();\n+                        if (formulaKey.isPresent()) {\n+                            // return values under mgr_clusters:<cluster-name>:<formula-key>\n+                            return getValueByPath(data,\n+                                    \"mgr_clusters:\" + cluster.get().getLabel() + \":\" + formulaKey.get())\n+                                    .filter(Map.class::isInstance)\n+                                    .map(Map.class::cast);\n+                        }\n+                        else {\n+                            return Optional.empty();\n+                        }\n+                    }\n+                    else {\n+                        return Optional.empty();\n+                    }", "originalCommit": "9bef3086ed1232b6f6343df22ec53ad91f189ba2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTcxMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436079713", "bodyText": "done", "author": "mateiw", "createdAt": "2020-06-05T18:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1MjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDE5OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435854199", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param keyType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(keyType::isInstance)\n          \n          \n            \n                            .map(keyType::cast);\n          \n          \n            \n                 * @param valueType the Java type of the value\n          \n          \n            \n                 * @param <T> the Java type of the value\n          \n          \n            \n                 * @return the value of the metadata key\n          \n          \n            \n                 */\n          \n          \n            \n                public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> valueType) {\n          \n          \n            \n                    Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n          \n          \n            \n                    return FormulaFactory.getValueByPath(metadata, key)\n          \n          \n            \n                            .filter(valueType::isInstance)\n          \n          \n            \n                            .map(valueType::cast);", "author": "cbbayburt", "createdAt": "2020-06-05T11:15:05Z", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);", "originalCommit": "9bef3086ed1232b6f6343df22ec53ad91f189ba2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3OTY3Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436079673", "bodyText": "done", "author": "mateiw", "createdAt": "2020-06-05T18:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjMwOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435856308", "bodyText": "Does it make sense to continue execution in this case? Otherwise maybe just throw a RuntimeException?", "author": "cbbayburt", "createdAt": "2020-06-05T11:20:11Z", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();", "originalCommit": "9bef3086ed1232b6f6343df22ec53ad91f189ba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NzE3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435857177", "bodyText": "Also here, maybe throw a RuntimeException so it propagates to the UI?", "author": "cbbayburt", "createdAt": "2020-06-05T11:22:22Z", "path": "java/code/src/com/redhat/rhn/domain/formula/FormulaFactory.java", "diffHunk": "@@ -888,4 +944,165 @@ private static boolean hasMonitoringDataEnabled(Map<String, Object> formData) {\n         return (boolean) nodeExporter.get(\"enabled\") || (boolean) apacheExporter.get(\"enabled\") ||\n                 (boolean) postgresExporter.get(\"enabled\");\n     }\n+\n+    /**\n+     * Returns the metadata of a cluster provider.\n+     * @param provider the name of the formula\n+     * @return the metadata\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static Map<String, Object> getClusterProviderMetadata(String provider) {\n+        // TODO cache metadata ?\n+        String metadataFilePath = provider + File.separator + METADATA_FILE;\n+        File metadataFileStandalone = new File(METADATA_DIR_CLUSTER_PROVIDERS + metadataFilePath);\n+        try {\n+            if (metadataFileStandalone.isFile()) {\n+                return (Map<String, Object>) YAML.load(new FileInputStream(metadataFileStandalone));\n+            }\n+            else {\n+                return Collections.emptyMap();\n+            }\n+        }\n+        catch (IOException e) {\n+            return Collections.emptyMap();\n+        }\n+    }\n+\n+    /**\n+     * Get a value from the cluster provider metadata.\n+     * @param provider the name of the cluster provider\n+     * @param key the key of the value\n+     * @param keyType the Java type of the value\n+     * @param <T> the Java type of the value\n+     * @return the value of the metadata key\n+     */\n+    public static <T> Optional<T> getClusterProviderMetadata(String provider, String key, Class<T> keyType) {\n+        Map<String, Object> metadata = FormulaFactory.getClusterProviderMetadata(provider);\n+        return FormulaFactory.getValueByPath(metadata, key)\n+                .filter(keyType::isInstance)\n+                .map(keyType::cast);\n+    }\n+\n+    /**\n+     * Get a formula layout from a cluster provider. The formula is referenced by its key not by it's actual name.\n+     * @param provider the name of the cluster provider\n+     * @param formulaKey the key of the formula used by the provider\n+     * @return the formula layout as a Map\n+     */\n+    public static Optional<Map<String, Object>> getClusterProviderFormulaLayout(String provider, String formulaKey) {\n+        Map<String, Object> metadata = getClusterProviderMetadata(provider);\n+        Optional<String> formulaName = getValueByPath(metadata, \"formulas:\" + formulaKey + \":name\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast);\n+\n+        String formulaSource = getValueByPath(metadata, \"formulas:\" + formulaKey + \":source\")\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .orElse(\"system\");\n+\n+        if (formulaName.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (\"system\".equals(formulaSource)) {\n+            return getFormulaLayoutByName(formulaName.get());\n+        }\n+        else if (\"cluster-provider\".equals(formulaSource)) {\n+            return getFormulaLayoutByClusterProviderAndName(provider, formulaName.get());\n+        }\n+        else {\n+            throw new RuntimeException(\"Unknown formula source \" + formulaSource);\n+        }\n+    }\n+\n+    private static Optional<Map<String, Object>> getFormulaLayoutByClusterProviderAndName(String provider,\n+                                                                                          String name) {\n+        Path layoutFile = Paths.get(METADATA_DIR_CLUSTER_PROVIDERS, provider, name + \".yml\");\n+        try {\n+            if (Files.exists(layoutFile)) {\n+                return Optional.of((Map<String, Object>) YAML.load(new FileInputStream(layoutFile.toFile())));\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        catch (FileNotFoundException | YAMLException e) {\n+            LOG.error(\"Error loading layout for formula '\" + name +\n+                    \"' from cluster provider '\" + provider + \"'\", e);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    /**\n+     * Checks the type of the formula.\n+     * @param formula the name of the formula\n+     * @param type the type\n+     * @return whether the formula has the given type or not\n+     */\n+    public static boolean formulaHasType(String formula, String type) {\n+        Map<String, Object> metadata = getMetadata(formula);\n+        return Optional.ofNullable(metadata.get(\"type\"))\n+                .filter(String.class::isInstance)\n+                .map(String.class::cast)\n+                .map(t -> t.equals(type))\n+                .orElse(false);\n+    }\n+\n+\n+    /**\n+     * Get the value from a nested map structure by a colon separated path.\n+     * E.g. key1:key2:key3 for a map with a depth of 3.\n+     * @param data the nested map\n+     * @param path the path\n+     * @return a value if available\n+     */\n+    public static Optional<Object> getValueByPath(Map<String, Object> data, String path) {\n+        String[] tokens = StringUtils.split(path, \":\");\n+        Map<String, Object> current = data;\n+        for (int i = 0; i < tokens.length; i++) {\n+            String token = tokens[i];\n+            Object val = current.get(token);\n+            if (i == tokens.length - 1) {\n+                return Optional.ofNullable(val);\n+            }\n+            if (val == null) {\n+                return Optional.empty();\n+            }\n+            if (val instanceof Map) {\n+                current = (Map<String, Object>)val;\n+            }\n+            else {\n+                return Optional.empty();\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers.\n+     * @return a list containing the metadata of all installed cluster providers\n+     */\n+    public static List<Map<String, Object>> getClusterProvidersMetadata() {\n+        Path dir = Path.of(METADATA_DIR_CLUSTER_PROVIDERS);\n+        try {\n+            return Files.list(dir)\n+                    .filter(Files::isDirectory)\n+                    .map(p -> {\n+                        String provider = p.getFileName().toString();\n+                        Map<String, Object> m = getClusterProviderMetadata(provider);\n+                        m = new HashMap<>(m);\n+                        m.put(\"label\", provider);\n+                        return m;\n+                    })\n+                    .collect(Collectors.toList());\n+        }\n+        catch (IOException e) {\n+            LOG.error(\"Error loading providers metadata\", e);\n+            return Collections.emptyList();", "originalCommit": "9bef3086ed1232b6f6343df22ec53ad91f189ba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MTk1Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435891953", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }\n          \n          \n            \n                }", "author": "cbbayburt", "createdAt": "2020-06-05T12:36:12Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0OTYxMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436149613", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MjY3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435892679", "bodyText": "We should use LocalizationService here", "author": "cbbayburt", "createdAt": "2020-06-05T12:37:45Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1NDQyOQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436154429", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5MjY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435894725", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "author": "cbbayburt", "createdAt": "2020-06-05T12:41:40Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTM4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435991386", "bodyText": "Are you referring to refresh group nodes ? It must query the cluster so it can take some time, that's why it's done async.", "author": "mateiw", "createdAt": "2020-06-05T15:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMjQ5MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436002491", "bodyText": "No, I mean:\n\nCreate the server group\nCreate the cluster\nCreate and store the action entry\n\nThese should be all-or-nothing", "author": "cbbayburt", "createdAt": "2020-06-05T15:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NTE4Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435895183", "bodyText": "If possible, the whole thing should be done in a single DB transaction", "author": "cbbayburt", "createdAt": "2020-06-05T12:42:35Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjgzNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435896836", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "author": "cbbayburt", "createdAt": "2020-06-05T12:45:36Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTg1OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436145859", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NjgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NzU4OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435897588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                },\n          \n          \n            \n                                        () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n          \n          \n            \n                                    },\n          \n          \n            \n                                    () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "author": "cbbayburt", "createdAt": "2020-06-05T12:46:59Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0ODY4Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436148687", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5NzU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTk3MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435899970", "bodyText": "It's better the use ClusterFactory.findClusterByIdAndOrg() instead.", "author": "cbbayburt", "createdAt": "2020-06-05T12:51:35Z", "path": "java/code/src/com/suse/manager/clusters/ClusterManager.java", "diffHunk": "@@ -0,0 +1,609 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.clusters;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.redhat.rhn.domain.action.ActionFactory;\n+import com.redhat.rhn.domain.action.ActionType;\n+import com.redhat.rhn.domain.action.cluster.BaseClusterModifyNodesAction;\n+import com.redhat.rhn.domain.action.cluster.ClusterActionCommand;\n+import com.redhat.rhn.domain.action.cluster.ClusterGroupRefreshNodesAction;\n+import com.redhat.rhn.domain.formula.FormulaFactory;\n+import com.redhat.rhn.domain.product.Tuple2;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.server.Server;\n+import com.redhat.rhn.domain.server.ServerFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.formula.FormulaManager;\n+import com.redhat.rhn.manager.formula.FormulaUtil;\n+import com.redhat.rhn.manager.rhnpackage.PackageManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+import com.suse.manager.model.clusters.Cluster;\n+import com.suse.manager.reactor.utils.LocalDateTimeISOAdapter;\n+import com.suse.manager.reactor.utils.OptionalTypeAdapterFactory;\n+import com.suse.manager.reactor.utils.ValueMap;\n+import com.suse.manager.webui.services.iface.SystemQuery;\n+import com.suse.manager.webui.services.impl.SaltService;\n+import com.suse.salt.netapi.datatypes.target.MinionList;\n+import com.suse.utils.Opt;\n+import org.apache.commons.jexl2.Expression;\n+import org.apache.commons.jexl2.JexlContext;\n+import org.apache.commons.jexl2.JexlEngine;\n+import org.apache.commons.jexl2.JexlException;\n+import org.apache.commons.jexl2.MapContext;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import static com.redhat.rhn.common.hibernate.HibernateFactory.getSession;\n+\n+public class ClusterManager {\n+\n+    private static final Logger LOG = Logger.getLogger(ClusterManager.class);\n+\n+    public static final Gson GSON = new GsonBuilder()\n+            .registerTypeAdapter(LocalDateTime.class, new LocalDateTimeISOAdapter())\n+            .registerTypeAdapterFactory(new OptionalTypeAdapterFactory())\n+            .serializeNulls()\n+            .create();\n+\n+\n+    private static volatile ClusterManager instance;\n+    private SystemQuery systemQuery;\n+    private ServerGroupManager serverGroupManager;\n+    private FormulaManager formulaManager;\n+\n+    /**\n+     * @return the instance\n+     */\n+    public static ClusterManager instance() {\n+        if (instance == null) {\n+            synchronized (ClusterManager.class) {\n+                if (instance == null) {\n+                    instance = new ClusterManager();\n+                }\n+            }\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * No arg constructor.\n+     */\n+    public ClusterManager() {\n+        this.systemQuery = SaltService.INSTANCE;\n+        this.serverGroupManager = ServerGroupManager.getInstance();\n+        this.formulaManager = FormulaManager.getInstance();\n+    }\n+\n+    /**\n+     * Get all installed cluster providers\n+     * @return list of cluster providers\n+     */\n+    public static List<ClusterProvider> findClusterProviders() {\n+        List<Map<String, Object>> providers = FormulaFactory.getClusterProvidersMetadata();\n+        return providers.stream().map(m -> {\n+            ClusterProvider p = new ClusterProvider();\n+            ValueMap v = new ValueMap(m);\n+            p.setLabel(v.getValueAsString(\"label\"));\n+            p.setName(v.getValueAsString(\"name\"));\n+            p.setDescription(v.getValueAsString(\"description\"));\n+            return p;\n+        }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Find cluster provider by label.\n+     * @param label the label\n+     * @return a cluster provider\n+     */\n+    public static Optional<ClusterProvider> findClusterProvider(String label) {\n+        return findClusterProviders().stream()\n+                .filter(provider -> label.equals(provider.getLabel()))\n+                .findFirst();\n+    }\n+\n+\n+    /**\n+     * Queries the cluster to get the all the nodes and tries to match\n+     * them with the registered systems.\n+     * @param cluster the cluster\n+     * @return a list of cluster nodes\n+     */\n+    public List<ClusterNode> listClusterNodes(Cluster cluster) {\n+        List<ClusterNode> result = new ArrayList<>();\n+\n+        Optional<Map<String, Object>> settingsFormulaData = formulaManager\n+                .getClusterFormulaData(cluster, \"settings\");\n+        if (settingsFormulaData.isEmpty()) {\n+            throw new RuntimeException(\"No settings data found for cluster \" + cluster.getLabel());\n+        }\n+\n+        ClusterProviderParameters cpp =\n+                new ClusterProviderParameters(cluster.getProvider(), Optional.of(settingsFormulaData.get()));\n+        systemQuery.listClusterNodes(cluster.getManagementNode(), cpp).ifPresent(ret -> {\n+            ret.forEach((k, v) -> result.add(new ClusterNode(k, v)));\n+        });\n+        matchClusterNodes(result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the nodes that can be joined to the given cluster. For each node it checks the preconditions for joining\n+     * a cluster required by the cluster provider.\n+     *\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return a Map with minion as keys and error/warning messages as values\n+     */\n+    public Map<MinionServer, List<Tuple2<String, String>>> getNodesAvailableForJoining(Cluster cluster, User user) {\n+        return MinionServerFactory.lookupVisibleToUser(user)\n+                .filter(server -> !ClusterFactory.listAllManagementNodes().contains(server))\n+                .filter(server -> !ClusterFactory.listAllClustersNodes().contains(server))\n+                .collect(Collectors.toMap(Function.identity(), minion -> checkJoinPreconditions(cluster, minion)));\n+        }\n+\n+    private List<Tuple2<String, String>> checkJoinPreconditions(Cluster cluster, MinionServer minion) {\n+        Optional<List<String>> requiredPackages = FormulaFactory\n+                .getClusterProviderMetadata(cluster.getProvider(), \"channels:required_packages\", List.class)\n+                .map(m -> (List<String>)m);\n+        var msgs = new ArrayList<Tuple2<String, String>>();\n+        requiredPackages.ifPresent(pkgs ->\n+            pkgs.forEach(pkgName -> {\n+                boolean pkgInChannels =\n+                        Optional.ofNullable(PackageManager.lookupEvrIdByPackageName(minion.getId(), pkgName))\n+                        .map(res -> !res.isEmpty())\n+                        .orElse(false);\n+                if (!pkgInChannels) {\n+                    msgs.add(new Tuple2<>(\"warning\", \"Package \" + pkgName + \" not found in subscribed channels\"));\n+                }\n+            })\n+        );\n+        return msgs;\n+    }\n+\n+    /**\n+     * Get the minion that can be used as management nodes for the given provider.\n+     * @param provider the provider\n+     * @return list of minion ids\n+     */\n+    public List<String> findManagementNodeByProvider(String provider) {\n+        Optional<String> value = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"management_node:match\", String.class);\n+        // TODO optimize to match pillar data directly in json files to speed up lookup instead of calling salt\n+        if (value.isEmpty()) {\n+            LOG.error(\"No string value found for path cluster:management_node:match in the '\" +\n+                    provider + \"' cluster provider metadata\");\n+            return Collections.emptyList();\n+        }\n+        String mgmtNodeTarget = value.get();\n+        return systemQuery.matchCompoundSync(mgmtNodeTarget);\n+    }\n+\n+\n+    /**\n+     * Adds an existing cluster to the db, creates a system group for it, adds the management node\n+     * to the group and  schedules a system group refresh to populate the group.\n+     * @param name name of the cluster\n+     * @param label label\n+     * @param description description\n+     * @param managementNodeId managmenet node\n+     * @param provider cluster provider label\n+     * @param managementSettings settings formula values\n+     * @param user the user\n+     * @return the new cluster object\n+     * @throws IOException if saving the formula values failed\n+     * @throws TaskomaticApiException if the system group refresh could not be schedules\n+     */\n+    public Cluster addCluster(String name, String label, String description, long managementNodeId,\n+                              String provider, Map<String, Object> managementSettings, User user)\n+            throws IOException, TaskomaticApiException {\n+        Server managementNode = ServerFactory.lookupById(managementNodeId);\n+        if (managementNode == null) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" not found\");\n+        }\n+        if (managementNode.asMinionServer().isEmpty()) {\n+            throw new RuntimeException(\"Server with id=\" + managementNodeId + \" is not a minion\");\n+        }\n+\n+        // find out settings formula from provider metadata\n+        String settingsFormula = FormulaFactory.getClusterProviderMetadata(provider,\n+                \"formulas:settings:name\", String.class)\n+                .orElseThrow(() -> new RuntimeException(\n+                        \"Missing key formulas:settings:name from metadata.yml of cluster provider \" +\n+                        provider));\n+\n+        // create corresponding group\n+        ManagedServerGroup group = serverGroupManager.create(user, getGroupName(name),\n+                getGroupDescription(label));\n+\n+        // create cluster\n+        Cluster cluster = new Cluster();\n+        cluster.setName(name);\n+        cluster.setLabel(label);\n+        cluster.setDescription(description);\n+        cluster.setProvider(provider);\n+        cluster.setManagementNode(managementNode.asMinionServer().get());\n+        cluster.setGroup(group);\n+        cluster.setOrg(user.getOrg());\n+        getSession().save(cluster);\n+\n+        // enable settings formula\n+        List<String> formulas = new ArrayList<>();\n+        formulas.addAll(FormulaFactory.getFormulasByGroupId(group.getId()));\n+        formulas.add(settingsFormula);\n+        FormulaFactory.saveGroupFormulas(group.getId(), formulas, user.getOrg());\n+\n+        // save settings data\n+        Map<String, Object> settingsInNamespace = adjustNamespace(label, \"settings\", managementSettings);\n+        FormulaFactory.saveGroupFormulaData(settingsInNamespace, group.getId(), user.getOrg(), settingsFormula);\n+\n+        // add management node to group\n+        serverGroupManager.addServers(group, Arrays.asList(managementNode), user);\n+\n+        // schedule refreshing group nodes\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> clusterActionCommand =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES,\n+                        managementNode.asMinionServer().get(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        clusterActionCommand.store();\n+        return cluster;\n+    }\n+\n+    private Map<String, Object> adjustNamespace(String clusterLabel, String key, Map<String, Object> data) {\n+        return Collections.singletonMap(\"mgr_clusters\",\n+                Collections.singletonMap(clusterLabel,\n+                        Collections.singletonMap(key, data)));\n+    }\n+\n+    /**\n+     * Deletes a cluster from the db.\n+     * @param cluster the cluster\n+     * @param user the user\n+     */\n+    public void deleteCluster(Cluster cluster, User user) {\n+        // delete first cluster to avoid non null foreign key error\n+        getSession().delete(cluster);\n+        // delete corresponding group\n+        serverGroupManager.remove(user, cluster.getGroup());\n+    }\n+\n+    /**\n+     * Save cluster formula data.\n+     * @param cluster the cluster\n+     * @param formulaKey the formula key used by the cluster provider\n+     * @param formData the formula data\n+     * @param user the user\n+     * @throws IOException if the data could not be saved\n+     */\n+    public void saveFormulaData(Cluster cluster, String formulaKey, Map<String, Object> formData,\n+                                User user) throws IOException {\n+        ManagedServerGroup group = cluster.getGroup();\n+        FormulaUtil.ensureUserHasPermissionsOnServerGroup(user, group);\n+        Optional<String> formulaName = FormulaFactory\n+                .getClusterProviderFormulaName(cluster.getProvider(), formulaKey);\n+        if (formulaName.isEmpty()) {\n+            throw new RuntimeException(\n+                    \"Couldn't find formula with key \" + formulaKey + \" in cluster provider \" + cluster.getProvider());\n+        }\n+        Map<String, Object> formDataInNamespace = adjustNamespace(cluster.getLabel(), formulaKey, formData);\n+        FormulaFactory.saveGroupFormulaData(formDataInNamespace, group.getId(), user.getOrg(), formulaName.get());\n+        List<String> minionIds = group.getServers().stream()\n+                .flatMap(s -> Opt.stream(s.asMinionServer()))\n+                .map(MinionServer::getMinionId).collect(Collectors.toList());\n+        systemQuery.refreshPillar(new MinionList(minionIds));\n+    }\n+\n+    /**\n+     * Match cluster nodes against registered systems using the machine-id\n+     * @param clusterNodes cluster nodes\n+     */\n+    public void matchClusterNodes(List<ClusterNode> clusterNodes) {\n+        clusterNodes.forEach(node -> {\n+            Optional<MinionServer> server = Optional.ofNullable(node.getDetails().get(\"machine-id\"))\n+                    .map(String.class::cast)\n+                    .flatMap(machineId -> MinionServerFactory.findByMachineId(machineId));\n+            node.setServer(server);\n+        });\n+    }\n+\n+    /**\n+     * Schedules the action to refresh the system group that belongs to a cluster.\n+     * @param cluster the cluster\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException is the action could not be scheduled\n+     */\n+    public ClusterGroupRefreshNodesAction refreshGroup(Cluster cluster, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<ClusterGroupRefreshNodesAction> cmd =\n+                new ClusterActionCommand(Optional.of(user), user.getOrg(),\n+                        new Date(),\n+                        null,\n+                        ActionFactory.TYPE_CLUSTER_GROUP_REFRESH_NODES, cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        null);\n+        cmd.store();\n+        return cmd.getAction();\n+\n+    }\n+\n+    /**\n+     * Schedules an action to join or remove a node from a cluster.\n+     * @param actionType the action type (join/remove)\n+     * @param cluster the cluster\n+     * @param serverIds the server id (optional for remove)\n+     * @param formulaData the formula data for joining/removing\n+     * @param earliest the date of execution\n+     * @param user the user\n+     * @return the action\n+     * @throws TaskomaticApiException if the action could not be scheduled\n+     */\n+    public BaseClusterModifyNodesAction modifyClusterNodes(ActionType actionType, Cluster cluster,\n+                                                           List<Long> serverIds, Map<String, Object> formulaData,\n+                                                           Date earliest, User user) throws TaskomaticApiException {\n+        ClusterActionCommand<BaseClusterModifyNodesAction> clusterActionCommand =\n+                new ClusterActionCommand<>(Optional.of(user), user.getOrg(),\n+                        earliest,\n+                        null,\n+                        actionType,\n+                        cluster.getManagementNode(),\n+                        cluster,\n+                        cluster.getGroup().getName(),\n+                        nodeAction -> {\n+                            nodeAction.getServerIds().addAll(serverIds);\n+                            nodeAction.setJsonParams(GSON.toJson(formulaData));\n+                        });\n+        clusterActionCommand.store();\n+        return clusterActionCommand.getAction();\n+    }\n+\n+    /**\n+     * Deserialize action params stored as JSON.\n+     * @param jsonParams json string\n+     * @return json as Map\n+     */\n+    public Map<String, Object> deserializeJsonParams(String jsonParams) {\n+        return GSON.fromJson(jsonParams, Map.class);\n+    }\n+\n+    /**\n+     * Evaluate a JEXL expression.\n+     * @param expr expression\n+     * @param ctx context for the expression\n+     * @return evaluation result\n+     */\n+    public Object evalExpression(String expr, Map<String, Object> ctx) {\n+        JexlEngine jexl = new JexlEngine();\n+\n+        // Create an expression\n+        Expression jexlExpr = jexl.createExpression(expr);\n+\n+        // Create a context and add data\n+        JexlContext jc = new MapContext(ctx);\n+        try {\n+            return jexlExpr.evaluate(jc);\n+        }\n+        catch (JexlException e) {\n+            LOG.error(\"Error evaluating expression: \" + expr, e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Creates the initial data for a cluster provider formula. It evaluates the entries from\n+     * the provider metadata, from formulas:[formula]:data (if present) using the provided context\n+     * and creates initial data for the form.\n+     *\n+     * It checks if \"cluster\" or \"node\" are present in the supplied context and contain an id and\n+     * tries to find the corresponding cluster or server entities in the db.\n+     *\n+     * If \"cluster\" can be resolved it also adds the cluster settings data to the context with\n+     * the name \"cluster_settings\".\n+     *\n+     * @param provider cluster provider label\n+     * @param formulaKey formula key\n+     * @param context context for evaluation\n+     * @return the initial data for the formula form\n+     */\n+    public Map<String, Object> initialFormulaData(String provider, String formulaKey, Map<String, Object> context) {\n+        Map<String, Object> initialData = new HashMap<>();\n+\n+        Optional<Map<String, Object>> formulaData = FormulaFactory\n+                .getClusterProviderMetadata(provider, \"formulas:\" + formulaKey + \":data\", Map.class)\n+                .map(m -> (Map<String, Object>)m);\n+        if (formulaData.isPresent()) {\n+            Map<String, Object> ctx = new HashMap<>();\n+            Optional.ofNullable(context.get(\"nodes\"))\n+                    .filter(List.class::isInstance)\n+                    .map(List.class::cast)\n+                    .filter(nodeIds -> nodeIds.stream().anyMatch(Number.class::isInstance))\n+                    .map(nodeIds -> (List<Number>)nodeIds)\n+//                    .map(nodeIds -> nodeIds.stream().map(id -> ((Number)id).longValue()).collect(Collectors.toList()))\n+                    .map(nodeIds -> nodeIds.stream()\n+                            .map(id -> MinionServerFactory.lookupById(((Number)id).longValue()))\n+                            .filter(Optional::isPresent)\n+                            .map(Optional::get)\n+                            .collect(Collectors.toList())\n+                    )\n+                    .ifPresentOrElse(minions ->\n+                            ctx.put(\"nodes\", minions),\n+                            () -> LOG.error(\"Could not find minions ids: \" + context.get(\"nodes\")));\n+\n+            Optional.ofNullable(context.get(\"cluster\"))\n+                    .filter(Number.class::isInstance)\n+                    .map(Number.class::cast)\n+                    .map(Number::longValue)\n+                    .flatMap(ClusterFactory::findClusterById)\n+                    .ifPresentOrElse(cluster-> {\n+                        ctx.put(\"cluster\", cluster);\n+                        formulaManager.getClusterFormulaData(cluster, \"settings\")\n+                                .ifPresent(data -> ctx.put(\"cluster_settings\", data));\n+                    },\n+                            () -> LOG.error(\"Could not find cluster id: \" + context.get(\"cluster\")));\n+\n+            Map<String, Object> otherValues = context.entrySet().stream()\n+                    .filter(e -> !e.getKey().equals(\"nodes\") &&\n+                            !e.getKey().equals(\"cluster\") &&\n+                            !e.getKey().equals(\"cluster_settings\"))\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            ctx.putAll(otherValues);\n+\n+            evalFormInitialData(initialData, \"\", formulaData.get(), ctx);\n+\n+            initialData.putAll(otherValues);\n+        }\n+        else {\n+            initialData.putAll(context);\n+        }\n+        return initialData;\n+    }\n+\n+    /**\n+     * Public for unit tests\n+     * @param out\n+     * @param dataKey\n+     * @param data\n+     * @param context\n+     */\n+    public void evalFormInitialData(Map out, String dataKey, Map<String, Object> data, Map<String, Object> context) {\n+            Map<String, Object> map = (Map<String, Object>)data;\n+            if (\"edit-group\".equals(map.get(\"$type\"))) {\n+                String valueExpr = (String)map.get(\"$value\");\n+                String itemName = (String)map.get(\"$item\");\n+                Map<String, Object> prototype = (Map<String, Object>)map.get(\"$prototype\");\n+                Object value = evalExpression(valueExpr, context);\n+                if (value instanceof Collection) {\n+                    List<Map<String, Object>> items = new LinkedList<>();\n+                    out.put(dataKey, items);\n+                    for (var item : ((Collection)value)) {\n+                        Map<String, Object> itemVal = new HashMap<>();\n+                        prototype.forEach((key, valExpr) -> {\n+                            Map<String, Object> valCtx = new HashMap<>();\n+                            valCtx.putAll(context);\n+                            valCtx.put(itemName, item);\n+                            if (valExpr instanceof String) {\n+                                Object val = evalExpression((String)valExpr, valCtx);\n+                                itemVal.put((String)key, val);\n+                            }\n+                            else if (valExpr instanceof Map) {\n+                                Map nestedVal = new HashMap();\n+                                evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, valCtx);\n+                                itemVal.putAll(nestedVal);\n+                            }\n+\n+                        });\n+                        items.add(itemVal);\n+                    }\n+                }\n+                else {\n+                    throw new RuntimeException(\"$value for edit-group doesn't evaluate to a collection\");\n+                }\n+            }\n+            else {\n+                map.forEach((key, valExpr) -> {\n+                    if (valExpr instanceof String) {\n+                        Object val = evalExpression((String) valExpr, context);\n+                        out.put(key, val);\n+                    }\n+                    else if (valExpr instanceof Map) {\n+                        Map nestedVal = new HashMap();\n+                        evalFormInitialData(nestedVal, key, (Map<String, Object>)valExpr, context);\n+                        out.putAll(nestedVal);\n+                    }\n+                });\n+            }\n+    }\n+\n+    /**\n+     * Get state hooks for cluster provider.\n+     * @param provider cluster provider label\n+     * @return state hooks as Map (if any)\n+     */\n+    public Optional<Map<String, List<String>>> getStateHooks(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"state_hooks\", Map.class)\n+                .map(m -> (Map<String, List<String>>)m);\n+\n+    }\n+\n+    /**\n+     * Get the details fields to show for each cluster node.\n+     * @param provider cluster provider label\n+     * @return detail fields to show (if any)\n+     */\n+    public Optional<List<String>> getNodesListFields(String provider) {\n+        return FormulaFactory.getClusterProviderMetadata(provider, \"ui:nodes_list:fields\", List.class)\n+                .map(l -> (List<String>)l);\n+    }\n+\n+    /**\n+     * Update cluster name and description.\n+     * @param cluster cluster\n+     * @param name new name\n+     * @param description new description\n+     */\n+    public void update(Cluster cluster, String name, String description) {\n+        cluster.setName(name);\n+        cluster.setDescription(description);\n+        getSession().save(cluster);\n+        cluster.getGroup().setName(getGroupName(name));\n+        cluster.getGroup().setDescription(getGroupDescription(name));\n+        ServerGroupFactory.save(cluster.getGroup());\n+    }\n+\n+    private String getGroupName(String clusterName) {\n+        return \"Cluster \" + clusterName;\n+    }\n+\n+    private String getGroupDescription(String clusterName) {\n+        return \"Group for cluster \" + clusterName;\n+    }\n+\n+    /**\n+     * Find a cluster by id and user. Checks if the cluster is in the same org as the user.\n+     * @param id cluster ir\n+     * @param user user\n+     * @return the cluster if found\n+     */\n+    public Optional<Cluster> findClusterByIdAndUser(Long id, User user) {\n+        return ClusterFactory.findClusterById(id)\n+                .filter(c -> c.getOrg().equals(user.getOrg()));\n+    }", "originalCommit": "800b8cd852916c9933548fb77c1dcf6fea4938f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0Nzg1OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436147859", "bodyText": "Fixed", "author": "mbologna", "createdAt": "2020-06-05T20:25:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg5OTk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzAzOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r435987038", "bodyText": "We should also make sure that the name/label does not exist (both here and in React).\nOtherwise, the process reports a confusing error about a duplicate system group name. We should explicitly tell the user that a cluster with this name already exists.", "author": "cbbayburt", "createdAt": "2020-06-05T15:12:15Z", "path": "java/code/src/com/suse/manager/webui/controllers/clusters/ClustersController.java", "diffHunk": "@@ -274,24 +284,109 @@ private static ModelAndView showClusterUpgrade(Request request, Response respons\n         return new ModelAndView(data, \"controllers/clusters/templates/upgrade.jade\");\n     }\n \n+    private static class AddClusterRequest {\n+        private String name;\n+        private String label;\n+        private String description;\n+        private String provider;\n+        private Long managementNodeId;\n+        private Map<String, Object> managementSettings;\n+\n+        /**\n+         * @return name to get\n+         */\n+        public String getName() {\n+            return name;\n+        }\n+\n+        /**\n+         * @return label to get\n+         */\n+        public String getLabel() {\n+            return label;\n+        }\n+\n+        /**\n+         * @return description to get\n+         */\n+        public String getDescription() {\n+            return description;\n+        }\n+\n+        /**\n+         * @return provider to get\n+         */\n+        public String getProvider() {\n+            return provider;\n+        }\n+\n+        /**\n+         * @return managementNodeId to get\n+         */\n+        public Long getManagementNodeId() {\n+            return managementNodeId;\n+        }\n+\n+        /**\n+         * @return managementSettings to get\n+         */\n+        public Map<String, Object> getManagementSettings() {\n+            return managementSettings;\n+        }\n+    }\n+\n     private static String addCluster(Request request, Response response, User user) {\n-        Optional<Map<String, Object>> json = parseJson(request, response);\n-        if (json.isEmpty()) {\n+        AddClusterRequest clusterRequest;\n+        try {\n+            clusterRequest = GSON.fromJson(request.body(), AddClusterRequest.class);\n+        }\n+        catch (JsonParseException e) {\n+            LOG.error(\"Error parsing request body\", e);\n             return json(response, HttpStatus.SC_BAD_REQUEST,\n-                    ResultJson.error(\"request_error\"));\n+                    ResultJson.error(\"invalid_request_body\"));\n+        }\n+\n+        if (StringUtils.isBlank(clusterRequest.getName())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Name is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getLabel())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label is mandatory\"));\n+        }\n+\n+        if (!LABEL_REGEX.matcher(clusterRequest.getLabel()).matches()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Label format is wrong\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getDescription())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Description is mandatory\"));\n+        }\n+        if (StringUtils.isBlank(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Provider is mandatory\"));\n+        }\n+        if (!validProvider(clusterRequest.getProvider())) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Invalid provider\"));\n+        }\n+        if (clusterRequest.getManagementNodeId() == null) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management node id is mandatory\"));\n+        }\n+        if (clusterRequest.getManagementSettings() == null ||\n+                clusterRequest.getManagementSettings().isEmpty()) {\n+            return json(response, HttpStatus.SC_BAD_REQUEST,\n+                    ResultJson.error(\"Management settings are mandatory\"));\n         }\n \n-        // TODO validate input", "originalCommit": "f0301dddf87387a290cf76d26444870bfab3e3d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA5OTYxNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436099615", "bodyText": "done", "author": "mateiw", "createdAt": "2020-06-05T18:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk4NzAzOA=="}], "type": "inlineReview"}, {"oid": "0a87e1d16a889501664c7aa5f036cb5fadb4141e", "url": "https://github.com/uyuni-project/uyuni/commit/0a87e1d16a889501664c7aa5f036cb5fadb4141e", "message": "Feat: handler for clusters", "committedDate": "2020-06-05T20:14:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2MTIyNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2070#discussion_r436361224", "bodyText": "wrong year", "author": "mcalmer", "createdAt": "2020-06-07T13:04:38Z", "path": "java/code/src/com/redhat/rhn/frontend/xmlrpc/NoSuchClusterException.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2017 SUSE LLC", "originalCommit": "59a8ab144fba08cec9b7880690c19a0190794faf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "17254afee3251655488327e5be52181491c06fbb", "url": "https://github.com/uyuni-project/uyuni/commit/17254afee3251655488327e5be52181491c06fbb", "message": "Chore: prereq: ES6 export style", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "ae9d4b94fb8fb2431a65ac4790800aeb892faf74", "url": "https://github.com/uyuni-project/uyuni/commit/ae9d4b94fb8fb2431a65ac4790800aeb892faf74", "message": "Chore: copy pillar modules with Ant", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "bd92784393a3da2f988efe0be8614fadbb6d175e", "url": "https://github.com/uyuni-project/uyuni/commit/bd92784393a3da2f988efe0be8614fadbb6d175e", "message": "Feat: UI: cluster menu and fonts", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "cde9424d41e0006e5db92d550a4a0e566c3b47bf", "url": "https://github.com/uyuni-project/uyuni/commit/cde9424d41e0006e5db92d550a4a0e566c3b47bf", "message": "Feat: UI: add cluster", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "029f352b05055e406a93cd863bba89f1aebfe841", "url": "https://github.com/uyuni-project/uyuni/commit/029f352b05055e406a93cd863bba89f1aebfe841", "message": "Feat: backend: add cluster_admin role", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "cbdf21a19d2e8aded8bd939cc05ff599bf317359", "url": "https://github.com/uyuni-project/uyuni/commit/cbdf21a19d2e8aded8bd939cc05ff599bf317359", "message": "Feat: backend: cluster model (db + POJOs)", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "aa9960aa290c66eb370fcf3637124c754959fa2a", "url": "https://github.com/uyuni-project/uyuni/commit/aa9960aa290c66eb370fcf3637124c754959fa2a", "message": "Feat: backend: brokers", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "32599561bba0ed25a97cc30f55b3b0052bef25e2", "url": "https://github.com/uyuni-project/uyuni/commit/32599561bba0ed25a97cc30f55b3b0052bef25e2", "message": "Feat: backend: formula provider utils", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "033cd7a647ba3fdc69faaa46337ac7c49137a389", "url": "https://github.com/uyuni-project/uyuni/commit/033cd7a647ba3fdc69faaa46337ac7c49137a389", "message": "Feat: Salt: CaaSP cluster provider", "committedDate": "2020-06-08T11:59:32Z", "type": "commit"}, {"oid": "4fb41c23ad90f3bedb75418c893aca3cb61e7306", "url": "https://github.com/uyuni-project/uyuni/commit/4fb41c23ad90f3bedb75418c893aca3cb61e7306", "message": "Feat: backend+UI: base cluster actions definition", "committedDate": "2020-06-08T11:59:33Z", "type": "commit"}, {"oid": "9e8c519c47031a862f35a4d48d01c1a524aee3c5", "url": "https://github.com/uyuni-project/uyuni/commit/9e8c519c47031a862f35a4d48d01c1a524aee3c5", "message": "Flowtype errs fixes", "committedDate": "2020-06-08T12:00:31Z", "type": "forcePushed"}, {"oid": "4e14d879c7c2805e464443ee6fa62a5fdaf2f78b", "url": "https://github.com/uyuni-project/uyuni/commit/4e14d879c7c2805e464443ee6fa62a5fdaf2f78b", "message": "Feat: backend: cluster manager", "committedDate": "2020-06-08T12:27:53Z", "type": "commit"}, {"oid": "cfe2e6ce5ba25a949a60bc52a73fd7d1633ea86f", "url": "https://github.com/uyuni-project/uyuni/commit/cfe2e6ce5ba25a949a60bc52a73fd7d1633ea86f", "message": "Feat: backend: cluster list nodes", "committedDate": "2020-06-08T12:27:53Z", "type": "commit"}, {"oid": "3f29383012e581da3ee3de21dccad91250b4e5c3", "url": "https://github.com/uyuni-project/uyuni/commit/3f29383012e581da3ee3de21dccad91250b4e5c3", "message": "Feat: backend: cluster refresh system group action", "committedDate": "2020-06-08T12:27:53Z", "type": "commit"}, {"oid": "a4f19ff7d0399e70afd76db1e304718671dd96fb", "url": "https://github.com/uyuni-project/uyuni/commit/a4f19ff7d0399e70afd76db1e304718671dd96fb", "message": "Feat: backend: cluster join node action", "committedDate": "2020-06-08T12:27:53Z", "type": "commit"}, {"oid": "5f6a0ab415d22e13cf45cb168161fd9190f665cb", "url": "https://github.com/uyuni-project/uyuni/commit/5f6a0ab415d22e13cf45cb168161fd9190f665cb", "message": "Feat: backend: cluster remove node action", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "dece145242d6b6b71ea350c793d65a2c9f55121f", "url": "https://github.com/uyuni-project/uyuni/commit/dece145242d6b6b71ea350c793d65a2c9f55121f", "message": "Feat: backend: cluster upgrade action", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "8fee75ef3bb741acfe24ace85fd9d455f6d64f73", "url": "https://github.com/uyuni-project/uyuni/commit/8fee75ef3bb741acfe24ace85fd9d455f6d64f73", "message": "Feat: UI: cluster join node action", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "fd6b1c6964e35b1aaed9fa93def40165a029a0cb", "url": "https://github.com/uyuni-project/uyuni/commit/fd6b1c6964e35b1aaed9fa93def40165a029a0cb", "message": "Feat: UI: cluster remove node action", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "94e32c270b2224c73567ac625f42cf6a532e7440", "url": "https://github.com/uyuni-project/uyuni/commit/94e32c270b2224c73567ac625f42cf6a532e7440", "message": "Feat: UI: cluster upgrade action", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "fe1f0d4ef4b2cb91cf4ce03dadf623c24df8f167", "url": "https://github.com/uyuni-project/uyuni/commit/fe1f0d4ef4b2cb91cf4ce03dadf623c24df8f167", "message": "Feat: UI: validation and cluster_admin role checks", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "62b5e45c6a2e5192f8040e6e8777a3a5b0e91830", "url": "https://github.com/uyuni-project/uyuni/commit/62b5e45c6a2e5192f8040e6e8777a3a5b0e91830", "message": "Feat: UI: show multiple toastr messages if input is array", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "5b821598261dee8c8fde629c7b00afe649a41ac7", "url": "https://github.com/uyuni-project/uyuni/commit/5b821598261dee8c8fde629c7b00afe649a41ac7", "message": "Chore: update tables deps", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "ab3598e68555b46310ebb0ab1afb391aa2460f0d", "url": "https://github.com/uyuni-project/uyuni/commit/ab3598e68555b46310ebb0ab1afb391aa2460f0d", "message": " Chore: require jexl in spacewalk-java", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "24d178b5a0aab388b5e57fedddc888ed98cb8d70", "url": "https://github.com/uyuni-project/uyuni/commit/24d178b5a0aab388b5e57fedddc888ed98cb8d70", "message": "Chore: announce changes", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "a4910ca171e2b3c7b3cf361a9ffbef19a4d90f0b", "url": "https://github.com/uyuni-project/uyuni/commit/a4910ca171e2b3c7b3cf361a9ffbef19a4d90f0b", "message": "HashRouter component fixes", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "e08b0c0794abb4485f93b3dd1c50142a042dce11", "url": "https://github.com/uyuni-project/uyuni/commit/e08b0c0794abb4485f93b3dd1c50142a042dce11", "message": "DB schema fixes", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "9867610bd9998e7e06c15b17189a2d8d8a5646ed", "url": "https://github.com/uyuni-project/uyuni/commit/9867610bd9998e7e06c15b17189a2d8d8a5646ed", "message": "Cluster UI fixes after review", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "ca02c307076d7e0963d22e5b0ef37c75522cf347", "url": "https://github.com/uyuni-project/uyuni/commit/ca02c307076d7e0963d22e5b0ef37c75522cf347", "message": "Drop modified column from action cluster tables and add trigger", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "e9a976074fdd5de85519a182b215274e2e130ae3", "url": "https://github.com/uyuni-project/uyuni/commit/e9a976074fdd5de85519a182b215274e2e130ae3", "message": "Fix cluster menu tree selection", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "7fe3e9f0d698cc2fab499c18a1eebbeab639857e", "url": "https://github.com/uyuni-project/uyuni/commit/7fe3e9f0d698cc2fab499c18a1eebbeab639857e", "message": "Expose caasp version in the list of cluster nodes", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "f0de2ba68b5f35c8878f197074c2cc8e25df1123", "url": "https://github.com/uyuni-project/uyuni/commit/f0de2ba68b5f35c8878f197074c2cc8e25df1123", "message": "Feat: handler for clusters", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "1033f775e1d870bc731c098b5091e82e57b145b3", "url": "https://github.com/uyuni-project/uyuni/commit/1033f775e1d870bc731c098b5091e82e57b145b3", "message": "Fix DangerDialog button style", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "e7270c049c7dc1d67c3b3716813c16083ed5307b", "url": "https://github.com/uyuni-project/uyuni/commit/e7270c049c7dc1d67c3b3716813c16083ed5307b", "message": "Revert refactoring of messages.js", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "4ee4bc129f4393d63d2a40e3fdeff4d33ec0752f", "url": "https://github.com/uyuni-project/uyuni/commit/4ee4bc129f4393d63d2a40e3fdeff4d33ec0752f", "message": "Disable deleting the cluster group", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "161afc4059db963cbd5c20cea2bffea409002f51", "url": "https://github.com/uyuni-project/uyuni/commit/161afc4059db963cbd5c20cea2bffea409002f51", "message": "Show kublet version in cluster nodes list", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "8a203348e43b01f30228cf8743a5e734e77fb3a5", "url": "https://github.com/uyuni-project/uyuni/commit/8a203348e43b01f30228cf8743a5e734e77fb3a5", "message": "Fix usage of ssh_auth_sock when applying the cluster upgrade state", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "3c5ddd0fad3389ed3ab08c1e8f8d6e89dc903f15", "url": "https://github.com/uyuni-project/uyuni/commit/3c5ddd0fad3389ed3ab08c1e8f8d6e89dc903f15", "message": "Store cluster action result as yaml", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "7df87c5775ca712d498fa268a37a127391fba141", "url": "https://github.com/uyuni-project/uyuni/commit/7df87c5775ca712d498fa268a37a127391fba141", "message": "Copyright year", "committedDate": "2020-06-08T12:27:54Z", "type": "commit"}, {"oid": "f3ab62debaf5385111dd01c86d0643e57c3174d1", "url": "https://github.com/uyuni-project/uyuni/commit/f3ab62debaf5385111dd01c86d0643e57c3174d1", "message": "Show message when group owned by cluster", "committedDate": "2020-06-08T12:27:55Z", "type": "commit"}, {"oid": "ca032fd114dab94eb11882c58563e3e1a8f5f90a", "url": "https://github.com/uyuni-project/uyuni/commit/ca032fd114dab94eb11882c58563e3e1a8f5f90a", "message": "Flowtype errs fixes", "committedDate": "2020-06-08T12:27:55Z", "type": "commit"}, {"oid": "ca032fd114dab94eb11882c58563e3e1a8f5f90a", "url": "https://github.com/uyuni-project/uyuni/commit/ca032fd114dab94eb11882c58563e3e1a8f5f90a", "message": "Flowtype errs fixes", "committedDate": "2020-06-08T12:27:55Z", "type": "forcePushed"}, {"oid": "6daf9176abcaafa097368c2f639254e1b2a8bd98", "url": "https://github.com/uyuni-project/uyuni/commit/6daf9176abcaafa097368c2f639254e1b2a8bd98", "message": "Merge branch 'master' into master-cluster-awareness-mvp-impl", "committedDate": "2020-06-08T13:19:58Z", "type": "commit"}]}