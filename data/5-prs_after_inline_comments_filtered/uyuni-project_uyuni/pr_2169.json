{"pr_number": 2169, "pr_title": "Frontend for configuring Maintenance Windows", "pr_createdAt": "2020-04-28T08:23:34Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2169", "timeline": [{"oid": "d479ab993ab002f922cd2e590d77b79a06a4e0b3", "url": "https://github.com/uyuni-project/uyuni/commit/d479ab993ab002f922cd2e590d77b79a06a4e0b3", "message": "Add details view for schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-04-30T15:17:27Z", "type": "forcePushed"}, {"oid": "18c1fb2b9d227d492af77337d80e3e63712a8cb4", "url": "https://github.com/uyuni-project/uyuni/commit/18c1fb2b9d227d492af77337d80e3e63712a8cb4", "message": "Controller save method\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-14T16:26:14Z", "type": "forcePushed"}, {"oid": "023327d3cae12b9e2bbd96677ab500ca15bb9474", "url": "https://github.com/uyuni-project/uyuni/commit/023327d3cae12b9e2bbd96677ab500ca15bb9474", "message": "Get detailed schedule info\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-19T11:15:14Z", "type": "forcePushed"}, {"oid": "96b21e7e8c966ee0ada155e656ee3ae799a05159", "url": "https://github.com/uyuni-project/uyuni/commit/96b21e7e8c966ee0ada155e656ee3ae799a05159", "message": "Add missing javadoc, fix checkstyle\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-05-27T09:01:11Z", "type": "forcePushed"}, {"oid": "eea876c7beb50d086a4beaeaa26f9f6adc018c86", "url": "https://github.com/uyuni-project/uyuni/commit/eea876c7beb50d086a4beaeaa26f9f6adc018c86", "message": "Handle reschedule strategy\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-02T16:26:01Z", "type": "forcePushed"}, {"oid": "a1af066a5ab3b6f3b19ab8d1ce1c8d5666f91ef5", "url": "https://github.com/uyuni-project/uyuni/commit/a1af066a5ab3b6f3b19ab8d1ce1c8d5666f91ef5", "message": "Support refreshing calendars from url\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-05T13:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMzE0Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437423143", "bodyText": "Looks like this comment has been copy-pasted all over the codebase, but it's wrong in many cases (including this one :) ).", "author": "hustodemon", "createdAt": "2020-06-09T13:37:52Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNDQzNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437424436", "bodyText": "Later todo suggestion (as per our talk): Splitting this to MaintenanceScheduleController and MaintenanceCalendarController would be nicer.", "author": "hustodemon", "createdAt": "2020-06-09T13:39:42Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyNTA3NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437425075", "bodyText": "The name for this endpoint should reflect its intent: maybe /manager/api/maintenance/calendar-names would be better?", "author": "hustodemon", "createdAt": "2020-06-09T13:40:25Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyODI2OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437428268", "bodyText": "In general, using Optional.get is discouraged, unless there is a very good reason for using it.\nI think this could be improved by using orElseThrow above:\nMaintenanceSchedule schedule = MM.lookupM.....(...)\n    .orElseThrow(() -> Spark.halt(\n        HttpStatus.SC_BAD_REQUEST,\n        GSON.toJson(ResultJson.error(LOCAL.getMessage(\"maintenance.schedule.id.not.exists\", scheduleId)))));\nThis way you get unwrapped MaintenanceSchedule.", "author": "hustodemon", "createdAt": "2020-06-09T13:43:27Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyOTI4NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437429285", "bodyText": "Same as above.", "author": "hustodemon", "createdAt": "2020-06-09T13:44:26Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMDIwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437430206", "bodyText": "There is nothing wrong with this, but if you want to be less verbose, you can use this notation:\nMap.of(\n    \"id\", schedule.getId().toString(),\n    \"name\", schedule.getName());", "author": "hustodemon", "createdAt": "2020-06-09T13:45:20Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzMjk0NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437432945", "bodyText": "I don't like the fact, that <None> is handled as a special value here. I believe this is something that should be handled internally by the frontend (and if user selects <None> from the combobox, null should be sent to the backend). Is there anything preventing us from using null?\nThis is related to all <None> occurences in here and in the js files.", "author": "hustodemon", "createdAt": "2020-06-09T13:47:56Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437434881", "bodyText": "In which situations is this check needed? Can you remove it? When we lookup the calendar from the database, it will always have null (the only exception would be, when the entity is not persisted yet, but I believe this is not the case here).", "author": "hustodemon", "createdAt": "2020-06-09T13:49:49Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNTkwMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440025903", "bodyText": "Yes we need it. This case happens, when the user tries to create a new calendar with a name that already exists. Without it you could override an existing calendar by creating a new one with the same name.", "author": "parlt91", "createdAt": "2020-06-15T08:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxNjg4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440716886", "bodyText": "Ok, that makes sense.", "author": "hustodemon", "createdAt": "2020-06-16T09:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNTc0OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437435749", "bodyText": "Please move this declaration & assignment to line 298.", "author": "hustodemon", "createdAt": "2020-06-09T13:50:35Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNjI1Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437436257", "bodyText": "Please remove this line.", "author": "hustodemon", "createdAt": "2020-06-09T13:51:03Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzOTU2OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437439569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (schedule.isPresent()) {\n          \n          \n            \n                        MM.remove(user, schedule.get());\n          \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                        Spark.halt(HttpStatus.SC_BAD_REQUEST);\n          \n          \n            \n                    }\n          \n          \n            \n            schedule.ifPresentOrElse(                                                                                                                       \n          \n          \n            \n                s -> MM.remove(user, s),                                                                                                                \n          \n          \n            \n                () -> Spark.halt(HttpStatus.SC_BAD_REQUEST));", "author": "hustodemon", "createdAt": "2020-06-09T13:54:00Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MDE4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437440186", "bodyText": "Could be simplified as well ^^^.", "author": "hustodemon", "createdAt": "2020-06-09T13:54:37Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTIxOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437441218", "bodyText": "I'm not sure here: Do we want to report the first unsuccessful result, or all of them? In case of the latter, we might need something like this:\n        // maybe we want to report unsuccessful results?                                                                                                \n        String message = results.stream()                                                                                                               \n                .filter(r -> !r.isSuccess())                                                                                                            \n                .map(r -> LOCAL.getMessage(strategy.equals(\"Cancel\") ?                                                                                  \n                                \"maintenance.action.reschedule.error.cancel\" :                                                                          \n                                \"maintenance.action.reschedule.error.fail\",                                                                             \n                        r.getScheduleName()))                                                                                                           \n                .collect(Collectors.joining(\", \"));                                                                                                     \n                                                                                                                                                        \n        if (!message.isEmpty()) {                                                                                                                       \n            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(message)));                                                              \n        }", "author": "hustodemon", "createdAt": "2020-06-09T13:55:46Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {\n+            String strategy = json.getRescheduleStrategy();\n+            handleRescheduleResult(MM.remove(user, calendar.get(), strategy.equals(\"Cancel\")), strategy);\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void handleRescheduleResult(List<RescheduleResult> results, String strategy) {\n+        results.forEach(result -> {\n+            if (!result.isSuccess()) {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDA0OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440020048", "bodyText": "We definitely want to display all of the failed results, but due to the lack of time I chose the minimalist approach. We cannot use a simple notification message to display multiple failures on the frontend, so we need to come up with something else here.", "author": "parlt91", "createdAt": "2020-06-15T08:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MzA1MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437443051", "bodyText": "Later todo: As discussed, this might be a good place for a specialized JPQL query. Moreover, it'd be great if we had a query that can handle multiple entities instead of calling this method N-times.", "author": "hustodemon", "createdAt": "2020-06-09T13:57:38Z", "path": "java/code/src/com/suse/manager/webui/controllers/MaintenanceController.java", "diffHunk": "@@ -0,0 +1,498 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.webui.controllers;\n+\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.json;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withCsrfToken;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUser;\n+import static com.suse.manager.webui.utils.SparkApplicationHelper.withUserPreferences;\n+import static spark.Spark.delete;\n+import static spark.Spark.get;\n+import static spark.Spark.post;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+import com.redhat.rhn.common.util.download.DownloadException;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityExistsException;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.suse.manager.maintenance.MaintenanceManager;\n+import com.suse.manager.maintenance.RescheduleResult;\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+import com.suse.manager.webui.utils.gson.MaintenanceWindowJson;\n+import com.suse.manager.webui.utils.gson.ResultJson;\n+import org.apache.http.HttpStatus;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import spark.ModelAndView;\n+import spark.Request;\n+import spark.Response;\n+import spark.Spark;\n+import spark.template.jade.JadeTemplateEngine;\n+\n+/**\n+ * Controller class providing the backend for API calls to work with maintenance windows.\n+ */\n+public class MaintenanceController {\n+\n+    private static final Gson GSON = new GsonBuilder().create();\n+    private static final MaintenanceManager MM = MaintenanceManager.instance();\n+    private static final LocalizationService LOCAL = LocalizationService.getInstance();\n+\n+    private MaintenanceController() { }\n+\n+    /**\n+     * Invoked from Router. Initialize routes for Systems Views.\n+     *\n+     * @param jade the template engine\n+     */\n+    public static void initRoutes(JadeTemplateEngine jade) {\n+        get(\"/manager/schedule/maintenance/schedules\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceSchedules))),\n+                jade);\n+        get(\"/manager/schedule/maintenance/calendars\",\n+                withUserPreferences(withCsrfToken(withUser(MaintenanceController::maintenanceCalendars))),\n+                jade);\n+        get(\"/manager/api/maintenance/schedule/list\", withUser(MaintenanceController::listSchedules));\n+        get(\"/manager/api/maintenance/calendar/list\", withUser(MaintenanceController::listCalendars));\n+        get(\"/manager/api/maintenance/schedule/:id/details\", withUser(MaintenanceController::getScheduleDetails));\n+        get(\"/manager/api/maintenance/calendar/:id/details\", withUser(MaintenanceController::getCalendarDetails));\n+        get(\"/manager/api/maintenance/calendar\", withUser(MaintenanceController::getCalendarNames));\n+        post(\"/manager/api/maintenance/schedule/save\", withUser(MaintenanceController::saveSchedule));\n+        post(\"/manager/api/maintenance/calendar/save\", withUser(MaintenanceController::saveCalendar));\n+        post(\"/manager/api/maintenance/calendar/refresh\", withUser(MaintenanceController::refreshCalendar));\n+        delete(\"/manager/api/maintenance/schedule/delete\", withUser(MaintenanceController::deleteSchedule));\n+        delete(\"/manager/api/maintenance/calendar/delete\", withUser(MaintenanceController::deleteCalendar));\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Schedules page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceSchedules(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"schedule\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Handler for the Maintenance Calendars page.\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the current user\n+     * @return the ModelAndView object to render the page\n+     */\n+    public static ModelAndView maintenanceCalendars(Request request, Response response, User user) {\n+        Map<String, String> params = new HashMap<>();\n+        params.put(\"type\", \"calendar\");\n+        return new ModelAndView(params, \"templates/schedule/maintenance-windows.jade\");\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Schedules visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listSchedules(Request request, Response response, User user) {\n+        List<MaintenanceSchedule> schedules = MM.listMaintenanceSchedulesByUser(user);\n+        return json(response, schedulesToJson(schedules));\n+    }\n+\n+    /**\n+     * Processes a GET request to get a list of all Maintenance Calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String listCalendars(Request request, Response response, User user) {\n+        List<MaintenanceCalendar> calendars = MM.listCalendarsByUser(user);\n+        return json(response, calendarsToJson(user, calendars));\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a schedule identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getScheduleDetails(Request request, Response response, User user) {\n+        Long scheduleId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndId(user, scheduleId);\n+        if (schedule.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.id.not.exists\", scheduleId\n+            ))));\n+        }\n+        json.setScheduleId(schedule.get().getId());\n+        json.setScheduleName(schedule.get().getName());\n+        json.setScheduleType(schedule.get().getScheduleType().toString());\n+\n+        schedule.get().getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+            json.setCalendarData(maintenanceCalendar.getIcal());\n+            maintenanceCalendar.getUrlOpt().ifPresent(json::setCalendarUrl);\n+        });\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the details of a calendar identified by its id\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarDetails(Request request, Response response, User user) {\n+        Long calendarId = Long.parseLong(request.params(\"id\"));\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndId(user, calendarId);\n+        if (calendar.isEmpty()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.id.not.exists\", calendarId\n+            ))));\n+        }\n+        json.setCalendarId(calendar.get().getId());\n+        json.setCalendarName(calendar.get().getLabel());\n+        json.setCalendarData(calendar.get().getIcal());\n+        calendar.get().getUrlOpt().ifPresent(json::setCalendarUrl);\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar.get()).stream().map(\n+                schedule -> Map.ofEntries(\n+                        Map.entry(\"id\", schedule.getId().toString()),\n+                        Map.entry(\"name\", schedule.getName())\n+                )\n+        ).collect(Collectors.toList()));\n+\n+        return json(response, json);\n+    }\n+\n+    /**\n+     * Processes a GET request to get the names of all calendars visible to given user\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorized user\n+     * @return the result JSON object\n+     */\n+    public static String getCalendarNames(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+\n+        List<String> calendarNames = new ArrayList<>();\n+        calendarNames.add(\"<None>\");\n+        calendarNames.addAll(MM.listCalendarLabelsByUser(user));\n+\n+        return json(response, calendarNames);\n+    }\n+\n+    /**\n+     * Create or update a schedule\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getScheduleName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.schedule.name.empty\"\n+            ))));\n+        }\n+        createOrUpdateSchedule(user, json);\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Create or update a calendar\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String saveCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        if (json.getCalendarName().isBlank()) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.empty\"\n+            ))));\n+        }\n+        else if (json.getCalendarName().equals(\"<None>\")) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.name.invalid\"\n+            ))));\n+        }\n+        else if (json.getCalendarUrl().isBlank() && json.getCalendarData() == null) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.data.empty\"\n+            ))));\n+        }\n+\n+        MM.lookupCalendarByUserAndLabel(user, json.getCalendarName()).ifPresentOrElse(\n+                /* update existing calendar */\n+                calendar -> {\n+                    if (json.getCalendarId() == null) {\n+                        Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.exists\", json.getCalendarName()\n+                        ))));\n+                    }\n+                    Map<String, String> details = new HashMap<>();\n+                    String rescheduleStrategy = json.getRescheduleStrategy();\n+                    details.put(\"label\", calendar.getLabel());\n+                    if (!json.getCalendarUrl().isBlank()) {\n+                        details.put(\"url\", json.getCalendarUrl());\n+                    }\n+                    else {\n+                        details.put(\"ical\", json.getCalendarData());\n+                    }\n+\n+                    try {\n+                        List<RescheduleResult> results = MM.updateCalendar(user, calendar.getLabel(), details,\n+                                MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy))\n+                        );\n+                        handleRescheduleResult(results, rescheduleStrategy);\n+                    }\n+                    catch (DownloadException e) {\n+                        Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                        ))));\n+                    }\n+                },\n+                /* Create new calendar */\n+                () -> {\n+                    if (json.getCalendarData() == null) {\n+                        try {\n+                            MM.createMaintenanceCalendarWithUrl(user, json.getCalendarName(), json.getCalendarUrl());\n+                        }\n+                        catch (DownloadException e) {\n+                            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+                            ))));\n+                        }\n+                    }\n+                    else {\n+                        MM.createMaintenanceCalendar(user, json.getCalendarName(), json.getCalendarData());\n+                    }\n+                }\n+        );\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void createOrUpdateSchedule(User user, MaintenanceWindowJson json) {\n+        try {\n+            if (json.getScheduleId() == null) {\n+                Optional<MaintenanceCalendar> calendar = Optional.empty();\n+                if (!json.getCalendarName().equals(\"<None>\")) {\n+                    /* Lookup calendar */\n+                    calendar = Optional.of(MM.lookupCalendarByUserAndLabel(user, json.getCalendarName())\n+                            .orElseThrow(() -> new EntityNotExistsException(LOCAL.getMessage(\n+                                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+                            )))\n+                    );\n+                }\n+                /* Create new schedule */\n+                MM.createMaintenanceSchedule(\n+                        user,\n+                        json.getScheduleName(),\n+                        MaintenanceSchedule.ScheduleType.lookupByLabel(json.getScheduleType().toLowerCase()),\n+                        calendar\n+                );\n+            }\n+            else {\n+                /* Update existing schedule */\n+                String rescheduleStrategy = json.getRescheduleStrategy();\n+                Map<String, String> details = new HashMap<>();\n+                details.put(\"type\", json.getScheduleType().toLowerCase());\n+                //details.put(\"name\", json.getScheduleName());\n+                String label = json.getCalendarName();\n+                details.put(\"calendar\", label.equals(\"<None>\") ? \"\" : label);\n+                RescheduleResult result = MM.updateMaintenanceSchedule(user, json.getScheduleName(), details,\n+                        MM.mapRescheduleStrategyStrings(List.of(rescheduleStrategy)));\n+                handleRescheduleResult(List.of(result), rescheduleStrategy);\n+            }\n+        }\n+        catch (EntityNotExistsException | EntityExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(e.getMessage())));\n+        }\n+    }\n+\n+    /**\n+     * Refresh calendar data from url\n+     *\n+     * @param request the request object\n+     * @param response the response obejct\n+     * @param user the authorized user\n+     * @return string containing the JSON response\n+     */\n+    public static String refreshCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        try {\n+            String strategy = json.getRescheduleStrategy();\n+            List<RescheduleResult> results = MM.refreshCalendar(\n+                    user,\n+                    json.getCalendarName(),\n+                    MM.mapRescheduleStrategyStrings(List.of(strategy))\n+            );\n+            handleRescheduleResult(results, strategy);\n+        }\n+        catch (EntityNotExistsException e) {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.not.exists\", json.getCalendarName()\n+            ))));\n+        }\n+        catch (DownloadException e) {\n+            Spark.halt(HttpStatus.SC_INTERNAL_SERVER_ERROR, GSON.toJson(ResultJson.error(LOCAL.getMessage(\n+                    \"maintenance.calendar.fetch.error\", json.getCalendarUrl()\n+            ))));\n+        }\n+\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given schedule\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteSchedule(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getScheduleName();\n+        Optional<MaintenanceSchedule> schedule = MM.lookupMaintenanceScheduleByUserAndName(user, name);\n+        if (schedule.isPresent()) {\n+            MM.remove(user, schedule.get());\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    /**\n+     * Deletes a given calendar\n+     *\n+     * @param request the request object\n+     * @param response the response object\n+     * @param user the authorzed user\n+     * @return the result JSON object\n+     */\n+    public static String deleteCalendar(Request request, Response response, User user) {\n+        response.type(\"application/json\");\n+        MaintenanceWindowJson json = GSON.fromJson(request.body(), MaintenanceWindowJson.class);\n+\n+        String name = json.getCalendarName();\n+        Optional<MaintenanceCalendar> calendar = MM.lookupCalendarByUserAndLabel(user, name);\n+        if (calendar.isPresent()) {\n+            String strategy = json.getRescheduleStrategy();\n+            handleRescheduleResult(MM.remove(user, calendar.get(), strategy.equals(\"Cancel\")), strategy);\n+        }\n+        else {\n+            Spark.halt(HttpStatus.SC_BAD_REQUEST);\n+        }\n+        return json(response, ResultJson.success());\n+    }\n+\n+    private static void handleRescheduleResult(List<RescheduleResult> results, String strategy) {\n+        results.forEach(result -> {\n+            if (!result.isSuccess()) {\n+                String affectedSchedule = result.getScheduleName();\n+                String message = LOCAL.getMessage(strategy.equals(\"Cancel\") ?\n+                        \"maintenance.action.reschedule.error.cancel\" :\n+                        \"maintenance.action.reschedule.error.fail\",\n+                        affectedSchedule);\n+                Spark.halt(HttpStatus.SC_BAD_REQUEST, GSON.toJson(ResultJson.error(message)));\n+            }\n+        });\n+    }\n+\n+    private static List<MaintenanceWindowJson> schedulesToJson(List<MaintenanceSchedule> schedules) {\n+        return schedules.stream().map(MaintenanceController::scheduleToJson).collect(Collectors.toList());\n+    }\n+\n+    private static List<MaintenanceWindowJson> calendarsToJson(User user, List<MaintenanceCalendar> calendars) {\n+        return calendars.stream().map(calendar -> calendarToJson(user, calendar)).collect(Collectors.toList());\n+    }\n+\n+    private static MaintenanceWindowJson scheduleToJson(MaintenanceSchedule schedule) {\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        json.setScheduleId(schedule.getId());\n+        json.setScheduleName(schedule.getName());\n+        schedule.getCalendarOpt().ifPresent(maintenanceCalendar -> {\n+            json.setCalendarId(maintenanceCalendar.getId());\n+            json.setCalendarName(maintenanceCalendar.getLabel());\n+        });\n+\n+        return json;\n+    }\n+\n+    private static MaintenanceWindowJson calendarToJson(User user, MaintenanceCalendar calendar) {\n+        MaintenanceWindowJson json = new MaintenanceWindowJson();\n+\n+        json.setCalendarId(calendar.getId());\n+        json.setCalendarName(calendar.getLabel());\n+\n+        json.setScheduleNames(MM.listMaintenanceSchedulesByCalendar(user, calendar).stream().map(", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NDA3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437444079", "bodyText": "Long-term todo: As we discussed, maybe this could be split into Schedule and Calendar object.", "author": "hustodemon", "createdAt": "2020-06-09T13:58:39Z", "path": "java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.gson;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * JSON representation of the Maintenance Window scheduling\n+ */\n+public class MaintenanceWindowJson {", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437447403", "bodyText": "Is this annotation needed?", "author": "hustodemon", "createdAt": "2020-06-09T14:02:58Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -246,6 +246,34 @@ protected void save(MaintenanceCalendar calendar) {\n             .list();\n     }\n \n+    /**\n+     * List Maintenance Schedules belonging to the given User\n+     * @param user the user\n+     * @return a list of Maintenance Schedules\n+     */\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxMjM3OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440012379", "bodyText": "All the other queries in this file added by mc also seem to have it. And it gets rid of annoying warnings", "author": "parlt91", "createdAt": "2020-06-15T08:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcxODQ3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440718477", "bodyText": "What warnings? I don't see any.", "author": "hustodemon", "createdAt": "2020-06-16T09:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM0MjkzNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r441342934", "bodyText": "It displays a unchecked assignment warning if removed.\nAnyway I am not opposed to removing it, but we should stay consistent.\nEither remove or add it everywhere.", "author": "parlt91", "createdAt": "2020-06-17T07:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0NzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437538675", "bodyText": "Just questioning to make sure: all users are allowed to reach these pages right? If so, then this is fine.", "author": "ncounter", "createdAt": "2020-06-09T15:51:48Z", "path": "java/code/src/com/suse/manager/webui/menu/MenuTree.java", "diffHunk": "@@ -288,6 +288,9 @@\n                 .addChild(new MenuItem(\"Action Chains\").withPrimaryUrl(\"/rhn/schedule/ActionChains.do\")\n                     .withAltUrl(\"/rhn/schedule/ActionChain.do\"))\n                 .addChild(new MenuItem(\"Recurring States\").withPrimaryUrl(\"/rhn/manager/schedule/recurring-states\"))\n+                .addChild(new MenuItem(\"Maintenance Windows\").withDir(\"/rhn/manager/schedule/maintenance\")", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxMDExMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r440010111", "bodyText": "I am not sure actually. 'normal' users are not allowed to edit/delete, but I don't know about viewing schedules/calendars. I will clarify this.", "author": "parlt91", "createdAt": "2020-06-15T08:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NTc4Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r441675786", "bodyText": "Restricted destructive operations to OrgAdmin user only as discussed", "author": "parlt91", "createdAt": "2020-06-17T16:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUzODY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0MDMyNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2169#discussion_r437540324", "bodyText": "I'd better drop possible values of a filed: what if in the future the set change? This comment would be outdated but not easy to catch.", "author": "ncounter", "createdAt": "2020-06-09T15:53:59Z", "path": "java/code/src/com/suse/manager/webui/utils/gson/MaintenanceWindowJson.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package com.suse.manager.webui.utils.gson;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * JSON representation of the Maintenance Window scheduling\n+ */\n+public class MaintenanceWindowJson {\n+\n+    /** schedule ID */\n+    private Long scheduleId;\n+\n+    /** Name of the schedule */\n+    private String scheduleName;\n+\n+    /** Type of the schedule\n+     * Either SINGLE or MULTI", "originalCommit": "fad7e771e35a0934287854b648845d8e45d17550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "url": "https://github.com/uyuni-project/uyuni/commit/6a1ac4fea475de12ad0c122cfee1ef94c3a26546", "message": "Add controller class\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:53:33Z", "type": "commit"}, {"oid": "34c7ffa04e688a3cf004983b12dd6d512d1e0218", "url": "https://github.com/uyuni-project/uyuni/commit/34c7ffa04e688a3cf004983b12dd6d512d1e0218", "message": "Add controller to the Router\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "7830e6a7ffad5f43c913db6c010163a60be9cc96", "url": "https://github.com/uyuni-project/uyuni/commit/7830e6a7ffad5f43c913db6c010163a60be9cc96", "message": "Add jade file\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "89a68df73e8cda44e7f71c2ac4721b5620bac116", "url": "https://github.com/uyuni-project/uyuni/commit/89a68df73e8cda44e7f71c2ac4721b5620bac116", "message": "Add Json class for maintenance schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "23bb872d4b3d82e926df04d1c78d9576221136ec", "url": "https://github.com/uyuni-project/uyuni/commit/23bb872d4b3d82e926df04d1c78d9576221136ec", "message": "Create MenuTree item\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "e55b7d02a125d4c597e4964403506de41fd8b78a", "url": "https://github.com/uyuni-project/uyuni/commit/e55b7d02a125d4c597e4964403506de41fd8b78a", "message": "Add maintenance schedules index\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c8505882c2e8a5d151560cb834d85bb31f8a5c76", "url": "https://github.com/uyuni-project/uyuni/commit/c8505882c2e8a5d151560cb834d85bb31f8a5c76", "message": "Add maintenance schedule base class\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "68206de2c3938cf4763c01a26a4aad4436f915a2", "url": "https://github.com/uyuni-project/uyuni/commit/68206de2c3938cf4763c01a26a4aad4436f915a2", "message": "Add ui for listing maintenance schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "acfd8ba635af3bc9ec6be784223f4f8519819e96", "url": "https://github.com/uyuni-project/uyuni/commit/acfd8ba635af3bc9ec6be784223f4f8519819e96", "message": "Add ui page for creating/editing schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "61a8d0f48c0cb6cbc40ad97dbfc060e22f9f7505", "url": "https://github.com/uyuni-project/uyuni/commit/61a8d0f48c0cb6cbc40ad97dbfc060e22f9f7505", "message": "Add details view for schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "8abfe8352759118cc7aa98048969e7d1c3bef008", "url": "https://github.com/uyuni-project/uyuni/commit/8abfe8352759118cc7aa98048969e7d1c3bef008", "message": "Controller save method\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "70428e1dc85d962f754b17de3a6dd2e337cb81de", "url": "https://github.com/uyuni-project/uyuni/commit/70428e1dc85d962f754b17de3a6dd2e337cb81de", "message": "Make 'Add Calendar' button instead of checkbox\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c6bb6c6227ed1251fe984b9e6843c37710262170", "url": "https://github.com/uyuni-project/uyuni/commit/c6bb6c6227ed1251fe984b9e6843c37710262170", "message": "Add Calendar column in schedule list\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "2b0558ff9b9a422ce1e8b2c4329fa8ffabba805d", "url": "https://github.com/uyuni-project/uyuni/commit/2b0558ff9b9a422ce1e8b2c4329fa8ffabba805d", "message": "Fix details view not rendering\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "c0eb71f4a9d780607cc4497000e2b53d88977efd", "url": "https://github.com/uyuni-project/uyuni/commit/c0eb71f4a9d780607cc4497000e2b53d88977efd", "message": "Add deleting of schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "e8ff6eaaa29bce7c96221465bd43adafe947940e", "url": "https://github.com/uyuni-project/uyuni/commit/e8ff6eaaa29bce7c96221465bd43adafe947940e", "message": "Get detailed schedule info\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "59b65698458620b58c1149ba449c81a56f90d37f", "url": "https://github.com/uyuni-project/uyuni/commit/59b65698458620b58c1149ba449c81a56f90d37f", "message": "Rename maintenance-schedules.jade -> maintenance-windows.jade\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:10Z", "type": "commit"}, {"oid": "dc86231dd68ca2d9cf07aaaa2afa45e220c50357", "url": "https://github.com/uyuni-project/uyuni/commit/dc86231dd68ca2d9cf07aaaa2afa45e220c50357", "message": "Update MenuTree, add translation strings\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "e1a5686378751272e9e3f6b44d2d84a4d82cef4e", "url": "https://github.com/uyuni-project/uyuni/commit/e1a5686378751272e9e3f6b44d2d84a4d82cef4e", "message": "Add type to distinguish between calendar and schedule in UI\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "28393778459bed891c23e8b7ad473e5e5fa2e2fa", "url": "https://github.com/uyuni-project/uyuni/commit/28393778459bed891c23e8b7ad473e5e5fa2e2fa", "message": "Rename maintenance-schedules -> maintenance-windows\n\nSince these components will handle both schedules and calendar\nmaintenance-windows seems to be a more adequate name.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "53b6fe538367a42ddf9ccef880a0003203a91f66", "url": "https://github.com/uyuni-project/uyuni/commit/53b6fe538367a42ddf9ccef880a0003203a91f66", "message": "Rename MaintenanceScheduleJson -> MaintenanceWindowJson\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "a1bd2bbfdf079cd7de1e72e77da27b29f65b724d", "url": "https://github.com/uyuni-project/uyuni/commit/a1bd2bbfdf079cd7de1e72e77da27b29f65b724d", "message": "Adapt controller class to handle schedules/calendars individually\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "be62705601a12a6df135a4511c23a9a47a5e15a5", "url": "https://github.com/uyuni-project/uyuni/commit/be62705601a12a6df135a4511c23a9a47a5e15a5", "message": "Change webui to reflect controller changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "29307ae0f98bb4cb8309c38950b5f33bdb9d2989", "url": "https://github.com/uyuni-project/uyuni/commit/29307ae0f98bb4cb8309c38950b5f33bdb9d2989", "message": "Add missing javadoc, fix checkstyle\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "87d1d3dd3a48079470839a5e7e22e891057015dc", "url": "https://github.com/uyuni-project/uyuni/commit/87d1d3dd3a48079470839a5e7e22e891057015dc", "message": "Display ical file in details, distinguish between schedule/calendar\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "a74a24ed1adfa6d0f57cbd3172830a0f254df6a3", "url": "https://github.com/uyuni-project/uyuni/commit/a74a24ed1adfa6d0f57cbd3172830a0f254df6a3", "message": "Handle reschedule strategy\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "d5cee2cace92759f154264316f1df0583d456f8d", "url": "https://github.com/uyuni-project/uyuni/commit/d5cee2cace92759f154264316f1df0583d456f8d", "message": "Support refreshing calendars from url\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "50c03dce6350a53599cc131a4b1a81cb438e7282", "url": "https://github.com/uyuni-project/uyuni/commit/50c03dce6350a53599cc131a4b1a81cb438e7282", "message": "Create links to calendar/schedule details in list\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "31aa0d16e49186c0cafae67102bde46a48114e89", "url": "https://github.com/uyuni-project/uyuni/commit/31aa0d16e49186c0cafae67102bde46a48114e89", "message": "Add queries to get schedule/calendar objects\n\nRename listScheduleNamesByCalendar -> listMaintenanceSchedulesByCalendar\nto clarify the behavior.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:54:11Z", "type": "commit"}, {"oid": "b75484f87a00eb1210aae53a26ffbd46896606e9", "url": "https://github.com/uyuni-project/uyuni/commit/b75484f87a00eb1210aae53a26ffbd46896606e9", "message": "Add localization to the controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "89b61c2a23603511459b9ec9687ae0b8ec4c4d72", "url": "https://github.com/uyuni-project/uyuni/commit/89b61c2a23603511459b9ec9687ae0b8ec4c4d72", "message": "Fix calendar data refresh\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "7ef882c4b967e2885edfd14bf2f3fb79abfab93e", "url": "https://github.com/uyuni-project/uyuni/commit/7ef882c4b967e2885edfd14bf2f3fb79abfab93e", "message": "Move styling to its own css file\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-15T14:55:51Z", "type": "commit"}, {"oid": "eaf1d9911b21394aa97d5b235146f90307901e8c", "url": "https://github.com/uyuni-project/uyuni/commit/eaf1d9911b21394aa97d5b235146f90307901e8c", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-16T07:32:13Z", "type": "forcePushed"}, {"oid": "fea7795d3938893af6bc10ea8cd92697c9c1012d", "url": "https://github.com/uyuni-project/uyuni/commit/fea7795d3938893af6bc10ea8cd92697c9c1012d", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-16T16:20:39Z", "type": "forcePushed"}, {"oid": "2a9c70a4713f7a17118b803af8cb0840dbd0ea0a", "url": "https://github.com/uyuni-project/uyuni/commit/2a9c70a4713f7a17118b803af8cb0840dbd0ea0a", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T09:38:37Z", "type": "forcePushed"}, {"oid": "057260017842f4807c0b0a04706ef3d5297149cd", "url": "https://github.com/uyuni-project/uyuni/commit/057260017842f4807c0b0a04706ef3d5297149cd", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:26:12Z", "type": "forcePushed"}, {"oid": "e9e49c2292695fc30271fee1c836e69f049aa653", "url": "https://github.com/uyuni-project/uyuni/commit/e9e49c2292695fc30271fee1c836e69f049aa653", "message": "Add requested changes\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:34Z", "type": "commit"}, {"oid": "70eef68b15725ecc9b578e8da6c57dc10db882c9", "url": "https://github.com/uyuni-project/uyuni/commit/70eef68b15725ecc9b578e8da6c57dc10db882c9", "message": "Display upcoming maintenance windows in schedule details view\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "commit"}, {"oid": "5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "url": "https://github.com/uyuni-project/uyuni/commit/5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "commit"}, {"oid": "5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "url": "https://github.com/uyuni-project/uyuni/commit/5e0992585eaf4c2d432f36bd7a49451d88c79eb2", "message": "Fix: Remove empty box displayed in schedule list if no calendar assigned\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-17T16:37:37Z", "type": "forcePushed"}, {"oid": "fbb4c4f98a963b7093582dbe94c3bad1c14fbaac", "url": "https://github.com/uyuni-project/uyuni/commit/fbb4c4f98a963b7093582dbe94c3bad1c14fbaac", "message": "Use the Table component for the details view\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-06-18T16:25:24Z", "type": "commit"}]}