{"pr_number": 2309, "pr_title": "Add checks for maintenance windows during recurring actions", "pr_createdAt": "2020-06-08T19:37:50Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2309", "timeline": [{"oid": "45fb65ce60b2bff6cb285d85f6f37e120fd9362a", "url": "https://github.com/uyuni-project/uyuni/commit/45fb65ce60b2bff6cb285d85f6f37e120fd9362a", "message": "fixed stuff", "committedDate": "2020-06-08T19:40:55Z", "type": "forcePushed"}, {"oid": "89183d3ddaaf848ff78a04860de0a1c6f1645b02", "url": "https://github.com/uyuni-project/uyuni/commit/89183d3ddaaf848ff78a04860de0a1c6f1645b02", "message": "test", "committedDate": "2020-06-08T20:01:08Z", "type": "forcePushed"}, {"oid": "3c2c56466ab9f17ae0c2fd62bbf402903d85143c", "url": "https://github.com/uyuni-project/uyuni/commit/3c2c56466ab9f17ae0c2fd62bbf402903d85143c", "message": "test", "committedDate": "2020-06-08T20:51:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIwOTcxMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r437209713", "bodyText": "This must return true. A System which does not have a schedule is allways in maintenance mode. This is the current behavior, you can schedule things at any time.\n(The final return false in Line 2205 is correct. When a client has a schedule but no calendar, this client is 'never' in maintenance mode.", "author": "mcalmer", "createdAt": "2020-06-09T07:57:23Z", "path": "java/code/src/com/redhat/rhn/domain/server/Server.java", "diffHunk": "@@ -2183,4 +2187,21 @@ public String getChannelHost() {\n         return this.getFirstServerPath().map(p -> p.getHostname())\n                 .orElseGet(() -> ConfigDefaults.get().getCobblerHost());\n     }\n+\n+    public boolean checkIfInMaintenanceMode() {\n+        if (maintenanceSchedule == null) {\n+            return false;", "originalCommit": "c925039ff9de5b37abce686a5d32b7211f1e8249", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzIwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r437213201", "bodyText": "Here we need to be careful with the performance. When this one action has 10000 clients this gets slow.\nWhile having checkIfInMaintenanceMode() for a single client is required, we should also have a function which does a mass checking.\nMaybe something like this:\nList<Long> systemIdsMaintenanceMode(List<MinionServer> minions)\n\nCould be implemented in MaintenanceManager.java", "author": "mcalmer", "createdAt": "2020-06-09T08:03:28Z", "path": "java/code/src/com/redhat/rhn/taskomatic/task/RecurringStateApplyJob.java", "diffHunk": "@@ -57,9 +60,14 @@ public void execute(JobExecutionContext context) throws JobExecutionException {\n     }\n \n     private void scheduleAction(JobExecutionContext context, RecurringAction action) {\n-        List<Long> minionIds = action.computeMinions().stream()\n-                .map(m -> m.getId())\n-                .collect(Collectors.toList());\n+        Map<Boolean, List<MinionServer>> sepList = action.computeMinions().stream()\n+              .collect(Collectors.partitioningBy(m -> m.checkIfInMaintenanceMode()));\n+        sepList.get(true).stream()\n+                       .forEach(m -> Log.info(m.getMinionId() + \" is in Maintenance mode, skipping recurring action.\"));", "originalCommit": "c925039ff9de5b37abce686a5d32b7211f1e8249", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAxOTkyNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r440019926", "bodyText": "In the end, we check one-by-one, unfortunately (we don't have a method for checking whether a bunch of minions has maintenance windows in their calendars (currently it's implemented one by one)). But I agree that having the method suggested by you (systemIdsMaintenanceMode(mids)) should be there. Then we can optimize it somehow.", "author": "hustodemon", "createdAt": "2020-06-15T08:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNjQwMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r440026400", "bodyText": "One more note about the logging: In order to prevent a flood of log messages, I think the following would make sense:\n\nlog a warning with the count of skipped minions\nlog a debug message (in case log level is >= DEBUG) with the minion ids (can explode)", "author": "hustodemon", "createdAt": "2020-06-15T08:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNzk3MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r440027970", "bodyText": "What about mapping clients to maintenance schedules first and than just make this test for every maintenance schedule. This would limit the number of test a lot .", "author": "mcalmer", "createdAt": "2020-06-15T08:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4ODEyMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r440688123", "bodyText": "that was my initial thinking was making a bool status thing on the server...", "author": "mseidl", "createdAt": "2020-06-16T08:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIxMzIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMzNjg5Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r437336892", "bodyText": "Move the whole logic  to MaintenanceManager (create a new method boolean isServerInMaintenanceMode(server) and call it with this). This will be clearer. There is no reason the Server class should do anything with CalendarComponent.\nAs for the implementation of the method itself:\n\nfix the formatting\nthis\n\n            if (cc.isEmpty()) {\n              return false;\n            }\n            else {\n                return true;\n            }\n\ncan be replaced with\nreturn !cc.isEmpty();", "author": "hustodemon", "createdAt": "2020-06-09T11:29:05Z", "path": "java/code/src/com/redhat/rhn/domain/server/Server.java", "diffHunk": "@@ -2183,4 +2187,21 @@ public String getChannelHost() {\n         return this.getFirstServerPath().map(p -> p.getHostname())\n                 .orElseGet(() -> ConfigDefaults.get().getCobblerHost());\n     }\n+\n+    public boolean checkIfInMaintenanceMode() {\n+        if (maintenanceSchedule == null) {\n+            return true;\n+        }\n+        if (!maintenanceSchedule.getCalendarOpt().isEmpty()) {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getDateFromSchedule(this.maintenanceSchedule);\n+            if (cc.isEmpty()) {\n+              return false;\n+            }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }", "originalCommit": "f351186bc4a7f3ad575d730fb153ebe3a20385f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8d6c4076a5d1a86f2ed2ab8eaac4c726426a1c3", "url": "https://github.com/uyuni-project/uyuni/commit/f8d6c4076a5d1a86f2ed2ab8eaac4c726426a1c3", "message": "remove unused import", "committedDate": "2020-06-16T08:40:49Z", "type": "forcePushed"}, {"oid": "1b20930410051ecdf6bf6f4b97e995e73fa9d955", "url": "https://github.com/uyuni-project/uyuni/commit/1b20930410051ecdf6bf6f4b97e995e73fa9d955", "message": "remove unused import", "committedDate": "2020-06-16T09:12:01Z", "type": "forcePushed"}, {"oid": "df33bad8d71c624f2819db85e9c780b783b66bd0", "url": "https://github.com/uyuni-project/uyuni/commit/df33bad8d71c624f2819db85e9c780b783b66bd0", "message": "update changelog", "committedDate": "2020-06-17T07:25:34Z", "type": "forcePushed"}, {"oid": "8de8cad9d89a25805f0e33603ad5da9928236023", "url": "https://github.com/uyuni-project/uyuni/commit/8de8cad9d89a25805f0e33603ad5da9928236023", "message": "update changelog", "committedDate": "2020-06-17T07:30:31Z", "type": "forcePushed"}, {"oid": "c6d98795057285acb4e23515385eef31f1595151", "url": "https://github.com/uyuni-project/uyuni/commit/c6d98795057285acb4e23515385eef31f1595151", "message": "update changelog", "committedDate": "2020-06-17T08:17:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwNzA4OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441407088", "bodyText": "I think this is incomplete. Just a variable without setter and getter does not make sense.\nFor now I would remove the changes for this class", "author": "mcalmer", "createdAt": "2020-06-17T09:22:55Z", "path": "java/code/src/com/redhat/rhn/domain/server/Server.java", "diffHunk": "@@ -128,6 +129,7 @@\n     private String hostname;\n     private boolean payg;\n     private MaintenanceSchedule maintenanceSchedule;\n+    private boolean inMaintenanceMode;", "originalCommit": "c6d98795057285acb4e23515385eef31f1595151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwODk0MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441508941", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     Map<Boolean, List<MinionServer>> sepList = minions.stream()\n          \n          \n            \n                          .collect(Collectors.partitioningBy(m -> MaintenanceManager.checkIfInMaintenanceMode(m)));\n          \n          \n            \n                    Map<Optional<MaintenanceSchedule>, List<MinionServer>> minionsBySchedule = minions\n          \n          \n            \n                            .stream().collect(Collectors.groupingBy(m -> m.getMaintenanceScheduleOpt()));\n          \n          \n            \n            \n          \n          \n            \n                    Map<Boolean, List<MinionServer>> sepList = minionsBySchedule.entrySet()\n          \n          \n            \n                            .stream().collect(Collectors.partitioningBy(mapEntry -> {\n          \n          \n            \n                                Optional<MaintenanceSchedule> optSchedule = mapEntry.getKey();\n          \n          \n            \n                                if (optSchedule.isEmpty()) {\n          \n          \n            \n                                    return true;\n          \n          \n            \n                                }\n          \n          \n            \n            \n          \n          \n            \n                                MaintenanceManager mm = MaintenanceManager.instance();\n          \n          \n            \n                                return !mm.getDateFromSchedule(optSchedule.get()).isEmpty();\n          \n          \n            \n                                }, Collectors.flatMapping(e -> e.getValue().stream(), Collectors.toList())));\n          \n      \n    \n    \n  \n\nLooks funny, but it should speedup things a lot as we do not check every single minion, but group them by maintenance schedules first and than perform the check only for every schedule.\nThe method checkIfMaintenanceMode is now unused. But it could be used in the Server object to perform this check for a single system.", "author": "mcalmer", "createdAt": "2020-06-17T12:33:09Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,57 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getDateFromSchedule(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise false\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        if (server.getMaintenanceScheduleOpt().isEmpty()) {\n+            return true;\n+        }\n+        else {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getDateFromSchedule(server.getMaintenanceScheduleOpt().get());\n+            return cc.isEmpty();\n+        }\n+    }\n+\n+    /**\n+     * Log the number of servers skipped and if debugging is enabled list the server names\n+     *\n+     * @param servers the list of servers to log\n+     */\n+    public static void logSkippedMinions(List<MinionServer> servers) {\n+       log.warn(\"Skipping action for \" + servers.size() + \" minions.\");\n+       if (log.isDebugEnabled()) {\n+          String serverNames = servers.stream()\n+          .map(m -> m.getName())\n+          .collect(Collectors.joining(\",\"));\n+          log.debug(\"Skipped minion ids: \" + serverNames);\n+       }\n+    }\n+\n+    /**\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n+     *\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public static List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+         Map<Boolean, List<MinionServer>> sepList = minions.stream()\n+              .collect(Collectors.partitioningBy(m -> MaintenanceManager.checkIfInMaintenanceMode(m)));", "originalCommit": "c6d98795057285acb4e23515385eef31f1595151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0MDQyNQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441640425", "bodyText": "@mcalmer I like the idea, but I think the implementation could be simplified, maybe something like this would be more readable. The idea here is to compute which maintenance schedules have maintenance mode right now (this happens once per schedule (see the distinct)). Then we use this information for filtering minions:\nMaintenanceManager mm = MaintenanceManager.instance(); // (btw, the `systemIdsMaintenanceMode` would better not be static, so we could avoid this assignment)\n\n// schedules that are in maintenance mode RIGHT NOW\nSet<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n        .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n        .distinct()\n        .filter(sched -> !mm.getDateFromSchedule(sched).isEmpty())\n        .collect(Collectors.toSet());\n\nList<Long> minionsInMaintMode = minions.stream()\n        .filter(minion -> minion.getMaintenanceScheduleOpt()\n                .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n                .orElse(true)) // or that have no maintenance schedule whatsoever\n        .map(minion -> minion.getId())\n        .collect(toList());\n\nreturn minionsInMaintMode;", "author": "hustodemon", "createdAt": "2020-06-17T15:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwODk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI3MDg5MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r442270890", "bodyText": "We need both lists, the list which could execute the action and the one for the skipped systems as we want to log.\nBut it can also be achieved by creating the list of minions which can execute the action, and than use this:\nminions.stream().filter(m -> !minionsInMaintMode.contains(m)).collect(toList())\n\nfor the logging", "author": "mcalmer", "createdAt": "2020-06-18T14:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwODk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDY4MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441514680", "bodyText": "ms.getCalendarOpt().get() is a potential NullPointerException", "author": "mcalmer", "createdAt": "2020-06-17T12:42:55Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,57 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getDateFromSchedule(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));", "originalCommit": "c6d98795057285acb4e23515385eef31f1595151", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNzM5Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441517393", "bodyText": "Can we find a better name for this method?", "author": "mcalmer", "createdAt": "2020-06-17T12:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MzYzMw==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444753633", "bodyText": "There is still the problem with the potential NPEx. If the schedule does not have a calendar, it's the same as if it had a calendar with no events, the code should check for something like that:\n        return ms.getCalendarOpt()\n                .map(cal -> getScheduleEventsAtDate(new Date(), ms, parseCalendar(cal)))\n                .orElse(Collections.emptyList());", "author": "hustodemon", "createdAt": "2020-06-24T09:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM5MzkxMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r445393911", "bodyText": "As mc and me said: there is a high risk of NPEx (schedule can exist without calendar, so the risk is pretty high). You can fix this using the code I pasted in my latest comment.", "author": "hustodemon", "createdAt": "2020-06-25T08:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjE0OQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r441516149", "bodyText": "I think we need to return !cc.isEmpty().\nCalendarComponents are mtching maintenance windows. So when we find something we are in maintenance mode,\notherwise - when empty - we are not.", "author": "mcalmer", "createdAt": "2020-06-17T12:45:21Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,57 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getDateFromSchedule(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise false\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        if (server.getMaintenanceScheduleOpt().isEmpty()) {\n+            return true;\n+        }\n+        else {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getDateFromSchedule(server.getMaintenanceScheduleOpt().get());\n+            return cc.isEmpty();", "originalCommit": "c6d98795057285acb4e23515385eef31f1595151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "86dd19584f4a8452c7e14d9b5bfca3a05dd9156d", "url": "https://github.com/uyuni-project/uyuni/commit/86dd19584f4a8452c7e14d9b5bfca3a05dd9156d", "message": "update changelog", "committedDate": "2020-06-19T07:36:11Z", "type": "forcePushed"}, {"oid": "8bd52ec2cd06a162c04a66221b9506b9c619db57", "url": "https://github.com/uyuni-project/uyuni/commit/8bd52ec2cd06a162c04a66221b9506b9c619db57", "message": "update changelog", "committedDate": "2020-06-22T12:21:28Z", "type": "forcePushed"}, {"oid": "7ccc8a642085d5c07cf5ec0d0ee3b39c3023a3c1", "url": "https://github.com/uyuni-project/uyuni/commit/7ccc8a642085d5c07cf5ec0d0ee3b39c3023a3c1", "message": "update changelog", "committedDate": "2020-06-23T07:18:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA4NTQyMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444085420", "bodyText": "The stream -> collect is not necessary. You can feed action.computeMinions() directly to systemidsMaintenanceMode.", "author": "hustodemon", "createdAt": "2020-06-23T09:22:13Z", "path": "java/code/src/com/redhat/rhn/taskomatic/task/RecurringStateApplyJob.java", "diffHunk": "@@ -57,9 +58,9 @@ public void execute(JobExecutionContext context) throws JobExecutionException {\n     }\n \n     private void scheduleAction(JobExecutionContext context, RecurringAction action) {\n-        List<Long> minionIds = action.computeMinions().stream()\n-                .map(m -> m.getId())\n-                .collect(Collectors.toList());\n+        List<Long> minionIds = MaintenanceManager.systemIdsMaintenanceMode(action.computeMinions().stream()", "originalCommit": "7ccc8a642085d5c07cf5ec0d0ee3b39c3023a3c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "884cb7e4ef694f50a70660e79d6a5559036aa95e", "url": "https://github.com/uyuni-project/uyuni/commit/884cb7e4ef694f50a70660e79d6a5559036aa95e", "message": "update changelog", "committedDate": "2020-06-23T09:30:46Z", "type": "forcePushed"}, {"oid": "19fe2fd44f69b7653cf364ac5d8708369d39cee8", "url": "https://github.com/uyuni-project/uyuni/commit/19fe2fd44f69b7653cf364ac5d8708369d39cee8", "message": "update changelog", "committedDate": "2020-06-24T06:53:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MDA2Ng==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444750066", "bodyText": "The body of the method looks incorrectly formatted. Please reformat in your IDE or use the following snippet.\n        MaintenanceManager mm = MaintenanceManager.instance();\n        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n                .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n                .distinct()\n                .filter(sched -> !mm.getCalendarForNow(sched).isEmpty())\n                .collect(Collectors.toSet());\n\n        List<Long> minionsInMaintMode = minions.stream()\n                .filter(minion -> minion.getMaintenanceScheduleOpt()\n                        .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n                        .orElse(true)) // or that have no maintenance schedule whatsoever\n                .map(minion -> minion.getId())\n                .collect(toList());\n\n        List<MinionServer> logList = minions.stream()\n                .filter(m -> !minionsInMaintMode.contains(m))\n                .collect(Collectors.toList());\n        logSkippedMinions(logList);\n\n        return minionsInMaintMode;", "author": "hustodemon", "createdAt": "2020-06-24T09:02:01Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,71 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        if (server.getMaintenanceScheduleOpt().isEmpty()) {\n+            return true;\n+        }\n+        else {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getCalendarForNow(server.getMaintenanceScheduleOpt().get());\n+            return !cc.isEmpty();\n+        }\n+    }\n+\n+    /**\n+     * Log the number of servers skipped and if debugging is enabled list the server names\n+     *\n+     * @param servers the list of servers to log\n+     */\n+    public static void logSkippedMinions(List<MinionServer> servers) {\n+       log.warn(\"Skipping action for \" + servers.size() + \" minions.\");\n+       if (log.isDebugEnabled()) {\n+          String serverNames = servers.stream()\n+          .map(m -> m.getName())\n+          .collect(Collectors.joining(\",\"));\n+          log.debug(\"Skipped minion ids: \" + serverNames);\n+       }\n+    }\n+\n+    /**\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n+     *\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public static List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+        MaintenanceManager mm = MaintenanceManager.instance();\n+        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n+            .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n+            .distinct()\n+            .filter(sched -> !mm.getCalendarForNow(sched).isEmpty())\n+            .collect(Collectors.toSet());\n+\n+        List<Long> minionsInMaintMode = minions.stream()\n+            .filter(minion -> minion.getMaintenanceScheduleOpt()\n+            .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n+            .orElse(true)) // or that have no maintenance schedule whatsoever\n+            .map(minion -> minion.getId())\n+            .collect(toList());\n+\n+         List<MinionServer> logList = minions.stream()\n+                 .filter(m -> !minionsInMaintMode.contains(m))\n+                 .collect(Collectors.toList());\n+         logSkippedMinions(logList);\n+\n+         return minionsInMaintMode;", "originalCommit": "19fe2fd44f69b7653cf364ac5d8708369d39cee8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1MjQ1MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444752450", "bodyText": "Collectors are not used anymore. Remove the import please.", "author": "hustodemon", "createdAt": "2020-06-24T09:06:07Z", "path": "java/code/src/com/redhat/rhn/taskomatic/task/RecurringStateApplyJob.java", "diffHunk": "@@ -57,9 +58,8 @@ public void execute(JobExecutionContext context) throws JobExecutionException {\n     }\n \n     private void scheduleAction(JobExecutionContext context, RecurringAction action) {\n-        List<Long> minionIds = action.computeMinions().stream()\n-                .map(m -> m.getId())\n-                .collect(Collectors.toList());", "originalCommit": "19fe2fd44f69b7653cf364ac5d8708369d39cee8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTcwNg==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444755706", "bodyText": "Do you want to log names or ids? The message says ids, but you're logging names.", "author": "hustodemon", "createdAt": "2020-06-24T09:11:35Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,71 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        if (server.getMaintenanceScheduleOpt().isEmpty()) {\n+            return true;\n+        }\n+        else {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getCalendarForNow(server.getMaintenanceScheduleOpt().get());\n+            return !cc.isEmpty();\n+        }\n+    }\n+\n+    /**\n+     * Log the number of servers skipped and if debugging is enabled list the server names\n+     *\n+     * @param servers the list of servers to log\n+     */\n+    public static void logSkippedMinions(List<MinionServer> servers) {\n+       log.warn(\"Skipping action for \" + servers.size() + \" minions.\");\n+       if (log.isDebugEnabled()) {\n+          String serverNames = servers.stream()\n+          .map(m -> m.getName())", "originalCommit": "19fe2fd44f69b7653cf364ac5d8708369d39cee8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc2NzA0MA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444767040", "bodyText": "well names would make more sense in this case?  as it's what the people will see", "author": "mseidl", "createdAt": "2020-06-24T09:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDgxMTI3Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444811273", "bodyText": "Yes, they are more readable, but they are not unique. The readability is not that important here anyway (it's a log). So I think ids are a better option here.", "author": "hustodemon", "createdAt": "2020-06-24T10:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1ODY4OA==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r444758688", "bodyText": "A proper way of doing this would be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (server.getMaintenanceScheduleOpt().isEmpty()) {\n          \n          \n            \n                        return true;\n          \n          \n            \n                    }\n          \n          \n            \n                    else {\n          \n          \n            \n                        MaintenanceManager mm = MaintenanceManager.instance();\n          \n          \n            \n                        Collection<CalendarComponent> cc = mm.getCalendarForNow(server.getMaintenanceScheduleOpt().get());\n          \n          \n            \n                        return !cc.isEmpty();\n          \n          \n            \n                    }\n          \n          \n            \n                    return server.getMaintenanceScheduleOpt()\n          \n          \n            \n                            .map(sched -> !mm.getCalendarForNow(sched).isEmpty())\n          \n          \n            \n                            .orElse(true);", "author": "hustodemon", "createdAt": "2020-06-24T09:16:39Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -695,6 +696,71 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return getScheduleEventsAtDate(new Date(), ms, parseCalendar(ms.getCalendarOpt().get()));\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        if (server.getMaintenanceScheduleOpt().isEmpty()) {\n+            return true;\n+        }\n+        else {\n+            MaintenanceManager mm = MaintenanceManager.instance();\n+            Collection<CalendarComponent> cc = mm.getCalendarForNow(server.getMaintenanceScheduleOpt().get());\n+            return !cc.isEmpty();\n+        }", "originalCommit": "19fe2fd44f69b7653cf364ac5d8708369d39cee8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b365b6ec7e2de9516e66a420ae3694b673df4df6", "url": "https://github.com/uyuni-project/uyuni/commit/b365b6ec7e2de9516e66a420ae3694b673df4df6", "message": "update changelog", "committedDate": "2020-06-24T23:07:00Z", "type": "forcePushed"}, {"oid": "cb2f76506dddeffa69f5b686f4d3c540344643eb", "url": "https://github.com/uyuni-project/uyuni/commit/cb2f76506dddeffa69f5b686f4d3c540344643eb", "message": "update changelog", "committedDate": "2020-06-24T23:21:17Z", "type": "forcePushed"}, {"oid": "fbf32a9270949713e3b25bf2c3654f92ce284cdd", "url": "https://github.com/uyuni-project/uyuni/commit/fbf32a9270949713e3b25bf2c3654f92ce284cdd", "message": "update changelog", "committedDate": "2020-06-26T06:41:46Z", "type": "forcePushed"}, {"oid": "7446c53afcf360c274ebd9f6352c546a572e45af", "url": "https://github.com/uyuni-project/uyuni/commit/7446c53afcf360c274ebd9f6352c546a572e45af", "message": "update changelog", "committedDate": "2020-06-29T09:13:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU0MTAwMQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2309#discussion_r447541001", "bodyText": "This should check the id presence, not the whole entity.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             .filter(m -> !minionsInMaintMode.contains(m))\n          \n          \n            \n                             .filter(m -> !minionsInMaintMode.contains(m.getId()))", "author": "hustodemon", "createdAt": "2020-06-30T09:22:39Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -777,6 +778,70 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return ms.getCalendarOpt()\n+                .map(cal -> getScheduleEventsAtDate(new Date(), ms, parseCalendar(cal)))\n+                .orElse(Collections.emptyList());\n+    }\n+\n+    /**\n+     * Check if system is in maintenance mode\n+     *\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n+     */\n+    public static boolean checkIfInMaintenanceMode(MinionServer server) {\n+        MaintenanceManager mm = MaintenanceManager.instance();\n+        return server.getMaintenanceScheduleOpt()\n+                .map(schedule -> !mm.getCalendarForNow(schedule)\n+                .isEmpty())\n+                .orElse(true);\n+    }\n+\n+    /**\n+     * Log the number of servers skipped and if debugging is enabled list the server ids\n+     *\n+     * @param servers the list of servers to log\n+     */\n+    public static void logSkippedMinions(List<MinionServer> servers) {\n+       log.warn(\"Skipping action for \" + servers.size() + \" minions.\");\n+       if (log.isDebugEnabled()) {\n+          String serverNames = servers.stream()\n+          .map(m -> m.getId().toString())\n+          .collect(Collectors.joining(\",\"));\n+          log.debug(\"Skipped minion ids: \" + serverNames);\n+       }\n+    }\n+\n+    /**\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n+     *\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public static List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+        MaintenanceManager mm = MaintenanceManager.instance();\n+        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n+                .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n+                .distinct()\n+                .filter(sched -> !mm.getCalendarForNow(sched).isEmpty())\n+                .collect(Collectors.toSet());\n+\n+        List<Long> minionsInMaintMode = minions.stream()\n+                .filter(minion -> minion.getMaintenanceScheduleOpt()\n+                .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n+                .orElse(true)) // or that have no maintenance schedule whatsoever\n+                .map(minion -> minion.getId())\n+                .collect(toList());\n+\n+         List<MinionServer> logList = minions.stream()\n+                 .filter(m -> !minionsInMaintMode.contains(m))", "originalCommit": "7446c53afcf360c274ebd9f6352c546a572e45af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4bcd18a7f89d1ce2a7c78b90490d8a344e220181", "url": "https://github.com/uyuni-project/uyuni/commit/4bcd18a7f89d1ce2a7c78b90490d8a344e220181", "message": "Check if minion is in maintenance mode when running recurring actions", "committedDate": "2020-06-30T09:40:00Z", "type": "commit"}, {"oid": "b2129ea8605dd61eba7b91377c16ecdbf8d32855", "url": "https://github.com/uyuni-project/uyuni/commit/b2129ea8605dd61eba7b91377c16ecdbf8d32855", "message": "update changelog", "committedDate": "2020-06-30T09:40:00Z", "type": "commit"}, {"oid": "b2129ea8605dd61eba7b91377c16ecdbf8d32855", "url": "https://github.com/uyuni-project/uyuni/commit/b2129ea8605dd61eba7b91377c16ecdbf8d32855", "message": "update changelog", "committedDate": "2020-06-30T09:40:00Z", "type": "forcePushed"}]}