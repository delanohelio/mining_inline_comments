{"pr_number": 1951, "pr_title": "Recurring action hibernate entity", "pr_createdAt": "2020-02-25T07:45:36Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/1951", "timeline": [{"oid": "43657ca77bbbd6a9bb51711e939453aa3c671ed9", "url": "https://github.com/uyuni-project/uyuni/commit/43657ca77bbbd6a9bb51711e939453aa3c671ed9", "message": "[WIP] Add more JUnit tests\n\n`testListGroupRecurringAction` still failing\nNeed to catch LookupException.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T07:34:34Z", "type": "forcePushed"}, {"oid": "4bf53b578d7db35cbbc354d2a51c076df9b51cfc", "url": "https://github.com/uyuni-project/uyuni/commit/4bf53b578d7db35cbbc354d2a51c076df9b51cfc", "message": "Create hibernate entity\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T07:50:14Z", "type": "commit"}, {"oid": "1d39f807f0155fb17aeae497be2cef7786bd855b", "url": "https://github.com/uyuni-project/uyuni/commit/1d39f807f0155fb17aeae497be2cef7786bd855b", "message": "Add javadocs and create entity for groups/orgs\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T07:50:14Z", "type": "commit"}, {"oid": "a8d0642fabf68c3f35dc41105506dfd8d9d0f5b7", "url": "https://github.com/uyuni-project/uyuni/commit/a8d0642fabf68c3f35dc41105506dfd8d9d0f5b7", "message": "[WIP] Add more JUnit tests\n\n`testListGroupRecurringAction` still failing\nNeed to catch LookupException.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T07:50:14Z", "type": "forcePushed"}, {"oid": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "url": "https://github.com/uyuni-project/uyuni/commit/8fb55f8d79b8b2bb580836a6968d9dd99a940933", "message": "Add JUnit tests\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T09:06:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MjM1NQ==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383772355", "bodyText": "Nit: I'd suggest a clearer phrasing here. When I see Recurring Action group, then I think about groups of recurring actions, not about a recurring action for group. I'd be more for \"Recurring Action for server group implementation\", or similar.", "author": "hustodemon", "createdAt": "2020-02-25T09:56:42Z", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/GroupRecurringAction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.domain.recurringactions;\n+\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.ServerGroup;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+\n+import com.suse.manager.utils.MinionServerUtils;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.Entity;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+\n+/**\n+ * Recurring Action group implementation", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3Mjc0Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383772742", "bodyText": "This could be simplified by using ServerGroupTestUtils.createManaged(user) to create a group.", "author": "hustodemon", "createdAt": "2020-02-25T09:57:19Z", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.redhat.rhn.domain.recurringactions.test;\n+\n+import com.redhat.rhn.domain.org.OrgFactory;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.TestUtils;\n+\n+import java.util.List;\n+\n+public class RecurringActionFactoryTest extends BaseTestCaseWithUser {\n+\n+    public void testListMinionRecurringAction() throws Exception {\n+        var action = new MinionRecurringAction();\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+        action.setMinion(minion);\n+        RecurringActionFactory.save(action);\n+\n+        assertEquals(List.of(action), RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListGroupRecurringAction() {\n+        var action = new GroupRecurringAction();\n+        var group = ServerGroupFactory.create(", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzU4MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383773580", "bodyText": "Small nitpick: using INSTANCE for singletons seems to be more frequent in the code. Consider using it too.", "author": "hustodemon", "createdAt": "2020-02-25T09:58:45Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3MzkzNA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383773934", "bodyText": "Nit: plural.", "author": "hustodemon", "createdAt": "2020-02-25T09:59:17Z", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.redhat.rhn.domain.recurringactions.test;\n+\n+import com.redhat.rhn.domain.org.OrgFactory;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.server.ServerGroupFactory;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.TestUtils;\n+\n+import java.util.List;\n+\n+public class RecurringActionFactoryTest extends BaseTestCaseWithUser {\n+\n+    public void testListMinionRecurringAction() throws Exception {", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDQ5MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383774490", "bodyText": "Please use the plural in the name (as we do in the Factory class, after all): listMinionRecurringActions. The same goes for the rest of the list* methods in this class.", "author": "hustodemon", "createdAt": "2020-02-25T10:00:12Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NDc4OA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383774788", "bodyText": "Please use plural here too.", "author": "hustodemon", "createdAt": "2020-02-25T10:00:42Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.redhat.rhn.manager.recurringactions.test;\n+\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.org.Org;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.UserTestUtils;\n+\n+import org.jmock.Expectations;\n+import org.jmock.Mockery;\n+import org.jmock.integration.junit3.JUnit3Mockery;\n+import org.jmock.lib.concurrent.Synchroniser;\n+import org.jmock.lib.legacy.ClassImposteriser;\n+\n+import java.util.List;\n+\n+public class RecurringActionManagerTest extends BaseTestCaseWithUser {\n+\n+    private static final Mockery CONTEXT = new JUnit3Mockery() {{\n+        setThreadingPolicy(new Synchroniser());\n+    }};\n+\n+    private Org anotherOrg;\n+    private User anotherUser;\n+\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        user.addPermanentRole(RoleFactory.ORG_ADMIN);\n+        anotherOrg = UserTestUtils.createNewOrgFull(\"anotherOrg\");\n+        anotherUser = UserTestUtils.createUser(\"anotherUser\", anotherOrg.getId());\n+    }\n+\n+    public void testCreateMinionRecurringAction() throws Exception {\n+        CONTEXT.setImposteriser(ClassImposteriser.INSTANCE);\n+        TaskomaticApi taskomaticMock = CONTEXT.mock(TaskomaticApi.class);\n+        RecurringActionManager.setTaskomaticApi(taskomaticMock);\n+\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+\n+        CONTEXT.checking(new Expectations() { {\n+            allowing(taskomaticMock).scheduleSatBunch(with(any(User.class)), with(any(String.class)), with(any(String.class)), with(any(String.class)));\n+        } });\n+\n+        try {\n+            RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+\n+        RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, user);\n+        assertNotEmpty(RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListMinionRecurringAction() throws Exception {", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3NjM3Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383776377", "bodyText": "You could pass the cause exception to the newly created PermissionException as follows:\nPermissionException(\"User does not have access to group\", e);", "author": "hustodemon", "createdAt": "2020-02-25T10:03:33Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        return RecurringActionFactory.listMinionRecurringActions(minionId);\n+    }\n+\n+    /**\n+     * List group recurring action with group id\n+     *\n+     * @param groupId id of the group\n+     * @param user the user\n+     * @return list of group recurring actions\n+     */\n+    public static List<GroupRecurringAction> listGroupRecurringAction(long groupId, User user) {\n+        ServerGroupManager groupManager = ServerGroupManager.getInstance();\n+        if (!user.hasRole(RoleFactory.SYSTEM_GROUP_ADMIN)) {\n+            throw new PermissionException(\"User does not have access to group\");\n+        }\n+        try {\n+            groupManager.lookup(groupId, user);\n+            return RecurringActionFactory.listGroupRecurringActions(groupId);\n+        }\n+        catch (LookupException e) {\n+            throw new PermissionException(\"User does not have access to group\");", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc3OTY1Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383779657", "bodyText": "Hmm, I think the presence lookup could confuse the readers a bit. Could you add here an explicit comment, that we're doing it for permission checking?", "author": "hustodemon", "createdAt": "2020-02-25T10:09:26Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        return RecurringActionFactory.listMinionRecurringActions(minionId);\n+    }\n+\n+    /**\n+     * List group recurring action with group id\n+     *\n+     * @param groupId id of the group\n+     * @param user the user\n+     * @return list of group recurring actions\n+     */\n+    public static List<GroupRecurringAction> listGroupRecurringAction(long groupId, User user) {\n+        ServerGroupManager groupManager = ServerGroupManager.getInstance();\n+        if (!user.hasRole(RoleFactory.SYSTEM_GROUP_ADMIN)) {\n+            throw new PermissionException(\"User does not have access to group\");\n+        }\n+        try {\n+            groupManager.lookup(groupId, user);", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MDM4MA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383780380", "bodyText": "Suggestion: instead of isAvailableUser, we could use ensureAvailableToUser. With this we'll get a more detailed exception info:\n        try {\n            SystemManager.ensureAvailableToUser(user, minionId);\n        }\n        catch (LookupException e) {\n            throw new PermissionException(\"Minion not accessible to user\", e);\n        }", "author": "hustodemon", "createdAt": "2020-02-25T10:10:49Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/RecurringActionManager.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.redhat.rhn.manager.recurringactions;\n+\n+import com.redhat.rhn.common.hibernate.LookupException;\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.MinionServer;\n+import com.redhat.rhn.domain.server.MinionServerFactory;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.EntityNotExistsException;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.manager.system.SystemManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.taskomatic.TaskomaticApiException;\n+\n+import java.util.List;\n+\n+/**\n+ * RecurringActionManager\n+ * @version $Rev$\n+ */\n+public class RecurringActionManager {\n+\n+    private static  TaskomaticApi taskomaticApi = new TaskomaticApi();\n+    private static final RecurringActionManager MANAGER = new RecurringActionManager();\n+\n+    /**\n+     * Set the {@link TaskomaticApi} instance to use. Only needed for unit tests.\n+     * @param taskomaticApiIn the {@link TaskomaticApi}\n+     */\n+    public static void setTaskomaticApi(TaskomaticApi taskomaticApiIn) {\n+        taskomaticApi = taskomaticApiIn;\n+    }\n+    /**\n+     * Singleton Instance to get manager object\n+     * @return an instance of the manager\n+     */\n+    public static RecurringActionManager getInstance() {\n+        return MANAGER;\n+    }\n+\n+    /**\n+     * Private constructor.\n+     */\n+    private RecurringActionManager() {\n+    }\n+\n+    /**\n+     * Create a new minion recurring action\n+     *\n+     * @param minionId id of the minion\n+     * @param cron the cron expression\n+     * @param testMode if test mode\n+     * @param active is is active\n+     * @param user the user\n+     * @throws TaskomaticApiException if TaskoSchedule creation fails\n+     */\n+    public static void createMinionRecurringAction(long minionId, String cron, boolean testMode,\n+                                                   boolean active, User user) throws TaskomaticApiException {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {\n+            throw new PermissionException(\"Minion not accessible to user\");\n+        }\n+        MinionServer minion = MinionServerFactory.lookupById(minionId)\n+                .orElseThrow(() -> new EntityNotExistsException(MinionServer.class, minionId));\n+        MinionRecurringAction action = new MinionRecurringAction(testMode, active, minion);\n+        RecurringActionFactory.save(action);\n+\n+        taskomaticApi.scheduleSatBunch(user, action.computeTaskoScheduleName(), \"recurring-state-apply-bunch\", cron);\n+    }\n+\n+    /**\n+     * List minion recurring action with minion id\n+     *\n+     * @param minionId id of the minion\n+     * @param user the user\n+     * @return list of minion recurring actions\n+     */\n+    public static List<MinionRecurringAction> listMinionRecurringAction(long minionId, User user) {\n+        if (!SystemManager.isAvailableToUser(user, minionId)) {", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4MTcyMA==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383781720", "bodyText": "This doesn't seem to be needed, as it's done in setUp already.", "author": "hustodemon", "createdAt": "2020-02-25T10:13:19Z", "path": "java/code/src/com/redhat/rhn/manager/recurringactions/test/RecurringActionManagerTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.redhat.rhn.manager.recurringactions.test;\n+\n+import com.redhat.rhn.common.security.PermissionException;\n+import com.redhat.rhn.domain.org.Org;\n+import com.redhat.rhn.domain.recurringactions.GroupRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.MinionRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.OrgRecurringAction;\n+import com.redhat.rhn.domain.recurringactions.RecurringActionFactory;\n+import com.redhat.rhn.domain.role.RoleFactory;\n+import com.redhat.rhn.domain.server.ManagedServerGroup;\n+import com.redhat.rhn.domain.server.test.MinionServerFactoryTest;\n+import com.redhat.rhn.domain.user.User;\n+import com.redhat.rhn.manager.recurringactions.RecurringActionManager;\n+import com.redhat.rhn.manager.system.ServerGroupManager;\n+import com.redhat.rhn.taskomatic.TaskomaticApi;\n+import com.redhat.rhn.testing.BaseTestCaseWithUser;\n+import com.redhat.rhn.testing.ServerGroupTestUtils;\n+import com.redhat.rhn.testing.UserTestUtils;\n+\n+import org.jmock.Expectations;\n+import org.jmock.Mockery;\n+import org.jmock.integration.junit3.JUnit3Mockery;\n+import org.jmock.lib.concurrent.Synchroniser;\n+import org.jmock.lib.legacy.ClassImposteriser;\n+\n+import java.util.List;\n+\n+public class RecurringActionManagerTest extends BaseTestCaseWithUser {\n+\n+    private static final Mockery CONTEXT = new JUnit3Mockery() {{\n+        setThreadingPolicy(new Synchroniser());\n+    }};\n+\n+    private Org anotherOrg;\n+    private User anotherUser;\n+\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        user.addPermanentRole(RoleFactory.ORG_ADMIN);\n+        anotherOrg = UserTestUtils.createNewOrgFull(\"anotherOrg\");\n+        anotherUser = UserTestUtils.createUser(\"anotherUser\", anotherOrg.getId());\n+    }\n+\n+    public void testCreateMinionRecurringAction() throws Exception {\n+        CONTEXT.setImposteriser(ClassImposteriser.INSTANCE);\n+        TaskomaticApi taskomaticMock = CONTEXT.mock(TaskomaticApi.class);\n+        RecurringActionManager.setTaskomaticApi(taskomaticMock);\n+\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+\n+        CONTEXT.checking(new Expectations() { {\n+            allowing(taskomaticMock).scheduleSatBunch(with(any(User.class)), with(any(String.class)), with(any(String.class)), with(any(String.class)));\n+        } });\n+\n+        try {\n+            RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+\n+        RecurringActionManager.createMinionRecurringAction(minion.getId(), \"\", false, false, user);\n+        assertNotEmpty(RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n+    }\n+\n+    public void testListMinionRecurringAction() throws Exception {\n+        var minion = MinionServerFactoryTest.createTestMinionServer(user);\n+        var action = new MinionRecurringAction();\n+        action.setMinion(minion);\n+        RecurringActionFactory.save(action);\n+\n+        assertEquals(List.of(action), RecurringActionManager.listMinionRecurringAction(minion.getId(), user));\n+\n+        try{\n+            RecurringActionManager.listMinionRecurringAction(minion.getId(), anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+    }\n+\n+    public void testListGroupRecurringAction() throws Exception {\n+        ServerGroupManager manager = ServerGroupManager.getInstance();\n+        ManagedServerGroup group = ServerGroupTestUtils.createManaged(user);\n+\n+        var action = new GroupRecurringAction();\n+        action.setGroup(group);\n+        RecurringActionFactory.save(action);\n+\n+        assertTrue(manager.canAccess(user, group));\n+        assertEquals(List.of(action), RecurringActionManager.listGroupRecurringAction(group.getId(), user));\n+\n+        try{\n+            RecurringActionManager.listGroupRecurringAction(group.getId(), anotherUser);\n+            fail(\"User shouldn't have access\");\n+        }\n+        catch (PermissionException e) {\n+            // no-op\n+        }\n+    }\n+\n+    public void testListOrgRecurringAction() throws Exception {\n+        var action = new OrgRecurringAction();\n+        action.setOrg(user.getOrg());\n+        RecurringActionFactory.save(action);\n+\n+        UserTestUtils.addUserRole(user, RoleFactory.ORG_ADMIN);", "originalCommit": "8fb55f8d79b8b2bb580836a6968d9dd99a940933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a9b58fe8426dca58cada5bbd4e1b13489cd6a496", "url": "https://github.com/uyuni-project/uyuni/commit/a9b58fe8426dca58cada5bbd4e1b13489cd6a496", "message": "Add JUnit tests\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T11:04:21Z", "type": "commit"}, {"oid": "a9b58fe8426dca58cada5bbd4e1b13489cd6a496", "url": "https://github.com/uyuni-project/uyuni/commit/a9b58fe8426dca58cada5bbd4e1b13489cd6a496", "message": "Add JUnit tests\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T11:04:21Z", "type": "forcePushed"}, {"oid": "a000330c33dd3be1c7be8cf9ac114a81a316024a", "url": "https://github.com/uyuni-project/uyuni/commit/a000330c33dd3be1c7be8cf9ac114a81a316024a", "message": "Use boxed Long for RecurringAction entity ID", "committedDate": "2020-02-25T11:50:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzQzMg==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r383867432", "bodyText": "There is two testListMinionRecurringActions tests. We should alter the existing one", "author": "parlt91", "createdAt": "2020-02-25T13:09:37Z", "path": "java/code/src/com/redhat/rhn/domain/recurringactions/test/RecurringActionFactoryTest.java", "diffHunk": "@@ -23,7 +23,43 @@ public void testListMinionRecurringActions() throws Exception {\n         assertEquals(List.of(action), RecurringActionFactory.listMinionRecurringActions(minion.getId()));\n     }\n \n-    public void testListGroupRecurringActions() {\n+    public void testListMinionRecurringActions() throws Exception {", "originalCommit": "e0ce6a9cec53c6e1fbbe797ee859444cbd3d1ab6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a03e06be1b98f6b340319cbc8dedbe702813404e", "url": "https://github.com/uyuni-project/uyuni/commit/a03e06be1b98f6b340319cbc8dedbe702813404e", "message": "Implement generating the taskomatic schedule label for recurring actions", "committedDate": "2020-02-25T14:01:47Z", "type": "commit"}, {"oid": "24e9672b1851b3f81478fd72c5fa962358f38575", "url": "https://github.com/uyuni-project/uyuni/commit/24e9672b1851b3f81478fd72c5fa962358f38575", "message": "Add creator User to RecurringAction", "committedDate": "2020-02-25T14:01:48Z", "type": "commit"}, {"oid": "06dcfa8ff5316d19a6d271ccb567ceaaed178d70", "url": "https://github.com/uyuni-project/uyuni/commit/06dcfa8ff5316d19a6d271ccb567ceaaed178d70", "message": "Migration for suseRecurringAction table", "committedDate": "2020-02-25T14:01:48Z", "type": "commit"}, {"oid": "3bede395de648bee8dc106d8fdceb9f0fc0a2323", "url": "https://github.com/uyuni-project/uyuni/commit/3bede395de648bee8dc106d8fdceb9f0fc0a2323", "message": "Recurring actions execution in taskomatic using hibernate entity", "committedDate": "2020-02-25T14:01:48Z", "type": "commit"}, {"oid": "d3d7758da1aa53469e56312c5492f1e1ec5ff642", "url": "https://github.com/uyuni-project/uyuni/commit/d3d7758da1aa53469e56312c5492f1e1ec5ff642", "message": "Postgres syntax", "committedDate": "2020-02-25T14:01:49Z", "type": "commit"}, {"oid": "d3d7758da1aa53469e56312c5492f1e1ec5ff642", "url": "https://github.com/uyuni-project/uyuni/commit/d3d7758da1aa53469e56312c5492f1e1ec5ff642", "message": "Postgres syntax", "committedDate": "2020-02-25T14:01:49Z", "type": "forcePushed"}, {"oid": "41d1367eb580509cbf5187bf915ff78d7ff3b4d6", "url": "https://github.com/uyuni-project/uyuni/commit/41d1367eb580509cbf5187bf915ff78d7ff3b4d6", "message": "Add name attribute to RecurringAction", "committedDate": "2020-02-25T14:05:11Z", "type": "commit"}, {"oid": "efe9d2e88b51c35af4f8d0c5683db9dcb90bbd4d", "url": "https://github.com/uyuni-project/uyuni/commit/efe9d2e88b51c35af4f8d0c5683db9dcb90bbd4d", "message": "Create unique index for Recurring Action names", "committedDate": "2020-02-25T14:21:13Z", "type": "commit"}, {"oid": "c526f984f307dd8db1b1b885c040d88d4eca7c8a", "url": "https://github.com/uyuni-project/uyuni/commit/c526f984f307dd8db1b1b885c040d88d4eca7c8a", "message": "Implement toString for RecurringAction implementations", "committedDate": "2020-02-25T14:35:05Z", "type": "commit"}, {"oid": "2760252bf0e6bbf8a259bf3d25bf7d500c48d0dc", "url": "https://github.com/uyuni-project/uyuni/commit/2760252bf0e6bbf8a259bf3d25bf7d500c48d0dc", "message": "Move recurring action related code to its own controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-25T14:59:39Z", "type": "commit"}, {"oid": "2a526958c884e89633cb62c0c552cf4571a0f9f1", "url": "https://github.com/uyuni-project/uyuni/commit/2a526958c884e89633cb62c0c552cf4571a0f9f1", "message": "Use own API endpoint for recurring actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-26T09:31:55Z", "type": "commit"}, {"oid": "60d8380a81f75a6885da65c6a6372ccf4dcebd71", "url": "https://github.com/uyuni-project/uyuni/commit/60d8380a81f75a6885da65c6a6372ccf4dcebd71", "message": "Make hibernate manager class non singleton\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-26T11:16:13Z", "type": "commit"}, {"oid": "6357aadf7767994d095f3b4ebac3bfed54bd0fc2", "url": "https://github.com/uyuni-project/uyuni/commit/6357aadf7767994d095f3b4ebac3bfed54bd0fc2", "message": "wip: hook the hibernate entities with the frontend controller", "committedDate": "2020-02-26T15:32:54Z", "type": "commit"}, {"oid": "a4694ccd820c8a890c47de49b3bb61e180a4e830", "url": "https://github.com/uyuni-project/uyuni/commit/a4694ccd820c8a890c47de49b3bb61e180a4e830", "message": "wip: hook the hibernate entities with the frontend controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-27T12:26:53Z", "type": "commit"}, {"oid": "a4694ccd820c8a890c47de49b3bb61e180a4e830", "url": "https://github.com/uyuni-project/uyuni/commit/a4694ccd820c8a890c47de49b3bb61e180a4e830", "message": "wip: hook the hibernate entities with the frontend controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-27T12:26:53Z", "type": "forcePushed"}, {"oid": "34d3c45f72b176a7316f2a96c82322ed1535fa5e", "url": "https://github.com/uyuni-project/uyuni/commit/34d3c45f72b176a7316f2a96c82322ed1535fa5e", "message": "Rename RecurringAction.TYPE enum to Type", "committedDate": "2020-02-27T16:50:58Z", "type": "commit"}, {"oid": "68e3f47e66e37f99048c9b575c2913d59103bca8", "url": "https://github.com/uyuni-project/uyuni/commit/68e3f47e66e37f99048c9b575c2913d59103bca8", "message": "[wip] Make the recurring schedule work for minions again\n\n(still some todos to be addressed)", "committedDate": "2020-02-27T16:50:58Z", "type": "commit"}, {"oid": "b9046f9f842b53d5caec7bc76d90d2987b6aebe0", "url": "https://github.com/uyuni-project/uyuni/commit/b9046f9f842b53d5caec7bc76d90d2987b6aebe0", "message": "Add cron expression to RecurringAction", "committedDate": "2020-02-27T16:50:58Z", "type": "commit"}, {"oid": "ae212165c7214f971ed96a365c2b7db1fdeabcb0", "url": "https://github.com/uyuni-project/uyuni/commit/ae212165c7214f971ed96a365c2b7db1fdeabcb0", "message": "Utilize the cronExpr from RecurringAction", "committedDate": "2020-02-27T16:50:58Z", "type": "commit"}, {"oid": "4fb73ccacf5d215dce8821a9a96351a130b18eee", "url": "https://github.com/uyuni-project/uyuni/commit/4fb73ccacf5d215dce8821a9a96351a130b18eee", "message": "RecurringAction extends BaseDomainHelper", "committedDate": "2020-02-27T16:50:58Z", "type": "commit"}, {"oid": "675a7cfb1d330449cea9dfb337a5fb06566582c6", "url": "https://github.com/uyuni-project/uyuni/commit/675a7cfb1d330449cea9dfb337a5fb06566582c6", "message": "Recurring Action name can't be null", "committedDate": "2020-02-27T16:50:59Z", "type": "commit"}, {"oid": "f36af294b25eff28778fd1d548c688b06984d233", "url": "https://github.com/uyuni-project/uyuni/commit/f36af294b25eff28778fd1d548c688b06984d233", "message": "Implement RecurringAction.getEntityId() to get the entity id for the frontend", "committedDate": "2020-02-27T16:50:59Z", "type": "commit"}, {"oid": "495bf94303b03736275e034e7980228e6c423f6b", "url": "https://github.com/uyuni-project/uyuni/commit/495bf94303b03736275e034e7980228e6c423f6b", "message": "Make the Recurring Action create,read and update operations work for the Org and Server Group too", "committedDate": "2020-02-27T16:50:59Z", "type": "commit"}, {"oid": "13f4e44e350a240e819ebe6119d31858ac4a6c59", "url": "https://github.com/uyuni-project/uyuni/commit/13f4e44e350a240e819ebe6119d31858ac4a6c59", "message": "Revert the TaskomaticApi changes", "committedDate": "2020-02-28T08:56:40Z", "type": "commit"}, {"oid": "8fb8c995ac37081546288f006023b5ec48616984", "url": "https://github.com/uyuni-project/uyuni/commit/8fb8c995ac37081546288f006023b5ec48616984", "message": "Implement permission checking for scheduling Recurring Actions via Taskomatic", "committedDate": "2020-02-28T09:40:59Z", "type": "commit"}, {"oid": "1db2dc9a52473b497fc7d057a43436dc545f1436", "url": "https://github.com/uyuni-project/uyuni/commit/1db2dc9a52473b497fc7d057a43436dc545f1436", "message": "Fix tests", "committedDate": "2020-02-28T09:41:22Z", "type": "commit"}, {"oid": "d66067e49a87c83f29d75da4feadfe5fd75ebc92", "url": "https://github.com/uyuni-project/uyuni/commit/d66067e49a87c83f29d75da4feadfe5fd75ebc92", "message": "Add delete action to Factory\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T11:41:20Z", "type": "commit"}, {"oid": "93156b78302872027e6cc73d36f3bf91b57933cb", "url": "https://github.com/uyuni-project/uyuni/commit/93156b78302872027e6cc73d36f3bf91b57933cb", "message": "Add permission checking for unscheduling recurring actions to taskomatic\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T11:41:26Z", "type": "commit"}, {"oid": "645c11e4caaf3f7d97ac50f72901c04075387e4e", "url": "https://github.com/uyuni-project/uyuni/commit/645c11e4caaf3f7d97ac50f72901c04075387e4e", "message": "Add function to unschedule/delete recurring actions\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T11:41:26Z", "type": "commit"}, {"oid": "adaaaf0d48db1abb48b6a78196c6f9e108010eba", "url": "https://github.com/uyuni-project/uyuni/commit/adaaaf0d48db1abb48b6a78196c6f9e108010eba", "message": "Implement delete operation\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T14:47:12Z", "type": "commit"}, {"oid": "adaaaf0d48db1abb48b6a78196c6f9e108010eba", "url": "https://github.com/uyuni-project/uyuni/commit/adaaaf0d48db1abb48b6a78196c6f9e108010eba", "message": "Implement delete operation\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T14:47:12Z", "type": "forcePushed"}, {"oid": "1e863a71666505906b863709dec8ea531e4d756a", "url": "https://github.com/uyuni-project/uyuni/commit/1e863a71666505906b863709dec8ea531e4d756a", "message": "Display schedule creation date in schedule details page\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-02-28T15:13:40Z", "type": "commit"}, {"oid": "8669a19ea16523207ba9725dc8d61ff780cf2d4f", "url": "https://github.com/uyuni-project/uyuni/commit/8669a19ea16523207ba9725dc8d61ff780cf2d4f", "message": "Implement hashCode & equals for RecurringAction subclasses", "committedDate": "2020-02-28T16:05:06Z", "type": "commit"}, {"oid": "0f74f0a4e4379b03513a34e4eef75e88066a3ae9", "url": "https://github.com/uyuni-project/uyuni/commit/0f74f0a4e4379b03513a34e4eef75e88066a3ae9", "message": "Implement lookup RecurringAction based on other entity attributes", "committedDate": "2020-03-02T14:11:09Z", "type": "commit"}, {"oid": "7a47492c3db3ce124a809199aa454b56e49b55bb", "url": "https://github.com/uyuni-project/uyuni/commit/7a47492c3db3ce124a809199aa454b56e49b55bb", "message": "Implement getType for RecurringAction", "committedDate": "2020-03-02T14:11:44Z", "type": "commit"}, {"oid": "36045c9a390e80a32f6bcf53ce39675c49ce6715", "url": "https://github.com/uyuni-project/uyuni/commit/36045c9a390e80a32f6bcf53ce39675c49ce6715", "message": "RecurringStateApplyJob: log with debug level, when action was skipped (previously info level was used)", "committedDate": "2020-03-02T14:12:17Z", "type": "commit"}, {"oid": "c2d26c2869e49c2a977cd38927c64fef39ca23a1", "url": "https://github.com/uyuni-project/uyuni/commit/c2d26c2869e49c2a977cd38927c64fef39ca23a1", "message": "HACK: Allow displaying messages from backend\n\nThis should be written in a clearer way.", "committedDate": "2020-03-02T14:16:01Z", "type": "commit"}, {"oid": "c2d26c2869e49c2a977cd38927c64fef39ca23a1", "url": "https://github.com/uyuni-project/uyuni/commit/c2d26c2869e49c2a977cd38927c64fef39ca23a1", "message": "HACK: Allow displaying messages from backend\n\nThis should be written in a clearer way.", "committedDate": "2020-03-02T14:16:01Z", "type": "forcePushed"}, {"oid": "3243daf43ded914d7796a2d4ab786e273bcb6ec8", "url": "https://github.com/uyuni-project/uyuni/commit/3243daf43ded914d7796a2d4ab786e273bcb6ec8", "message": "DB index on suseRecurringAction.target_type column", "committedDate": "2020-03-02T14:39:45Z", "type": "commit"}, {"oid": "5463bd9639913661fcde1f85b05f043a39258d58", "url": "https://github.com/uyuni-project/uyuni/commit/5463bd9639913661fcde1f85b05f043a39258d58", "message": "Clean up controller code\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-02T14:53:30Z", "type": "commit"}, {"oid": "3ab20613869a762b873163d4f1fc955d2f40ec6c", "url": "https://github.com/uyuni-project/uyuni/commit/3ab20613869a762b873163d4f1fc955d2f40ec6c", "message": "Remove unused frontend code\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-02T15:48:44Z", "type": "commit"}, {"oid": "b471b9bc90905548fd5c03f599704fa2355b84aa", "url": "https://github.com/uyuni-project/uyuni/commit/b471b9bc90905548fd5c03f599704fa2355b84aa", "message": "Initialize recurring-event-picker\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T07:37:01Z", "type": "commit"}, {"oid": "b471b9bc90905548fd5c03f599704fa2355b84aa", "url": "https://github.com/uyuni-project/uyuni/commit/b471b9bc90905548fd5c03f599704fa2355b84aa", "message": "Initialize recurring-event-picker\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T07:37:01Z", "type": "forcePushed"}, {"oid": "419c4b6d5b34294faf6797a331be9b9e903ca5dc", "url": "https://github.com/uyuni-project/uyuni/commit/419c4b6d5b34294faf6797a331be9b9e903ca5dc", "message": "Fix first Custom Quartz format char not being able to be deleted\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T08:59:15Z", "type": "commit"}, {"oid": "dba49d34a656978e528bee3c633dbc8cc2a642ac", "url": "https://github.com/uyuni-project/uyuni/commit/dba49d34a656978e528bee3c633dbc8cc2a642ac", "message": "Add Recurring States translation strings\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T09:59:04Z", "type": "commit"}, {"oid": "a4e4737629023f2aad6f2c854f1b281efbb8a362", "url": "https://github.com/uyuni-project/uyuni/commit/a4e4737629023f2aad6f2c854f1b281efbb8a362", "message": "Minor: extract create/lookup action to a standalone method for better readability", "committedDate": "2020-03-03T10:12:01Z", "type": "commit"}, {"oid": "219743ec5eb25db2bd8c7b23bb0e715740629fd8", "url": "https://github.com/uyuni-project/uyuni/commit/219743ec5eb25db2bd8c7b23bb0e715740629fd8", "message": "Drop SSM support for Recurring Actions for now", "committedDate": "2020-03-03T10:12:01Z", "type": "commit"}, {"oid": "ecd73b9183fc5b7b648c80d333e652962cf1e6ae", "url": "https://github.com/uyuni-project/uyuni/commit/ecd73b9183fc5b7b648c80d333e652962cf1e6ae", "message": "Address TODOs\n\nMany TODOs were just no-op.", "committedDate": "2020-03-03T10:18:47Z", "type": "commit"}, {"oid": "9445aa0cd9d3137c8daa510bbdf1b4573c18ba7c", "url": "https://github.com/uyuni-project/uyuni/commit/9445aa0cd9d3137c8daa510bbdf1b4573c18ba7c", "message": "Fix test: Previously we expected an ordered list", "committedDate": "2020-03-03T10:23:38Z", "type": "commit"}, {"oid": "18f9df5a5a02b3697cbe8d3b185a7760a22d7ac1", "url": "https://github.com/uyuni-project/uyuni/commit/18f9df5a5a02b3697cbe8d3b185a7760a22d7ac1", "message": "Minor: address most annoying checkstyle issues in tests", "committedDate": "2020-03-03T10:24:09Z", "type": "commit"}, {"oid": "f6d68a1557e20f093516fae84d2fa73300e544a2", "url": "https://github.com/uyuni-project/uyuni/commit/f6d68a1557e20f093516fae84d2fa73300e544a2", "message": "Add UI warning that picked times are in server timezone\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T11:50:31Z", "type": "commit"}, {"oid": "3638e48484d57c9a51ed751df9b330380d391aeb", "url": "https://github.com/uyuni-project/uyuni/commit/3638e48484d57c9a51ed751df9b330380d391aeb", "message": "Refactor recurring-event-picker\n\nRemove the active slider\nMake input fields half size\nMake hourly picker up/down instead of dropdown\nAdd example placeholder for custom cron string\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T12:40:03Z", "type": "commit"}, {"oid": "c89a4ae5696585cbe471fe888b1bdeceba8c5fe7", "url": "https://github.com/uyuni-project/uyuni/commit/c89a4ae5696585cbe471fe888b1bdeceba8c5fe7", "message": "Mark scheduleName as mandatory in the UI\n\nMake use of the Form component\nPossibly expand usage to other fields in future?\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-03T14:03:55Z", "type": "commit"}, {"oid": "600145eb736d3f640e4243e3734bcfe3d923f570", "url": "https://github.com/uyuni-project/uyuni/commit/600145eb736d3f640e4243e3734bcfe3d923f570", "message": "Fix: List actions in the same order", "committedDate": "2020-03-03T16:30:42Z", "type": "commit"}, {"oid": "788a7dff759217adacbfe498b3dc9f7f0e83d5c0", "url": "https://github.com/uyuni-project/uyuni/commit/788a7dff759217adacbfe498b3dc9f7f0e83d5c0", "message": "Implement listing of all Recurring Actions visible to user", "committedDate": "2020-03-03T16:30:42Z", "type": "commit"}, {"oid": "a856a999d2d4cac4efcc9069cd5e8bc50aad1330", "url": "https://github.com/uyuni-project/uyuni/commit/a856a999d2d4cac4efcc9069cd5e8bc50aad1330", "message": "More descriptive exceptions", "committedDate": "2020-03-04T09:22:42Z", "type": "commit"}, {"oid": "163e7120edf6d9a3d848369f5328f8712087f451", "url": "https://github.com/uyuni-project/uyuni/commit/163e7120edf6d9a3d848369f5328f8712087f451", "message": "Fix the permission check for OrgRecurringAction", "committedDate": "2020-03-04T09:55:36Z", "type": "commit"}, {"oid": "33060d096861e22415dac2d07d2233ccc5bf7ea5", "url": "https://github.com/uyuni-project/uyuni/commit/33060d096861e22415dac2d07d2233ccc5bf7ea5", "message": "Fix: Edit schedules in list of all schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T10:03:01Z", "type": "commit"}, {"oid": "2c86ccf35086a5919d094fb165e9b50457748a07", "url": "https://github.com/uyuni-project/uyuni/commit/2c86ccf35086a5919d094fb165e9b50457748a07", "message": "Make `InnerPanel` buttonsLeft prop optional\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T10:09:08Z", "type": "commit"}, {"oid": "fd7453b9b5327e092a1a272a0415e971b73c16e4", "url": "https://github.com/uyuni-project/uyuni/commit/fd7453b9b5327e092a1a272a0415e971b73c16e4", "message": "Hide recurring schedule create button for SSM\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T10:35:41Z", "type": "commit"}, {"oid": "6003577e55e14d6dd15d65702e2178c938edf22e", "url": "https://github.com/uyuni-project/uyuni/commit/6003577e55e14d6dd15d65702e2178c938edf22e", "message": "Fix: Admin>Organizations breadcrumb not showing for recurring states\n\nCleanup unneeded imports in MenuTree.java\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T11:34:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYyODY2Mg==", "url": "https://github.com/uyuni-project/uyuni/pull/1951#discussion_r387628662", "bodyText": "please update the Year", "author": "mcalmer", "createdAt": "2020-03-04T12:16:25Z", "path": "java/code/src/com/suse/manager/webui/controllers/RecurringActionController.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/**\n+ * Copyright (c) 2015 SUSE LLC", "originalCommit": "6003577e55e14d6dd15d65702e2178c938edf22e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c7dcb8ddae354595d5f9fe3a65731926ade0997", "url": "https://github.com/uyuni-project/uyuni/commit/6c7dcb8ddae354595d5f9fe3a65731926ade0997", "message": "Update Year in controller\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T13:03:41Z", "type": "commit"}, {"oid": "a6a4b28dede03e0312626ed58b3c72ad2ad16f2c", "url": "https://github.com/uyuni-project/uyuni/commit/a6a4b28dede03e0312626ed58b3c72ad2ad16f2c", "message": "Add null value handling for indices\n\nMove index creation to `schema/spacewalk/postgres/tables`.\nUpdate table dependencies.\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T13:04:30Z", "type": "commit"}, {"oid": "db881898e721936a3c7303dbcd17284272c0b563", "url": "https://github.com/uyuni-project/uyuni/commit/db881898e721936a3c7303dbcd17284272c0b563", "message": "Idempotent db migration", "committedDate": "2020-03-04T13:41:04Z", "type": "commit"}, {"oid": "e72e001f134b48561b698d36f17c9754c67f9db0", "url": "https://github.com/uyuni-project/uyuni/commit/e72e001f134b48561b698d36f17c9754c67f9db0", "message": "Fix: Use Create to add a schedule on listing all schedules\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T13:57:57Z", "type": "commit"}, {"oid": "3cdf9ff0c0e002ff61fb323f7b713fd5be34c270", "url": "https://github.com/uyuni-project/uyuni/commit/3cdf9ff0c0e002ff61fb323f7b713fd5be34c270", "message": "Add not null values to schema indices\n\nSigned-off-by: Pascal Arlt <parlt@suse.com>", "committedDate": "2020-03-04T16:22:25Z", "type": "commit"}]}