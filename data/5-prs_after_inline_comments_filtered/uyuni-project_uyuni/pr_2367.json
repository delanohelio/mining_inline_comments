{"pr_number": 2367, "pr_title": "Refactoring of the code related to maintenance windows", "pr_createdAt": "2020-06-29T13:10:10Z", "pr_url": "https://github.com/uyuni-project/uyuni/pull/2367", "timeline": [{"oid": "cb4ed69f2c762e7470262f983b06f04c879fce4f", "url": "https://github.com/uyuni-project/uyuni/commit/cb4ed69f2c762e7470262f983b06f04c879fce4f", "message": "Refactor: Better naming for methods", "committedDate": "2020-06-29T13:08:52Z", "type": "forcePushed"}, {"oid": "1513e323237fdb02e30a377ae8020619534b2623", "url": "https://github.com/uyuni-project/uyuni/commit/1513e323237fdb02e30a377ae8020619534b2623", "message": "Refactor: Better naming for methods", "committedDate": "2020-06-29T13:23:39Z", "type": "forcePushed"}, {"oid": "5f140721f0fb0a206aef2024b4810af89856ce19", "url": "https://github.com/uyuni-project/uyuni/commit/5f140721f0fb0a206aef2024b4810af89856ce19", "message": "Refactor: Better naming for methods", "committedDate": "2020-06-29T13:33:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTc1Mw==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447059753", "bodyText": "This give a warning in eclipse as \"m\" is a full minion object and we check a List<Long>.contains(Minion)", "author": "mcalmer", "createdAt": "2020-06-29T15:30:04Z", "path": "java/code/src/com/suse/manager/maintenance/MaintenanceManager.java", "diffHunk": "@@ -777,90 +640,67 @@ public boolean isActionInMaintenanceWindow(Action action, MaintenanceSchedule sc\n         return false;\n     }\n \n-    private Collection<CalendarComponent> getScheduleEventsAtDate(\n-            Date date, MaintenanceSchedule schedule, Optional<Calendar> calendarOpt) {\n-        if (calendarOpt.isEmpty()) {\n-            return emptySet();\n-        }\n-\n-        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n-        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n-        rules.add(new PeriodRule<>(p));\n-\n-        if (schedule.getScheduleType().equals(ScheduleType.MULTI)) {\n-            Summary summary = new Summary(schedule.getName());\n-            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(summary);\n-            rules.add(propertyRule);\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Predicate<CalendarComponent>[] comArr = new Predicate[rules.size()];\n-        comArr = rules.toArray(comArr);\n-\n-        Filter<CalendarComponent> filter = new Filter<>(comArr, Filter.MATCH_ALL);\n-\n-        return filter.filter(calendarOpt.get().getComponents(Component.VEVENT));\n+    private Collection<CalendarComponent> getCalendarForNow(MaintenanceSchedule ms) {\n+        return ms.getCalendarOpt()\n+                .map(cal -> icalUtils.getCalendarEventsAtDate(\n+                        new Date(), icalUtils.parseCalendar(cal),\n+                        getScheduleNameForMulti(ms)))\n+                .orElse(Collections.emptyList());\n     }\n \n     /**\n-     * Assign {@link MaintenanceSchedule} to given set of {@link Server}s.\n+     * Check if system is in maintenance mode\n      *\n-     * @param user the user\n-     * @param schedule the {@link MaintenanceSchedule}\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @throws IllegalArgumentException if systems have pending maintenance-only actions\n-     * @return the number of involved {@link Server}s\n+     * @param server the server to check\n+     * @return true when the action is inside of a maintenance window, otherwise falsegg\n      */\n-    public int assignScheduleToSystems(User user, MaintenanceSchedule schedule, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n-        ensureScheduleAccessible(user, schedule);\n-\n-        Set<Long> withMaintenanceActions = ServerFactory.filterSystemsWithPendingMaintOnlyActions(systemIds);\n-        if (!withMaintenanceActions.isEmpty()) {\n-            throw new IllegalArgumentException(\"Systems have pending maintenance-only actions:\" +\n-                    withMaintenanceActions);\n-        }\n-\n-        return ServerFactory.setMaintenanceScheduleToSystems(schedule, systemIds);\n+    public boolean isSystemInMaintenanceMode(MinionServer server) {\n+        return server.getMaintenanceScheduleOpt()\n+                .map(schedule -> !getCalendarForNow(schedule).isEmpty())\n+                .orElse(true);\n     }\n \n     /**\n-     * Retract {@link MaintenanceSchedule} from given set of {@link Server}s.\n+     * Given a list of minions, sorts by maintenance mode status, logs skipped minions\n      *\n-     * @param user the user\n-     * @param systemIds the set of {@link Server} IDs\n-     * @throws PermissionException if the user does not have access to given servers\n-     * @return the number of involved {@link Server}s\n-     */\n-    public int retractScheduleFromSystems(User user, Set<Long> systemIds) {\n-        ensureOrgAdmin(user);\n-        ensureSystemsAccessible(user, systemIds);\n+     * @param minions servers to check\n+     * @return List of minions in maintenance mode\n+     */\n+    public List<Long> systemIdsMaintenanceMode(List<MinionServer> minions) {\n+        Set<MaintenanceSchedule> schedulesInMaintMode = minions.stream()\n+                .flatMap(minion -> minion.getMaintenanceScheduleOpt().stream())\n+                .distinct()\n+                .filter(sched -> !getCalendarForNow(sched).isEmpty())\n+                .collect(Collectors.toSet());\n+\n+        List<Long> minionsInMaintMode = minions.stream()\n+                .filter(minion -> minion.getMaintenanceScheduleOpt()\n+                .map(sched -> schedulesInMaintMode.contains(sched)) // keep minions that have maintenance mode\n+                .orElse(true)) // or that have no maintenance schedule whatsoever\n+                .map(minion -> minion.getId())\n+                .collect(toList());\n \n-        return ServerFactory.setMaintenanceScheduleToSystems(null, systemIds);\n+         List<MinionServer> logList = minions.stream()\n+                 .filter(m -> !minionsInMaintMode.contains(m))", "originalCommit": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzcwOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447708", "bodyText": "This is an inherited code, but I'll fix that anyway. Good catch!", "author": "hustodemon", "createdAt": "2020-06-30T06:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA1OTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTI2Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447061267", "bodyText": "As this is now in CalendarFactory why is \"Calendar\" in the method name? I think this can refactored as well.", "author": "mcalmer", "createdAt": "2020-06-29T15:32:10Z", "path": "java/code/src/com/suse/manager/maintenance/factory/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "originalCommit": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzkzOA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447938", "bodyText": "Makes sense. Changing.", "author": "hustodemon", "createdAt": "2020-06-30T06:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTgxNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447061814", "bodyText": "Same as in CalendarFactory: as we are in ScheduleFactory, we do not need the word Schedule in the method name.", "author": "mcalmer", "createdAt": "2020-06-29T15:32:57Z", "path": "java/code/src/com/suse/manager/maintenance/factory/ScheduleFactory.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance.factory;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toSet;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * {@link HibernateFactory} for Maintenance Windows-related objects.\n+ */\n+public class ScheduleFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(ScheduleFactory.class);\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        saveObject(schedule);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceSchedule}\n+     * @param schedule to remove\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        removeObject(schedule);\n+    }\n+\n+    /**\n+     * List schedules by User and Calendar\n+     * @param user the User\n+     * @param calendar the Calendar\n+     * @return the list of Schedules\n+     */\n+    public List<MaintenanceSchedule> listSchedulesByUserAndCalendar(User user, MaintenanceCalendar calendar) {", "originalCommit": "976bc3c49ee295ebc03c5ad6ed4042fe6ac39995", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0NzgyMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447447820", "bodyText": "Makes sense. Changing.", "author": "hustodemon", "createdAt": "2020-06-30T06:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA2MTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447483012", "bodyText": "I guess that one slipped through the net ;)", "author": "parlt91", "createdAt": "2020-06-30T07:52:26Z", "path": "java/code/src/com/suse/manager/maintenance/IcalUtils.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.Optional.empty;\n+import static java.util.Optional.of;\n+import static java.util.Optional.ofNullable;\n+import static java.util.stream.Collectors.toList;\n+\n+import com.redhat.rhn.common.localization.LocalizationService;\n+\n+import com.suse.manager.model.maintenance.MaintenanceCalendar;\n+import com.suse.manager.model.maintenance.MaintenanceSchedule;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.log4j.Logger;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import net.fortuna.ical4j.data.CalendarBuilder;\n+import net.fortuna.ical4j.data.ParserException;\n+import net.fortuna.ical4j.filter.Filter;\n+import net.fortuna.ical4j.filter.HasPropertyRule;\n+import net.fortuna.ical4j.filter.PeriodRule;\n+import net.fortuna.ical4j.model.Calendar;\n+import net.fortuna.ical4j.model.Component;\n+import net.fortuna.ical4j.model.ComponentList;\n+import net.fortuna.ical4j.model.DateTime;\n+import net.fortuna.ical4j.model.Period;\n+import net.fortuna.ical4j.model.PeriodList;\n+import net.fortuna.ical4j.model.component.CalendarComponent;\n+import net.fortuna.ical4j.model.property.Summary;\n+\n+/**\n+ * Computation related to the ICalendar objects\n+ */\n+public class IcalUtils {\n+\n+    private static Logger log = Logger.getLogger(IcalUtils.class);\n+\n+    /**\n+     * Given MaintenanceSchedule calculate upcoming maintenance windows\n+     *\n+     * The windows are returned as a list of triples consisting of:\n+     * - window start date as a human-readable string\n+     * - window end date as a human-readable string\n+     * - start date as number of milliseconds since the epoch\n+     *\n+     * The formatting is done by {@link LocalizationService}.\n+     *\n+     * The upper limit of returned maintenance windows is currently hardcoded to 10.\n+     *\n+     * @param schedule the given MaintenanceSchedule\n+     * @return the optional upcoming maintenance windows\n+     */\n+    public Optional<List<MaintenanceWindowData>> calculateUpcomingMaintenanceWindows(MaintenanceSchedule schedule) {\n+        Optional<String> multiScheduleName = getScheduleNameForMulti(schedule);\n+\n+        Stream<Pair<Instant, Instant>> periodStream = schedule.getCalendarOpt()\n+                .flatMap(c -> parseCalendar(c))\n+                .map(c -> calculateUpcomingPeriods(c, multiScheduleName, Instant.now(), 10))\n+                .orElseGet(Stream::empty);\n+\n+        List<MaintenanceWindowData> result = periodStream\n+                .map(p -> new MaintenanceWindowData(p.getLeft(), p.getRight()))\n+                .collect(toList());\n+        return of(result);\n+    }\n+\n+    /**\n+     * Convenience method: return schedule name if the schedule type is MULTI, return empty otherwise\n+     * @param schedule the schedule\n+     * @return optional of schedule name\n+     */\n+    private static Optional<String> getScheduleNameForMulti(MaintenanceSchedule schedule) {\n+        if (schedule.getScheduleType() == MaintenanceSchedule.ScheduleType.MULTI) {\n+            return of(schedule.getName());\n+        }\n+        return empty();\n+    }\n+\n+    /**\n+     * THIS IS ONLY PUBLIC FOR TESTING.\n+     *\n+     * Calculate upcoming maintenance windows starting from given date based on calendar and optional filter name\n+     * (in case we're dealing with MULTI calendar and want to filter only events we're interested in).\n+     *\n+     * The algorithm only checks maintenance windows within roughly a year and a month since the startDate.\n+     *\n+     * @param calendar the {@link Calendar}\n+     * @param eventName for MULTI calendars: only deal with events with this name, filter out the rest\n+     * @param startDate the start date\n+     * @param limit upper limit of maintenance windows to return\n+     * @return the list of upcoming maintenance windows\n+     */\n+    public Stream<Pair<Instant, Instant>> calculateUpcomingPeriods(Calendar calendar, Optional<String> eventName,\n+            Instant startDate, int limit) {\n+        ComponentList<CalendarComponent> allEvents = calendar.getComponents(Component.VEVENT);\n+\n+        Collection<CalendarComponent> filteredEvents = eventName.map(name -> {\n+            Predicate<CalendarComponent> summary = c -> c.getProperty(\"SUMMARY\").equals(name);\n+            Predicate<CalendarComponent>[] ps = new Predicate[]{summary};\n+            Filter<CalendarComponent> filter = new Filter<>(ps, Filter.MATCH_ALL);\n+            return filter.filter(allEvents);\n+        }).orElse(allEvents);\n+\n+        // we will look a year and month to the future\n+        Period period = new Period(new DateTime(startDate.toEpochMilli()), Duration.ofDays(365 + 31));\n+\n+        List<PeriodList> periodLists = filteredEvents.stream()\n+                .map(c -> c.calculateRecurrenceSet(period))\n+                .filter(l -> !l.isEmpty())\n+                .collect(toList());\n+\n+        Stream<Pair<Instant, Instant>> sortedLimited = periodLists.stream()\n+                .map(pl -> pl.stream())\n+                .reduce(Stream.empty(), Stream::concat)\n+                .sorted()\n+                .limit(limit)\n+                .map(p -> Pair.of(p.getStart().toInstant(), p.getRangeEnd().toInstant()));\n+\n+        return sortedLimited;\n+    }\n+\n+    /**\n+     * Get all schedules of given calendar at given date.\n+     * Filter results by summary, if the summary parameter is passed.\n+     *\n+     * @param date the date\n+     * @param calendar the calendar\n+     * @param summary event summary\n+     * @return the collection of calendars components matching given date (and optionally summary)\n+     */\n+    public Collection<CalendarComponent> getCalendarEventsAtDate(Date date, Optional<Calendar> calendar,\n+            Optional<String> summary) {\n+        if (calendar.isEmpty()) {\n+            return emptySet();\n+        }\n+\n+        Period p = new Period(new DateTime(date), java.time.Duration.ofSeconds(1));\n+        ArrayList<Predicate<Component>> rules = new ArrayList<>();\n+        rules.add(new PeriodRule<>(p));\n+\n+        summary.ifPresent(s -> {\n+            Summary filterSummary = new Summary(s);\n+            HasPropertyRule<Component> propertyRule = new HasPropertyRule<>(filterSummary);\n+            rules.add(propertyRule);\n+        });\n+\n+        @SuppressWarnings(\"unchecked\")", "originalCommit": "85bd9b7329f088d7de572ed1023cea57bced63aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4ODIzMg==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447588232", "bodyText": "Uf, I actually didn't want to remove these annotations in this PR (it's a separate task in our task list). Removing the others was \"an accident\". I'll leave it like this for now, but we need to talk about it with @mcalmer , who said, it produced some errors in his IDE.", "author": "hustodemon", "createdAt": "2020-06-30T10:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDg5MQ==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447600891", "bodyText": "Right let's have a discussion about this. This can also be addressed later", "author": "parlt91", "createdAt": "2020-06-30T11:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4MzAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODY5Nw==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447678697", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public List<String> listCalendarLabelsByUser(User user) {\n          \n          \n            \n                public List<String> listLabelsByUser(User user) {\n          \n      \n    \n    \n  \n\nOr was Calendar left here for a reason?", "author": "mcalmer", "createdAt": "2020-06-30T13:24:27Z", "path": "java/code/src/com/suse/manager/model/maintenance/CalendarFactory.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.model.maintenance;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * {@link HibernateFactory} for {@link MaintenanceCalendar}\n+ */\n+public class CalendarFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(CalendarFactory.class);\n+\n+    /**\n+     * Save a MaintenanceCalendar\n+     * @param calendar the calendar\n+     */\n+    public void save(MaintenanceCalendar calendar) {\n+        getSession().save(calendar);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceCalendar}\n+     * @param calendar to remove\n+     */\n+    public void remove(MaintenanceCalendar calendar) {\n+        removeObject(calendar);\n+    }\n+\n+    /**\n+     * List Maintenance Calendar Labels belonging to the given User\n+     * @param user the user\n+     * @return a list of Calendar labels\n+     */\n+    public List<String> listCalendarLabelsByUser(User user) {", "originalCommit": "195e22cc1952543800bfdcb905317791b270920e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc0MjMwNA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447742304", "bodyText": "Yes, I left this one on purpose. I was thinking, that listLabelsByUser was too puristic :) Same for the Schedule case...", "author": "hustodemon", "createdAt": "2020-06-30T14:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY4MDExMA==", "url": "https://github.com/uyuni-project/uyuni/pull/2367#discussion_r447680110", "bodyText": "Is Schedule still here for a reason?", "author": "mcalmer", "createdAt": "2020-06-30T13:26:18Z", "path": "java/code/src/com/suse/manager/model/maintenance/ScheduleFactory.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2020 SUSE LLC\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package com.suse.manager.model.maintenance;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.stream.Collectors.toSet;\n+\n+import com.redhat.rhn.common.hibernate.HibernateFactory;\n+import com.redhat.rhn.domain.user.User;\n+\n+import org.apache.log4j.Logger;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * {@link HibernateFactory} for Maintenance Windows-related objects.\n+ */\n+public class ScheduleFactory extends HibernateFactory {\n+\n+    private static Logger log = Logger.getLogger(ScheduleFactory.class);\n+\n+    /**\n+     * Save a MaintenanceSchedule\n+     * @param schedule the schedule\n+     */\n+    public void save(MaintenanceSchedule schedule) {\n+        saveObject(schedule);\n+    }\n+\n+    /**\n+     * Remove a {@link MaintenanceSchedule}\n+     * @param schedule to remove\n+     */\n+    public void remove(MaintenanceSchedule schedule) {\n+        removeObject(schedule);\n+    }\n+\n+    /**\n+     * List schedules by User and Calendar\n+     * @param user the User\n+     * @param calendar the Calendar\n+     * @return the list of Schedules\n+     */\n+    public List<MaintenanceSchedule> listByUserAndCalendar(User user, MaintenanceCalendar calendar) {\n+        return getSession()\n+                .createQuery(\"FROM MaintenanceSchedule \" +\n+                        \"WHERE org = :org and calendar = :calendar \" +\n+                        \"ORDER BY name ASC\")\n+                .setParameter(\"org\", user.getOrg())\n+                .setParameter(\"calendar\", calendar).getResultList();\n+    }\n+\n+    /**\n+     * List Maintenance Schedule Names belong to the given User\n+     * @param user the user\n+     * @return a list of Schedule names\n+     */\n+    public List<String> listScheduleNamesByUser(User user) {", "originalCommit": "195e22cc1952543800bfdcb905317791b270920e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a0b80b648bb8ba72d5a72df463f3652965b8723", "url": "https://github.com/uyuni-project/uyuni/commit/3a0b80b648bb8ba72d5a72df463f3652965b8723", "message": "Turn methods to static ones for consistency", "committedDate": "2020-06-30T14:19:38Z", "type": "commit"}, {"oid": "8035ac5e02266bfcc903851b115ab3db2babaf25", "url": "https://github.com/uyuni-project/uyuni/commit/8035ac5e02266bfcc903851b115ab3db2babaf25", "message": "Refactor: Extract hibernate code from MaintenanceManager to MaintenanceFactory", "committedDate": "2020-06-30T14:19:38Z", "type": "commit"}, {"oid": "95d90b952f8098cbf7e6ee6e936249b87490db12", "url": "https://github.com/uyuni-project/uyuni/commit/95d90b952f8098cbf7e6ee6e936249b87490db12", "message": "Protected -> private in MaintenanceManager", "committedDate": "2020-06-30T14:19:38Z", "type": "commit"}, {"oid": "472e78b786ccd3404fa3b3e0a979a9015463c1d2", "url": "https://github.com/uyuni-project/uyuni/commit/472e78b786ccd3404fa3b3e0a979a9015463c1d2", "message": "Refactor: Move more hibernate-related methods to the MaintenanceFactory", "committedDate": "2020-06-30T14:19:38Z", "type": "commit"}, {"oid": "77b1db53abb174f54fadd2923400e897a4ed7728", "url": "https://github.com/uyuni-project/uyuni/commit/77b1db53abb174f54fadd2923400e897a4ed7728", "message": "Refactor: Get rid of 'Maintenance' in the method names", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "8f1a844be32190de55d7d1924075971f77af6135", "url": "https://github.com/uyuni-project/uyuni/commit/8f1a844be32190de55d7d1924075971f77af6135", "message": "Refactor: Split the MaintenanceFactory to ScheduleFactory and CalendarFactory", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "416929aad4969c3efaa8469fc171478ea941d8e2", "url": "https://github.com/uyuni-project/uyuni/commit/416929aad4969c3efaa8469fc171478ea941d8e2", "message": "Revert: Protected -> private in MaintenanceManager", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "8f0efe09ba67fcba4f6e82494bd86bed98e6e94a", "url": "https://github.com/uyuni-project/uyuni/commit/8f0efe09ba67fcba4f6e82494bd86bed98e6e94a", "message": "Refactor: Also get rid of the useless 'Maintenance' word in the MaintenanceManager methods", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "4de30d1b8e772bfea17e5774813b910acddc887f", "url": "https://github.com/uyuni-project/uyuni/commit/4de30d1b8e772bfea17e5774813b910acddc887f", "message": "Refactor: Extract Ical-related methods to a separate class", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "dfc230efeff3e98f67b536107749f2c2a8af397b", "url": "https://github.com/uyuni-project/uyuni/commit/dfc230efeff3e98f67b536107749f2c2a8af397b", "message": "Refactor: Move the rescheduling-related code to a separate package", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "03bfe8b10b4bc8a00ba2e0b3150085d7fcca6929", "url": "https://github.com/uyuni-project/uyuni/commit/03bfe8b10b4bc8a00ba2e0b3150085d7fcca6929", "message": "Adjust comments", "committedDate": "2020-06-30T14:19:39Z", "type": "commit"}, {"oid": "5ca5ffc56c6d76576b69261c7663c0743fbc1e98", "url": "https://github.com/uyuni-project/uyuni/commit/5ca5ffc56c6d76576b69261c7663c0743fbc1e98", "message": "Refactor: Turn getScheduleEventsAtDate into getCalendarEventsAtDate\n\nThis slightly simplifies the intent of the method: previously, we passed\nboth schedule and calendar as params. Now we just pass calendar (and\noptionally name for filtering).", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "8e489ab70a9941ee6b36918308b9b5990658c5d5", "url": "https://github.com/uyuni-project/uyuni/commit/8e489ab70a9941ee6b36918308b9b5990658c5d5", "message": "Remove unused method", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "004548c1aac717f3bf3f05aefa472cc337a36c54", "url": "https://github.com/uyuni-project/uyuni/commit/004548c1aac717f3bf3f05aefa472cc337a36c54", "message": "RescheduleStrategyType class", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "a180653b0d5b328fda34cab9610ac403615b3274", "url": "https://github.com/uyuni-project/uyuni/commit/a180653b0d5b328fda34cab9610ac403615b3274", "message": "Refactor: Improve the mapping of string to RescheduleStrategy", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "ce81166b0ad30c344ec4645e1dc1264347551bd3", "url": "https://github.com/uyuni-project/uyuni/commit/ce81166b0ad30c344ec4645e1dc1264347551bd3", "message": "Refactor: Explicitly control the lifecycle of MaintenanceManager instances", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "1d2db6135889c6fd2f4953f8c5213924c849e052", "url": "https://github.com/uyuni-project/uyuni/commit/1d2db6135889c6fd2f4953f8c5213924c849e052", "message": "Refactor: Fix typo", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "b7a39d82abef1aa9b31d329ee9ae859f76d5ee2f", "url": "https://github.com/uyuni-project/uyuni/commit/b7a39d82abef1aa9b31d329ee9ae859f76d5ee2f", "message": "Refactor: Re-arrange the MaintenanceManager methods\n\nThe new order:\n- the CRUD methods for schedule\n- the CRUD methods for calendar\n- rest", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "8a5867a72b3ecf5e789a2626dac8a8aa282667d3", "url": "https://github.com/uyuni-project/uyuni/commit/8a5867a72b3ecf5e789a2626dac8a8aa282667d3", "message": "Correct indentation", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "578fb0250105a418b7dfb614f258e498999244ef", "url": "https://github.com/uyuni-project/uyuni/commit/578fb0250105a418b7dfb614f258e498999244ef", "message": "Refactor: Better naming for methods", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "912921ca2fe0b85393e2558a24e5668cae79cdd1", "url": "https://github.com/uyuni-project/uyuni/commit/912921ca2fe0b85393e2558a24e5668cae79cdd1", "message": "Fix the javadoc, remove dangling comment", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "594c0aa72c9b27360c24833332d9406580670e87", "url": "https://github.com/uyuni-project/uyuni/commit/594c0aa72c9b27360c24833332d9406580670e87", "message": "Get rid of smurf code in CalendarFactory and ScheduleFactory", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "adba0207a87421c7a5be6d5eac8aee44d5473108", "url": "https://github.com/uyuni-project/uyuni/commit/adba0207a87421c7a5be6d5eac8aee44d5473108", "message": "Remove unused method", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "cdf2b54be34df3bf491da8a4494a628ef96a4fc8", "url": "https://github.com/uyuni-project/uyuni/commit/cdf2b54be34df3bf491da8a4494a628ef96a4fc8", "message": "Move the maintenance factories to model package", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "fa17acecc121934782f8ae9061cd995fa4c86e52", "url": "https://github.com/uyuni-project/uyuni/commit/fa17acecc121934782f8ae9061cd995fa4c86e52", "message": "Initialize static field properly", "committedDate": "2020-06-30T14:19:40Z", "type": "commit"}, {"oid": "fa17acecc121934782f8ae9061cd995fa4c86e52", "url": "https://github.com/uyuni-project/uyuni/commit/fa17acecc121934782f8ae9061cd995fa4c86e52", "message": "Initialize static field properly", "committedDate": "2020-06-30T14:19:40Z", "type": "forcePushed"}]}