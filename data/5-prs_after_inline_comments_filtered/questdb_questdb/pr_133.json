{"pr_number": 133, "pr_title": "Table backup2", "pr_createdAt": "2020-03-31T11:05:46Z", "pr_url": "https://github.com/questdb/questdb/pull/133", "timeline": [{"oid": "dc3f1675f5e1350f1f011979ebc78300a72f0250", "url": "https://github.com/questdb/questdb/commit/dc3f1675f5e1350f1f011979ebc78300a72f0250", "message": "feat(cairo): add table backup", "committedDate": "2020-03-26T08:04:07Z", "type": "commit"}, {"oid": "6e0016a52f10b7c04ca5e17079fea57630fa86f2", "url": "https://github.com/questdb/questdb/commit/6e0016a52f10b7c04ca5e17079fea57630fa86f2", "message": "Merge branch 'master' into table-backup", "committedDate": "2020-03-26T08:37:31Z", "type": "commit"}, {"oid": "db0069c3f2063297466d1da597abede52942d7f2", "url": "https://github.com/questdb/questdb/commit/db0069c3f2063297466d1da597abede52942d7f2", "message": "Merge branch 'master' into table-backup", "committedDate": "2020-03-30T08:50:52Z", "type": "commit"}, {"oid": "651f92aadca96f1ae8d0cca1587d32a69c00f252", "url": "https://github.com/questdb/questdb/commit/651f92aadca96f1ae8d0cca1587d32a69c00f252", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T13:08:37Z", "type": "commit"}, {"oid": "039159463351e3bb0e760da6295529bf77279aa9", "url": "https://github.com/questdb/questdb/commit/039159463351e3bb0e760da6295529bf77279aa9", "message": "feat(cairo): add table backup\n\tMove backupTable to CairoEngine and use reader/writer pools", "committedDate": "2020-03-30T22:16:55Z", "type": "commit"}, {"oid": "2d7af63cb3c25b416da87641cf8be455d8d05bc0", "url": "https://github.com/questdb/questdb/commit/2d7af63cb3c25b416da87641cf8be455d8d05bc0", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T23:11:50Z", "type": "commit"}, {"oid": "86bc987640852387a5a8a7ded4fe2cbd605df87d", "url": "https://github.com/questdb/questdb/commit/86bc987640852387a5a8a7ded4fe2cbd605df87d", "message": "feat(cairo): add table backup", "committedDate": "2020-03-30T23:12:53Z", "type": "commit"}, {"oid": "7ea01dd3799e603c60929fbc741419028e515674", "url": "https://github.com/questdb/questdb/commit/7ea01dd3799e603c60929fbc741419028e515674", "message": "feat(cairo): add table backup\n\tMove backupTable to CairoEngine and use reader/writer pools", "committedDate": "2020-03-30T23:21:50Z", "type": "commit"}, {"oid": "f874d2c66dd0b59070c668592e801f5f171e43d2", "url": "https://github.com/questdb/questdb/commit/f874d2c66dd0b59070c668592e801f5f171e43d2", "message": "Merge branch 'table-backup' of github.com:questdb/questdb into table-backup", "committedDate": "2020-03-31T07:01:15Z", "type": "commit"}, {"oid": "9b21ccf4d129c1d53c0a15e76328877831f5d91d", "url": "https://github.com/questdb/questdb/commit/9b21ccf4d129c1d53c0a15e76328877831f5d91d", "message": "feat(griffin): add table backup", "committedDate": "2020-03-31T09:41:14Z", "type": "commit"}, {"oid": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "url": "https://github.com/questdb/questdb/commit/34d7114ca1fd7d662621ade008a9b82abf4e3a23", "message": "feat(griffin): add table backup", "committedDate": "2020-03-31T10:40:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgyODk1MA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400828950", "bodyText": "Misc.free() does null check already", "author": "bluestreak01", "createdAt": "2020-03-31T11:10:49Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -51,23 +54,36 @@\n     private final ReaderPool readerPool;\n     private final CairoConfiguration configuration;\n     private final WriterMaintenanceJob writerMaintenanceJob;\n+    private final WriterPool backupWriterPool;\n \n     public CairoEngine(CairoConfiguration configuration) {\n         this(configuration, null);\n     }\n \n     public CairoEngine(CairoConfiguration configuration, @Nullable MessageBus messageBus) {\n         this.configuration = configuration;\n-        this.writerPool = new WriterPool(configuration, messageBus);\n+        this.writerPool = new WriterPool(configuration, messageBus, false);\n         this.readerPool = new ReaderPool(configuration);\n         this.writerMaintenanceJob = new WriterMaintenanceJob(configuration);\n+        if (null != configuration.getBackupRoot()) {\n+        \tbackupWriterPool = new WriterPool(configuration, messageBus, true);\n+        } else {\n+        \tbackupWriterPool = null;\n+        }\n+    }\n+\n+    public WriterMaintenanceJob getWriterMaintenanceJob() {\n+        return writerMaintenanceJob;\n     }\n \n     @Override\n     public void close() {\n         Misc.free(writerPool);\n         Misc.free(readerPool);\n-    }\n+        if (null != backupWriterPool) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400830259", "bodyText": "this should be &&\nif writerPool releases and backup doesn't result should be false.\nPerhaps a unit test should be added to ensure this behaviour", "author": "bluestreak01", "createdAt": "2020-03-31T11:13:20Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -200,9 +219,13 @@ public boolean releaseAllReaders() {\n     }\n \n     public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n+        boolean released = writerPool.releaseAll();\n+        if (null != backupWriterPool) {\n+        \treturn backupWriterPool.releaseAll() || released;", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzOTcwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400839701", "bodyText": "I added a comment about this yesterday, it got lost in all the branch mess. writerPool.releaseAll() returns false if there are no writers OR if the release can't meet the deadline, but the deadline is infinite, so it will return false even iif the method succeeds (there were no writers).\nAlso, the return value of releaseAllWriters is never checked and its is always called when releaseAllReaders is called (by tests only). Wouldn't it be better to have a releaseAll with a void return?", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0NzA4Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400847086", "bodyText": "return value is used by WriterMaintenanceJob to throttle threads", "author": "bluestreak01", "createdAt": "2020-03-31T11:44:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMTgzNA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400831834", "bodyText": "what happened here with padding?", "author": "bluestreak01", "createdAt": "2020-03-31T11:16:16Z", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -51,17 +54,17 @@\n     protected static CairoConfiguration configuration;\n     protected static MessageBus messageBus;\n \n-    @BeforeClass\n-    public static void setUp() {\n-        // it is necessary to initialise logger before tests start\n-        // logger doesn't relinquish memory until JVM stops\n-        // which causes memory leak detector to fail should logger be\n-        // created mid-test\n-        LOG.info().$(\"begin\").$();\n-        root = temp.getRoot().getAbsolutePath();\n-        configuration = new DefaultCairoConfiguration(root);\n+\t@BeforeClass\n+\tpublic static void setUp() throws IOException {\n+\t\t// it is necessary to initialise logger before tests start\n+\t\t// logger doesn't relinquish memory until JVM stops", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDU2NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400840564", "bodyText": "I need to figure out how to configure the code formatter ...", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMTgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMjQ1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400832454", "bodyText": "if we use SQL to backup tables, which is likely, this code can move into SQLCompiler", "author": "bluestreak01", "createdAt": "2020-03-31T11:17:24Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDMzMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400840331", "bodyText": "Yes, I was think of that, but SQLCompiler is already very long ...\nHowever, I am not bothered either way, it does make sense to put it into SQLCompiler", "author": "patrickSpaceSurfer", "createdAt": "2020-03-31T11:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMjQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMzM5NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400833394", "bodyText": "if this becomes part of SQLCompiler, it already has instance of AppendMemory called mem for cases like this.", "author": "bluestreak01", "createdAt": "2020-03-31T11:19:14Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);\n+\n+\t\t\tif (ff.exists(path)) {\n+\t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t\t}\n+\n+\t\t\tif (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+\t\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t\t}\n+\n+\t\t\tfinal int rootLen = path.length();\n+\t\t\ttry (AppendMemory backupMem = new AppendMemory()) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzMzc5Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400833796", "bodyText": "CairoException provides methods to avoid string concatenation", "author": "bluestreak01", "createdAt": "2020-03-31T11:20:01Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);\n+\n+\t\t\tif (ff.exists(path)) {\n+\t\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNDM5Nw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400834397", "bodyText": "why not reuse instance of TableReaderMetadata that TableReader has (in a call just above)", "author": "bluestreak01", "createdAt": "2020-03-31T11:21:14Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNDc0OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400834749", "bodyText": "path is a zero-terminated string. When concatenation is finished it is imperative to terminate path with .$()", "author": "bluestreak01", "createdAt": "2020-03-31T11:21:58Z", "path": "core/src/main/java/io/questdb/griffin/TableBackupManager.java", "diffHunk": "@@ -0,0 +1,78 @@\n+package io.questdb.griffin;\n+\n+import io.questdb.cairo.AppendMemory;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.CairoSecurityContext;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.SymbolMapWriter;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.TableReaderMetadata;\n+import io.questdb.cairo.TableUtils;\n+import io.questdb.cairo.TableWriter;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupManager {\n+\tprivate final CairoConfiguration configuration;\n+\tprivate final CairoEngine engine;\n+\tprivate final SqlCompiler compiler;\n+\n+\tpublic TableBackupManager(CairoConfiguration configuration, CairoEngine engine, SqlCompiler compiler) {\n+\t\tsuper();\n+\t\tthis.configuration = configuration;\n+\t\tthis.engine = engine;\n+\t\tthis.compiler = compiler;\n+\t}\n+\n+\tpublic void backupTable(CairoSecurityContext securityContext, CharSequence tableName, Path path) {\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getFilesFacade(), path, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcompiler.copyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static void cloneMetaData(CharSequence tableName, FilesFacade ff, Path path, CharSequence root, CharSequence backupRoot, int mkDirMode) {\n+\t\tpath.of(root).concat(tableName).concat(TableUtils.META_FILE_NAME).$();\n+\t\ttry (TableReaderMetadata sourceMetaData = new TableReaderMetadata(ff, path)) {\n+\t\t\tpath.of(backupRoot).concat(tableName);", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNTY0Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400835643", "bodyText": "path is \"Closeable\", not freeing it up will leak memory in test", "author": "bluestreak01", "createdAt": "2020-03-31T11:23:35Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNTg0Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400835842", "bodyText": "leak test needs to surround entire test", "author": "bluestreak01", "createdAt": "2020-03-31T11:23:57Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNjE1Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r400836152", "bodyText": "factory is also Closeable", "author": "bluestreak01", "createdAt": "2020-03-31T11:24:34Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,127 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import io.questdb.cairo.AbstractCairoTest;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.std.str.Path;\n+\n+public class TableBackupTest extends AbstractGriffinTest {\n+\tprivate CharSequence backupRoot;\n+\n+\t@Test\n+\tpublic void simpleTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\t// @formatter:off\n+\t\t\tcompiler.compile(\"create table \" + tableName + \" as (select\" + \n+\t\t\t\t\t\" rnd_symbol(4,4,4,2) sym,\" + \n+\t\t\t\t\t\" rnd_double(2) d,\" + \n+\t\t\t\t\t\" timestamp_sequence(0, 1000000000) ts\" + \n+\t\t\t\t\t\" from long_sequence(10000)) timestamp(ts)\", sqlExecutionContext);\n+\t\t\t// @formatter:on\n+\t\t});\n+\n+\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n+\t\t});\n+\n+\t\tString sourceSelectAll = selectAll(tableName);\n+\t\tsetup(backupRoot, null);\n+\t\tString backupSelectAll = selectAll(tableName);\n+\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t}\n+\n+\t@Test\n+\tpublic void allTypesPartitionedTableTest1() throws Exception {\n+\t\tString tableName = \"testTable\";\n+\t\tPath path = new Path();\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\t// @formatter:off\n+\t\t\tcompiler.compile(\"create table \" + tableName + \" as (\" +\n+                        \"select\" +\n+                        \" rnd_char() ch,\" +\n+                        \" rnd_long256() ll,\" +\n+                        \" rnd_int() a1,\" +\n+                        \" rnd_int(0, 30, 2) a,\" +\n+                        \" rnd_boolean() b,\" +\n+                        \" rnd_str(3,3,2) c,\" +\n+                        \" rnd_double(2) d,\" +\n+                        \" rnd_float(2) e,\" +\n+                        \" rnd_short(10,1024) f,\" +\n+                        \" rnd_short() f1,\" +\n+                        \" rnd_date(to_date('2015', 'yyyy'), to_date('2016', 'yyyy'), 2) g,\" +\n+                        \" rnd_timestamp(to_timestamp('2015', 'yyyy'), to_timestamp('2016', 'yyyy'), 2) h,\" +\n+                        \" rnd_symbol(4,4,4,2) i,\" +\n+                        \" rnd_long(100,200,2) j,\" +\n+                        \" rnd_long() j1,\" +\n+                        \" timestamp_sequence(0, 1000000000) k,\" +\n+                        \" rnd_byte(2,50) l,\" +\n+                        \" rnd_bin(10, 20, 2) m\" +\n+                        \" from long_sequence(1000)\" +\n+                        \")  timestamp(k) partition by DAY\", sqlExecutionContext);\n+\t\t\t// @formatter:on\n+\t\t});\n+\n+\t\tTableBackupManager tableBackupManager = new TableBackupManager(configuration, engine, compiler);\n+\t\tAbstractGriffinTest.assertMemoryLeak(() -> {\n+\t\t\ttableBackupManager.backupTable(sqlExecutionContext.getCairoSecurityContext(), tableName, path);\n+\t\t});\n+\n+\t\tString sourceSelectAll = selectAll(tableName);\n+\t\tsetup(backupRoot, null);\n+\t\tString backupSelectAll = selectAll(tableName);\n+\t\tAssert.assertEquals(sourceSelectAll, backupSelectAll);\n+\t}\n+\n+\tprivate String selectAll(String tableName) throws Exception {\n+\t\tassertMemoryLeak(() -> {\n+\t\t\tCompiledQuery compiledQuery = compiler.compile(\"select * from \" + tableName, sqlExecutionContext);\n+\t\t\tRecordCursorFactory factory = compiledQuery.getRecordCursorFactory();", "originalCommit": "34d7114ca1fd7d662621ade008a9b82abf4e3a23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "772f09e6c559213791e79601ed7d2cef363bf9e2", "url": "https://github.com/questdb/questdb/commit/772f09e6c559213791e79601ed7d2cef363bf9e2", "message": "feat(griffin): add table backup\n\tFix incorrect usage of path", "committedDate": "2020-03-31T15:11:16Z", "type": "commit"}, {"oid": "cfa9db8c42a88d945aefca0caf728eef14caff26", "url": "https://github.com/questdb/questdb/commit/cfa9db8c42a88d945aefca0caf728eef14caff26", "message": "feat(griffin): add table backup\n\tAvoid allocating new TableReaderMetadata needlessly", "committedDate": "2020-03-31T15:17:37Z", "type": "commit"}, {"oid": "cd81cb5f34d8422f37271c9e1418e570bf97ea24", "url": "https://github.com/questdb/questdb/commit/cd81cb5f34d8422f37271c9e1418e570bf97ea24", "message": "feat(griffin): add table backup\n\tImprove test\n\tInclude backup writers in cairo engine maintenance job", "committedDate": "2020-04-01T10:04:49Z", "type": "commit"}, {"oid": "95824588567ceac5df614c27e70c12af335effd5", "url": "https://github.com/questdb/questdb/commit/95824588567ceac5df614c27e70c12af335effd5", "message": "feat(griffin): add table backup\n\tMove table backup into SqlCompiler", "committedDate": "2020-04-01T10:34:15Z", "type": "commit"}, {"oid": "4958162f5d69e846fddcbef6ea95f31437f952bc", "url": "https://github.com/questdb/questdb/commit/4958162f5d69e846fddcbef6ea95f31437f952bc", "message": "feat(griffin): add table backup\n\tengine#releaseInactive correctly!", "committedDate": "2020-04-01T10:38:13Z", "type": "commit"}, {"oid": "3b6c0c721c9a80473ed7cec21fbd750b7786e6f3", "url": "https://github.com/questdb/questdb/commit/3b6c0c721c9a80473ed7cec21fbd750b7786e6f3", "message": "feat(griffin): add table backup\n\trefactor CairoEngine.releaseInactive", "committedDate": "2020-04-01T12:43:08Z", "type": "commit"}, {"oid": "ffe3066f232e2941761b2e19fc1ccce7a70ff66c", "url": "https://github.com/questdb/questdb/commit/ffe3066f232e2941761b2e19fc1ccce7a70ff66c", "message": "feat(griffin): add table backup\n\tAdd BACKUP TABLE SQL", "committedDate": "2020-04-01T16:27:37Z", "type": "commit"}, {"oid": "c443829637241dc6e2134a1c2219d584393f6cab", "url": "https://github.com/questdb/questdb/commit/c443829637241dc6e2134a1c2219d584393f6cab", "message": "Merge remote-tracking branch 'origin/master' into table-backup2", "committedDate": "2020-04-01T16:36:55Z", "type": "commit"}, {"oid": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "url": "https://github.com/questdb/questdb/commit/62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "message": "feat(griffin): add table backup\n\tFix merge issue", "committedDate": "2020-04-01T16:43:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NTAxNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401845016", "bodyText": "code formatting is still inconsistent with rest of the code. This isn't the only line.", "author": "bluestreak01", "createdAt": "2020-04-01T19:07:12Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +216,22 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n \n-    public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n-    }\n-\n-    public void releaseInactive() {\n-        writerPool.releaseInactive();\n-        readerPool.releaseInactive();\n+    public boolean releaseAllWriters () {\n+    \tboolean released = writerPool.releaseAll();\n+    \tif (null != backupWriterPool && backupWriterPool.releaseAll()) {\n+    \t\treleased = true;\n+    \t}\n+    \treturn released;\n     }\n+    \n+\tpublic boolean releaseInactive() {\n+\t\tboolean useful = writerPool.releaseInactive();\n+\t\tuseful |= readerPool.releaseInactive();\n+\t\tif (null != backupWriterPool) {\n+\t\t\tuseful |= backupWriterPool.releaseInactive();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg0NzkwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401847901", "bodyText": "If backup is a regular thing, which it might be, it would make sense to cache copiers. Copier can be cached against table name + structure version.", "author": "bluestreak01", "createdAt": "2020-04-01T19:12:29Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1035,23 +1088,27 @@ private void copyTable(SqlExecutionContext executionContext, CopyModel model) th\n     private TableWriter copyTableData(CharSequence tableName, RecordCursor cursor, RecordMetadata cursorMetadata) {\n         TableWriter writer = new TableWriter(configuration, tableName, messageBus, false, DefaultLifecycleManager.INSTANCE);\n         try {\n-            RecordMetadata writerMetadata = writer.getMetadata();\n-            entityColumnFilter.of(writerMetadata.getColumnCount());\n-            RecordToRowCopier recordToRowCopier = assembleRecordToRowCopier(asm, cursorMetadata, writerMetadata, entityColumnFilter);\n-\n-            int timestampIndex = writerMetadata.getTimestampIndex();\n-            if (timestampIndex == -1) {\n-                copyUnordered(cursor, writer, recordToRowCopier);\n-            } else {\n-                copyOrdered(writer, cursor, recordToRowCopier, timestampIndex);\n-            }\n+            copyTableData(cursor, cursorMetadata, writer);\n             return writer;\n         } catch (CairoException e) {\n             writer.close();\n             throw e;\n         }\n     }\n \n+\tpublic void copyTableData(RecordCursor cursor, RecordMetadata cursorMetadata, TableWriter writer) {\n+\t\tRecordMetadata writerMetadata = writer.getMetadata();\n+\t\tentityColumnFilter.of(writerMetadata.getColumnCount());\n+\t\tRecordToRowCopier recordToRowCopier = assembleRecordToRowCopier(asm, cursorMetadata, writerMetadata, entityColumnFilter);", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MDEyOQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401850129", "bodyText": "this can be replaced with existing expectKeyword call. It is a fairly standard thing to check in parser/compiler", "author": "bluestreak01", "createdAt": "2020-04-01T19:16:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTIwOQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401851209", "bodyText": "perhaps backup needs its own result", "author": "bluestreak01", "createdAt": "2020-04-01T19:18:26Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MTQzNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401851436", "bodyText": "concatenation remains", "author": "bluestreak01", "createdAt": "2020-04-01T19:18:49Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1MjcwNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401852706", "bodyText": "128 and true need to be taken from source metadata", "author": "bluestreak01", "createdAt": "2020-04-01T19:21:12Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tint rootLen = path.length();\n+\t\ttry {\n+\t\t\tmem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+\t\t\tsourceMetaData.cloneTo(mem);\n+\t\n+\t\t\t// create symbol maps\n+\t\t\tpath.trimTo(rootLen).$();\n+\t\t\tint symbolMapCount = 0;\n+\t\t\tfor (int i = 0; i < sourceMetaData.getColumnCount(); i++) {\n+\t\t\t\tif (sourceMetaData.getColumnType(i) == ColumnType.SYMBOL) {\n+\t\t\t\t\tSymbolMapWriter.createSymbolMapFiles(ff, mem, path, sourceMetaData.getColumnName(i), 128, true);", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1Nzc3Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401857773", "bodyText": "reader.getCursor() is an oddball here. It must not be closed, otherwise it detaches from reader.\nObviously we need a test that shows backup can run multiple times", "author": "bluestreak01", "createdAt": "2020-04-01T19:30:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1ODMyNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401858326", "bodyText": "This perhaps need to be a set? What if someone specifies the same table name several times in the list of tables?\nThis needs a test too.", "author": "bluestreak01", "createdAt": "2020-04-01T19:31:25Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTg1OTEyNQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401859125", "bodyText": "this is an ok loop, but not the fastest. Loops around our codebase consistently use the following syntax:\nfor (int i = 0, n = obj.size(); i < n; i++) {\n}", "author": "bluestreak01", "createdAt": "2020-04-01T19:32:42Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {\n+\t\t\tCharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+\t\t\t}\n+\t\t\tCharSequence tableName = GenericLexer.unquote(tok);\n+\t\t\tint status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+\t\t\tif (status != TableUtils.TABLE_EXISTS) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+\t\t\t}\n+\t\t\ttableNames.add(tableName);\n+\n+\t\t\ttok = SqlUtil.fetchNext(lexer);\n+\t\t\tif (null == tok || Chars.equals(tok, ';')) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tif (!Chars.equals(tok, ',')) {\n+\t\t\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tfor (int n=0; n<tableNames.size(); n++) {\n+\t\t\tbackupTable(tableNames.get(n), executionContext);\n+\t\t}\n+\n+\t\treturn compiledQuery.ofRenameTable();\n+\t}\n+    \n+\tpublic void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+\t\tLOG.info().$(\"Starting backup of \").$(tableName).$();\n+\t\tif (null == configuration.getBackupRoot()) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+\t\t}\n+\n+\t\tCairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+\t\ttry (TableReader reader = engine.getReader(securityContext, tableName)) {\n+\t\t\tcloneMetaData(tableName, configuration.getRoot(), configuration.getBackupRoot(), configuration.getMkDirMode(), (TableReaderMetadata) reader.getMetadata());\n+\t\t\ttry (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName); RecordCursor cursor = reader.getCursor()) {\n+\t\t\t\tcopyTableData(cursor, reader.getMetadata(), backupWriter);\n+\t\t\t\tbackupWriter.commit();\n+\t\t\t}\n+\t\t}\n+\t\tLOG.info().$(\"Completed backup of \").$(tableName).$();\n+\t}\n+\n+\tprivate void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReaderMetadata sourceMetaData) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+\t\t\tthrow CairoException.instance(0).put(\"Backup dir for table \\\"\" + tableName + \"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tint rootLen = path.length();\n+\t\ttry {\n+\t\t\tmem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+\t\t\tsourceMetaData.cloneTo(mem);\n+\t\n+\t\t\t// create symbol maps\n+\t\t\tpath.trimTo(rootLen).$();\n+\t\t\tint symbolMapCount = 0;\n+\t\t\tfor (int i = 0; i < sourceMetaData.getColumnCount(); i++) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e65cd766bc952fb40a9ae660bc3be7587991f730", "url": "https://github.com/questdb/questdb/commit/e65cd766bc952fb40a9ae660bc3be7587991f730", "message": "Merge remote-tracking branch 'origin/master' into table-backup2", "committedDate": "2020-04-06T08:23:38Z", "type": "commit"}, {"oid": "16a959e1f6252ef7f3acbcb21232f22285b26dfd", "url": "https://github.com/questdb/questdb/commit/16a959e1f6252ef7f3acbcb21232f22285b26dfd", "message": "feat(griffin): add table backup", "committedDate": "2020-04-06T08:43:51Z", "type": "commit"}, {"oid": "f0cf50472cf2bac9f826542ce489156db6239ec9", "url": "https://github.com/questdb/questdb/commit/f0cf50472cf2bac9f826542ce489156db6239ec9", "message": "feat(griffin): add table backup", "committedDate": "2020-04-06T09:01:42Z", "type": "commit"}, {"oid": "cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "url": "https://github.com/questdb/questdb/commit/cdbc63cbe5be9433a6c9e0ef139e654686a353b1", "message": "feat(griffin): add table backup", "committedDate": "2020-04-07T15:34:05Z", "type": "commit"}, {"oid": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "url": "https://github.com/questdb/questdb/commit/e9f78ad9b44a657e8344bbeeff99288c17410dc1", "message": "feat(griffin): add database backup", "committedDate": "2020-04-07T16:21:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMDc3MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405500771", "bodyText": "can be simplified, right?", "author": "bluestreak01", "createdAt": "2020-04-08T12:53:29Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +211,16 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n \n-    public boolean releaseAllWriters() {\n-        return writerPool.releaseAll();\n-    }\n-\n-    public void releaseInactive() {\n-        writerPool.releaseInactive();\n-        readerPool.releaseInactive();\n+    public boolean releaseAllWriters () {\n+    \tboolean released = writerPool.releaseAll();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405503049", "bodyText": "formatting still off", "author": "bluestreak01", "createdAt": "2020-04-08T12:57:12Z", "path": "core/src/main/java/io/questdb/cairo/TableWriter.java", "diffHunk": "@@ -140,6 +140,17 @@ public TableWriter(\n             @Nullable MessageBus messageBus,\n             boolean lock,\n             LifecycleManager lifecycleManager\n+    ) {\n+    \tthis(configuration, name, messageBus, lock, lifecycleManager, configuration.getRoot());", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0NjM2MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405546361", "bodyText": "Are you sure? Looks consistent to me. line 143 and 154 are exactly the same", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T13:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NjUxMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407976512", "bodyText": "I reformatted the method and something did change other on eclipse it looks the same, I guess there was a tab hidden somewhere...", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T08:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMzA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNDg3Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405504876", "bodyText": "i think it should be lexer.getLastTokenPosition. You are reporting wrong token in SQL, using this code position will be behind this token.", "author": "bluestreak01", "createdAt": "2020-04-08T12:59:56Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTA1OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405505058", "bodyText": "indeed, lets cache", "author": "bluestreak01", "createdAt": "2020-04-08T13:00:15Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTU1Nw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405505557", "bodyText": "Lambda should be refactored into a method, will play nicely with caching nativeLPSZ", "author": "bluestreak01", "createdAt": "2020-04-08T13:01:00Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1MDU3NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405550574", "bodyText": "True, however I have seen other code where lambdas are used in this way, thats why I did it. Lambdas always allocate unless you have a field set to the method, so I'll change it here and anywhere else I see it", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T14:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNjQxMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405506411", "bodyText": "why would this not be typed?", "author": "bluestreak01", "createdAt": "2020-04-08T13:02:18Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -73,6 +129,8 @@\n     private final ExecutableMethod createTableMethod = this::createTable;\n     private final TextLoader textLoader;\n     private final FilesFacade ff;\n+    private final ObjHashSet<?> cachedObjSet = new ObjHashSet<>();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU0ODMxOA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405548318", "bodyText": "The idea is that it can be used for any purpose required, I use it with CharSequence in sqlTableBackup, but it could be used anywhere a ObjHashSet is required, just needs to be cleared when the method completes. I can change this to CharSequence but then maybe change the name too", "author": "patrickSpaceSurfer", "createdAt": "2020-04-08T14:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNjQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzM4NQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507385", "bodyText": "same as before, lastTokenPosition() should be used", "author": "bluestreak01", "createdAt": "2020-04-08T13:03:44Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgzMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507832", "bodyText": "and here", "author": "bluestreak01", "createdAt": "2020-04-08T13:04:19Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzk1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405507954", "bodyText": "are there tests?", "author": "bluestreak01", "createdAt": "2020-04-08T13:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwNzgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwODYwMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405508601", "bodyText": "there are date library functions for these", "author": "bluestreak01", "createdAt": "2020-04-08T13:05:28Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwOTE1Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405509153", "bodyText": "path should support printing \"int\"", "author": "bluestreak01", "createdAt": "2020-04-08T13:06:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxMDE5OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405510198", "bodyText": "\"tmp\" should probably be a config", "author": "bluestreak01", "createdAt": "2020-04-08T13:07:59Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+    \n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).concat(tableName).$();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTA1NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405515054", "bodyText": "formatting", "author": "bluestreak01", "createdAt": "2020-04-08T13:15:07Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1646,171 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.getPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+        // TODO: Cache the nativeLPSZ\n+        NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        ff.iterateDir(path.of(configuration.getRoot()).$(), (file, type) -> {\n+            nativeLPSZ.of(file);\n+            if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+                backupTable(nativeLPSZ, executionContext);\n+            }\n+        });\n+\n+        return compiledQuery.ofBackupTable();\n+    }\n+\n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unquote(tok);\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.getPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+\t}\n+\n+    private void setupBackupRenamePath() {\n+        // TODO: Use a formatter that produces less garbage\n+        DateTimeFormatter formatter = configuration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        int n = 0;\n+        // TODO: There is a race here, to threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm);\n+            if (n > 0) {\n+                renamePath.put('.').put(Integer.valueOf(n).toString());\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+    \n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(\"tmp\").put(Files.SEPARATOR).concat(tableName).$();\n+        int renameRootLen = renamePath.length();\n+        try {\n+            renamePath.trimTo(renameRootLen).concat(tableName).$();\n+            if (!ff.rename(path, renamePath)) {\n+                throw CairoException.instance(ff.errno()).put(\"Could not rename [from=\").put(path).put(\", to=\").put(renamePath).put(']');\n+            }\n+            LOG.info().$(\"Completed backup of \").$(tableName).$(\" to \").$(renamePath).$();\n+        } finally {\n+            renamePath.trimTo(renameRootLen).$();\n+        }\n+    }\n+\n+    private void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReader reader) {\n+\t\tpath.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+\t\tif (ff.exists(path)) {\n+            throw CairoException.instance(0).put(\"Backup dir for table \\\"\").put(tableName).put(\"\\\" already exists [dir=\").put(path).put(']');\n+\t\t}\n+\n+\t\tif (ff.mkdirs(path, mkDirMode) != 0) {\n+\t\t\tthrow CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+\t\t}\n+\n+        TableReaderMetadata sourceMetaData = (TableReaderMetadata) reader.getMetadata();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNjk4Mw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r405516983", "bodyText": "in this instance it isn't necessary to pass table twice", "author": "bluestreak01", "createdAt": "2020-04-08T13:17:56Z", "path": "core/src/test/java/io/questdb/griffin/TableBackupTest.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package io.questdb.griffin;\n+\n+import java.io.IOException;\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import io.questdb.MessageBus;\n+import io.questdb.MessageBusImpl;\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.CairoException;\n+import io.questdb.cairo.DefaultCairoConfiguration;\n+import io.questdb.cairo.RecordCursorPrinter;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordCursorFactory;\n+import io.questdb.griffin.engine.functions.bind.BindVariableService;\n+import io.questdb.std.Files;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.test.tools.TestUtils;\n+\n+public class TableBackupTest {\n+    private static final StringSink sink = new StringSink();\n+    private static final RecordCursorPrinter printer = new RecordCursorPrinter(sink);\n+    @Rule\n+    public TemporaryFolder temp = new TemporaryFolder();\n+\n+    private CharSequence backupRoot;\n+    private Path finalBackupPath;\n+\n+    private CairoConfiguration mainConfiguration;\n+    private CairoEngine mainEngine;\n+    private SqlCompiler mainCompiler;\n+    private SqlExecutionContext mainSqlExecutionContext;\n+\n+    @Test\n+    public void simpleTableTest1() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void allTypesPartitionedTableTest1() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable2\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (\" +\n+                    \"select\" +\n+                    \" rnd_char() ch,\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" rnd_int() a1,\" +\n+                    \" rnd_int(0, 30, 2) a,\" +\n+                    \" rnd_boolean() b,\" +\n+                    \" rnd_str(3,3,2) c,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" rnd_float(2) e,\" +\n+                    \" rnd_short(10,1024) f,\" +\n+                    \" rnd_short() f1,\" +\n+                    \" rnd_date(to_date('2015', 'yyyy'), to_date('2016', 'yyyy'), 2) g,\" +\n+                    \" rnd_timestamp(to_timestamp('2015', 'yyyy'), to_timestamp('2016', 'yyyy'), 2) h,\" +\n+                    \" rnd_symbol(4,4,4,2) i,\" +\n+                    \" rnd_long(100,200,2) j,\" +\n+                    \" rnd_long() j1,\" +\n+                    \" timestamp_sequence(0, 1000000000) k,\" +\n+                    \" rnd_byte(2,50) l,\" +\n+                    \" rnd_bin(10, 20, 2) m\" +\n+                    \" from long_sequence(1000)\" +\n+                    \")  timestamp(k) partition by DAY\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void multipleTableTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            mainCompiler.compile(\"create table tb2 as (select\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" timestamp_sequence(10000000000, 500000000) ts\" +\n+                    \" from long_sequence(100000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+\n+            setFinalBackupPath();\n+\n+            String sourceSelectAll = selectAll(\"tb1\", false);\n+            String backupSelectAll = selectAll(\"tb1\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+\n+            sourceSelectAll = selectAll(\"tb2\", false);\n+            backupSelectAll = selectAll(\"tb2\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    @Test\n+    public void successiveBackupsTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+            setFinalBackupPath();\n+            String sourceSelectAll = selectAll(tableName, false);\n+            String backupSelectAll1 = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll1);\n+\n+            // @formatter:off\n+            mainCompiler.compile(\"insert into \" + tableName +\n+                    \" select * from (\" +\n+                    \" select rnd_symbol(4,4,4,2) sym, rnd_double(2) d, timestamp_sequence(10000000000, 500000000) ts from long_sequence(5)\" +\n+                    \") timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+\n+            sourceSelectAll = selectAll(tableName, false);\n+            setFinalBackupPath(1);\n+            String backupSelectAll2 = selectAll(tableName, true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll2);\n+\n+            // Check previous backup is unaffected\n+            setFinalBackupPath();\n+            String backupSelectAllOriginal = selectAll(tableName, true);\n+            Assert.assertEquals(backupSelectAll1, backupSelectAllOriginal);\n+        });\n+    }\n+\n+    @Test(expected = SqlException.class)\n+    public void missingTableTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table tb1, tb2\", mainSqlExecutionContext);\n+        });\n+    }\n+\n+    @Test(expected = CairoException.class)\n+    public void incorrectConfigTest() throws Exception {\n+        backupRoot = null;\n+        assertMemoryLeak(() -> {\n+            String tableName = \"testTable1\";\n+            // @formatter:off\n+            mainCompiler.compile(\"create table \" + tableName + \" as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup table \" + tableName, mainSqlExecutionContext);\n+        });\n+    }\n+\n+    @Test\n+    public void backupDatabaseTest() throws Exception {\n+        assertMemoryLeak(() -> {\n+            // @formatter:off\n+            mainCompiler.compile(\"create table tb1 as (select\" +\n+                    \" rnd_symbol(4,4,4,2) sym,\" +\n+                    \" rnd_double(2) d,\" +\n+                    \" timestamp_sequence(0, 1000000000) ts\" +\n+                    \" from long_sequence(10000)) timestamp(ts)\", mainSqlExecutionContext);\n+            mainCompiler.compile(\"create table tb2 as (select\" +\n+                    \" rnd_long256() ll,\" +\n+                    \" timestamp_sequence(10000000000, 500000000) ts\" +\n+                    \" from long_sequence(100000)) timestamp(ts)\", mainSqlExecutionContext);\n+            // @formatter:on\n+\n+            mainCompiler.compile(\"backup database\", mainSqlExecutionContext);\n+\n+            setFinalBackupPath();\n+\n+            String sourceSelectAll = selectAll(\"tb1\", false);\n+            String backupSelectAll = selectAll(\"tb1\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+\n+            sourceSelectAll = selectAll(\"tb2\", false);\n+            backupSelectAll = selectAll(\"tb2\", true);\n+            Assert.assertEquals(sourceSelectAll, backupSelectAll);\n+        });\n+    }\n+\n+    private void setFinalBackupPath() {\n+        setFinalBackupPath(0);\n+    }\n+\n+    private void setFinalBackupPath(int n) {\n+        DateTimeFormatter formatter = mainConfiguration.getBackupDirDateTimeFormatter();\n+        String subDirNm = formatter.format(LocalDate.now());\n+        if (n > 0) {\n+            subDirNm += \".\" + n;\n+        }\n+        finalBackupPath.of(mainConfiguration.getBackupRoot()).put(Files.SEPARATOR).concat(subDirNm).put(Files.SEPARATOR).$();\n+    }\n+\n+    private String selectAll(String tableName, boolean backup) throws Exception {\n+        CairoEngine engine = null;\n+        SqlCompiler compiler = null;\n+        SqlExecutionContext sqlExecutionContext;\n+        try {\n+            if (backup) {\n+                CairoConfiguration backupConfiguration = new DefaultCairoConfiguration(finalBackupPath.toString());\n+                MessageBus backupMessageBus = new MessageBusImpl();\n+                sqlExecutionContext = new SqlExecutionContextImpl().with(AllowAllCairoSecurityContext.INSTANCE, new BindVariableService(), backupMessageBus);\n+                engine = new CairoEngine(backupConfiguration, backupMessageBus);\n+                compiler = new SqlCompiler(engine);\n+            } else {\n+                engine = mainEngine;\n+                compiler = mainCompiler;\n+                sqlExecutionContext = mainSqlExecutionContext;\n+            }\n+            return selectAll(engine, compiler, sqlExecutionContext, tableName);\n+        } finally {\n+            if (backup) {\n+                engine.close();\n+                compiler.close();\n+            }\n+        }\n+    }\n+\n+    private String selectAll(CairoEngine engine, SqlCompiler compiler, SqlExecutionContext sqlExecutionContext, String tableName) throws Exception {\n+        CompiledQuery compiledQuery = compiler.compile(\"select * from \" + tableName, sqlExecutionContext);\n+        try (RecordCursorFactory factory = compiledQuery.getRecordCursorFactory(); RecordCursor cursor = factory.getCursor(sqlExecutionContext)) {\n+            sink.clear();\n+            printer.print(cursor, factory.getMetadata(), true);\n+            cursor.toTop();", "originalCommit": "e9f78ad9b44a657e8344bbeeff99288c17410dc1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0fd40db31aafe9a8210b9dffe22c9b29567b1534", "url": "https://github.com/questdb/questdb/commit/0fd40db31aafe9a8210b9dffe22c9b29567b1534", "message": "feat(griffin): add database backup", "committedDate": "2020-04-08T15:53:43Z", "type": "commit"}, {"oid": "e1a453da2bc6541eaee9ccd6cd969be1c2794452", "url": "https://github.com/questdb/questdb/commit/e1a453da2bc6541eaee9ccd6cd969be1c2794452", "message": "feat(griffin): add database backup\n\treplace java.time.format.DateTimeFormatter with io.questdb.std.microtime.TimestampFormat", "committedDate": "2020-04-08T21:04:40Z", "type": "commit"}, {"oid": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "url": "https://github.com/questdb/questdb/commit/4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "message": "feat(griffin): add database backup", "committedDate": "2020-04-08T21:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODY3Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407048672", "bodyText": "SqlCompiler is generally not thread safe, Because we have fixed number of threads, each thread is assigned a compiler to use. Does this allow us to remove the todo?", "author": "bluestreak01", "createdAt": "2020-04-11T10:48:56Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDM3OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407990379", "bodyText": "I am happy to remove it. Even if two thread run exactly at the same time one will succeed and one will fail, it should not trash anything, will remove the TODO but leave the comment", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0ODkxNA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407048914", "bodyText": "you may not have known this, but to avoid copying the same string to path over and over Path supports trimTo() method. For example this code will do the same thing as original loop:\nrenamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\nint plen = renamePath.length();\ndo {\n    renamePath.trimTo(plen);\n    format.format(\n         epochMicros, \n         TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), \n         null, \n         renamePath\n    );\n    if (n > 0) {\n        renamePath.put('.').put(n);\n     }\n     renamePath.put(Files.SEPARATOR).$();\n} while(ff.exists(renamePath));", "author": "bluestreak01", "createdAt": "2020-04-11T10:51:27Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0OTk3NA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407049974", "bodyText": "Caching backup root like this can cause a potential side effect that server will not be able to back a table after backup directory was successfully created by server and then manually removed by user.\nChecking dir for existence is a low overhead generally compared to creating a directory anyway.\nOh, looking down the code, cloneMetaData will create these directories anyway. May be we should not be creating directory upfront like this?", "author": "bluestreak01", "createdAt": "2020-04-11T11:01:36Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMDE1MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408030151", "bodyText": "I cached the tmp backup root because its a string and I dont want to create one every time. We could add yet another Path object to the SqlCompiler but I though the code was clearer with the transient String cachedTmpBackupRoot. However, you are correct that we dont need to create the directory at the same time as populating cachedTmpBackupRoot. The cloneMetaData will do it and its safer to do it there, so I have remove the mkdirs.", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA0OTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MDQzMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407050431", "bodyText": "on the subject of mkdir mode, perhaps we should have separate configuration property for backup mode?\nOriginal mkdirMode is for directories created by server runtime, these are not necessarily need to be readable by other processes and/or users. On other hand backup directory could potentially be picked up by another process, such as tape backup or something similar and thus need to have different permissions than runtime dirs.", "author": "bluestreak01", "createdAt": "2020-04-11T11:06:52Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzMTY1Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408031652", "bodyText": "I can add one, but I do think we need to be wary of adding a lot of configuration parameters without user input.", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTUyMQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407051521", "bodyText": "sorry to be a pain, all other \"for\" loops across the project at limited by constant rather than function. The rationale is to avoid calling function in a loop unnecessarily (which java will do).\nThis may not matter as much here, but still it goes on the assumption that sourceMetaData.getColumnCount() is lightweight, which it is, but only coincidentally.\nMore robust loop would be:\nfor (int i = 0, n = sourceMetaData.getColumnCount(); i < n; i++) {", "author": "bluestreak01", "createdAt": "2020-04-11T11:18:22Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);\n+\n+                tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok || Chars.equals(tok, ';')) {\n+                    break;\n+                }\n+                if (!Chars.equals(tok, ',')) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected ','\");\n+                }\n+            }\n+\n+            for (int n = 0; n < tableNames.size(); n++) {\n+                backupTable(tableNames.get(n), executionContext);\n+            }\n+\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            tableNames.clear();\n+        }\n+    }\n+\n+    private void setupBackupRenamePath() {\n+        TimestampFormat format = configuration.getBackupDirTimestampFormat();\n+        long epochMicros = configuration.getMicrosecondClock().getTicks();\n+        int n = 0;\n+        // TODO: There is a race here, two threads could try and create the same renamePath, only one will succeed the other will throw\n+        // a CairoException. Maybe it should be serialised\n+        do {\n+            renamePath.of(configuration.getBackupRoot()).put(Files.SEPARATOR);\n+            format.format(epochMicros, TimestampLocaleFactory.INSTANCE.getDefaultTimestampLocale(), null, renamePath);\n+            if (n > 0) {\n+                renamePath.put('.').put(n);\n+            }\n+            renamePath.put(Files.SEPARATOR).$();\n+            n++;\n+        } while (ff.exists(renamePath));\n+        if (ff.mkdirs(renamePath, configuration.getMkDirMode()) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"could not create [dir=\").put(renamePath).put(']');\n+        }\n+    }\n+\n+    private transient String cachedTmpBackupRoot;\n+\n+    private void backupTable(@NotNull CharSequence tableName, @NotNull SqlExecutionContext executionContext) {\n+        LOG.info().$(\"Starting backup of \").$(tableName).$();\n+        if (null == cachedTmpBackupRoot) {\n+            if (null == configuration.getBackupRoot()) {\n+                throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+            }\n+            path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).$();\n+            cachedTmpBackupRoot = path.toString();\n+            if (!ff.exists(path)) {\n+                LOG.info().$(\"Creating backup directory \").$(cachedTmpBackupRoot).$();\n+                if (ff.mkdirs(path, configuration.getMkDirMode()) != 0) {\n+                    throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+                }\n+            }\n+        }\n+\n+        CairoSecurityContext securityContext = executionContext.getCairoSecurityContext();\n+        try (TableReader reader = engine.getReader(securityContext, tableName)) {\n+            cloneMetaData(tableName, configuration.getRoot(), cachedTmpBackupRoot, configuration.getMkDirMode(), reader);\n+            try (TableWriter backupWriter = engine.getBackupWriter(securityContext, tableName, cachedTmpBackupRoot)) {\n+                RecordCursor cursor = reader.getCursor();\n+                copyTableData(cursor, reader.getMetadata(), backupWriter);\n+                backupWriter.commit();\n+            }\n+        }\n+\n+        path.of(configuration.getBackupRoot()).concat(configuration.getBackupTempDirName()).put(Files.SEPARATOR).concat(tableName).$();\n+        int renameRootLen = renamePath.length();\n+        try {\n+            renamePath.trimTo(renameRootLen).concat(tableName).$();\n+            if (!ff.rename(path, renamePath)) {\n+                throw CairoException.instance(ff.errno()).put(\"Could not rename [from=\").put(path).put(\", to=\").put(renamePath).put(']');\n+            }\n+            LOG.info().$(\"Completed backup of \").$(tableName).$(\" to \").$(renamePath).$();\n+        } finally {\n+            renamePath.trimTo(renameRootLen).$();\n+        }\n+    }\n+\n+    private void cloneMetaData(CharSequence tableName, CharSequence root, CharSequence backupRoot, int mkDirMode, TableReader reader) {\n+        path.of(backupRoot).concat(tableName).put(Files.SEPARATOR).$();\n+\n+        if (ff.exists(path)) {\n+            throw CairoException.instance(0).put(\"Backup dir for table \\\"\").put(tableName).put(\"\\\" already exists [dir=\").put(path).put(']');\n+        }\n+\n+        if (ff.mkdirs(path, mkDirMode) != 0) {\n+            throw CairoException.instance(ff.errno()).put(\"Could not create [dir=\").put(path).put(']');\n+        }\n+\n+        TableReaderMetadata sourceMetaData = (TableReaderMetadata) reader.getMetadata();\n+        int rootLen = path.length();\n+        try {\n+            mem.of(ff, path.trimTo(rootLen).concat(TableUtils.META_FILE_NAME).$(), ff.getPageSize());\n+            sourceMetaData.cloneTo(mem);\n+\n+            // create symbol maps\n+            path.trimTo(rootLen).$();\n+            int symbolMapCount = 0;\n+            for (int i = 0; i < sourceMetaData.getColumnCount(); i++) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNDI4Ng==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408034286", "bodyText": "lol, I am not sure this will make any difference at all, the function call is just a getter and it will be inlined. However, changing the code will make it explicit rather than implicit,I will change this", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T10:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjAwMg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052002", "bodyText": "I feel this loop should be robust to directory creating corrupt tables, for example any table on which backupTable  might fail.\nThis would make interface relatively consistent. We should be able to say that backup database will backup everything than can be backed up and will log tables it could not backup.", "author": "bluestreak01", "createdAt": "2020-04-11T11:23:25Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4Nzk1MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407987951", "bodyText": "Yes, sounds sensible, will log at error levele", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052789", "bodyText": "These names should be validated that they don't contain malicious paths. There is GenericLexer.unhack to do that.", "author": "bluestreak01", "createdAt": "2020-04-11T11:32:23Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1581,6 +1650,178 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+        if (null == configuration.getBackupRoot()) {\n+            throw CairoException.instance(0).put(\"Backup is disabled, no backup root directory is configured in the server configuration ['cairo.sql.backup.root' property]\");\n+        }\n+\n+        final CharSequence tok = SqlUtil.fetchNext(lexer);\n+        if (null != tok) {\n+            if (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+                return sqlTableBackup(executionContext);\n+            }\n+            if (Chars.equalsLowerCaseAscii(tok, \"database\")) {\n+                return sqlDatabaseBackup(executionContext);\n+            }\n+        }\n+\n+        throw SqlException.position(lexer.lastTokenPosition()).put(\" expected 'table' or 'database'\");\n+    }\n+\n+    private final FindVisitor sqlDatabaseBackupOnFind = (file, type) -> {\n+        nativeLPSZ.of(file);\n+        if (type == Files.DT_DIR && nativeLPSZ.charAt(0) != '.') {\n+            backupTable(nativeLPSZ, currentExecutionContext);\n+        }\n+    };\n+\n+    private CompiledQuery sqlDatabaseBackup(SqlExecutionContext executionContext) throws SqlException {\n+        currentExecutionContext = executionContext;\n+        try {\n+            setupBackupRenamePath();\n+            ff.iterateDir(path.of(configuration.getRoot()).$(), sqlDatabaseBackupOnFind);\n+            return compiledQuery.ofBackupTable();\n+        } finally {\n+            currentExecutionContext = null;\n+        }\n+    }\n+\n+    private CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+        setupBackupRenamePath();\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ObjHashSet<CharSequence> tableNames = (ObjHashSet<CharSequence>) cachedObjSet;\n+        try {\n+            tableNames.clear();\n+            while (true) {\n+                CharSequence tok = SqlUtil.fetchNext(lexer);\n+                if (null == tok) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a table name\");\n+                }\n+                CharSequence tableName = GenericLexer.unhack(GenericLexer.unquote(tok));\n+                if (tableName == null) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" expected a valid table name\");\n+                }\n+                int status = engine.getStatus(executionContext.getCairoSecurityContext(), path, tableName, 0, tableName.length());\n+                if (status != TableUtils.TABLE_EXISTS) {\n+                    throw SqlException.position(lexer.lastTokenPosition()).put(\" '\").put(tableName).put(\"' is not  a valid table\");\n+                }\n+                tableNames.add(tableName);", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4OTM0MQ==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407989341", "bodyText": "tableName is already unhacked after being unquoteded, is that not ok?", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T09:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzODMzNg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r408238336", "bodyText": "it is ok, sorry, overlooked!", "author": "bluestreak01", "createdAt": "2020-04-14T15:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjk4Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407052982", "bodyText": "I feel these checks are unnecessary. The config comes from file on disk, so attacker would have already gotten access to file system.\nAdditionally there are methods like Chars.contains() and others, which would let you check if CharSequence contains \\ without creating a string.", "author": "bluestreak01", "createdAt": "2020-04-11T11:34:24Z", "path": "core/src/main/java/io/questdb/PropServerConfiguration.java", "diffHunk": "@@ -497,6 +527,21 @@ private String getString(Properties properties, String key, String defaultValue)\n         return value;\n     }\n \n+    private TimestampFormat getTimestampFormat(Properties properties, String key, String defaultPattern) throws ServerConfigurationException {\n+        String pattern = properties.getProperty(key);\n+        if (null == pattern) {\n+            pattern = defaultPattern;\n+        }\n+        DateFormatCompiler compiler = new DateFormatCompiler();\n+        if (null != pattern) {\n+            if (pattern.contains(new StringBuilder().append(Files.SEPARATOR).toString()) || pattern.startsWith(\".\")) {", "originalCommit": "4c64e803a40bbf54c7c5d47c29dabaa8fdf3133d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3MTg1OA==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r407971858", "bodyText": "True, it is over defensive, I will remove it", "author": "patrickSpaceSurfer", "createdAt": "2020-04-14T08:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1Mjk4Mg=="}], "type": "inlineReview"}, {"oid": "a26ced865d7885399d0d7e9762f44bd9a6bbf463", "url": "https://github.com/questdb/questdb/commit/a26ced865d7885399d0d7e9762f44bd9a6bbf463", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T10:34:25Z", "type": "commit"}, {"oid": "0dd5fe7def598c5bf04e611bb492af669223296f", "url": "https://github.com/questdb/questdb/commit/0dd5fe7def598c5bf04e611bb492af669223296f", "message": "Merge branch 'master' into table-backup2", "committedDate": "2020-04-14T10:55:19Z", "type": "commit"}, {"oid": "281302eab06515beef3716944aafb6d40355e267", "url": "https://github.com/questdb/questdb/commit/281302eab06515beef3716944aafb6d40355e267", "message": "feat(griffin): add database backup\n\tcache table copier", "committedDate": "2020-04-14T13:42:20Z", "type": "commit"}, {"oid": "a20b7ecef33ad7f5f1e5bf843ad428d75448bc74", "url": "https://github.com/questdb/questdb/commit/a20b7ecef33ad7f5f1e5bf843ad428d75448bc74", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T13:50:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MTcyNw==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401771727", "bodyText": "Allocating new ObjList here, probably want to have this as a reusable resource in SqlCompiler. Or maybe there is a better way of parsing the SQL in general", "author": "patrickSpaceSurfer", "createdAt": "2020-04-01T17:04:44Z", "path": "core/src/main/java/io/questdb/griffin/SqlCompiler.java", "diffHunk": "@@ -1611,6 +1668,95 @@ private void validateTableModelAndCreateTypeCast(\n             throw SqlException.position(0).put(\"timestamp is not defined\");\n         }\n     }\n+    \n+    private CompiledQuery sqlBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tfinal CharSequence tok = SqlUtil.fetchNext(lexer);\n+\t\tif (null != tok) {\n+\t\t\tif (Chars.equalsLowerCaseAscii(tok, \"table\")) {\n+\t\t\t\treturn sqlTableBackup(executionContext);\n+\t\t\t}\n+\t\t}\n+\t\tthrow SqlException.position(lexer.getPosition()).put(\" expected 'table'\");\n+      }\n+    \n+\tprivate CompiledQuery sqlTableBackup(SqlExecutionContext executionContext) throws SqlException {\n+\t\tObjList<CharSequence> tableNames = new ObjList<>();\n+\t\twhile (true) {", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc3MjQ5Mg==", "url": "https://github.com/questdb/questdb/pull/133#discussion_r401772492", "bodyText": "Refactored releaseInactive so that it can also be used by the WriterMaintenanceJob below. Not sure if this is a good idea", "author": "patrickSpaceSurfer", "createdAt": "2020-04-01T17:06:11Z", "path": "core/src/main/java/io/questdb/cairo/CairoEngine.java", "diffHunk": "@@ -199,14 +216,22 @@ public boolean releaseAllReaders() {\n         return readerPool.releaseAll();\n     }\n ", "originalCommit": "62b7d0ec0f9f0af398f2b676e6c258e433fe1895", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7361ffa19521f4caf5e9a985f8f606b3769175b2", "url": "https://github.com/questdb/questdb/commit/7361ffa19521f4caf5e9a985f8f606b3769175b2", "message": "feat(griffin): add database backup", "committedDate": "2020-04-14T16:35:58Z", "type": "commit"}]}