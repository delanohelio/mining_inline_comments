{"pr_number": 244, "pr_title": "Replication", "pr_createdAt": "2020-04-28T22:10:04Z", "pr_url": "https://github.com/questdb/questdb/pull/244", "timeline": [{"oid": "80b6707228abc015f13f7fc338815ff2ce72e633", "url": "https://github.com/questdb/questdb/commit/80b6707228abc015f13f7fc338815ff2ce72e633", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-07T10:51:47Z", "type": "commit"}, {"oid": "001e1945dac7a1e945e3e6147a96e9aca5b71ab8", "url": "https://github.com/questdb/questdb/commit/001e1945dac7a1e945e3e6147a96e9aca5b71ab8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-07T12:48:29Z", "type": "commit"}, {"oid": "ca1e22f025ddcc0c9a1529bd19265da5a26c6089", "url": "https://github.com/questdb/questdb/commit/ca1e22f025ddcc0c9a1529bd19265da5a26c6089", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-09T13:23:42Z", "type": "commit"}, {"oid": "ec1b7518dac6240261fa7a43dc3564c8f6e555a7", "url": "https://github.com/questdb/questdb/commit/ec1b7518dac6240261fa7a43dc3564c8f6e555a7", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T15:00:47Z", "type": "commit"}, {"oid": "ea2589535b7cd74b6bbbda29446fe99f00cbc664", "url": "https://github.com/questdb/questdb/commit/ea2589535b7cd74b6bbbda29446fe99f00cbc664", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T15:47:47Z", "type": "commit"}, {"oid": "df935b839cc9d478799d341b6ce34541a0c70b4d", "url": "https://github.com/questdb/questdb/commit/df935b839cc9d478799d341b6ce34541a0c70b4d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-13T16:41:58Z", "type": "commit"}, {"oid": "f46e994df2efe1889b85ecbb7e5dda03ad3bfc7f", "url": "https://github.com/questdb/questdb/commit/f46e994df2efe1889b85ecbb7e5dda03ad3bfc7f", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-14T08:02:40Z", "type": "commit"}, {"oid": "5567cf5427f825dbc25e11bf5906d71713bc1ddd", "url": "https://github.com/questdb/questdb/commit/5567cf5427f825dbc25e11bf5906d71713bc1ddd", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-14T09:48:16Z", "type": "commit"}, {"oid": "c32aaf306eb1722197ca4fb0a51422dd1f0013ca", "url": "https://github.com/questdb/questdb/commit/c32aaf306eb1722197ca4fb0a51422dd1f0013ca", "message": "chore(cairo): block writer minor tidy-up, added asserts", "committedDate": "2020-10-15T14:39:29Z", "type": "commit"}, {"oid": "81f166dc8a7c1b6c10d7db692b36768ae998fddd", "url": "https://github.com/questdb/questdb/commit/81f166dc8a7c1b6c10d7db692b36768ae998fddd", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-16T16:41:53Z", "type": "commit"}, {"oid": "b4bc35ff2f0a545f8fe1bd7f2c67078f6e1d8d9a", "url": "https://github.com/questdb/questdb/commit/b4bc35ff2f0a545f8fe1bd7f2c67078f6e1d8d9a", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-19T09:38:14Z", "type": "commit"}, {"oid": "4fa5bf1d92503b8c2b262aa29b75aea610d59943", "url": "https://github.com/questdb/questdb/commit/4fa5bf1d92503b8c2b262aa29b75aea610d59943", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-21T14:16:45Z", "type": "commit"}, {"oid": "0498df790c73816700503d039a69c4e041ae6979", "url": "https://github.com/questdb/questdb/commit/0498df790c73816700503d039a69c4e041ae6979", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:42:33Z", "type": "commit"}, {"oid": "5549a9d18f2a12d97ab59376b5c21960774d4356", "url": "https://github.com/questdb/questdb/commit/5549a9d18f2a12d97ab59376b5c21960774d4356", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:52:27Z", "type": "commit"}, {"oid": "8b5037a32936d3f39cab6d094a30c0677a04cd0f", "url": "https://github.com/questdb/questdb/commit/8b5037a32936d3f39cab6d094a30c0677a04cd0f", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T14:58:49Z", "type": "commit"}, {"oid": "581df752e14ade1bb4d98c1aec57583375f7723a", "url": "https://github.com/questdb/questdb/commit/581df752e14ade1bb4d98c1aec57583375f7723a", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-21T15:18:46Z", "type": "commit"}, {"oid": "7c4158cd611c6d3fde329c43c3924ad7387390ee", "url": "https://github.com/questdb/questdb/commit/7c4158cd611c6d3fde329c43c3924ad7387390ee", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-22T12:57:23Z", "type": "commit"}, {"oid": "f15fe2039b2c03893cb2e1455e83a58baa5ffc58", "url": "https://github.com/questdb/questdb/commit/f15fe2039b2c03893cb2e1455e83a58baa5ffc58", "message": "chore(cairo): Use PartitionStruct in TableBlockWriter", "committedDate": "2020-10-22T13:12:42Z", "type": "commit"}, {"oid": "f1e67609161067d52acd33965979b29f4cff8f34", "url": "https://github.com/questdb/questdb/commit/f1e67609161067d52acd33965979b29f4cff8f34", "message": "chore(cairo): Use factory correctly in TableBlockWriterTest", "committedDate": "2020-10-22T13:20:37Z", "type": "commit"}, {"oid": "ac0ea836641f796a49368303913f3fd4332aff14", "url": "https://github.com/questdb/questdb/commit/ac0ea836641f796a49368303913f3fd4332aff14", "message": "chore(cairo): Refactor PageFrame", "committedDate": "2020-10-22T13:22:22Z", "type": "commit"}, {"oid": "7b7cd9caa6f64cca425bba047f36e5ceaf34448b", "url": "https://github.com/questdb/questdb/commit/7b7cd9caa6f64cca425bba047f36e5ceaf34448b", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-22T16:56:37Z", "type": "commit"}, {"oid": "79d697fcc6b6ec4b0cf9e9a7c788c9b6127d7867", "url": "https://github.com/questdb/questdb/commit/79d697fcc6b6ec4b0cf9e9a7c788c9b6127d7867", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-23T14:37:04Z", "type": "commit"}, {"oid": "f4ab3e83bb9e5299051b4d8a3a204ec31456c7de", "url": "https://github.com/questdb/questdb/commit/f4ab3e83bb9e5299051b4d8a3a204ec31456c7de", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-23T16:40:47Z", "type": "commit"}, {"oid": "c4de88c2956e97ba48bf9ea2b471b792429b1430", "url": "https://github.com/questdb/questdb/commit/c4de88c2956e97ba48bf9ea2b471b792429b1430", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-26T10:29:33Z", "type": "commit"}, {"oid": "f00e66deb3d1fe627aa7be31141df427327bef33", "url": "https://github.com/questdb/questdb/commit/f00e66deb3d1fe627aa7be31141df427327bef33", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-26T11:01:43Z", "type": "commit"}, {"oid": "be0f0ba6cb54553bc1702352dac6b5d7af2281c3", "url": "https://github.com/questdb/questdb/commit/be0f0ba6cb54553bc1702352dac6b5d7af2281c3", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T11:55:36Z", "type": "commit"}, {"oid": "052b1f320df2a66f88bf2059817d596376e10e1d", "url": "https://github.com/questdb/questdb/commit/052b1f320df2a66f88bf2059817d596376e10e1d", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T13:45:22Z", "type": "commit"}, {"oid": "434a006fcba8ce8092fb9c88ebd36987b4961143", "url": "https://github.com/questdb/questdb/commit/434a006fcba8ce8092fb9c88ebd36987b4961143", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:09:20Z", "type": "commit"}, {"oid": "c3e9cfd5a8f9dcefcb6f4f2f60ce9bb7f7f975f7", "url": "https://github.com/questdb/questdb/commit/c3e9cfd5a8f9dcefcb6f4f2f60ce9bb7f7f975f7", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:32:24Z", "type": "commit"}, {"oid": "47bc7c2ea5663e503f219a29e725a2bfc56687ec", "url": "https://github.com/questdb/questdb/commit/47bc7c2ea5663e503f219a29e725a2bfc56687ec", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T14:46:38Z", "type": "commit"}, {"oid": "63ff73cafd600c43e3c27a4bd30f2b5027801dd2", "url": "https://github.com/questdb/questdb/commit/63ff73cafd600c43e3c27a4bd30f2b5027801dd2", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T15:39:12Z", "type": "commit"}, {"oid": "83512acd018ae7dd9bd7cd8d3789dcfe12362388", "url": "https://github.com/questdb/questdb/commit/83512acd018ae7dd9bd7cd8d3789dcfe12362388", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-10-28T15:50:42Z", "type": "commit"}, {"oid": "077120ada123af47e34b91839f957f815fb860b2", "url": "https://github.com/questdb/questdb/commit/077120ada123af47e34b91839f957f815fb860b2", "message": "chore(blockwriter): code tidy up", "committedDate": "2020-10-29T11:53:10Z", "type": "commit"}, {"oid": "4bba3ba39bb9d5d12a84b47e773ba0103afb589f", "url": "https://github.com/questdb/questdb/commit/4bba3ba39bb9d5d12a84b47e773ba0103afb589f", "message": "chore(blockwriter): code tidy up", "committedDate": "2020-10-29T12:32:18Z", "type": "commit"}, {"oid": "b295a701369be3ff6f0ede49384815a36ffccecb", "url": "https://github.com/questdb/questdb/commit/b295a701369be3ff6f0ede49384815a36ffccecb", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-29T12:34:04Z", "type": "commit"}, {"oid": "bacd6360b11ff45f64bb212a20c93dbc67fbc795", "url": "https://github.com/questdb/questdb/commit/bacd6360b11ff45f64bb212a20c93dbc67fbc795", "message": "chore(blockwriter): Reduce test resource usage", "committedDate": "2020-10-29T14:09:15Z", "type": "commit"}, {"oid": "57539df8f1b16979a5e19109f614474fdadeea89", "url": "https://github.com/questdb/questdb/commit/57539df8f1b16979a5e19109f614474fdadeea89", "message": "chore(blockwriter): Add more tests", "committedDate": "2020-10-29T14:13:38Z", "type": "commit"}, {"oid": "59fed07c2580d77e8f734e4449d2268aaf5247a9", "url": "https://github.com/questdb/questdb/commit/59fed07c2580d77e8f734e4449d2268aaf5247a9", "message": "chore(blockwriter): Fix fd leaks on open failure", "committedDate": "2020-10-29T14:50:50Z", "type": "commit"}, {"oid": "4afc5998e2ba0a6c24a199f352d3964848dafb88", "url": "https://github.com/questdb/questdb/commit/4afc5998e2ba0a6c24a199f352d3964848dafb88", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-30T10:26:38Z", "type": "commit"}, {"oid": "784244d0b1a9aa823a0890411c827892393fc8cf", "url": "https://github.com/questdb/questdb/commit/784244d0b1a9aa823a0890411c827892393fc8cf", "message": "chore(cairo): split up DataFrame and PageFrame interfaces, removed redundant calculations for row count", "committedDate": "2020-10-30T13:53:08Z", "type": "commit"}, {"oid": "fe82919d5fb0ccde123d10ded9c1253bde1ec37f", "url": "https://github.com/questdb/questdb/commit/fe82919d5fb0ccde123d10ded9c1253bde1ec37f", "message": "feat(cairo): Replication\n\tAdd VirtualMemory.putRawBytes", "committedDate": "2020-04-29T08:22:29Z", "type": "forcePushed"}, {"oid": "4a648a6d0152e2e8e66a24970ba84928c34079b3", "url": "https://github.com/questdb/questdb/commit/4a648a6d0152e2e8e66a24970ba84928c34079b3", "message": "feat(cairo): Replication", "committedDate": "2020-05-04T22:16:47Z", "type": "forcePushed"}, {"oid": "44ed0c38c5b96ff6f07c5ade908da50f254aa246", "url": "https://github.com/questdb/questdb/commit/44ed0c38c5b96ff6f07c5ade908da50f254aa246", "message": "feat(cairo): Replication\n\tChange ServerMain to integrate pulsar\n\tAdd VirtualMemory.getRawBytes", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "b63944dd70e86681a2a020ddfff5d2859416d607", "url": "https://github.com/questdb/questdb/commit/b63944dd70e86681a2a020ddfff5d2859416d607", "message": "feat(cairo): Replication\n\tAdd VirtualMemory.putRawBytes", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "b3d620c9dafcc0ac1d5f8672109938d34b8fd51a", "url": "https://github.com/questdb/questdb/commit/b3d620c9dafcc0ac1d5f8672109938d34b8fd51a", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:41:32Z", "type": "commit"}, {"oid": "aecefe2d6de460caecd9b99821fe8e4971a46242", "url": "https://github.com/questdb/questdb/commit/aecefe2d6de460caecd9b99821fe8e4971a46242", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:23Z", "type": "commit"}, {"oid": "fb19f5c89ebbd3d9064bada0ff8a6800ba1bbc99", "url": "https://github.com/questdb/questdb/commit/fb19f5c89ebbd3d9064bada0ff8a6800ba1bbc99", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:23Z", "type": "commit"}, {"oid": "4b2fc4eee433b3bce4e5ecb43f42c49c38ff2f38", "url": "https://github.com/questdb/questdb/commit/4b2fc4eee433b3bce4e5ecb43f42c49c38ff2f38", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:44:24Z", "type": "commit"}, {"oid": "ef00ad0e92198c95e6cf3900753034c74fc91fa6", "url": "https://github.com/questdb/questdb/commit/ef00ad0e92198c95e6cf3900753034c74fc91fa6", "message": "feat(cairo): Replication\n Allow PGWireServer to be enabled", "committedDate": "2020-05-11T15:44:24Z", "type": "commit"}, {"oid": "ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "url": "https://github.com/questdb/questdb/commit/ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:46:01Z", "type": "commit"}, {"oid": "ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "url": "https://github.com/questdb/questdb/commit/ea1d72335b3390bf5d1f9d047aef4625dc4a3473", "message": "feat(cairo): Replication", "committedDate": "2020-05-11T15:46:01Z", "type": "forcePushed"}, {"oid": "1c0bde6b9cb4c833fc103805afc866d6b31371f6", "url": "https://github.com/questdb/questdb/commit/1c0bde6b9cb4c833fc103805afc866d6b31371f6", "message": "feat(cairo): Replication", "committedDate": "2020-07-15T08:46:52Z", "type": "commit"}, {"oid": "ed04f5da398ea7db33c0e998ed4999c92178a4f6", "url": "https://github.com/questdb/questdb/commit/ed04f5da398ea7db33c0e998ed4999c92178a4f6", "message": "Merge tag '5.0.0' into replication", "committedDate": "2020-07-15T09:09:26Z", "type": "commit"}, {"oid": "9cfa8c691d60781d7be45d23d753a95d3f22ab24", "url": "https://github.com/questdb/questdb/commit/9cfa8c691d60781d7be45d23d753a95d3f22ab24", "message": "feat(cairo): Replication, fix memory leak", "committedDate": "2020-07-15T10:11:26Z", "type": "commit"}, {"oid": "10d03f0322b38f56af3b17c070595ae292e708e0", "url": "https://github.com/questdb/questdb/commit/10d03f0322b38f56af3b17c070595ae292e708e0", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-15T13:29:33Z", "type": "commit"}, {"oid": "ac5f5ac831f74bef1b75202b5fd2d961bf1f804b", "url": "https://github.com/questdb/questdb/commit/ac5f5ac831f74bef1b75202b5fd2d961bf1f804b", "message": "feat(cairo): Replication, fix merge issues", "committedDate": "2020-07-15T14:00:06Z", "type": "commit"}, {"oid": "f0c3fed9fb2272cc50fc016c7d34bde7f4b83562", "url": "https://github.com/questdb/questdb/commit/f0c3fed9fb2272cc50fc016c7d34bde7f4b83562", "message": "chore: Improve SOUnboundedCountDownLatchTest efficiency", "committedDate": "2020-07-24T13:02:45Z", "type": "commit"}, {"oid": "e59fe53233b5f9f6dc97bf548d07df3d1d40087f", "url": "https://github.com/questdb/questdb/commit/e59fe53233b5f9f6dc97bf548d07df3d1d40087f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-24T13:07:55Z", "type": "commit"}, {"oid": "d07afed18cd10e7c6381c3dd6a0a014dd2d1b04f", "url": "https://github.com/questdb/questdb/commit/d07afed18cd10e7c6381c3dd6a0a014dd2d1b04f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-27T13:39:59Z", "type": "commit"}, {"oid": "c7f6e8970ce9b80dc89c5d8b635aadcd0ad6cdc6", "url": "https://github.com/questdb/questdb/commit/c7f6e8970ce9b80dc89c5d8b635aadcd0ad6cdc6", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-27T13:57:56Z", "type": "commit"}, {"oid": "2a100e646f62830860bf8c003bf648370d469f47", "url": "https://github.com/questdb/questdb/commit/2a100e646f62830860bf8c003bf648370d469f47", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-27T14:34:30Z", "type": "commit"}, {"oid": "8eea2b1d3b4097b759e70c06d3bf13eba4d7f9b1", "url": "https://github.com/questdb/questdb/commit/8eea2b1d3b4097b759e70c06d3bf13eba4d7f9b1", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-29T13:32:39Z", "type": "commit"}, {"oid": "105152da243c54241bc9de5c36bc540f92f5e972", "url": "https://github.com/questdb/questdb/commit/105152da243c54241bc9de5c36bc540f92f5e972", "message": "Merge branch 'master' into replication", "committedDate": "2020-07-29T13:35:28Z", "type": "commit"}, {"oid": "b72a7da0e3ba4ca1bb424e22406b0fd08537a6c0", "url": "https://github.com/questdb/questdb/commit/b72a7da0e3ba4ca1bb424e22406b0fd08537a6c0", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-07-29T13:42:56Z", "type": "commit"}, {"oid": "fa92c1c8771d13a6ed5db8a5bdd19c45a7c6e2c3", "url": "https://github.com/questdb/questdb/commit/fa92c1c8771d13a6ed5db8a5bdd19c45a7c6e2c3", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-03T10:48:05Z", "type": "commit"}, {"oid": "1d804cce905c00a07965759e2a316a4f5d69a209", "url": "https://github.com/questdb/questdb/commit/1d804cce905c00a07965759e2a316a4f5d69a209", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-03T22:15:33Z", "type": "commit"}, {"oid": "26ef52d982e67650de58c51bc34c791ac91cd44f", "url": "https://github.com/questdb/questdb/commit/26ef52d982e67650de58c51bc34c791ac91cd44f", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-03T22:30:54Z", "type": "commit"}, {"oid": "01024a9cef33fddf6963f747a851c9b29d45a7a3", "url": "https://github.com/questdb/questdb/commit/01024a9cef33fddf6963f747a851c9b29d45a7a3", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:25:43Z", "type": "commit"}, {"oid": "5df53f228e199638443c1f7ade2e7780959f903a", "url": "https://github.com/questdb/questdb/commit/5df53f228e199638443c1f7ade2e7780959f903a", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:36:58Z", "type": "commit"}, {"oid": "bad6748f33eee5206bcfa31a107bf05a4d8cdc39", "url": "https://github.com/questdb/questdb/commit/bad6748f33eee5206bcfa31a107bf05a4d8cdc39", "message": "feat(cairo): Replication, change block write interface", "committedDate": "2020-08-04T08:39:57Z", "type": "commit"}, {"oid": "fbc159a519301326a03fad694c9f932c432247e8", "url": "https://github.com/questdb/questdb/commit/fbc159a519301326a03fad694c9f932c432247e8", "message": "feat(cairo): Replication refactoring", "committedDate": "2020-08-04T08:54:46Z", "type": "commit"}, {"oid": "b5d195112f69aa52c9ab5845445bc2b695339ca1", "url": "https://github.com/questdb/questdb/commit/b5d195112f69aa52c9ab5845445bc2b695339ca1", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-12T07:14:22Z", "type": "commit"}, {"oid": "bf3f089108fd5a321d4832aaa1dba59bf1bfe454", "url": "https://github.com/questdb/questdb/commit/bf3f089108fd5a321d4832aaa1dba59bf1bfe454", "message": "feat(cairo): Replication refactoring", "committedDate": "2020-08-12T08:13:54Z", "type": "commit"}, {"oid": "dade6478de20892db9cc9059cf2917f3a1780085", "url": "https://github.com/questdb/questdb/commit/dade6478de20892db9cc9059cf2917f3a1780085", "message": "chore: Fix merge issues", "committedDate": "2020-08-12T08:14:09Z", "type": "commit"}, {"oid": "22900ed6244df2d2339f49692ed730277f5e8668", "url": "https://github.com/questdb/questdb/commit/22900ed6244df2d2339f49692ed730277f5e8668", "message": "feat(cairo): Add support for String columns to TableBlockWriter", "committedDate": "2020-08-14T10:21:23Z", "type": "commit"}, {"oid": "e36b69f829dca019fdf913005575b9125d41e6e0", "url": "https://github.com/questdb/questdb/commit/e36b69f829dca019fdf913005575b9125d41e6e0", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-14T10:24:34Z", "type": "commit"}, {"oid": "b3e1f1514a150d58b69af820759e9b55dd0236e9", "url": "https://github.com/questdb/questdb/commit/b3e1f1514a150d58b69af820759e9b55dd0236e9", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-14T10:57:32Z", "type": "commit"}, {"oid": "e31427f20014a91faa4bda80c53fff4b88544fd5", "url": "https://github.com/questdb/questdb/commit/e31427f20014a91faa4bda80c53fff4b88544fd5", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-14T13:02:23Z", "type": "commit"}, {"oid": "cf8a8a6cb0c60cac4f78fe36189a932a4516f6ad", "url": "https://github.com/questdb/questdb/commit/cf8a8a6cb0c60cac4f78fe36189a932a4516f6ad", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-17T10:20:41Z", "type": "commit"}, {"oid": "e867e4d9d7f7a27d939e3060f938ffaca62a726b", "url": "https://github.com/questdb/questdb/commit/e867e4d9d7f7a27d939e3060f938ffaca62a726b", "message": "feat(cairo): Add support for binary columns to TableBlockWriter", "committedDate": "2020-08-17T12:41:45Z", "type": "commit"}, {"oid": "41c6ed2b7798508d11094f30b601da19a9940f47", "url": "https://github.com/questdb/questdb/commit/41c6ed2b7798508d11094f30b601da19a9940f47", "message": "chore(cairo): Fix memory leak in LimitRecordCursorFactory", "committedDate": "2020-08-19T11:10:44Z", "type": "commit"}, {"oid": "ee64f1fbc2eb5ed051b2dbaf80e4171aa2f8aa7e", "url": "https://github.com/questdb/questdb/commit/ee64f1fbc2eb5ed051b2dbaf80e4171aa2f8aa7e", "message": "feat(cairo): Fix issues with variable length columns", "committedDate": "2020-08-19T13:11:37Z", "type": "commit"}, {"oid": "0152c89521b944570c0d603ee75f3163df55e551", "url": "https://github.com/questdb/questdb/commit/0152c89521b944570c0d603ee75f3163df55e551", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-19T13:13:50Z", "type": "commit"}, {"oid": "5dd7a62446f27582715eca1d9884af5c45285364", "url": "https://github.com/questdb/questdb/commit/5dd7a62446f27582715eca1d9884af5c45285364", "message": "chore(cairo): Change SymbolMapReader to support symbolCharsAddressOf and replace ReadOnlyMemory with ExtendableOnePageMemory", "committedDate": "2020-08-20T09:31:33Z", "type": "commit"}, {"oid": "64378b1e7d4e2a177574caad948cbe9897f137ce", "url": "https://github.com/questdb/questdb/commit/64378b1e7d4e2a177574caad948cbe9897f137ce", "message": "chore(cairo): Fix exception message in test", "committedDate": "2020-08-20T09:51:52Z", "type": "commit"}, {"oid": "3a815e24130e08b7c0f71a808f9bbba8395bfa16", "url": "https://github.com/questdb/questdb/commit/3a815e24130e08b7c0f71a808f9bbba8395bfa16", "message": "feat(cairo): Add spoort for symbols to TableBlockWriter", "committedDate": "2020-08-20T10:50:07Z", "type": "commit"}, {"oid": "77a5ad4abbe76ce41ac6b783e82863a1e97bb622", "url": "https://github.com/questdb/questdb/commit/77a5ad4abbe76ce41ac6b783e82863a1e97bb622", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-20T16:37:34Z", "type": "commit"}, {"oid": "05db13c0e3cef9c909f7e3cd6e7fd4ad8d4194ab", "url": "https://github.com/questdb/questdb/commit/05db13c0e3cef9c909f7e3cd6e7fd4ad8d4194ab", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-20T21:20:09Z", "type": "commit"}, {"oid": "f1f7adf435af7afc56bd899f2fc7afb3a759ddb0", "url": "https://github.com/questdb/questdb/commit/f1f7adf435af7afc56bd899f2fc7afb3a759ddb0", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-21T13:29:08Z", "type": "commit"}, {"oid": "2f72d66a6918bc8f249d612f3ab36fab45ac8fe2", "url": "https://github.com/questdb/questdb/commit/2f72d66a6918bc8f249d612f3ab36fab45ac8fe2", "message": "feat(cairo): TableBlockWriter", "committedDate": "2020-08-21T14:09:17Z", "type": "commit"}, {"oid": "88d6eb4db7d9df1e2bf9192f02a533f10a9c8731", "url": "https://github.com/questdb/questdb/commit/88d6eb4db7d9df1e2bf9192f02a533f10a9c8731", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-21T14:28:51Z", "type": "commit"}, {"oid": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "url": "https://github.com/questdb/questdb/commit/bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-21T19:12:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwMDI1MQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475200251", "bodyText": "this needs fixing a bit more in so far as not checking if string fits the page when len = -1. I would probably make it looks like this emphasising hot path:\n    public final CharSequence getStr0(long offset, CharSequenceView view) {\n        final int len = getInt(offset);\n        if (len > -1 && offset + len * Character.BYTES + Integer.BYTES <= size) {\n            return view.of(offset + VirtualMemory.STRING_LENGTH_BYTES, len);\n        }\n        \n        if (len == TableUtils.NULL_LEN) {\n            return null;\n        }\n\n        throw CairoException.instance(0).put(\"String is outside of file boundary [offset=\").put(offset).put(\", len=\").put(len).put(']');\n    }", "author": "bluestreak01", "createdAt": "2020-08-23T10:10:22Z", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -232,7 +232,7 @@ public void getLong256(long offset, Long256Sink sink) {\n \n     public final CharSequence getStr0(long offset, CharSequenceView view) {\n         final int len = getInt(offset);\n-        if (offset + len + Integer.BYTES < size) {\n+        if (offset + len * 2 + Integer.BYTES <= size) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNTQwNw==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475205407", "bodyText": "For \"overflown\" symbol index we should just return the high address of underlying memory.", "author": "bluestreak01", "createdAt": "2020-08-23T11:04:42Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapReaderImpl.java", "diffHunk": "@@ -204,4 +205,19 @@ private void growCharMemToSymbolCount(int symbolCount) {\n     private CharSequence uncachedValue(int key) {\n         return charMem.getStr(offsetMem.getLong(SymbolMapWriter.keyToOffset(key)));\n     }\n+\n+    @Override\n+    public long symbolCharsAddressOf(int symbolIndex) {\n+        if (symbolIndex < symbolCount) {\n+            long offset = offsetMem.getLong(SymbolMapWriter.keyToOffset(symbolIndex));\n+            return charMem.addressOf(offset);\n+        } else if (symbolIndex == symbolCount) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475206596", "bodyText": "does Hash.hasMem() not work in this case?", "author": "bluestreak01", "createdAt": "2020-08-23T11:16:08Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "diffHunk": "@@ -234,4 +243,41 @@ private int put0(CharSequence symbol, int hash) {\n         indexWriter.add(hash, offsetOffset);\n         return offsetToKey(offsetOffset);\n     }\n+\n+    public void appendSymbolCharsBlock(long blockLength, long sourceAddress) {\n+        long appendOffset = charMem.getAppendOffset();\n+        try {\n+            charMem.jumpTo(appendOffset);\n+            charMem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            charMem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void commitAppendedBlock(int nSymbolsAdded) {\n+        long offset = charMem.getAppendOffset();\n+        int symbolIndex = getSymbolCount();\n+        int nSymbols = symbolIndex + nSymbolsAdded;\n+        while (symbolIndex < nSymbols) {\n+            long symCharsOffset = offset;\n+            int symLen = charMem.getInt(offset);\n+            offset += Integer.BYTES;\n+            long symCharsOffsetHi = offset + symLen * Character.BYTES;\n+            tmpSymbol.of(charMem.addressOf(offset), charMem.addressOf(symCharsOffsetHi));\n+\n+            long offsetOffset = offsetMem.getAppendOffset();\n+            offsetMem.putLong(symCharsOffset);\n+            int hash = Hash.boundedHash(tmpSymbol, maxHash);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2Mjc1NQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r478562755", "bodyText": "The hashes generated are different", "author": "patrickSpaceSurfer", "createdAt": "2020-08-27T16:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNjU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzA3OQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207079", "bodyText": "This is a bad reference ownership. I feel this whole class can be part of TableWriter to avoid issues like this", "author": "bluestreak01", "createdAt": "2020-08-23T11:20:57Z", "path": "core/src/main/java/io/questdb/cairo/TableBlockWriter.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package io.questdb.cairo;\n+\n+import java.io.Closeable;\n+\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.ObjList;\n+import io.questdb.std.str.Path;\n+\n+public class TableBlockWriter implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TableBlockWriter.class);\n+    private TableWriter writer;\n+    private final ObjList<AppendMemory> columns = new ObjList<>();\n+    private final CharSequence root;\n+    private final FilesFacade ff;\n+    private final int mkDirMode;\n+    private final Path path = new Path();\n+\n+    private int rootLen;\n+    private RecordMetadata metadata;\n+    private int columnCount;\n+    private int partitionBy;\n+    private long partitionLo;\n+    private long partitionHi;\n+\n+    public TableBlockWriter(CairoConfiguration configuration) {\n+        root = configuration.getRoot();\n+        this.ff = configuration.getFilesFacade();\n+        this.mkDirMode = configuration.getMkDirMode();\n+    }\n+\n+    public void appendBlock(long timestamp, int columnIndex, long blockLength, long sourceAddress) {\n+        if (timestamp < partitionLo && partitionLo != Long.MAX_VALUE) {\n+            throw CairoException.instance(0).put(\"can only append [timestamp=\").put(timestamp).put(\", partitionLo=\").put(partitionLo).put(']');\n+        }\n+\n+        if (timestamp > partitionHi || partitionLo == Long.MAX_VALUE) {\n+            openPartition(timestamp);\n+        }\n+\n+        AppendMemory mem = columns.getQuick(columnIndex);\n+        long appendOffset = mem.getAppendOffset();\n+        try {\n+            mem.putBlockOfBytes(sourceAddress, blockLength);\n+        } finally {\n+            mem.jumpTo(appendOffset);\n+        }\n+    }\n+\n+    public void appendSymbolCharsBlock(int columnIndex, long blockLength, long sourceAddress) {\n+        writer.getSymbolMapWriter(columnIndex).appendSymbolCharsBlock(blockLength, sourceAddress);\n+    }\n+\n+    public void commitAppendedBlock(long firstTimestamp, long lastTimestamp, long nRowsAdded) {\n+        LOG.info().$(\"committing block write of \").$(nRowsAdded).$(\" rows to \").$(path).$(\" [firstTimestamp=\").$ts(firstTimestamp).$(\", lastTimestamp=\").$ts(lastTimestamp).$(']').$();\n+        writer.commitAppendedBlock(firstTimestamp, lastTimestamp, nRowsAdded);\n+        reset();\n+    }\n+\n+    private void openPartition(long timestamp) {\n+        try {\n+            partitionLo = timestamp;\n+            partitionHi = TableUtils.setPathForPartition(path, partitionBy, timestamp);\n+            int plen = path.length();\n+            if (ff.mkdirs(path.put(Files.SEPARATOR).$(), mkDirMode) != 0) {\n+                throw CairoException.instance(ff.errno()).put(\"Cannot create directory: \").put(path);\n+            }\n+\n+            assert columnCount > 0;\n+            for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                final CharSequence name = metadata.getColumnName(columnIndex);\n+                AppendMemory mem = columns.getQuick(columnIndex);\n+                mem.of(ff, TableUtils.dFile(path.trimTo(plen), name), ff.getMapPageSize());\n+                mem.jumpTo(writer.getPrimaryAppendOffset(timestamp, columnIndex));\n+            }\n+            LOG.info().$(\"switched partition to '\").$(path).$('\\'').$();\n+        } finally {\n+            path.trimTo(rootLen);\n+        }\n+    }\n+\n+    public void of(TableWriter writer) {\n+        clear();\n+        this.writer = writer;\n+        metadata = writer.getMetadata();\n+        path.of(root).concat(writer.getName());\n+        rootLen = path.length();\n+        columnCount = metadata.getColumnCount();\n+        partitionBy = writer.getPartitionBy();\n+        int columnsSize = columns.size();\n+        while (columnsSize < columnCount) {\n+            columns.extendAndSet(columnsSize++, new AppendMemory());\n+        }\n+    }\n+\n+    public void clear() {\n+        if (null != writer) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzI2NQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207265", "bodyText": "this algorithm does not take into account column tops. Something that another implementation of framing does. Column top is non-zero when column is added to table after table was populated.", "author": "bluestreak01", "createdAt": "2020-08-23T11:23:03Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwNzUyNQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475207525", "bodyText": "can max symbol index be calculated from table reader?", "author": "bluestreak01", "createdAt": "2020-08-23T11:25:47Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODAzMQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208031", "bodyText": "if we use ContiguousPages the limit of row can be calculated as:\n  if (row < count - 1) \n      hi = getOffset(row+1)\n else \n      hi = pageSize", "author": "bluestreak01", "createdAt": "2020-08-23T11:30:57Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODEzNQ==", "url": "https://github.com/questdb/questdb/pull/244#discussion_r475208135", "bodyText": "symbol for all intents and purposes is an INT column\nSymbolTable is global (not partitioned) so it should not be part of the frame", "author": "bluestreak01", "createdAt": "2020-08-23T11:32:00Z", "path": "core/src/main/java/io/questdb/cairo/TableReplicationRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,330 @@\n+package io.questdb.cairo;\n+\n+import org.jetbrains.annotations.Nullable;\n+\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.cairo.sql.PageFrame;\n+import io.questdb.cairo.sql.PageFrameCursor;\n+import io.questdb.cairo.sql.RecordCursor;\n+import io.questdb.cairo.sql.RecordMetadata;\n+import io.questdb.cairo.sql.SymbolTable;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.IntList;\n+import io.questdb.std.LongList;\n+import io.questdb.std.Misc;\n+import io.questdb.std.Numbers;\n+import io.questdb.std.Unsafe;\n+\n+public class TableReplicationRecordCursorFactory extends AbstractRecordCursorFactory {\n+    private final TableReplicationRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final CharSequence tableName;\n+\n+    private static final RecordMetadata createMetadata(CairoEngine engine, CharSequence tableName) {\n+        try (TableReader reader = engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName, -1)) {\n+            return GenericRecordMetadata.copyOf(reader.getMetadata());\n+        }\n+    }\n+\n+    public TableReplicationRecordCursorFactory(CairoEngine engine, CharSequence tableName) {\n+        super(createMetadata(engine, tableName));\n+        this.cursor = new TableReplicationRecordCursor();\n+        this.engine = engine;\n+        this.tableName = tableName;\n+    }\n+\n+    @Override\n+    public TableReplicationRecordCursor getPageFrameCursor(SqlExecutionContext executionContext) {\n+        return cursor.of(engine.getReader(executionContext.getCairoSecurityContext(), tableName));\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursorFrom(SqlExecutionContext executionContext, long nFirstRow) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+        int partitionIndex = 0;\n+        int partitionCount = reader.getPartitionCount();\n+        while (partitionIndex < partitionCount) {\n+            long partitionRowCount = reader.openPartition(partitionIndex);\n+            if (nFirstRow < partitionRowCount) {\n+                break;\n+            }\n+            partitionIndex++;\n+            nFirstRow -= partitionRowCount;\n+        }\n+        return cursor.of(reader, partitionIndex, nFirstRow);\n+    }\n+\n+    public TableReplicationRecordCursor getPageFrameCursor(int partitionIndex, long paritionRowCount) {\n+        return cursor.of(engine.getReader(AllowAllCairoSecurityContext.INSTANCE, tableName), partitionIndex, paritionRowCount);\n+    }\n+\n+    @Override\n+    public void close() {\n+        Misc.free(cursor);\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean recordCursorSupportsRandomAccess() {\n+        return false;\n+    }\n+\n+    public static class TableReplicationRecordCursor implements PageFrameCursor {\n+        private final LongList columnFrameAddresses = new LongList();\n+        private final LongList columnFrameLengths = new LongList();\n+        private final LongList symbolCharsFrameAddresses = new LongList();\n+        private final LongList symbolCharsFrameLengths = new LongList();\n+        private final IntList nSymbolsProcessed = new IntList();\n+        private final ReplicationPageFrame frame = new ReplicationPageFrame();\n+        private TableReader reader;\n+        private int partitionIndex;\n+        private int partitionCount;\n+        private int columnCount;\n+        private int timestampColumnIndex;\n+        private long nFirstFrameRow;\n+        private long nFrameRows;\n+        private long firstTimestamp = Long.MIN_VALUE;\n+        private long lastTimestamp = Numbers.LONG_NaN;;\n+\n+        private TableReplicationRecordCursor() {\n+            super();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (null != reader) {\n+                reader = Misc.free(reader);\n+                reader = null;\n+            }\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return reader.getSymbolMapReader(columnIndex);\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader, int partitionIndex, long partitionRowCount) {\n+            of(reader);\n+            this.partitionIndex = partitionIndex - 1;\n+            nFirstFrameRow = partitionRowCount;\n+\n+            long nRows = -1;\n+            for (int atPartitionIndex = 0; atPartitionIndex <= partitionIndex; atPartitionIndex++) {\n+                final int base = reader.getColumnBase(partitionIndex);\n+                for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                    int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                    if (columnType == ColumnType.SYMBOL) {\n+                        if (nRows == -1) {\n+                            nRows = atPartitionIndex == partitionIndex ? nFirstFrameRow : reader.openPartition(partitionIndex);\n+                        }\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long symbolIndexAddess = col.getPageAddress(0);\n+                        int maxSymbolIndex = nSymbolsProcessed.getQuick(columnIndex) - 1;\n+                        // TODO: Use vector instructions (rosti?) to find max\n+                        for (int nRow = 0; nRow < nRows; nRow++) {\n+                            int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                            symbolIndexAddess += Integer.BYTES;\n+                            maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                        }\n+                        nSymbolsProcessed.setQuick(columnIndex, maxSymbolIndex + 1);\n+                    }\n+                }\n+                nRows = -1;\n+            }\n+\n+            return this;\n+        }\n+\n+        private TableReplicationRecordCursor of(TableReader reader) {\n+            this.reader = reader;\n+            columnCount = reader.getMetadata().getColumnCount();\n+            timestampColumnIndex = reader.getMetadata().getTimestampIndex();\n+            columnFrameAddresses.ensureCapacity(columnCount);\n+            columnFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.ensureCapacity(columnCount);\n+            symbolCharsFrameLengths.ensureCapacity(columnCount);\n+            symbolCharsFrameAddresses.setAll(columnCount, -1);\n+            symbolCharsFrameLengths.setAll(columnCount, 0);\n+            toTop();\n+            return this;\n+        }\n+\n+        @Override\n+        public @Nullable ReplicationPageFrame next() {\n+            while (++partitionIndex < partitionCount) {\n+                nFrameRows = reader.openPartition(partitionIndex);\n+                if (nFrameRows > nFirstFrameRow) {\n+                    final int base = reader.getColumnBase(partitionIndex);\n+                    for (int columnIndex = 0; columnIndex < columnCount; columnIndex++) {\n+                        final ReadOnlyColumn col = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex));\n+                        assert col.getPageCount() == 1;\n+                        long columnPageAddress = col.getPageAddress(0);\n+                        long columnPageLength;\n+\n+                        int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                        switch (columnType) {\n+                            case ColumnType.STRING: {\n+                                final ReadOnlyColumn strLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateStringPagePosition(col, strLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateStringPagePosition(col, strLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            case ColumnType.BINARY: {\n+                                final ReadOnlyColumn binLenCol = reader.getColumn(TableReader.getPrimaryColumnIndex(base, columnIndex) + 1);\n+                                columnPageLength = calculateBinaryPagePosition(col, binLenCol, nFrameRows);\n+\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = calculateBinaryPagePosition(col, binLenCol, nFirstFrameRow);\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+\n+                                break;\n+                            }\n+\n+                            default: {\n+                                int columnSizeBinaryPower = Numbers.msb(ColumnType.sizeOf(reader.getMetadata().getColumnType(columnIndex)));\n+                                columnPageLength = nFrameRows << columnSizeBinaryPower;\n+                                if (nFirstFrameRow > 0) {\n+                                    long columnPageBegin = nFirstFrameRow << columnSizeBinaryPower;\n+                                    columnPageAddress += columnPageBegin;\n+                                    columnPageLength -= columnPageBegin;\n+                                }\n+                            }\n+                        }\n+\n+                        columnFrameAddresses.setQuick(columnIndex, columnPageAddress);\n+                        columnFrameLengths.setQuick(columnIndex, columnPageLength);\n+\n+                        if (timestampColumnIndex == columnIndex) {\n+                            firstTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress);\n+                            lastTimestamp = Unsafe.getUnsafe().getLong(columnPageAddress + columnPageLength - Long.BYTES);\n+                        }\n+\n+                        if (columnType == ColumnType.SYMBOL) {\n+                            long symbolIndexAddess = columnPageAddress;\n+                            int maxSymbolIndex = 0;\n+                            // TODO: Use vector instructions (rosti?) to find max\n+                            for (int nRow = 0; nRow < nFrameRows; nRow++) {\n+                                int symbolIndex = Unsafe.getUnsafe().getInt(symbolIndexAddess);\n+                                symbolIndexAddess += Integer.BYTES;\n+                                maxSymbolIndex = Math.max(maxSymbolIndex, symbolIndex);\n+                            }\n+\n+                            int nSymbols = nSymbolsProcessed.getQuick(columnIndex);\n+                            if (maxSymbolIndex >= nSymbols) {\n+                                int newNSymbols = maxSymbolIndex + 1;\n+                                SymbolMapReader symReader = reader.getSymbolMapReader(columnIndex);\n+                                long address = symReader.symbolCharsAddressOf(nSymbols);\n+                                long addressHi = symReader.symbolCharsAddressOf(newNSymbols);\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, address);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, addressHi - address);\n+                                nSymbolsProcessed.setQuick(columnIndex, newNSymbols);\n+                            } else {\n+                                symbolCharsFrameAddresses.setQuick(columnIndex, -1);\n+                                symbolCharsFrameLengths.setQuick(columnIndex, 0);\n+                            }\n+                        }\n+                    }\n+\n+                    nFrameRows -= nFirstFrameRow;\n+                    nFirstFrameRow = 0;\n+                    return frame;\n+                }\n+                nFirstFrameRow = 0;\n+            }\n+            return null;\n+        }\n+\n+        private long calculateBinaryPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn binLenCol, long row) {\n+            long columnPageLength;\n+            long lastBinLenOffset = (row - 1) << 3;\n+            long lastBinOffset = binLenCol.getLong(lastBinLenOffset);\n+            long lastBinLen = col.getBinLen(lastBinOffset);\n+            if (lastBinLen == TableUtils.NULL_LEN) {\n+                lastBinLen = 0;\n+            }\n+            columnPageLength = lastBinOffset + Long.BYTES + lastBinLen;\n+            return columnPageLength;\n+        }\n+\n+        private long calculateStringPagePosition(final ReadOnlyColumn col, final ReadOnlyColumn strLenCol, long row) {\n+            long columnPageLength;\n+            long lastStrLenOffset = (row - 1) << 3;\n+            long lastStrOffset = strLenCol.getLong(lastStrLenOffset);\n+            int lastStrLen = col.getStrLen(lastStrOffset);\n+            if (lastStrLen == TableUtils.NULL_LEN) {\n+                lastStrLen = 0;\n+            }\n+            columnPageLength = lastStrOffset + VirtualMemory.STRING_LENGTH_BYTES + lastStrLen * 2;\n+            return columnPageLength;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            partitionIndex = -1;\n+            partitionCount = reader.getPartitionCount();\n+            firstTimestamp = Long.MIN_VALUE;\n+            lastTimestamp = 0;\n+            nSymbolsProcessed.setAll(columnCount, 0);\n+        }\n+\n+        @Override\n+        public long size() {\n+            return reader.size();\n+        }\n+\n+        public class ReplicationPageFrame implements PageFrame {\n+\n+            @Override\n+            public long getPageAddress(int columnIndex) {\n+                return columnFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getPageValueCount(int columnIndex) {\n+                return nFrameRows;\n+            }\n+\n+            @Override\n+            public long getFirstTimestamp() {\n+                return firstTimestamp;\n+            }\n+\n+            @Override\n+            public long getLastTimestamp() {\n+                return lastTimestamp;\n+            }\n+\n+            public int getPartitionIndex() {\n+                return partitionIndex;\n+            }\n+\n+            @Override\n+            public long getPageLength(int columnIndex) {\n+                return columnFrameLengths.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageAddress(int columnIndex) {\n+                return symbolCharsFrameAddresses.getQuick(columnIndex);\n+            }\n+\n+            @Override\n+            public long getSymbolCharsPageLength(int columnIndex) {", "originalCommit": "bd78d4d70ef2cee03c40b75d0a3d5dcab442fc8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a2ed535cf1f5845b974b1f30bd105d556adad6fb", "url": "https://github.com/questdb/questdb/commit/a2ed535cf1f5845b974b1f30bd105d556adad6fb", "message": "feat(cairo): TableBlockWriter - Move symbol replication out of page frame", "committedDate": "2020-08-25T08:46:43Z", "type": "commit"}, {"oid": "f28af765f5acafbee6a6fa598ba1b02269633e1f", "url": "https://github.com/questdb/questdb/commit/f28af765f5acafbee6a6fa598ba1b02269633e1f", "message": "fix(cairo): Fix minor bug in SymbolMapReaderImpl", "committedDate": "2020-08-25T09:21:03Z", "type": "commit"}, {"oid": "a45b1d579eeb9ed901e8686ead1669a370194990", "url": "https://github.com/questdb/questdb/commit/a45b1d579eeb9ed901e8686ead1669a370194990", "message": "fix(cairo): Fix minor bug in SymbolMapReaderImpl", "committedDate": "2020-08-25T09:43:07Z", "type": "commit"}, {"oid": "f1374dd8b6fdc2f92435b81c9a9adc94990292bb", "url": "https://github.com/questdb/questdb/commit/f1374dd8b6fdc2f92435b81c9a9adc94990292bb", "message": "feat(cairo): TableBlockWriter - improvements to symbol table copying", "committedDate": "2020-08-25T10:33:43Z", "type": "commit"}, {"oid": "b94b62db5a8af11742e5aa562c5120182c8707e0", "url": "https://github.com/questdb/questdb/commit/b94b62db5a8af11742e5aa562c5120182c8707e0", "message": "feat(cairo): TableBlockWriter - improvements to variable length field copying", "committedDate": "2020-08-25T11:07:04Z", "type": "commit"}, {"oid": "f6e24f8bfef56e19f0b17839da7bf86b826905fb", "url": "https://github.com/questdb/questdb/commit/f6e24f8bfef56e19f0b17839da7bf86b826905fb", "message": "feat(cairo): TableBlockWriter - add support for added columns", "committedDate": "2020-08-25T14:08:21Z", "type": "commit"}, {"oid": "c2ff856013a7d447e50460c85292b9ae09fabd23", "url": "https://github.com/questdb/questdb/commit/c2ff856013a7d447e50460c85292b9ae09fabd23", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursorFactory", "committedDate": "2020-08-26T13:20:31Z", "type": "commit"}, {"oid": "0ef1282fe7e3a69f5fb0a31690ae0e0706cd36e0", "url": "https://github.com/questdb/questdb/commit/0ef1282fe7e3a69f5fb0a31690ae0e0706cd36e0", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor to split frames to prevent column tops straddling a frame", "committedDate": "2020-08-26T15:35:35Z", "type": "commit"}, {"oid": "ff7a08f81ffe24aaf069c27e768ee765b61eaa08", "url": "https://github.com/questdb/questdb/commit/ff7a08f81ffe24aaf069c27e768ee765b61eaa08", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor", "committedDate": "2020-08-27T09:01:33Z", "type": "commit"}, {"oid": "4edb64e57c7e147558a6df3253bccb75d2199f2e", "url": "https://github.com/questdb/questdb/commit/4edb64e57c7e147558a6df3253bccb75d2199f2e", "message": "feat(cairo): TableBlockWriter - refactor TableReplicationRecordCursor, make timestamp column index optional", "committedDate": "2020-08-27T10:47:31Z", "type": "commit"}, {"oid": "9a76b07c2a47f1fe4dd518ee628b0ea20e8a8805", "url": "https://github.com/questdb/questdb/commit/9a76b07c2a47f1fe4dd518ee628b0ea20e8a8805", "message": "feat(cairo): TableBlockWriter - Add grownLength to ExtendableOnePageMemory", "committedDate": "2020-08-27T11:12:47Z", "type": "commit"}, {"oid": "b8d4aec8bb3f1bd2bf7acb26d6a63e4dfb07b890", "url": "https://github.com/questdb/questdb/commit/b8d4aec8bb3f1bd2bf7acb26d6a63e4dfb07b890", "message": "feat(cairo): TableBlockWriter - Changes to TableReaderRecordCursorFactory so that all the tests can be run with the new page frame implementation", "committedDate": "2020-08-27T11:13:47Z", "type": "commit"}, {"oid": "27d78afd27dbaf7f348bf2a7dfd61b948282c9fd", "url": "https://github.com/questdb/questdb/commit/27d78afd27dbaf7f348bf2a7dfd61b948282c9fd", "message": "feat(cairo): TableBlockWriter - Changes to TableReaderRecordCursorFactory so that all the tests can be run with the new page frame implementation", "committedDate": "2020-08-27T13:08:01Z", "type": "commit"}, {"oid": "52aa2f94524c673e49ede753781fce9934997f62", "url": "https://github.com/questdb/questdb/commit/52aa2f94524c673e49ede753781fce9934997f62", "message": "feat(cairo): TableBlockWriter - add getGrownLength to ReadOnlyColumn and change how var length field column lengths are calculated", "committedDate": "2020-08-27T13:45:09Z", "type": "commit"}, {"oid": "d9343b03a4ca1e86e89f0cf5b02371bb2c2261b8", "url": "https://github.com/questdb/questdb/commit/d9343b03a4ca1e86e89f0cf5b02371bb2c2261b8", "message": "chore(cairo): Fix length checks in OnePageMemory#getStr0", "committedDate": "2020-08-27T14:26:03Z", "type": "commit"}, {"oid": "e3f091b6aa2ba4def421cf4e38baf2fe524dde78", "url": "https://github.com/questdb/questdb/commit/e3f091b6aa2ba4def421cf4e38baf2fe524dde78", "message": "feat(cairo): TableBlockWriter - change TableBlockWriter so that it is owned by TableWriter", "committedDate": "2020-08-27T15:43:47Z", "type": "commit"}, {"oid": "4603a01d6201ce272257bde6dce197d34d65b119", "url": "https://github.com/questdb/questdb/commit/4603a01d6201ce272257bde6dce197d34d65b119", "message": "feat(cairo): TableBlockWriter - change TableBlockWriter so that it is owned by TableWriter", "committedDate": "2020-08-27T16:22:21Z", "type": "commit"}, {"oid": "c6595073e91ebf6da822525eb27f0f4c3e68ae09", "url": "https://github.com/questdb/questdb/commit/c6595073e91ebf6da822525eb27f0f4c3e68ae09", "message": "feat(cairo): TableBlockWriter - Move TablePageFrameCursor out of TableReplicationRecordCursorFactory", "committedDate": "2020-08-27T16:53:42Z", "type": "commit"}, {"oid": "74a55edbc3f2898556857e55313ad8a73d9f28b7", "url": "https://github.com/questdb/questdb/commit/74a55edbc3f2898556857e55313ad8a73d9f28b7", "message": "Merge branch 'master' into replication", "committedDate": "2020-08-28T06:50:54Z", "type": "commit"}, {"oid": "01518ada55e5ee77bab3a69172e846e26a86bf59", "url": "https://github.com/questdb/questdb/commit/01518ada55e5ee77bab3a69172e846e26a86bf59", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T11:16:00Z", "type": "commit"}, {"oid": "5bfac5cd947cc6e0a9e94f17966e88d61279b5a1", "url": "https://github.com/questdb/questdb/commit/5bfac5cd947cc6e0a9e94f17966e88d61279b5a1", "message": "Merge branch 'master' into replication", "committedDate": "2020-09-07T11:59:47Z", "type": "commit"}, {"oid": "06e935e6fa854df49a543c1f1cb39ef775cc671b", "url": "https://github.com/questdb/questdb/commit/06e935e6fa854df49a543c1f1cb39ef775cc671b", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:19:04Z", "type": "commit"}, {"oid": "1f1697e53d7681dcdcb2de2be57f0984f296c93c", "url": "https://github.com/questdb/questdb/commit/1f1697e53d7681dcdcb2de2be57f0984f296c93c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:48:51Z", "type": "commit"}, {"oid": "aa8fdeae8c5515c65a913dcb283755d0203aaaa8", "url": "https://github.com/questdb/questdb/commit/aa8fdeae8c5515c65a913dcb283755d0203aaaa8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T14:53:30Z", "type": "commit"}, {"oid": "7b0d8004d48f7ec1753413c2dab3dc6b306e26bf", "url": "https://github.com/questdb/questdb/commit/7b0d8004d48f7ec1753413c2dab3dc6b306e26bf", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-07T15:23:19Z", "type": "commit"}, {"oid": "2dd85d8c7ca73055fab5266cf73604678132137d", "url": "https://github.com/questdb/questdb/commit/2dd85d8c7ca73055fab5266cf73604678132137d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T13:32:59Z", "type": "commit"}, {"oid": "fe6ae13917ac46d2b8661a70f3b73724a94761e9", "url": "https://github.com/questdb/questdb/commit/fe6ae13917ac46d2b8661a70f3b73724a94761e9", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T14:01:47Z", "type": "commit"}, {"oid": "4b86946f24f67f07a3e201865350282180a21bc4", "url": "https://github.com/questdb/questdb/commit/4b86946f24f67f07a3e201865350282180a21bc4", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T16:24:31Z", "type": "commit"}, {"oid": "aef3442b5b8ae12a2ca626d6e02988dd5f4f067c", "url": "https://github.com/questdb/questdb/commit/aef3442b5b8ae12a2ca626d6e02988dd5f4f067c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T16:34:30Z", "type": "commit"}, {"oid": "7b481ff56a16f7805787e331cec4c8a6f4e1570b", "url": "https://github.com/questdb/questdb/commit/7b481ff56a16f7805787e331cec4c8a6f4e1570b", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-08T17:29:55Z", "type": "commit"}, {"oid": "1007d4e63c50c781f8557e1019d223fcbec5f5a6", "url": "https://github.com/questdb/questdb/commit/1007d4e63c50c781f8557e1019d223fcbec5f5a6", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T12:24:40Z", "type": "commit"}, {"oid": "e383a7785a696b48d54a78b5e4dbd58b5308de04", "url": "https://github.com/questdb/questdb/commit/e383a7785a696b48d54a78b5e4dbd58b5308de04", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T13:28:48Z", "type": "commit"}, {"oid": "1305c152ef2992dde7a62a7815dc8db1ffab87b8", "url": "https://github.com/questdb/questdb/commit/1305c152ef2992dde7a62a7815dc8db1ffab87b8", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-09T20:02:47Z", "type": "commit"}, {"oid": "526a1d25af5b4376616781efee2bc5dd5eba4d2d", "url": "https://github.com/questdb/questdb/commit/526a1d25af5b4376616781efee2bc5dd5eba4d2d", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T13:35:06Z", "type": "commit"}, {"oid": "c895ad7009120d94a17c6f3d3cdc5e0bbea637f1", "url": "https://github.com/questdb/questdb/commit/c895ad7009120d94a17c6f3d3cdc5e0bbea637f1", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:08:16Z", "type": "commit"}, {"oid": "5b14cce50947be1545415c2c87cf84fda517144f", "url": "https://github.com/questdb/questdb/commit/5b14cce50947be1545415c2c87cf84fda517144f", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:38:40Z", "type": "commit"}, {"oid": "f920e476df1768b8ef6362824695c808707ad580", "url": "https://github.com/questdb/questdb/commit/f920e476df1768b8ef6362824695c808707ad580", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-10T14:51:49Z", "type": "commit"}, {"oid": "a544ebd4662e3d52959f298614eeaaf6558bf0c4", "url": "https://github.com/questdb/questdb/commit/a544ebd4662e3d52959f298614eeaaf6558bf0c4", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-09-30T13:41:31Z", "type": "commit"}, {"oid": "dd641727842a11d387da0e48d4fc65396b519412", "url": "https://github.com/questdb/questdb/commit/dd641727842a11d387da0e48d4fc65396b519412", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-01T11:45:24Z", "type": "commit"}, {"oid": "95266b90d8ba9367a43bd3f4120372d0fbefd65c", "url": "https://github.com/questdb/questdb/commit/95266b90d8ba9367a43bd3f4120372d0fbefd65c", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-01T13:54:43Z", "type": "commit"}, {"oid": "a8c80064eff5d30265cabbc99d37dbc2c0783517", "url": "https://github.com/questdb/questdb/commit/a8c80064eff5d30265cabbc99d37dbc2c0783517", "message": "Merge branch 'master' into replication", "committedDate": "2020-10-02T08:51:01Z", "type": "commit"}, {"oid": "25cd203f0bbada642890bec5660b59181c6eb925", "url": "https://github.com/questdb/questdb/commit/25cd203f0bbada642890bec5660b59181c6eb925", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-05T15:47:47Z", "type": "commit"}, {"oid": "4a7e0da437bd5a5d46d89ab8630c49062052cf34", "url": "https://github.com/questdb/questdb/commit/4a7e0da437bd5a5d46d89ab8630c49062052cf34", "message": "feat(cairo): TableBlockWriter add parallel writes", "committedDate": "2020-10-06T08:28:15Z", "type": "commit"}, {"oid": "27d9ae0bf3e9a62be6211406d670da70326aedaa", "url": "https://github.com/questdb/questdb/commit/27d9ae0bf3e9a62be6211406d670da70326aedaa", "message": "chore(cairo): Change Files.openRW such that it does not write lock the file in windows", "committedDate": "2020-10-06T14:32:06Z", "type": "commit"}, {"oid": "50407920dceb6150d3072495cda0f973a2a375d2", "url": "https://github.com/questdb/questdb/commit/50407920dceb6150d3072495cda0f973a2a375d2", "message": "chore(cairo): Change Files.openRW such that it does not write lock the file in windows", "committedDate": "2020-10-06T21:07:17Z", "type": "commit"}, {"oid": "72934fb1929a33bf30c0a5e2a91b603f6f71cf47", "url": "https://github.com/questdb/questdb/commit/72934fb1929a33bf30c0a5e2a91b603f6f71cf47", "message": "Merge branch 'master' into windows_open_changes2", "committedDate": "2020-10-06T21:10:02Z", "type": "commit"}, {"oid": "094185e5762d71a889f90630d3b5435084efda53", "url": "https://github.com/questdb/questdb/commit/094185e5762d71a889f90630d3b5435084efda53", "message": "Merge branch 'windows_open_changes2' into replication", "committedDate": "2020-10-06T21:12:16Z", "type": "commit"}]}