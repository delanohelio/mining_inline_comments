{"pr_number": 690, "pr_title": "Support for Kafka metadata queries", "pr_createdAt": "2020-11-06T13:40:20Z", "pr_url": "https://github.com/questdb/questdb/pull/690", "timeline": [{"oid": "303dd9ad6fb54291d2044b32f4a5e774e955b0b7", "url": "https://github.com/questdb/questdb/commit/303dd9ad6fb54291d2044b32f4a5e774e955b0b7", "message": "feature(griffin) - drop partition based on boolean expression. refactored fix for rename/drop partition flag  fix #669", "committedDate": "2020-10-30T14:34:18Z", "type": "commit"}, {"oid": "c5186e59279821c39a92c1637b98e487ee4d9858", "url": "https://github.com/questdb/questdb/commit/c5186e59279821c39a92c1637b98e487ee4d9858", "message": "fix(griffin) - kafka attribute and index views", "committedDate": "2020-10-30T17:33:40Z", "type": "commit"}, {"oid": "d48a475fe2de67c3cabf1022891e585d96178a3d", "url": "https://github.com/questdb/questdb/commit/d48a475fe2de67c3cabf1022891e585d96178a3d", "message": "Merge branch 'master' into kafka.catalog.attribute", "committedDate": "2020-11-04T10:22:43Z", "type": "commit"}, {"oid": "d7a9d460d8365f83bbfc59c2b4803e5d1c7a1469", "url": "https://github.com/questdb/questdb/commit/d7a9d460d8365f83bbfc59c2b4803e5d1c7a1469", "message": "chore(griffin) - kafka changes - lowercase column, catalog, index views, table id integration", "committedDate": "2020-11-04T14:07:22Z", "type": "commit"}, {"oid": "38d5fbdacf56413967dd0746b7103157e181aa53", "url": "https://github.com/questdb/questdb/commit/38d5fbdacf56413967dd0746b7103157e181aa53", "message": "chore(griffin) - kafka changes - case insensitivity for order by, where clause", "committedDate": "2020-11-05T10:20:31Z", "type": "commit"}, {"oid": "64ffde85c72b80604e657a337c7af1cd07e2c102", "url": "https://github.com/questdb/questdb/commit/64ffde85c72b80604e657a337c7af1cd07e2c102", "message": "chore(griffin) - kafka changes - case insensitivity", "committedDate": "2020-11-05T12:28:44Z", "type": "commit"}, {"oid": "1a7b2c7254f789287f52ad541511ca8c4bd0aa74", "url": "https://github.com/questdb/questdb/commit/1a7b2c7254f789287f52ad541511ca8c4bd0aa74", "message": "chore(griffin) - kafka changes - information schema pivoted", "committedDate": "2020-11-06T11:22:45Z", "type": "commit"}, {"oid": "242e9a4a0fe803ef2d125a98450c0a4e64e58185", "url": "https://github.com/questdb/questdb/commit/242e9a4a0fe803ef2d125a98450c0a4e64e58185", "message": "chore(griffin) - kafka changes - removed OnePageMemory allocation", "committedDate": "2020-11-06T12:01:14Z", "type": "commit"}, {"oid": "7d8fd6d95b40309eca000818103b0bd7669c8cc8", "url": "https://github.com/questdb/questdb/commit/7d8fd6d95b40309eca000818103b0bd7669c8cc8", "message": "chore(griffin) - kafka changes - undoing changes in ExprNode", "committedDate": "2020-11-06T12:02:24Z", "type": "commit"}, {"oid": "b98371529ea7a66fdcc013fffa41d903eac8f317", "url": "https://github.com/questdb/questdb/commit/b98371529ea7a66fdcc013fffa41d903eac8f317", "message": "chore(griffin) - kafka changes - function tests", "committedDate": "2020-11-06T13:34:30Z", "type": "commit"}, {"oid": "567a04a1b212998b4b780b3d873bcc405e9ea3e1", "url": "https://github.com/questdb/questdb/commit/567a04a1b212998b4b780b3d873bcc405e9ea3e1", "message": "chore(griffin) - kafka changes - spelling", "committedDate": "2020-11-06T13:37:21Z", "type": "commit"}, {"oid": "4692df14245a27188223779bdbb688b0a30a08c1", "url": "https://github.com/questdb/questdb/commit/4692df14245a27188223779bdbb688b0a30a08c1", "message": "chore(griffin) - kafka changes - removing assert in Logger", "committedDate": "2020-11-06T13:46:05Z", "type": "commit"}, {"oid": "32baf23e99c7027760f6ae1dd82ce05b25906e3c", "url": "https://github.com/questdb/questdb/commit/32baf23e99c7027760f6ae1dd82ce05b25906e3c", "message": "chore(griffin) - kafka changes - removing assert in Logger", "committedDate": "2020-11-06T13:58:21Z", "type": "commit"}, {"oid": "2bf8febe0cde862f02736c0300e4b30c8911b0a1", "url": "https://github.com/questdb/questdb/commit/2bf8febe0cde862f02736c0300e4b30c8911b0a1", "message": "chore(griffin) - kafka changes - tidy up tests", "committedDate": "2020-11-06T14:27:51Z", "type": "commit"}, {"oid": "7ded9edba34923978ddf2c04fccbb37ce78a81de", "url": "https://github.com/questdb/questdb/commit/7ded9edba34923978ddf2c04fccbb37ce78a81de", "message": "chore(griffin) - kafka changes - fixing broken tests", "committedDate": "2020-11-06T15:19:25Z", "type": "commit"}, {"oid": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "url": "https://github.com/questdb/questdb/commit/386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "message": "chore(griffin) - kafka changes - fixing broken test - adding `order by` for unit test that enumerate files", "committedDate": "2020-11-06T15:26:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODQyNg==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518878426", "bodyText": "unnecessary toLowerCase()", "author": "bluestreak01", "createdAt": "2020-11-06T16:53:51Z", "path": "core/src/main/java/io/questdb/griffin/model/QueryModel.java", "diffHunk": "@@ -258,7 +258,7 @@ public void copyColumnsFrom(QueryModel other) {\n         this.bottomUpColumnNames.addAll(columnNames);\n         for (int i = 0, n = columnNames.size(); i < n; i++) {\n             final CharSequence name = columnNames.getQuick(i);\n-            this.aliasToColumnNameMap.put(name, name);\n+            this.aliasToColumnNameMap.put(Chars.toLowerCase(name), Chars.toLowerCase(name));", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3ODk3MQ==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518878971", "bodyText": "Unnecessary toLowerCase", "author": "bluestreak01", "createdAt": "2020-11-06T16:54:40Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -201,7 +201,7 @@ private void addColumnToTranslatingModel(\n             QueryModel validatingModel\n     ) throws SqlException {\n         if (validatingModel != null) {\n-            CharSequence refColumn = column.getAst().token;\n+            CharSequence refColumn = Chars.toLowerCase(column.getAst().token);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3OTg5OA==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518879898", "bodyText": "\"quick\" was fine, we should not need extra check", "author": "bluestreak01", "createdAt": "2020-11-06T16:56:17Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -729,11 +729,11 @@ private void createSelectColumn(\n         // taking into account that column is pre-aliased, e.g.\n         // \"col, col\" will look like \"col, col col1\"\n \n-        CharSequenceObjHashMap<CharSequence> translatingAliasMap = translatingModel.getColumnNameToAliasMap();\n+        LowerCaseCharSequenceObjHashMap<CharSequence> translatingAliasMap = translatingModel.getColumnNameToAliasMap();\n         int index = translatingAliasMap.keyIndex(columnAst.token);\n         if (index < 0) {\n             // column is already being referenced by translating model\n-            final CharSequence translatedColumnName = translatingAliasMap.valueAtQuick(index);\n+            final CharSequence translatedColumnName = translatingAliasMap.valueAt(index);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDM3OQ==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880379", "bodyText": "quick was fine", "author": "bluestreak01", "createdAt": "2020-11-06T16:57:07Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -950,7 +950,7 @@ private ExpressionNode doReplaceLiteral(@Transient ExpressionNode node, QueryMod\n                 }\n \n                 if (found) {\n-                    return nextLiteral(map.valueAtQuick(index), node.position);\n+                    return nextLiteral(map.valueAt(index), node.position);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDY0MA==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880640", "bodyText": "\"quick\" was fine", "author": "bluestreak01", "createdAt": "2020-11-06T16:57:35Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -964,7 +964,7 @@ private ExpressionNode doReplaceLiteral(@Transient ExpressionNode node, QueryMod\n             }\n             return nextLiteral(alias, node.position);\n         }\n-        return nextLiteral(map.valueAtQuick(index), node.position);\n+        return nextLiteral(map.valueAt(index), node.position);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MDkyMA==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518880920", "bodyText": "unnecessary", "author": "bluestreak01", "createdAt": "2020-11-06T16:58:05Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -1168,6 +1168,7 @@ private void eraseColumnPrefixInWhereClauses(QueryModel model) throws SqlExcepti\n     }\n \n     private int getIndexOfTableForColumn(QueryModel model, CharSequence column, int dot, int position) throws SqlException {\n+        column = Chars.toLowerCase(column);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjA5Ng==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882096", "bodyText": "same, pls re-introduce getValueQuick()", "author": "bluestreak01", "createdAt": "2020-11-06T17:00:00Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2287,7 +2288,7 @@ private QueryModel rewriteOrderBy(QueryModel model) throws SqlException {\n \n                         if (index < 0) {\n                             // we have found alias, rewrite order by column\n-                            orderBy.token = map.valueAtQuick(index);\n+                            orderBy.token = map.valueAt(index);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjE3MA==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882170", "bodyText": "same", "author": "bluestreak01", "createdAt": "2020-11-06T17:00:06Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2317,7 +2318,7 @@ private QueryModel rewriteOrderBy(QueryModel model) throws SqlException {\n                                     index = synthetic.getColumnNameToAliasMap().keyIndex(column);\n \n                                     if (index < 0) {\n-                                        alias = synthetic.getColumnNameToAliasMap().valueAtQuick(index);\n+                                        alias = synthetic.getColumnNameToAliasMap().valueAt(index);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjI4Mg==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882282", "bodyText": "same", "author": "bluestreak01", "createdAt": "2020-11-06T17:00:17Z", "path": "core/src/main/java/io/questdb/griffin/SqlOptimiser.java", "diffHunk": "@@ -2854,7 +2855,7 @@ public void visit(ExpressionNode node) {\n                 // we have table column hit when alias is not found\n                 // in this case expression rewrite is unnecessary\n                 if (index < 0) {\n-                    CharSequence column = aliasToColumnMap.valueAtQuick(index);\n+                    CharSequence column = aliasToColumnMap.valueAt(index);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MjgyNg==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518882826", "bodyText": "when cursor is not fully scrolled down we will have file descriptor leak", "author": "bluestreak01", "createdAt": "2020-11-06T17:01:17Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttributeCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attribute()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttributeCatalogueCursorFactory(\n+                        configuration,\n+                        METADATA\n+                )\n+        );\n+    }\n+\n+    private static class AttributeCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttributeClassCatalogueCursor cursor;\n+\n+        public AttributeCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.cursor = new AttributeClassCatalogueCursor(configuration, path);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttributeClassCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final DiskReadingRecord diskReadingRecord = new DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final ReadOnlyColumn metaMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private int tableId = 1000;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttributeClassCatalogueCursor(CairoConfiguration configuration, Path path) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.metaMem = new OnePageMemory();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+            metaMem.close();\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (\n+                                ff.findType(findFileStruct) == Files.DT_DIR\n+                                        && !Chars.equals(nativeLPSZ, '.')\n+                                        && !Chars.equals(nativeLPSZ, \"..\")\n+                        ) {\n+                            path.trimTo(plimit);\n+                            path.concat(pname);\n+                            if (ff.exists(path.concat(TableUtils.META_FILE_NAME).$())) {\n+                                foundMetadataFile = true;\n+                                metaMem.of(ff, path, ff.getPageSize(), ff.length(path));\n+                                columnCount = metaMem.getInt(TableUtils.META_OFFSET_COUNT);\n+                                tableId = metaMem.getInt(TableUtils.META_OFFSET_TABLE_ID);\n+                            }\n+                        }\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                    }\n+                }\n+\n+                if (foundMetadataFile) {\n+                    long offset = TableUtils.getColumnNameOffset(columnCount);\n+                    for (int i = 0; i < columnCount; i++) {\n+                        CharSequence name = metaMem.getStr(offset);\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.name = name;\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            diskReadingRecord.tableId = tableId;\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                        offset += ReadOnlyMemory.getStorageLength(name);\n+                    }\n+                }\n+            } while (hasNextFile);\n+\n+            ff.findClose(findFileStruct);", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzY4Ng==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518883686", "bodyText": "toLowerCase should be on both sides", "author": "bluestreak01", "createdAt": "2020-11-06T17:02:53Z", "path": "core/src/main/java/io/questdb/std/Chars.java", "diffHunk": "@@ -230,6 +230,39 @@ public static boolean equalsIgnoreCaseNc(CharSequence l, CharSequence r) {\n         return l != null && equalsIgnoreCase(l, r);\n     }\n \n+    public static boolean equalsLowerCase(CharSequence l, int lLo, int lHi, CharSequence r, int rLo, int rHi) {\n+        if (l == r) {\n+            return true;\n+        }\n+\n+        int ll = lHi - lLo;\n+        if (ll != rHi - rLo) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i + lLo)) != r.charAt(i + rLo)) {", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg4MzcyNg==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r518883726", "bodyText": "same", "author": "bluestreak01", "createdAt": "2020-11-06T17:03:00Z", "path": "core/src/main/java/io/questdb/std/Chars.java", "diffHunk": "@@ -230,6 +230,39 @@ public static boolean equalsIgnoreCaseNc(CharSequence l, CharSequence r) {\n         return l != null && equalsIgnoreCase(l, r);\n     }\n \n+    public static boolean equalsLowerCase(CharSequence l, int lLo, int lHi, CharSequence r, int rLo, int rHi) {\n+        if (l == r) {\n+            return true;\n+        }\n+\n+        int ll = lHi - lLo;\n+        if (ll != rHi - rLo) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i + lLo)) != r.charAt(i + rLo)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static boolean equalsLowerCase(@NotNull CharSequence l, CharSequence r) {\n+        int ll;\n+        if ((ll = l.length()) != r.length()) {\n+            return false;\n+        }\n+\n+        for (int i = 0; i < ll; i++) {\n+            if (Character.toLowerCase(l.charAt(i)) != r.charAt(i)) {", "originalCommit": "386a2e0c9af5ff79bcdf9bb937335f698fcc2341", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eecf54bd390d0ccfb5a28def9fcfb48d981a9803", "url": "https://github.com/questdb/questdb/commit/eecf54bd390d0ccfb5a28def9fcfb48d981a9803", "message": "chore(griffin) - kafka changes - PR review", "committedDate": "2020-11-06T17:26:28Z", "type": "commit"}, {"oid": "a5584d8d08b6dc5740683a556489c944e8f1f0b7", "url": "https://github.com/questdb/questdb/commit/a5584d8d08b6dc5740683a556489c944e8f1f0b7", "message": "chore(griffin) - kafka changes - lowercase map/set changes", "committedDate": "2020-11-09T10:03:38Z", "type": "commit"}, {"oid": "197ccb0be3f2d3c2af42ca3f69ed5b2cf976429f", "url": "https://github.com/questdb/questdb/commit/197ccb0be3f2d3c2af42ca3f69ed5b2cf976429f", "message": "Merge branch 'master' into kafka.catalog.attribute\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/griffin/SqlOptimiser.java", "committedDate": "2020-11-09T11:22:00Z", "type": "commit"}, {"oid": "9e1a66ea5483559b7b8585f93472ac022ab42ead", "url": "https://github.com/questdb/questdb/commit/9e1a66ea5483559b7b8585f93472ac022ab42ead", "message": "chore(griffin) - kafka changes - fixing failing test", "committedDate": "2020-11-09T12:11:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMTQwMg==", "url": "https://github.com/questdb/questdb/pull/690#discussion_r519801402", "bodyText": "perhaps this class can also (like Path) be at factory level so we do not need to allocate to re-execute the cursor", "author": "bluestreak01", "createdAt": "2020-11-09T13:12:32Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttributeCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attribute()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttributeCatalogueCursorFactory(\n+                        configuration,\n+                        METADATA\n+                )\n+        );\n+    }\n+\n+    private static class AttributeCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttributeClassCatalogueCursor cursor;\n+\n+        public AttributeCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.cursor = new AttributeClassCatalogueCursor(configuration, path);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttributeClassCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final DiskReadingRecord diskReadingRecord = new DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final ReadOnlyColumn metaMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private int tableId = 1000;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttributeClassCatalogueCursor(CairoConfiguration configuration, Path path) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.metaMem = new OnePageMemory();\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+            metaMem.close();", "originalCommit": "9e1a66ea5483559b7b8585f93472ac022ab42ead", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b57f73b61050db647fda9782e11bb00a111f72e", "url": "https://github.com/questdb/questdb/commit/8b57f73b61050db647fda9782e11bb00a111f72e", "message": "chore(griffin) - kafka changes - moving metaMem to factory", "committedDate": "2020-11-09T13:24:17Z", "type": "commit"}]}