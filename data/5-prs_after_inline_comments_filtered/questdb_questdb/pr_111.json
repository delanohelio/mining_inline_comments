{"pr_number": 111, "pr_title": "feat(griffin): distinct queries on symbol column retrieve the list fr\u2026", "pr_createdAt": "2020-03-12T21:11:04Z", "pr_url": "https://github.com/questdb/questdb/pull/111", "timeline": [{"oid": "63301efbdd0ebac975824f5c1408053eceac295c", "url": "https://github.com/questdb/questdb/commit/63301efbdd0ebac975824f5c1408053eceac295c", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-12T21:09:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxMDgyOQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391910829", "bodyText": "this factory does not need creating if condition below is met", "author": "bluestreak01", "createdAt": "2020-03-12T21:35:21Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1110,6 +1110,21 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n         final RecordCursorFactory factory = generateSubQuery(model, executionContext);", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxMTY2OQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391911669", "bodyText": "reader is a shared resource - SQL code generator must not assign it to the factory, but close it instead in try() block.", "author": "bluestreak01", "createdAt": "2020-03-12T21:36:19Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1110,6 +1110,21 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n         final RecordCursorFactory factory = generateSubQuery(model, executionContext);\n         try {\n+            if (model.getColumns().size() == 1 && model.getNestedModel() != null && model.getNestedModel().getNestedModel() != null && model.getNestedModel().getNestedModel().getTableName() != null) {\n+                ExpressionNode tableName = model.getNestedModel().getNestedModel().getTableName();\n+                TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName.token);", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNDYwMQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391914601", "bodyText": "this cursor should not need base factory", "author": "bluestreak01", "createdAt": "2020-03-12T21:40:15Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1110,6 +1110,21 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n         final RecordCursorFactory factory = generateSubQuery(model, executionContext);\n         try {\n+            if (model.getColumns().size() == 1 && model.getNestedModel() != null && model.getNestedModel().getNestedModel() != null && model.getNestedModel().getNestedModel().getTableName() != null) {\n+                ExpressionNode tableName = model.getNestedModel().getNestedModel().getTableName();\n+                TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName.token);\n+                CharSequence columnName = model.getColumnNames().get(0);\n+                int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+                int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                if (columnType == ColumnType.SYMBOL) {\n+                    return new DistinctSymbolRecordCursorFactory(\n+                            factory,", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNTQ2NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391915465", "bodyText": "Reader must not be held by factory. This is a resource hungry instance, which are shared through the engine. Factory must hold on to the CairoEngine instance instead and table name.", "author": "bluestreak01", "createdAt": "2020-03-12T21:41:27Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1110,6 +1110,21 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n         final RecordCursorFactory factory = generateSubQuery(model, executionContext);\n         try {\n+            if (model.getColumns().size() == 1 && model.getNestedModel() != null && model.getNestedModel().getNestedModel() != null && model.getNestedModel().getNestedModel().getTableName() != null) {\n+                ExpressionNode tableName = model.getNestedModel().getNestedModel().getTableName();\n+                TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName.token);\n+                CharSequence columnName = model.getColumnNames().get(0);\n+                int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+                int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                if (columnType == ColumnType.SYMBOL) {\n+                    return new DistinctSymbolRecordCursorFactory(\n+                            factory,\n+                            entityColumnFilter,\n+                            reader,", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxNTc4MA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391915780", "bodyText": "it is better to pass column index", "author": "bluestreak01", "createdAt": "2020-03-12T21:41:52Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1110,6 +1110,21 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n         final RecordCursorFactory factory = generateSubQuery(model, executionContext);\n         try {\n+            if (model.getColumns().size() == 1 && model.getNestedModel() != null && model.getNestedModel().getNestedModel() != null && model.getNestedModel().getNestedModel().getTableName() != null) {\n+                ExpressionNode tableName = model.getNestedModel().getNestedModel().getTableName();\n+                TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName.token);\n+                CharSequence columnName = model.getColumnNames().get(0);\n+                int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+                int columnType = reader.getMetadata().getColumnType(columnIndex);\n+                if (columnType == ColumnType.SYMBOL) {\n+                    return new DistinctSymbolRecordCursorFactory(\n+                            factory,\n+                            entityColumnFilter,\n+                            reader,\n+                            columnName", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxODc3MA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391918770", "bodyText": "not sure why we need column filter?", "author": "bluestreak01", "createdAt": "2020-03-12T21:45:48Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.EntityColumnFilter;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final RecordMetadata metadata;\n+    private final TableReader reader;\n+    private final CharSequence columnName;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            RecordCursorFactory base,\n+            EntityColumnFilter columnFilter,", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkxOTk5Nw==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391919997", "bodyText": "when you have CairoEngine - this is the place to get reader", "author": "bluestreak01", "createdAt": "2020-03-12T21:47:35Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.EntityColumnFilter;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final RecordMetadata metadata;\n+    private final TableReader reader;\n+    private final CharSequence columnName;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            RecordCursorFactory base,\n+            EntityColumnFilter columnFilter,\n+            TableReader reader,\n+            CharSequence columnName) {\n+        final RecordMetadata metadata = base.getMetadata();\n+        columnFilter.of(metadata.getColumnCount());\n+        this.metadata = metadata;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+        this.reader = reader;\n+        this.columnName = columnName;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        cursor.of(reader, columnName);", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyMDM4NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391920385", "bodyText": "there is method Misc.free() that does something like this", "author": "bluestreak01", "createdAt": "2020-03-12T21:48:04Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.EntityColumnFilter;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final RecordMetadata metadata;\n+    private final TableReader reader;\n+    private final CharSequence columnName;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            RecordCursorFactory base,\n+            EntityColumnFilter columnFilter,\n+            TableReader reader,\n+            CharSequence columnName) {\n+        final RecordMetadata metadata = base.getMetadata();\n+        columnFilter.of(metadata.getColumnCount());\n+        this.metadata = metadata;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+        this.reader = reader;\n+        this.columnName = columnName;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        cursor.of(reader, columnName);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();\n+        private TableReader reader;\n+        private SymbolMapReader symbolMapReader;\n+        private int numberOfSymbols;\n+\n+        DistinctSymbolRecordCursor() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (reader != null) {", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyMTA0NA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r391921044", "bodyText": "we need one more test where symbol value is NULL", "author": "bluestreak01", "createdAt": "2020-03-12T21:48:57Z", "path": "core/src/test/java/io/questdb/griffin/SqlCodeGeneratorTest.java", "diffHunk": "@@ -1104,6 +1104,31 @@ public void testSumDoubleColumn() throws Exception {\n         }\n     }\n \n+\n+    @Test\n+    public void testDistinctSymbolColumn() throws Exception {", "originalCommit": "63301efbdd0ebac975824f5c1408053eceac295c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "680668e8bc766f33c598560357aa7c4472850726", "url": "https://github.com/questdb/questdb/commit/680668e8bc766f33c598560357aa7c4472850726", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T10:55:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE1OTkxMA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392159910", "bodyText": "what is happening here? :) you already have column index", "author": "bluestreak01", "createdAt": "2020-03-13T10:58:42Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MDczOA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392160738", "bodyText": "you shouldn't need to pass TableReader to record. Record needs SymbolMapReader", "author": "bluestreak01", "createdAt": "2020-03-13T11:00:22Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();\n+        private TableReader reader;\n+        private SymbolMapReader symbolMapReader;\n+        private int numberOfSymbols;\n+\n+        DistinctSymbolRecordCursor() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(reader);\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return recordA;\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return symbolMapReader;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (recordA.getRecordIndex() + 1 < numberOfSymbols) {\n+                recordA.incrementRecordIndex();\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Record getRecordB() {\n+            return recordB;\n+        }\n+\n+        @Override\n+        public void recordAt(Record record, long atRowId) {\n+            ((DistinctSymbolRecord) record).recordIndex = (int) atRowId;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            recordA.recordIndex = -1;\n+        }\n+\n+        public void of(TableReader reader, int columnIndex) {\n+            this.symbolMapReader = reader.getSymbolMapReader(columnIndex);\n+            this.numberOfSymbols = symbolMapReader.size();\n+            this.reader = reader;\n+            this.recordA.of(reader, columnIndex);", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MTI1MA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392161250", "bodyText": "we can avoid calling for every value of the result set\nreader.getSymbolMapReader(columnIndex)", "author": "bluestreak01", "createdAt": "2020-03-13T11:01:26Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();\n+        private TableReader reader;\n+        private SymbolMapReader symbolMapReader;\n+        private int numberOfSymbols;\n+\n+        DistinctSymbolRecordCursor() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(reader);\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return recordA;\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return symbolMapReader;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (recordA.getRecordIndex() + 1 < numberOfSymbols) {\n+                recordA.incrementRecordIndex();\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Record getRecordB() {\n+            return recordB;\n+        }\n+\n+        @Override\n+        public void recordAt(Record record, long atRowId) {\n+            ((DistinctSymbolRecord) record).recordIndex = (int) atRowId;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            recordA.recordIndex = -1;\n+        }\n+\n+        public void of(TableReader reader, int columnIndex) {\n+            this.symbolMapReader = reader.getSymbolMapReader(columnIndex);\n+            this.numberOfSymbols = symbolMapReader.size();\n+            this.reader = reader;\n+            this.recordA.of(reader, columnIndex);\n+            this.recordB.of(reader, columnIndex);\n+        }\n+\n+        @Override\n+        public long size() {\n+            return numberOfSymbols;\n+        }\n+    }\n+\n+    public static class DistinctSymbolRecord implements Record {\n+        private int columnIndex;\n+        private int recordIndex = -1;\n+        private TableReader reader;\n+\n+        @Override\n+        public CharSequence getSym(int col) {\n+            if (reader != null) {\n+                return reader.getSymbolMapReader(columnIndex).valueOf(recordIndex);", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MTc2OQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392161769", "bodyText": "reader null check should not be necessary when Record is setup correctly. If reader is every to become null this should be reported where cursor is requested (don't think null is possible at all in this case)", "author": "bluestreak01", "createdAt": "2020-03-13T11:02:36Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();\n+        private TableReader reader;\n+        private SymbolMapReader symbolMapReader;\n+        private int numberOfSymbols;\n+\n+        DistinctSymbolRecordCursor() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(reader);\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return recordA;\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return symbolMapReader;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (recordA.getRecordIndex() + 1 < numberOfSymbols) {\n+                recordA.incrementRecordIndex();\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Record getRecordB() {\n+            return recordB;\n+        }\n+\n+        @Override\n+        public void recordAt(Record record, long atRowId) {\n+            ((DistinctSymbolRecord) record).recordIndex = (int) atRowId;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            recordA.recordIndex = -1;\n+        }\n+\n+        public void of(TableReader reader, int columnIndex) {\n+            this.symbolMapReader = reader.getSymbolMapReader(columnIndex);\n+            this.numberOfSymbols = symbolMapReader.size();\n+            this.reader = reader;\n+            this.recordA.of(reader, columnIndex);\n+            this.recordB.of(reader, columnIndex);\n+        }\n+\n+        @Override\n+        public long size() {\n+            return numberOfSymbols;\n+        }\n+    }\n+\n+    public static class DistinctSymbolRecord implements Record {\n+        private int columnIndex;\n+        private int recordIndex = -1;\n+        private TableReader reader;\n+\n+        @Override\n+        public CharSequence getSym(int col) {\n+            if (reader != null) {", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MzA2MA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392163060", "bodyText": "I would suggest making DistinctSymbolRecord non-static class. This way it can access symbol map reader on factory instance and only have its own record index.\nThis said, recordB is better be created lazily. It is only used when someone is ordering symbols returned by this cursor. Which is not very often.", "author": "bluestreak01", "createdAt": "2020-03-13T11:05:37Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2MzYyNQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392163625", "bodyText": "spelling disticntSymbolMetadata", "author": "bluestreak01", "createdAt": "2020-03-13T11:06:47Z", "path": "core/src/main/java/io/questdb/griffin/SqlCodeGenerator.java", "diffHunk": "@@ -1108,6 +1108,37 @@ private RecordCursorFactory generateSelectChoose(QueryModel model, SqlExecutionC\n     }\n \n     private RecordCursorFactory generateSelectDistinct(QueryModel model, SqlExecutionContext executionContext) throws SqlException {\n+\n+        if (model.getColumns().size() == 1 && model.getNestedModel() != null && model.getNestedModel().getNestedModel() != null && model.getNestedModel().getNestedModel().getTableName() != null) {\n+            ExpressionNode tableNameExpressionNode = model.getNestedModel().getNestedModel().getTableName();\n+            CharSequence tableName = tableNameExpressionNode.token;\n+            TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName);\n+            CharSequence columnName = model.getColumnNames().get(0);\n+            RecordMetadata readerMetadata = reader.getMetadata();\n+            int columnIndex = readerMetadata.getColumnIndex(columnName);\n+            int columnType = readerMetadata.getColumnType(columnIndex);\n+            if (columnType == ColumnType.SYMBOL) {\n+                final GenericRecordMetadata disticntSymbolMetadata = new GenericRecordMetadata();", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NDQxNw==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392164417", "bodyText": "it would be better to assign reader, e.g.\nreader = Misc.free(reader);\n\nto defend against double close", "author": "bluestreak01", "createdAt": "2020-03-13T11:08:36Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        CharSequence columnName = reader.getMetadata().getColumnName(columnIndex);\n+        int columnIndex = reader.getMetadata().getColumnIndex(columnName);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = new DistinctSymbolRecord();\n+        private TableReader reader;\n+        private SymbolMapReader symbolMapReader;\n+        private int numberOfSymbols;\n+\n+        DistinctSymbolRecordCursor() {\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(reader);", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjE2NDU3NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392164575", "bodyText": "factory must close its cursor (which is closeable)", "author": "bluestreak01", "createdAt": "2020-03-13T11:08:58Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+    }", "originalCommit": "680668e8bc766f33c598560357aa7c4472850726", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e49045ac24f8eba61df250dd08575760f902b47", "url": "https://github.com/questdb/questdb/commit/9e49045ac24f8eba61df250dd08575760f902b47", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T11:52:36Z", "type": "commit"}, {"oid": "48e56228b6d6588f465d15543b531fa3d4a1c8af", "url": "https://github.com/questdb/questdb/commit/48e56228b6d6588f465d15543b531fa3d4a1c8af", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T11:52:57Z", "type": "commit"}, {"oid": "ac90c9504613bbbf16bdd53d39d6e195f5f03d03", "url": "https://github.com/questdb/questdb/commit/ac90c9504613bbbf16bdd53d39d6e195f5f03d03", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T11:54:34Z", "type": "commit"}, {"oid": "9394bf63a30ee3c87d0b4edb5e72c62295058129", "url": "https://github.com/questdb/questdb/commit/9394bf63a30ee3c87d0b4edb5e72c62295058129", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T13:47:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI2OTU2Ng==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392269566", "bodyText": "minor: toTop() and record.reset() implement the same logic, perhaps topTop() can call recordA.reset(). Or may be record.reset() could be renamed to record.toTop()", "author": "bluestreak01", "createdAt": "2020-03-13T14:41:01Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final CharSequence tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final CharSequence tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+        cursor.close();\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = null;\n+        private TableReader reader;\n+        private int columnIndex;\n+        private int numberOfSymbols;\n+        private SymbolMapReader symbolMapReader;\n+\n+        @Override\n+        public void close() {\n+            reader = Misc.free(reader);\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return recordA;\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return symbolMapReader;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (recordA.getRecordIndex() + 1 < numberOfSymbols) {\n+                recordA.incrementRecordIndex();\n+                return true;\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public Record getRecordB() {\n+            if (recordB == null) {\n+                recordB = new DistinctSymbolRecord();\n+            }\n+            recordB.reset();\n+            return recordB;\n+        }\n+\n+        @Override\n+        public void recordAt(Record record, long atRowId) {\n+            ((DistinctSymbolRecord) record).recordIndex = (int) atRowId;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            recordA.recordIndex = -1;", "originalCommit": "9394bf63a30ee3c87d0b4edb5e72c62295058129", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "36321bb44678dd406945c10956e9235e4065580f", "url": "https://github.com/questdb/questdb/commit/36321bb44678dd406945c10956e9235e4065580f", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-13T16:13:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDY0NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392334645", "bodyText": "Can we pull this value up StaticSymbolTable interface level? The idea of static symbol table is that it is bounded, e.g. knows of its size and presumably that it knows that it has null?", "author": "bluestreak01", "createdAt": "2020-03-13T16:25:49Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapReader.java", "diffHunk": "@@ -35,4 +35,6 @@\n     boolean isDeleted();\n \n     void updateSymbolCount(int count);\n+\n+    boolean containsNullValue();", "originalCommit": "36321bb44678dd406945c10956e9235e4065580f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNTA1NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392335055", "bodyText": "sure", "author": "jaugsburger", "createdAt": "2020-03-13T16:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzOTUzMw==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392339533", "bodyText": "\ud83d\udc4d", "author": "bluestreak01", "createdAt": "2020-03-13T16:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNDY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNTYwNg==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392335606", "bodyText": "this write should be cached i feel like, e.g. read of class member is faster than write to memory mapped file", "author": "bluestreak01", "createdAt": "2020-03-13T16:27:22Z", "path": "core/src/main/java/io/questdb/cairo/SymbolMapWriter.java", "diffHunk": "@@ -155,6 +158,7 @@ public int getSymbolCount() {\n     public int put(CharSequence symbol) {\n \n         if (symbol == null) {\n+            offsetMem.putBool(HEADER_NULL_FLAG, true);", "originalCommit": "36321bb44678dd406945c10956e9235e4065580f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNjc2NQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392336765", "bodyText": "yes, working on that, just wanted to push the latest changes", "author": "jaugsburger", "createdAt": "2020-03-13T16:29:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNTYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNjI4OQ==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392336289", "bodyText": "I don't follow this condition. Why are we comparing int value of symbol to size of symbol map?", "author": "bluestreak01", "createdAt": "2020-03-13T16:28:40Z", "path": "core/src/test/java/io/questdb/griffin/AbstractGriffinTest.java", "diffHunk": "@@ -290,7 +287,11 @@ private static void testSymbolAPI(RecordMetadata metadata, RecordCursor cursor)\n                     if (symbolTable instanceof StaticSymbolTable) {\n                         CharSequence sym = record.getSym(column);\n                         int value = record.getInt(column);\n-                        Assert.assertEquals(value, ((StaticSymbolTable) symbolTable).keyOf(sym));\n+                        if (symbolTable instanceof SymbolMapReader && ((SymbolMapReader) symbolTable).containsNullValue() && value == ((StaticSymbolTable) symbolTable).size()) {", "originalCommit": "36321bb44678dd406945c10956e9235e4065580f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2MTk4Mg==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392361982", "bodyText": "the reason is that the symboMapReader.size() still returns the number of symbols without counting the null value. on the other hand, record.hasNext() now returns true one final time if the symbolMapReader contains a null symbol", "author": "jaugsburger", "createdAt": "2020-03-13T17:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNjI4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU5Nzc2Mg==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r392597762", "bodyText": "perfect, understood, thanks!", "author": "bluestreak01", "createdAt": "2020-03-14T15:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzNjI4OQ=="}], "type": "inlineReview"}, {"oid": "016fb9fb731fcc3fac8cfccef089cf67372c3d4c", "url": "https://github.com/questdb/questdb/commit/016fb9fb731fcc3fac8cfccef089cf67372c3d4c", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-14T14:02:41Z", "type": "commit"}, {"oid": "73111cfe29645c5a9836bb6528bd9e88c4b0ec16", "url": "https://github.com/questdb/questdb/commit/73111cfe29645c5a9836bb6528bd9e88c4b0ec16", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-16T10:01:37Z", "type": "commit"}, {"oid": "7a69a57522b890215dba99a1242d0c1bbe17e70a", "url": "https://github.com/questdb/questdb/commit/7a69a57522b890215dba99a1242d0c1bbe17e70a", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-17T10:28:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzU4NzEzOA==", "url": "https://github.com/questdb/questdb/pull/111#discussion_r393587138", "bodyText": "missed a spot", "author": "bluestreak01", "createdAt": "2020-03-17T10:42:35Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/DistinctSymbolRecordCursorFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/* ******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.groupby;\n+\n+import io.questdb.cairo.CairoEngine;\n+import io.questdb.cairo.GenericRecordMetadata;\n+import io.questdb.cairo.SymbolMapReader;\n+import io.questdb.cairo.TableReader;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.std.Misc;\n+\n+public class DistinctSymbolRecordCursorFactory implements RecordCursorFactory {\n+    private final DistinctSymbolRecordCursor cursor;\n+    private final CairoEngine engine;\n+    private final GenericRecordMetadata metadata;\n+    private final String tableName;\n+    private final int columnIndex;\n+    private final long tableVersion;\n+\n+    public DistinctSymbolRecordCursorFactory(\n+            final CairoEngine engine,\n+            final GenericRecordMetadata metadata,\n+            final String tableName,\n+            final int columnIndex,\n+            final long tableVersion) {\n+        this.engine = engine;\n+        this.metadata = metadata;\n+        this.tableName = tableName;\n+        this.columnIndex = columnIndex;\n+        this.tableVersion = tableVersion;\n+        this.cursor = new DistinctSymbolRecordCursor();\n+    }\n+\n+    @Override\n+    public void close() {\n+        cursor.close();\n+    }\n+\n+    @Override\n+    public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+        TableReader reader = engine.getReader(executionContext.getCairoSecurityContext(), tableName, tableVersion);\n+        cursor.of(reader, columnIndex);\n+        return cursor;\n+    }\n+\n+    @Override\n+    public RecordMetadata getMetadata() {\n+        return metadata;\n+    }\n+\n+    @Override\n+    public boolean isRandomAccessCursor() {\n+        return true;\n+    }\n+\n+    private static class DistinctSymbolRecordCursor implements RecordCursor {\n+        private DistinctSymbolRecord recordA = new DistinctSymbolRecord();\n+        private DistinctSymbolRecord recordB = null;\n+        private TableReader reader;\n+        private int columnIndex;\n+        private int numberOfSymbols;\n+        private SymbolMapReader symbolMapReader;\n+\n+        @Override\n+        public void close() {\n+            reader = Misc.free(reader);\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return recordA;\n+        }\n+\n+        @Override\n+        public SymbolTable getSymbolTable(int columnIndex) {\n+            return symbolMapReader;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (recordA.getAndIncrementRecordIndex() < numberOfSymbols) {\n+                return true;\n+            }\n+            recordA.decrementRecordIndex();\n+            return false;\n+        }\n+\n+        @Override\n+        public Record getRecordB() {\n+            if (recordB == null) {\n+                recordB = new DistinctSymbolRecord();\n+            }\n+            recordB.reset();\n+            return recordB;\n+        }\n+\n+        @Override\n+        public void recordAt(Record record, long atRowId) {\n+            ((DistinctSymbolRecord) record).recordIndex = (int) atRowId;\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            recordA.reset();\n+        }\n+\n+        public void of(TableReader reader, int columnIndex) {\n+            this.reader = reader;\n+            this.columnIndex = columnIndex;\n+            this.symbolMapReader = reader.getSymbolMapReader(columnIndex);\n+            this.numberOfSymbols = symbolMapReader.size() + (symbolMapReader.containsNullValue() ? 1 : 0);\n+            this.recordA.reset();\n+        }\n+\n+        @Override\n+        public long size() {\n+            return numberOfSymbols;\n+        }\n+\n+        public class DistinctSymbolRecord implements Record {\n+            private int recordIndex = -1;\n+\n+            public void decrementRecordIndex() {\n+                recordIndex--;\n+            }\n+\n+            @Override\n+            public CharSequence getSym(int col) {\n+                return reader.getSymbolMapReader(columnIndex).valueOf(recordIndex);", "originalCommit": "7a69a57522b890215dba99a1242d0c1bbe17e70a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3b95878137c57cff9981fe1bef911e9fe0a7723", "url": "https://github.com/questdb/questdb/commit/c3b95878137c57cff9981fe1bef911e9fe0a7723", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-19T12:53:55Z", "type": "commit"}, {"oid": "a1f3a0876c6e03005366857ffea69b53cb620805", "url": "https://github.com/questdb/questdb/commit/a1f3a0876c6e03005366857ffea69b53cb620805", "message": "feat(griffin): distinct queries on symbol column retrieve the list from metadata instead of iterating through the table.", "committedDate": "2020-03-20T10:14:06Z", "type": "commit"}]}