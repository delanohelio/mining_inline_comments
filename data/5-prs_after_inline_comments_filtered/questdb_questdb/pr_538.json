{"pr_number": 538, "pr_title": "A support to remap memory mapped files that grow", "pr_createdAt": "2020-08-07T16:02:56Z", "pr_url": "https://github.com/questdb/questdb/pull/538", "timeline": [{"oid": "daabd2415f352c85f210e285eab48a9c46f57b4c", "url": "https://github.com/questdb/questdb/commit/daabd2415f352c85f210e285eab48a9c46f57b4c", "message": "feat(cairo): Remap memory pages that grow rather than adding a new mapping", "committedDate": "2020-08-05T12:15:30Z", "type": "commit"}, {"oid": "d1a48535ebefed33002fa4174b3e9e9b0e95f58a", "url": "https://github.com/questdb/questdb/commit/d1a48535ebefed33002fa4174b3e9e9b0e95f58a", "message": "feat(cairo): Remap memory pages that grow rather than adding a new mapping", "committedDate": "2020-08-05T12:25:54Z", "type": "commit"}, {"oid": "7d4923dfeeabaeed9cd78d09d799d4c365fafec7", "url": "https://github.com/questdb/questdb/commit/7d4923dfeeabaeed9cd78d09d799d4c365fafec7", "message": "feat(cairo): Create ContiguousVirtualMemory", "committedDate": "2020-08-06T09:54:12Z", "type": "commit"}, {"oid": "e242874d54e9fb8242d8ba3374515809decd82b8", "url": "https://github.com/questdb/questdb/commit/e242874d54e9fb8242d8ba3374515809decd82b8", "message": "feat(cairo): Remap memory pages that grow rather than adding a new mapping", "committedDate": "2020-08-06T11:40:42Z", "type": "commit"}, {"oid": "554a267f69c2dcc61fbf8dac69d1013c6b4d98cc", "url": "https://github.com/questdb/questdb/commit/554a267f69c2dcc61fbf8dac69d1013c6b4d98cc", "message": "feat(cairo): Remap memory pages that grow rather than adding a new mapping", "committedDate": "2020-08-06T13:06:49Z", "type": "commit"}, {"oid": "93f6e0d23a21104a9cc1cd903d799724f13d9cf3", "url": "https://github.com/questdb/questdb/commit/93f6e0d23a21104a9cc1cd903d799724f13d9cf3", "message": "feat(cairo): Change TableReader to to use single memory page instances to represent columns, so that columm values can never straddle pages", "committedDate": "2020-08-07T07:09:01Z", "type": "commit"}, {"oid": "5fc9cdca8adf2a30dd47294d82279e49ce2532ac", "url": "https://github.com/questdb/questdb/commit/5fc9cdca8adf2a30dd47294d82279e49ce2532ac", "message": "feat(cairo): Change TableReader to to use single memory page instances to represent columns, so that columm values can never straddle pages", "committedDate": "2020-08-07T10:50:32Z", "type": "commit"}, {"oid": "28e61107d6786fc3f39ddb0eb6af9f7842eadc28", "url": "https://github.com/questdb/questdb/commit/28e61107d6786fc3f39ddb0eb6af9f7842eadc28", "message": "feat(cairo): Change TableReader to to use single memory page instances to represent columns, so that columm values can never straddle pages", "committedDate": "2020-08-07T12:05:20Z", "type": "commit"}, {"oid": "2e54bb5151a0467df25d4d31296f6cc65857b1d8", "url": "https://github.com/questdb/questdb/commit/2e54bb5151a0467df25d4d31296f6cc65857b1d8", "message": "chore(cairo): Fix bug in OnePageMemory", "committedDate": "2020-08-07T14:33:24Z", "type": "commit"}, {"oid": "5b2ce5f022a2d3ab2eb3311b125f9b361efd47c3", "url": "https://github.com/questdb/questdb/commit/5b2ce5f022a2d3ab2eb3311b125f9b361efd47c3", "message": "feat(cairo): Change TableReader to to use single memory page instances to represent columns, so that columm values can never straddle pages", "committedDate": "2020-08-07T14:51:55Z", "type": "commit"}, {"oid": "d71b400767e6df99b42dd343d6e78862a175f165", "url": "https://github.com/questdb/questdb/commit/d71b400767e6df99b42dd343d6e78862a175f165", "message": "feat(cairo): Change TableReader to to use single memory page instances to represent columns, so that columm values can never straddle pages", "committedDate": "2020-08-07T15:59:40Z", "type": "commit"}, {"oid": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a", "url": "https://github.com/questdb/questdb/commit/b15a69d8cc29f7ba6491256a6b1be03c40527b0a", "message": "chore: added benchmarks, inlined some code and extracted method out of hot path", "committedDate": "2020-08-08T00:34:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODQ4NA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467338484", "bodyText": "this is a better implementation than legacy virtual memory. Perhaps we should go ahead and replace virtual memory usages with this class.\nAdditionally class is not fully tested. There are a number of gaps. Using this impl instead of VirtualMemory will subject code to better testing.", "author": "bluestreak01", "createdAt": "2020-08-08T00:39:43Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;", "originalCommit": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4MjcwMw==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467782703", "bodyText": "I have created a use_contiguous branch, will move everything over to ContiguousVirtualMemory there", "author": "patrickSpaceSurfer", "createdAt": "2020-08-10T09:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzOTA2Nw==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r467339067", "bodyText": "exception should say \"could not\" rather than \"cannot\"", "author": "bluestreak01", "createdAt": "2020-08-08T00:43:32Z", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -81,12 +84,26 @@ public void of(FilesFacade ff, LPSZ name, long pageSize, long size) {\n             throw CairoException.instance(ff.errno()).put(\"Cannot open file: \").put(name);\n         }\n \n+        map(ff, name, size);\n+    }\n+\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n         this.size = size;\n-        this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n-        this.absolutePointer = page;\n+        if (size > 0) {\n+            this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n+            if (page == FilesFacade.MAP_FAILED) {\n+                close();\n+                throw CairoException.instance(ff.errno()).put(\"Cannot mmap \").put(name).put(\" [size=\").put(size).put(\", fd=\").put(fd).put(']');", "originalCommit": "b15a69d8cc29f7ba6491256a6b1be03c40527b0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d42a330c87af9ce87959d8796218906ccb5d2f11", "url": "https://github.com/questdb/questdb/commit/d42a330c87af9ce87959d8796218906ccb5d2f11", "message": "feat(cairo): Cleanup remap code", "committedDate": "2020-08-10T09:02:51Z", "type": "commit"}, {"oid": "de5e065c0be44b8bad61d6e77dc6bdfe47aee88e", "url": "https://github.com/questdb/questdb/commit/de5e065c0be44b8bad61d6e77dc6bdfe47aee88e", "message": "Merge remote-tracking branch 'refs/remotes/origin/remap' into remap", "committedDate": "2020-08-10T09:03:43Z", "type": "commit"}, {"oid": "a7f37c1b44a5196ef23bfab961b0ab8a73a8abd8", "url": "https://github.com/questdb/questdb/commit/a7f37c1b44a5196ef23bfab961b0ab8a73a8abd8", "message": "feat(cairo): Use ContiguousVirtualMemory in CompactMap", "committedDate": "2020-08-10T09:14:27Z", "type": "commit"}, {"oid": "7898591f969d65c1821b028cba962e1bae537bb5", "url": "https://github.com/questdb/questdb/commit/7898591f969d65c1821b028cba962e1bae537bb5", "message": "feat(cairo): Use ContiguousVirtualMemory in TableWriter, RecordChain, RndStringRndListFunctionFactory", "committedDate": "2020-08-10T09:24:02Z", "type": "commit"}, {"oid": "1818ab75f89e69720b03adf01595112fb4b2b258", "url": "https://github.com/questdb/questdb/commit/1818ab75f89e69720b03adf01595112fb4b2b258", "message": "feat(cairo): Use ContiguousVirtualMemory in LongChain and LongTreeChain", "committedDate": "2020-08-10T10:15:22Z", "type": "commit"}, {"oid": "0b95f8c817ad704c1cf49a662585689dd73d4a98", "url": "https://github.com/questdb/questdb/commit/0b95f8c817ad704c1cf49a662585689dd73d4a98", "message": "feat(cairo): Change JNI implementation for remap to use an inline function", "committedDate": "2020-08-10T10:48:06Z", "type": "commit"}, {"oid": "efe66d681a2894002994294a69b1d9052b3a4ec2", "url": "https://github.com/questdb/questdb/commit/efe66d681a2894002994294a69b1d9052b3a4ec2", "message": "chore(cairo): Add linux jni lib", "committedDate": "2020-08-10T10:52:26Z", "type": "commit"}, {"oid": "f3320b989cdf68a9b4e6547abac0bc47a7185323", "url": "https://github.com/questdb/questdb/commit/f3320b989cdf68a9b4e6547abac0bc47a7185323", "message": "feat(cair): Update OS/X JNI library", "committedDate": "2020-08-10T11:00:42Z", "type": "commit"}, {"oid": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "url": "https://github.com/questdb/questdb/commit/d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "message": "feat(cairo): Update windows JNI library", "committedDate": "2020-08-10T13:43:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjE5Mg==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092192", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:19:41Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjI5OA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092298", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:19:52Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjQ3MQ==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092471", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:20:10Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjY0OA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092648", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:20:32Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Mjg1Ng==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092856", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:20:53Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MjkxNQ==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468092915", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:21:01Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzEzMQ==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093131", "bodyText": "constants like that should be Character.BYTES", "author": "bluestreak01", "createdAt": "2020-08-10T18:21:25Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzMyNg==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093326", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:21:46Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzQ4MQ==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093481", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:22:05Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzcwNw==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093707", "bodyText": "untested and unused", "author": "bluestreak01", "createdAt": "2020-08-10T18:22:31Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5MzkyMA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468093920", "bodyText": "exception untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:22:55Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {\n+        assert newSize <= getMemorySize();\n+        assert baseAddress != 0;\n+        baseAddressHi = baseAddress + newSize;\n+        if (appendAddress > baseAddressHi) {\n+            appendAddress = baseAddressHi;\n+        }\n+    }\n+\n+    protected final void handleMemoryReleased() {\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    protected final void setPageSize(long pageSize) {\n+        this.pageSize = Numbers.ceilPow2(pageSize);\n+    }\n+\n+    protected final long getMemorySize() {\n+        return baseAddressHi - baseAddress;\n+    }\n+\n+    private void checkAndExtend(long addressHi) {\n+        assert appendAddress <= baseAddressHi;\n+        assert addressHi >= baseAddress;\n+        if (addressHi > baseAddressHi) {\n+            doExtend(addressHi);\n+        }\n+    }\n+\n+    protected final void checkLimits(long size) {\n+        checkAndExtend(appendAddress + size);\n+    }\n+\n+    protected final void checkLimits(long offset, long size) {\n+        checkAndExtend(baseAddress + offset + size);\n+    }\n+\n+    private void doExtend(long addressHi) {\n+        long newSize = addressHi - baseAddress;\n+        long nPages = (newSize / pageSize) + 1;\n+        newSize = nPages * pageSize;\n+        long oldSize = getMemorySize();\n+        LOG.info().$(\"extending [oldSize=\").$(oldSize).$(\", newSize=\").$(newSize).$(']').$();\n+        if (nPages > maxPages) {\n+            throw LimitOverflowException.instance().put(\"Maximum number of pages (\").put(maxPages).put(\") breached in VirtualMemory\");", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDE1NQ==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094155", "bodyText": "exception untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:23:24Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;\n+        }\n+\n+        return STRING_LENGTH_BYTES + s.length() * 2;\n+    }\n+\n+    private static void copyStrChars(CharSequence value, int pos, int len, long address) {\n+        for (int i = 0; i < len; i++) {\n+            char c = value.charAt(i + pos);\n+            Unsafe.getUnsafe().putChar(address + 2 * i, c);\n+        }\n+    }\n+\n+    public long addressOf(long offset) {\n+        checkLimits(offset, 1);\n+        return baseAddress + offset;\n+    }\n+\n+    @Override\n+    public void close() {\n+        releaseMemory();\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    public final long getAppendOffset() {\n+        return appendAddress - baseAddress;\n+    }\n+\n+    public final BinarySequence getBin(long offset) {\n+        final long len = getLong(offset);\n+        if (len == -1) {\n+            return null;\n+        }\n+        return bsview.of(offset + 8, len);\n+    }\n+\n+    public final long getBinLen(long offset) {\n+        return getLong(offset);\n+    }\n+\n+    public boolean getBool(long offset) {\n+        return getByte(offset) == 1;\n+    }\n+\n+    public final byte getByte(long offset) {\n+        return Unsafe.getUnsafe().getByte(addressOf(offset));\n+    }\n+\n+    public final char getChar(long offset) {\n+        return Unsafe.getUnsafe().getChar(addressOf(offset));\n+    }\n+\n+    public final double getDouble(long offset) {\n+        return Unsafe.getUnsafe().getDouble(addressOf(offset));\n+    }\n+\n+    public final float getFloat(long offset) {\n+        return Unsafe.getUnsafe().getFloat(addressOf(offset));\n+    }\n+\n+    public final int getInt(long offset) {\n+        return Unsafe.getUnsafe().getInt(addressOf(offset));\n+    }\n+\n+    public long getLong(long offset) {\n+        return Unsafe.getUnsafe().getLong(addressOf(offset));\n+    }\n+\n+    public void getLong256(long offset, CharSink sink) {\n+        final long a, b, c, d;\n+        a = getLong(offset);\n+        b = getLong(offset + Long.BYTES);\n+        c = getLong(offset + Long.BYTES * 2);\n+        d = getLong(offset + Long.BYTES * 3);\n+        Numbers.appendLong256(a, b, c, d, sink);\n+    }\n+\n+    public void getLong256(long offset, Long256Sink sink) {\n+        sink.setLong0(getLong(offset));\n+        sink.setLong1(getLong(offset + Long.BYTES));\n+        sink.setLong2(getLong(offset + Long.BYTES * 2));\n+        sink.setLong3(getLong(offset + Long.BYTES * 3));\n+    }\n+\n+    public Long256 getLong256A(long offset) {\n+        getLong256(offset, long256);\n+        return long256;\n+    }\n+\n+    public Long256 getLong256B(long offset) {\n+        getLong256(offset, long256B);\n+        return long256B;\n+    }\n+\n+    protected long getMapPageSize() {\n+        return pageSize;\n+    }\n+\n+    public final short getShort(long offset) {\n+        return Unsafe.getUnsafe().getShort(addressOf(offset));\n+    }\n+\n+    public final CharSequence getStr(long offset) {\n+        return getStr0(offset, csview);\n+    }\n+\n+    public final CharSequence getStr0(long offset, CharSequenceView view) {\n+        final int len = getInt(offset);\n+        if (len == TableUtils.NULL_LEN) {\n+            return null;\n+        }\n+\n+        if (len == 0) {\n+            return \"\";\n+        }\n+\n+        return view.of(offset + STRING_LENGTH_BYTES, len);\n+    }\n+\n+    public final CharSequence getStr2(long offset) {\n+        return getStr0(offset, csview2);\n+    }\n+\n+    public final int getStrLen(long offset) {\n+        return getInt(offset);\n+    }\n+\n+    public long hash(long offset, long size) {\n+        long n = size - (size & 7);\n+        long h = 179426491L;\n+        for (long i = 0; i < n; i += 8) {\n+            h = (h << 5) - h + getLong(offset + i);\n+        }\n+\n+        for (; n < size; n++) {\n+            h = (h << 5) - h + getByte(offset + n);\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Updates append pointer with address for the given offset. All put* functions will be\n+     * appending from this offset onwards effectively overwriting data. Size of virtual memory remains\n+     * unaffected until the moment memory has to be extended.\n+     *\n+     * @param offset position from 0 in virtual memory.\n+     */\n+    public void jumpTo(long offset) {\n+        checkLimits(offset, 0);\n+        appendAddress = baseAddress + offset;\n+    }\n+\n+    public final long putBin(BinarySequence value) {\n+        final long offset = getAppendOffset();\n+        if (value == null) {\n+            putLong(TableUtils.NULL_LEN);\n+        } else {\n+            final long len = value.length();\n+            checkLimits(len + 8);\n+            putLong(len);\n+            value.copyTo(appendAddress, 0, len);\n+            appendAddress += len;\n+        }\n+        return offset;\n+    }\n+\n+    public final long putBin(long from, long len) {\n+        checkLimits(len + 8);\n+        final long offset = getAppendOffset();\n+        putLong(len > 0 ? len : TableUtils.NULL_LEN);\n+        if (len < 1) {\n+            return offset;\n+        }\n+\n+        Unsafe.getUnsafe().copyMemory(from, appendAddress, len);\n+        appendAddress += len;\n+        return offset;\n+    }\n+\n+    public void putBool(boolean value) {\n+        putByte((byte) (value ? 1 : 0));\n+    }\n+\n+    public void putBool(long offset, boolean value) {\n+        putByte(offset, (byte) (value ? 1 : 0));\n+    }\n+\n+    public final void putByte(long offset, byte value) {\n+        checkLimits(offset, 1);\n+        Unsafe.getUnsafe().putByte(baseAddress + offset, value);\n+    }\n+\n+    public void putByte(byte b) {\n+        checkLimits(1);\n+        Unsafe.getUnsafe().putByte(appendAddress, b);\n+        appendAddress++;\n+    }\n+\n+    public void putChar(long offset, char value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putChar(baseAddress + offset, value);\n+    }\n+\n+    public final void putChar(char value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putChar(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public void putDouble(long offset, double value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putDouble(baseAddress + offset, value);\n+    }\n+\n+    public final void putDouble(double value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putDouble(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public void putFloat(long offset, float value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putFloat(baseAddress + offset, value);\n+    }\n+\n+    public final void putFloat(float value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putFloat(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putInt(long offset, int value) {\n+        checkLimits(offset, 4);\n+        Unsafe.getUnsafe().putInt(baseAddress + offset, value);\n+    }\n+\n+    public final void putInt(int value) {\n+        checkLimits(4);\n+        Unsafe.getUnsafe().putInt(appendAddress, value);\n+        appendAddress += 4;\n+    }\n+\n+    public void putLong(long offset, long value) {\n+        checkLimits(offset, 8);\n+        Unsafe.getUnsafe().putLong(baseAddress + offset, value);\n+    }\n+\n+    public final void putLong(long value) {\n+        checkLimits(8);\n+        Unsafe.getUnsafe().putLong(appendAddress, value);\n+        appendAddress += 8;\n+    }\n+\n+    public final void putLong128(long l1, long l2) {\n+        putLong(l1);\n+        putLong(l2);\n+    }\n+\n+    public void putLong256(long offset, Long256 value) {\n+        putLong256(\n+                offset,\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public void putLong256(long offset, long l0, long l1, long l2, long l3) {\n+        putLong(offset, l0);\n+        putLong(offset + Long.BYTES, l1);\n+        putLong(offset + Long.BYTES * 2, l2);\n+        putLong(offset + Long.BYTES * 3, l3);\n+    }\n+\n+    public final void putLong256(long l0, long l1, long l2, long l3) {\n+        putLong(l0);\n+        putLong(l1);\n+        putLong(l2);\n+        putLong(l3);\n+    }\n+\n+    public final void putLong256(Long256 value) {\n+        putLong256(\n+                value.getLong0(),\n+                value.getLong1(),\n+                value.getLong2(),\n+                value.getLong3());\n+    }\n+\n+    public final void putLong256(CharSequence hexString) {\n+        inPageLong256Decoder.putLong256(hexString);\n+    }\n+\n+    public final void putLong256(@NotNull CharSequence hexString, int start, int end) {\n+        inPageLong256Decoder.putLong256(hexString, start, end);\n+    }\n+\n+    public final long putNullBin() {\n+        final long offset = getAppendOffset();\n+        putLong(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final long putNullStr() {\n+        final long offset = getAppendOffset();\n+        putInt(TableUtils.NULL_LEN);\n+        return offset;\n+    }\n+\n+    public final void putNullStr(long offset) {\n+        putInt(offset, TableUtils.NULL_LEN);\n+    }\n+\n+    public void putShort(long offset, short value) {\n+        checkLimits(offset, 2);\n+        Unsafe.getUnsafe().putShort(baseAddress + offset, value);\n+    }\n+\n+    public final void putShort(short value) {\n+        checkLimits(2);\n+        Unsafe.getUnsafe().putShort(appendAddress, value);\n+        appendAddress += 2;\n+    }\n+\n+    public final long putStr(CharSequence value) {\n+        return value == null ? putNullStr() : putStr0(value, 0, value.length());\n+    }\n+\n+    public final long putStr(char value) {\n+        if (value == 0)\n+            return putNullStr();\n+        else {\n+            checkLimits(6);\n+            final long offset = getAppendOffset();\n+            putInt(1);\n+            Unsafe.getUnsafe().putChar(appendAddress, value);\n+            appendAddress += Character.BYTES;\n+            return offset;\n+        }\n+    }\n+\n+    public final long putStr(CharSequence value, int pos, int len) {\n+        if (value == null) {\n+            return putNullStr();\n+        }\n+        return putStr0(value, pos, len);\n+    }\n+\n+    public void putStr(long offset, CharSequence value) {\n+        if (value == null) {\n+            putNullStr(offset);\n+        } else {\n+            putStr(offset, value, 0, value.length());\n+        }\n+    }\n+\n+    public void putStr(long offset, CharSequence value, int pos, int len) {\n+        checkLimits(offset, len * 2 + STRING_LENGTH_BYTES);\n+        putInt(offset, len);\n+        copyStrChars(value, pos, len, baseAddress + offset + STRING_LENGTH_BYTES);\n+    }\n+\n+    /**\n+     * Skips given number of bytes. Same as logically appending 0-bytes. Advantage of this method is that\n+     * no memory write takes place.\n+     *\n+     * @param bytes number of bytes to skip\n+     */\n+    public void skip(long bytes) {\n+        checkLimits(bytes);\n+        appendAddress += bytes;\n+    }\n+\n+    public void zero() {\n+        long baseLength = baseAddressHi - baseAddress;\n+        Unsafe.getUnsafe().setMemory(baseAddress, baseLength, (byte) 0);\n+    }\n+\n+    private void putLong256Null() {\n+        checkLimits(32);\n+        Unsafe.getUnsafe().putLong(appendAddress, Long256Impl.NULL_LONG256.getLong0());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES, Long256Impl.NULL_LONG256.getLong1());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 2, Long256Impl.NULL_LONG256.getLong2());\n+        Unsafe.getUnsafe().putLong(appendAddress + Long.BYTES * 3, Long256Impl.NULL_LONG256.getLong3());\n+    }\n+\n+    private long putStr0(CharSequence value, int pos, int len) {\n+        checkLimits(len * 2 + STRING_LENGTH_BYTES);\n+        final long offset = getAppendOffset();\n+        putInt(len);\n+        copyStrChars(value, pos, len, appendAddress);\n+        appendAddress += len * 2;\n+        return offset;\n+    }\n+\n+    protected void releaseMemory() {\n+        if (baseAddress != 0) {\n+            long baseLength = baseAddressHi - baseAddress;\n+            Unsafe.free(baseAddress, baseLength);\n+            handleMemoryReleased();\n+        }\n+    }\n+\n+    protected long remapMemory(long newSize) {\n+        if (baseAddress == 0) {\n+            return Unsafe.malloc(newSize);\n+        }\n+        long oldSize = getMemorySize();\n+        return Unsafe.realloc(baseAddress, oldSize, newSize);\n+    }\n+\n+    protected final void handleMemoryTruncated(long newSize) {\n+        assert newSize <= getMemorySize();\n+        assert baseAddress != 0;\n+        baseAddressHi = baseAddress + newSize;\n+        if (appendAddress > baseAddressHi) {\n+            appendAddress = baseAddressHi;\n+        }\n+    }\n+\n+    protected final void handleMemoryReleased() {\n+        baseAddress = 0;\n+        baseAddressHi = 0;\n+        appendAddress = 0;\n+    }\n+\n+    protected final void setPageSize(long pageSize) {\n+        this.pageSize = Numbers.ceilPow2(pageSize);\n+    }\n+\n+    protected final long getMemorySize() {\n+        return baseAddressHi - baseAddress;\n+    }\n+\n+    private void checkAndExtend(long addressHi) {\n+        assert appendAddress <= baseAddressHi;\n+        assert addressHi >= baseAddress;\n+        if (addressHi > baseAddressHi) {\n+            doExtend(addressHi);\n+        }\n+    }\n+\n+    protected final void checkLimits(long size) {\n+        checkAndExtend(appendAddress + size);\n+    }\n+\n+    protected final void checkLimits(long offset, long size) {\n+        checkAndExtend(baseAddress + offset + size);\n+    }\n+\n+    private void doExtend(long addressHi) {\n+        long newSize = addressHi - baseAddress;\n+        long nPages = (newSize / pageSize) + 1;\n+        newSize = nPages * pageSize;\n+        long oldSize = getMemorySize();\n+        LOG.info().$(\"extending [oldSize=\").$(oldSize).$(\", newSize=\").$(newSize).$(']').$();\n+        if (nPages > maxPages) {\n+            throw LimitOverflowException.instance().put(\"Maximum number of pages (\").put(maxPages).put(\") breached in VirtualMemory\");\n+        }\n+        long appendOffset = appendAddress - baseAddress;\n+        baseAddress = remapMemory(newSize);\n+        baseAddressHi = baseAddress + newSize;\n+        appendAddress = baseAddress + appendOffset;\n+    }\n+\n+    public class CharSequenceView extends AbstractCharSequence {\n+        private int len;\n+        private long offset;\n+\n+        @Override\n+        public int length() {\n+            return len;\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            return ContiguousVirtualMemory.this.getChar(offset + index * 2L);\n+        }\n+\n+        CharSequenceView of(long offset, int len) {\n+            this.offset = offset;\n+            this.len = len;\n+            return this;\n+        }\n+    }\n+\n+    private class ByteSequenceView implements BinarySequence {\n+        private long offset;\n+        private long len = -1;\n+\n+        @Override\n+        public byte byteAt(long index) {\n+            return getByte(offset + index);\n+        }\n+\n+        @Override\n+        public void copyTo(long address, final long start, final long length) {\n+            long bytesRemaining = Math.min(length, this.len - start);\n+            long offset = this.offset + start;\n+            Unsafe.getUnsafe().copyMemory(baseAddress + offset, address, bytesRemaining);\n+        }\n+\n+        @Override\n+        public long length() {\n+            return len;\n+        }\n+\n+        ByteSequenceView of(long offset, long len) {\n+            this.offset = offset;\n+            this.len = len;\n+            return this;\n+        }\n+    }\n+\n+    private class InPageLong256FromCharSequenceDecoder extends Long256FromCharSequenceDecoder {\n+        private void putLong256(CharSequence hexString) {\n+            final int len;\n+            if (hexString == null || (len = hexString.length()) == 0) {\n+                putLong256Null();\n+                appendAddress += Long256.BYTES;\n+            } else {\n+                putLong256(hexString, 2, len);\n+            }\n+        }\n+\n+        private void putLong256(CharSequence hexString, int start, int end) {\n+            try {\n+                inPageLong256Decoder.decode(hexString, start, end);\n+            } catch (NumericException e) {\n+                throw CairoException.instance(0).put(\"invalid long256 [hex=\").put(hexString).put(']');", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDM3OA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094378", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:23:49Z", "path": "core/src/main/java/io/questdb/cairo/ExtendableOnePageMemory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.std.Files;\n+import io.questdb.std.FilesFacade;\n+import io.questdb.std.str.LPSZ;\n+\n+public class ExtendableOnePageMemory extends OnePageMemory {\n+    public ExtendableOnePageMemory(FilesFacade ff, LPSZ name, long size) {\n+        super(ff, name, size);\n+    }\n+\n+    public ExtendableOnePageMemory() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n+        size = Math.min(ff.length(fd), size);\n+        super.map(ff, name, size);\n+    }\n+\n+    @Override\n+    public void grow(long newSize) {\n+        final long fileSize = ff.length(fd);\n+        newSize = Math.max(newSize, fileSize);\n+        if (newSize <= size) {\n+            return;\n+        }\n+\n+        long offset = absolutePointer - page;\n+        long previousSize = size;\n+        if (previousSize > 0) {\n+            page = ff.mremap(fd, page, previousSize, newSize, 0, Files.MAP_RO);\n+        } else {\n+            assert page == -1;\n+            page = ff.mmap(fd, newSize, 0, Files.MAP_RO);\n+        }\n+        if (page == FilesFacade.MAP_FAILED) {\n+            close();", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NDYwNg==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468094606", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:24:18Z", "path": "core/src/main/java/io/questdb/cairo/OnePageMemory.java", "diffHunk": "@@ -81,12 +84,26 @@ public void of(FilesFacade ff, LPSZ name, long pageSize, long size) {\n             throw CairoException.instance(ff.errno()).put(\"Cannot open file: \").put(name);\n         }\n \n+        map(ff, name, size);\n+    }\n+\n+    protected void map(FilesFacade ff, LPSZ name, long size) {\n         this.size = size;\n-        this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n-        this.absolutePointer = page;\n+        if (size > 0) {\n+            this.page = ff.mmap(fd, size, 0, Files.MAP_RO);\n+            if (page == FilesFacade.MAP_FAILED) {\n+                close();", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjMxMg==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468106312", "bodyText": "unused", "author": "bluestreak01", "createdAt": "2020-08-10T18:46:12Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwNjM5NA==", "url": "https://github.com/questdb/questdb/pull/538#discussion_r468106394", "bodyText": "untested", "author": "bluestreak01", "createdAt": "2020-08-10T18:46:22Z", "path": "core/src/main/java/io/questdb/cairo/ContiguousVirtualMemory.java", "diffHunk": "@@ -0,0 +1,615 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cairo;\n+\n+import io.questdb.griffin.engine.LimitOverflowException;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.AbstractCharSequence;\n+import io.questdb.std.str.CharSink;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.io.Closeable;\n+\n+/**\n+ * \n+ * A version of {@link VirtualMemory} that uses a single contiguous memory region instead of pages. Note that it still has the concept of a page such that the contiguous memory region will grow in page sizes.\n+ * \n+ * @author Patrick Mackinlay\n+ *\n+ */\n+public class ContiguousVirtualMemory implements Closeable {\n+    static final int STRING_LENGTH_BYTES = 4;\n+    private static final Log LOG = LogFactory.getLog(ContiguousVirtualMemory.class);\n+    private final ByteSequenceView bsview = new ByteSequenceView();\n+    private final CharSequenceView csview = new CharSequenceView();\n+    private final CharSequenceView csview2 = new CharSequenceView();\n+    private final Long256Impl long256 = new Long256Impl();\n+    private final Long256Impl long256B = new Long256Impl();\n+    private long pageSize;\n+    private final int maxPages;\n+    private long baseAddress = 0;\n+    private long baseAddressHi = 0;\n+    private long appendAddress = 0;\n+    private final InPageLong256FromCharSequenceDecoder inPageLong256Decoder = new InPageLong256FromCharSequenceDecoder();\n+\n+    public ContiguousVirtualMemory(long pageSize, int maxPages) {\n+        this.maxPages = maxPages;\n+        setPageSize(pageSize);\n+    }\n+\n+    protected ContiguousVirtualMemory() {\n+        this.maxPages = Integer.MAX_VALUE;\n+    }\n+\n+    public static int getStorageLength(CharSequence s) {\n+        if (s == null) {\n+            return STRING_LENGTH_BYTES;", "originalCommit": "d9a0881e011b6f1f14d1c407a6dc49cbf0119dfd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d18386b0b8686b4988709a482e4f6b14122783b", "url": "https://github.com/questdb/questdb/commit/5d18386b0b8686b4988709a482e4f6b14122783b", "message": "chore: Add jacoco profile to maven", "committedDate": "2020-08-10T20:17:03Z", "type": "commit"}, {"oid": "cd5c7126a055f5c18db7d6f4a4910e811f653576", "url": "https://github.com/questdb/questdb/commit/cd5c7126a055f5c18db7d6f4a4910e811f653576", "message": "Merge remote-tracking branch 'origin/master' into remap", "committedDate": "2020-08-11T08:14:42Z", "type": "commit"}, {"oid": "2c98583f6b8ace7b30bfa1bb40b1d726b1abd076", "url": "https://github.com/questdb/questdb/commit/2c98583f6b8ace7b30bfa1bb40b1d726b1abd076", "message": "chore(cairo): Improve ContiguousVirtualMemory/VirtualMemory testing", "committedDate": "2020-08-11T11:17:41Z", "type": "commit"}, {"oid": "0551cdd2ad25db95abe0f321e9c548af65c0fb36", "url": "https://github.com/questdb/questdb/commit/0551cdd2ad25db95abe0f321e9c548af65c0fb36", "message": "chore(cairo): Improve ContiguousVirtualMemory/VirtualMemory testing", "committedDate": "2020-08-11T13:55:28Z", "type": "commit"}, {"oid": "813340c4985320ed9131ecfd9544e05b4e0783e7", "url": "https://github.com/questdb/questdb/commit/813340c4985320ed9131ecfd9544e05b4e0783e7", "message": "chore(cairo): Improve ContiguousVirtualMemory/VirtualMemory testing", "committedDate": "2020-08-11T14:54:47Z", "type": "commit"}, {"oid": "c3a3147778b7b9645c0cd4c21edb2c6d4534c5e0", "url": "https://github.com/questdb/questdb/commit/c3a3147778b7b9645c0cd4c21edb2c6d4534c5e0", "message": "chore(cairo): Improve ContiguousVirtualMemory/VirtualMemory testing", "committedDate": "2020-08-11T16:06:59Z", "type": "commit"}]}