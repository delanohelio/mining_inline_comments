{"pr_number": 470, "pr_title": "feat: add telemetry for CairoEngine events + PGWire and HTTP JSON apis", "pr_createdAt": "2020-06-30T09:35:39Z", "pr_url": "https://github.com/questdb/questdb/pull/470", "timeline": [{"oid": "263da50c440e4b5cae61ac694dbd8b006782a850", "url": "https://github.com/questdb/questdb/commit/263da50c440e4b5cae61ac694dbd8b006782a850", "message": "feat: add telemetry for CairoEngine events + PGWire and HTTP JSON apis", "committedDate": "2020-06-30T10:09:37Z", "type": "commit"}, {"oid": "1d0eac136450b3c14a405a9c7d0e4c5c763887bd", "url": "https://github.com/questdb/questdb/commit/1d0eac136450b3c14a405a9c7d0e4c5c763887bd", "message": "fix: correct/improve tests", "committedDate": "2020-06-30T10:09:40Z", "type": "commit"}, {"oid": "1d0eac136450b3c14a405a9c7d0e4c5c763887bd", "url": "https://github.com/questdb/questdb/commit/1d0eac136450b3c14a405a9c7d0e4c5c763887bd", "message": "fix: correct/improve tests", "committedDate": "2020-06-30T10:09:40Z", "type": "forcePushed"}, {"oid": "e7592b51c81630074d4b57464aa216269fe0d73d", "url": "https://github.com/questdb/questdb/commit/e7592b51c81630074d4b57464aa216269fe0d73d", "message": "fix: simplify tests + remove dangling temp folders", "committedDate": "2020-06-30T11:45:01Z", "type": "commit"}, {"oid": "6305be7d9104c0de6ad63d55a6408d700c5504ad", "url": "https://github.com/questdb/questdb/commit/6305be7d9104c0de6ad63d55a6408d700c5504ad", "message": "feat: close telemetryJob as part of shutdownQuestDb in server", "committedDate": "2020-06-30T11:53:16Z", "type": "commit"}, {"oid": "1682c16382df6278cfacfa8d2c8a30068f7cff14", "url": "https://github.com/questdb/questdb/commit/1682c16382df6278cfacfa8d2c8a30068f7cff14", "message": "fix: correct path to server.conf", "committedDate": "2020-06-30T14:13:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMDE2OQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447800169", "bodyText": "if you cannot open \"writerConfig\", constructor will leak \"writer\" instance.", "author": "bluestreak01", "createdAt": "2020-06-30T16:03:55Z", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();", "originalCommit": "1682c16382df6278cfacfa8d2c8a30068f7cff14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NzYzMQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447867631", "bodyText": "Done", "author": "mpsq", "createdAt": "2020-06-30T17:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMDE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjk4OA==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447802988", "bodyText": "ts appears to be in microseconds, putDate() expects millis", "author": "bluestreak01", "createdAt": "2020-06-30T16:08:17Z", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MicrosecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMicrosecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        try (TableReader reader = new TableReader(cairoConfig, configTableName)) {\n+            final NanosecondClock nanosecondClock = cairoConfig.getNanosecondClock();\n+\n+            if (reader.size() > 0) {\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+                final boolean _enabled = reader.getCursor().getRecord().getBool(1);\n+\n+                if (enabled != _enabled) {\n+                    final TableWriter.Row row = writerConfig.newRow();\n+                    row.putLong256(0, idSink);\n+                    row.putBool(1, enabled);\n+                    row.append();\n+                    writerConfig.commit();\n+                }\n+            } else {\n+                final TableWriter.Row row = writerConfig.newRow();\n+                row.putLong256(0, nanosecondClock.getTicks(), clock.getTicks(), 0, 0);\n+                row.putBool(1, enabled);\n+                row.append();\n+                writerConfig.commit();\n+                reader.reload();\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+            }\n+        }\n+\n+        newRow(TelemetryEvent.UP);\n+    }\n+\n+    public int getTableStatus(Path path, CharSequence tableName) {\n+        return TableUtils.exists(\n+                configuration.getCairoConfiguration().getFilesFacade(),\n+                path,\n+                configuration.getCairoConfiguration().getRoot(),\n+                tableName,\n+                0,\n+                tableName.length()\n+        );\n+    }\n+\n+    private void newRow(short event) {\n+        if (enabled) {\n+            final TableWriter.Row row = writer.newRow();\n+            row.putDate(0, clock.getTicks());\n+            row.putShort(1, event);\n+            row.append();\n+        }\n+    }\n+\n+    private void newRowConsumer(TelemetryTask telemetryRow) {\n+        final TableWriter.Row row = writer.newRow();\n+        row.putDate(0, telemetryRow.ts);", "originalCommit": "1682c16382df6278cfacfa8d2c8a30068f7cff14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NzIwNQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447867205", "bodyText": "Done", "author": "mpsq", "createdAt": "2020-06-30T17:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNDU1OQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447804559", "bodyText": "I hate to creep the scope here, but it would be super useful to capture execution site, e.g. PG wire, http etc", "author": "bluestreak01", "createdAt": "2020-06-30T16:10:38Z", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGConnectionContext.java", "diffHunk": "@@ -1241,6 +1243,7 @@ private void processQuery(\n         final Object statement = factoryCache.peek(queryText);\n         if (statement == null) {\n             final CompiledQuery cc = compiler.compile(queryText, sqlExecutionContext);\n+            sqlExecutionContext.storeTelemetry(cc.getType());", "originalCommit": "1682c16382df6278cfacfa8d2c8a30068f7cff14", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjI0MA==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447806240", "bodyText": "you absolutely must check the value of the cursor here. When queue is full, cursor == -1, the store has to be a noop. when cursor = -2, next() must be retried", "author": "bluestreak01", "createdAt": "2020-06-30T16:12:47Z", "path": "core/src/main/java/io/questdb/griffin/SqlExecutionContextImpl.java", "diffHunk": "@@ -121,6 +135,28 @@ public SqlExecutionInterruptor getSqlExecutionInterruptor() {\n         return interruptor;\n     }\n \n+    @Override\n+    public void storeTelemetry(short event) {\n+        telemetryMethod.store(event);\n+    }\n+\n+    private void doStoreTelemetry(short event) {\n+        final long cursor = telemetryPubSeq.next();\n+        TelemetryTask row = telemetryQueue.get(cursor);", "originalCommit": "1682c16382df6278cfacfa8d2c8a30068f7cff14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDI2OQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r447870269", "bodyText": "Done", "author": "mpsq", "createdAt": "2020-06-30T17:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNjI0MA=="}], "type": "inlineReview"}, {"oid": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "url": "https://github.com/questdb/questdb/commit/597677d40c4873dfdf7eddd60270a62f6f1e22d7", "message": "fix: address comments", "committedDate": "2020-06-30T19:05:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI3NjI2MQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448276261", "bodyText": "consiguration instance like this already exists at the class level (static)", "author": "bluestreak01", "createdAt": "2020-07-01T10:42:05Z", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -105,4 +105,20 @@ protected void assertThat(CharSequence expected, RecordCursor cursor, RecordMeta\n         cursor.toTop();\n         assertOnce(expected, cursor, metadata, header);\n     }\n+\n+    protected void assertColumn(CharSequence expected, CharSequence tableName, int index) {\n+        DefaultCairoConfiguration configuration = new DefaultCairoConfiguration(root);", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MTY3OA==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448281678", "bodyText": "engine is unused here", "author": "bluestreak01", "createdAt": "2020-07-01T10:52:53Z", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MjAzMQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448282031", "bodyText": "can use existing configuration instance here", "author": "bluestreak01", "createdAt": "2020-07-01T10:53:40Z", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryCreatesTablesWhenEnabled() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                final TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+\n+                Misc.free(telemetryJob);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryStoresUpAndDownEvents() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+                @Override\n+                public CairoConfiguration getCairoConfiguration() {\n+                    return new DefaultCairoConfiguration(root);", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4MjE4Ng==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448282186", "bodyText": "unused method", "author": "bluestreak01", "createdAt": "2020-07-01T10:53:57Z", "path": "core/src/test/java/io/questdb/TelemetryTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.std.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.test.tools.*;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Properties;\n+\n+public class TelemetryTest extends AbstractCairoTest {\n+    private final static FilesFacade FF = FilesFacadeImpl.INSTANCE;\n+\n+    @Test\n+    public void testTelemetryDisabledByDefault() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_DOES_NOT_EXIST, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryCreatesTablesWhenEnabled() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            try (CairoEngine engine = new CairoEngine(configuration, null)) {\n+                final TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+\n+                try (Path path = new Path()) {\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry\"));\n+                    Assert.assertEquals(TableUtils.TABLE_EXISTS, TableUtils.exists(FF, path, root, \"telemetry_config\"));\n+                }\n+\n+                Misc.free(telemetryJob);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testTelemetryStoresUpAndDownEvents() throws Exception {\n+        TestUtils.assertMemoryLeak(() -> {\n+            serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+                @Override\n+                public CairoConfiguration getCairoConfiguration() {\n+                    return new DefaultCairoConfiguration(root);\n+                }\n+            };\n+            configuration = serverConfiguration.getCairoConfiguration();\n+            messageBus = new MessageBusImpl(serverConfiguration);\n+            CairoEngine engine = new CairoEngine(configuration, messageBus);\n+            TelemetryJob telemetryJob = new TelemetryJob(serverConfiguration, engine, messageBus);\n+            Misc.free(telemetryJob);\n+\n+            final String expectedEvent = \"100\\n\" +\n+                    \"101\\n\";\n+            assertColumn(expectedEvent, \"telemetry\", 1);\n+\n+            final String expectedOrigin = \"1\\n\" +\n+                    \"1\\n\";\n+            assertColumn(expectedOrigin, \"telemetry\", 2);\n+\n+            Misc.free(engine);\n+        });\n+    }\n+\n+    private void assertTable(CharSequence expected, CharSequence tableName) {", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NDE0NA==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448284144", "bodyText": "returning new instance of configuration on each getCairoConfiguration() call could be inefficient and lead to memory churn in tests. It would be better to implement this method like so:\n            private final CairoConfiguration conf = new DefaultCairoConfiguration(root);\n            @Override\n            public CairoConfiguration getCairoConfiguration() {\n                return conf;\n            }", "author": "bluestreak01", "createdAt": "2020-07-01T10:58:02Z", "path": "core/src/test/java/io/questdb/cairo/AbstractCairoTest.java", "diffHunk": "@@ -51,18 +55,26 @@\n     public static TemporaryFolder temp = new TemporaryFolder();\n     protected static CharSequence root;\n     protected static CairoConfiguration configuration;\n+    protected static PropServerConfiguration serverConfiguration;\n     protected static MessageBus messageBus;\n \n     @BeforeClass\n-    public static void setUp() throws IOException {\n+    public static void setUp() throws IOException, JsonException, ServerConfigurationException {\n         // it is necessary to initialise logger before tests start\n         // logger doesn't relinquish memory until JVM stops\n         // which causes memory leak detector to fail should logger be\n         // created mid-test\n         LOG.info().$(\"begin\").$();\n         root = temp.newFolder(\"dbRoot\").getAbsolutePath();\n-        configuration = new DefaultCairoConfiguration(root);\n-        messageBus = new MessageBusImpl();\n+        TestUtils.copyMimeTypes(temp.getRoot().getAbsolutePath());\n+        serverConfiguration = new PropServerConfiguration(temp.getRoot().getAbsolutePath(), new Properties()) {\n+            @Override\n+            public CairoConfiguration getCairoConfiguration() {\n+                return new DefaultCairoConfiguration(root);", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NjgzMg==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448286832", "bodyText": "when telemetry is disabled it is better not to create job at all. This would meet potential user expectations such as:\n\ni disabled telemetry\ntelemetry tables are not created", "author": "bluestreak01", "createdAt": "2020-07-01T11:03:20Z", "path": "core/src/main/java/io/questdb/ServerMain.java", "diffHunk": "@@ -139,12 +139,17 @@ public static void main(String[] args) throws Exception {\n         }\n \n         final WorkerPool workerPool = new WorkerPool(configuration.getWorkerPoolConfiguration());\n-        final MessageBus messageBus = new MessageBusImpl();\n+        final MessageBus messageBus = new MessageBusImpl(configuration);\n         final FunctionFactoryCache functionFactoryCache = new FunctionFactoryCache(configuration.getCairoConfiguration(), ServiceLoader.load(FunctionFactory.class));\n \n         LogFactory.configureFromSystemProperties(workerPool);\n         final CairoEngine cairoEngine = new CairoEngine(configuration.getCairoConfiguration(), messageBus);\n         workerPool.assign(cairoEngine.getWriterMaintenanceJob());\n+        final TelemetryJob telemetryJob = new TelemetryJob(configuration, cairoEngine, messageBus);\n+\n+        if (configuration.getTelemetryConfiguration().getEnabled()) {", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM1OTE2Mw==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448359163", "bodyText": "TelemetryJob is needed even when telemetry is turned off because it is responsible for updating the telemetry_config table, if I remove it, telemetry will always be on from the UI perspective (because the table won't be updated). I will keep this as is.\nAlso the table telemetry_config is always required (again, for the UI).", "author": "mpsq", "createdAt": "2020-07-01T13:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NjgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4NzM4Ng==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448287386", "bodyText": "There is disjointed syntax here. MessageBus is declared nullable and yet the code behaves as if it was declared NotNull", "author": "bluestreak01", "createdAt": "2020-07-01T11:04:29Z", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.std.time.MillisecondClock;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MillisecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMillisecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI4OTk1MQ==", "url": "https://github.com/questdb/questdb/pull/470#discussion_r448289951", "bodyText": "Accessing record like this is very fragile. Convention is for access like this:\nRecordCursor cursor = reader.getCursor();\nRecord record = cursor.getRecord();\nif (cursor.next()) {\n   record.getLong256...\n} else {\n   // is my table empty?!\n}", "author": "bluestreak01", "createdAt": "2020-07-01T11:09:40Z", "path": "core/src/main/java/io/questdb/TelemetryJob.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.security.AllowAllCairoSecurityContext;\n+import io.questdb.griffin.SqlCompiler;\n+import io.questdb.griffin.SqlException;\n+import io.questdb.griffin.SqlExecutionContextImpl;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.mp.*;\n+import io.questdb.std.*;\n+import io.questdb.std.microtime.*;\n+import io.questdb.std.str.Path;\n+import io.questdb.std.str.StringSink;\n+import io.questdb.std.time.MillisecondClock;\n+import io.questdb.tasks.TelemetryTask;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.io.Closeable;\n+\n+public class TelemetryJob extends SynchronizedJob implements Closeable {\n+    private static final Log LOG = LogFactory.getLog(TelemetryJob.class);\n+\n+    private final CharSequence tableName = \"telemetry\";\n+    private final CharSequence configTableName = \"telemetry_config\";\n+    private final QueueConsumer<TelemetryTask> myConsumer = this::newRowConsumer;\n+    private final StringSink idSink = new StringSink();\n+\n+    private final MillisecondClock clock;\n+    private final PropServerConfiguration configuration;\n+    private final boolean enabled;\n+    private final TableWriter writer;\n+    private final TableWriter writerConfig;\n+    private final RingQueue<TelemetryTask> queue;\n+    private final SCSequence subSeq;\n+\n+    public TelemetryJob(PropServerConfiguration configuration, CairoEngine engine, @Nullable MessageBus messageBus) throws SqlException, CairoException {\n+        final CairoConfiguration cairoConfig = configuration.getCairoConfiguration();\n+\n+        this.clock = cairoConfig.getMillisecondClock();\n+        this.configuration = configuration;\n+        this.enabled = configuration.getTelemetryConfiguration().getEnabled();\n+        this.queue = messageBus.getTelemetryQueue();\n+        this.subSeq = messageBus.getTelemetrySubSequence();\n+\n+        try (\n+                Path path = new Path();\n+                SqlCompiler compiler = new SqlCompiler(engine)\n+        ) {\n+            final SqlExecutionContextImpl sqlExecutionContext = new SqlExecutionContextImpl(messageBus, 1, engine);\n+            sqlExecutionContext.with(AllowAllCairoSecurityContext.INSTANCE, null, null);\n+\n+            if (getTableStatus(path, tableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + tableName + \" (ts timestamp, event short, origin short)\", sqlExecutionContext);\n+            }\n+\n+            if (getTableStatus(path, configTableName) == TableUtils.TABLE_DOES_NOT_EXIST) {\n+                compiler.compile(\"CREATE TABLE \" + configTableName + \" (id long256, enabled boolean)\", sqlExecutionContext);\n+            }\n+        }\n+\n+        try {\n+            this.writer = new TableWriter(cairoConfig, tableName);\n+        } catch (CairoException ex) {\n+            LOG.error().$(\"could not open [table=\").utf8(tableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        // todo: close writerConfig. We currently keep it opened to prevent users from modifying the table.\n+        // Once we have a permission system, we can use that instead.\n+        try {\n+            this.writerConfig = new TableWriter(cairoConfig, configTableName);\n+        } catch (CairoException ex) {\n+            Misc.free(writer);\n+            LOG.error().$(\"could not open [table=\").utf8(configTableName).$(\"]\").$();\n+            throw ex;\n+        }\n+\n+        try (TableReader reader = new TableReader(cairoConfig, configTableName)) {\n+            final NanosecondClock nanosecondClock = cairoConfig.getNanosecondClock();\n+\n+            if (reader.size() > 0) {\n+                reader.getCursor().getRecord().getLong256(0, idSink);\n+                final boolean _enabled = reader.getCursor().getRecord().getBool(1);\n+\n+                if (enabled != _enabled) {\n+                    final TableWriter.Row row = writerConfig.newRow();\n+                    row.putLong256(0, idSink);\n+                    row.putBool(1, enabled);\n+                    row.append();\n+                    writerConfig.commit();\n+                }\n+            } else {\n+                final MicrosecondClock clock = cairoConfig.getMicrosecondClock();\n+                final TableWriter.Row row = writerConfig.newRow();\n+                row.putLong256(0, nanosecondClock.getTicks(), clock.getTicks(), 0, 0);\n+                row.putBool(1, enabled);\n+                row.append();\n+                writerConfig.commit();\n+                reader.reload();\n+                reader.getCursor().getRecord().getLong256(0, idSink);", "originalCommit": "597677d40c4873dfdf7eddd60270a62f6f1e22d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "115cb48a3bb7a26d38d6cdc963f1f02e7cf33cdb", "url": "https://github.com/questdb/questdb/commit/115cb48a3bb7a26d38d6cdc963f1f02e7cf33cdb", "message": "fix: address comments", "committedDate": "2020-07-01T14:27:29Z", "type": "commit"}, {"oid": "68036070fc46018cbab8c8c095e362177afc8026", "url": "https://github.com/questdb/questdb/commit/68036070fc46018cbab8c8c095e362177afc8026", "message": "fix: correct column size for Long256 type", "committedDate": "2020-07-01T14:59:09Z", "type": "commit"}]}