{"pr_number": 597, "pr_title": "feat(griffin): haversine distance function", "pr_createdAt": "2020-09-09T13:09:32Z", "pr_url": "https://github.com/questdb/questdb/pull/597", "timeline": [{"oid": "54196d724bb9b6b5cd32953fabe590a44382cb59", "url": "https://github.com/questdb/questdb/commit/54196d724bb9b6b5cd32953fabe590a44382cb59", "message": "feat(griffin): haversine distance function", "committedDate": "2020-09-09T11:07:05Z", "type": "commit"}, {"oid": "d27ba5dab2f7d45f877621a5dff4b93d9704295d", "url": "https://github.com/questdb/questdb/commit/d27ba5dab2f7d45f877621a5dff4b93d9704295d", "message": "feat(griffin): added func to meta-inf services", "committedDate": "2020-09-09T13:41:27Z", "type": "commit"}, {"oid": "8aef318a64e9b7ca41cdff3d51bac602ce26b33b", "url": "https://github.com/questdb/questdb/commit/8aef318a64e9b7ca41cdff3d51bac602ce26b33b", "message": "feat(griffin): fixed bug with nulls at middle and end", "committedDate": "2020-09-09T15:12:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNDcwMg==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485614702", "bodyText": "lat2, lon2\n\nare already computed, no need for extra function calls", "author": "bluestreak01", "createdAt": "2020-09-09T13:33:45Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.ArrayColumnTypes;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.map.MapValue;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.griffin.engine.functions.BinaryFunction;\n+import io.questdb.griffin.engine.functions.DoubleFunction;\n+import io.questdb.griffin.engine.functions.GroupByFunction;\n+import org.jetbrains.annotations.NotNull;\n+\n+import static java.lang.Math.*;\n+\n+public class HaversineDistDegreeGroupByFunction extends DoubleFunction implements GroupByFunction, BinaryFunction {\n+\n+    private final static double EARTH_RADIUS = 6371.088;\n+    private final Function latDegree;\n+    private final Function lonDegree;\n+    private int valueIndex;\n+\n+    public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDegree, @NotNull Function lonDegree) {\n+        super(position);\n+        this.latDegree = latDegree;\n+        this.lonDegree = lonDegree;\n+    }\n+\n+    @Override\n+    public void computeFirst(MapValue mapValue, Record record) {\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 2, 0);\n+    }\n+\n+    @Override\n+    public void computeNext(MapValue mapValue, Record record) {\n+        double lat1 = toRad(mapValue.getDouble(valueIndex));\n+        double lon1 = toRad(mapValue.getDouble(valueIndex + 1));\n+        double lat2 = toRad(this.latDegree.getDouble(record));\n+        double lon2 = toRad(this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));", "originalCommit": "54196d724bb9b6b5cd32953fabe590a44382cb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0ODg3NA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485848874", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-09T19:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYxNDcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzNzEwNA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485637104", "bodyText": "this check should be done before storing lon2 as previous value. The whole distance will degrade to NaN. Are there tests covering this scenario?", "author": "bluestreak01", "createdAt": "2020-09-09T14:03:04Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.ArrayColumnTypes;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.map.MapValue;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.griffin.engine.functions.BinaryFunction;\n+import io.questdb.griffin.engine.functions.DoubleFunction;\n+import io.questdb.griffin.engine.functions.GroupByFunction;\n+import org.jetbrains.annotations.NotNull;\n+\n+import static java.lang.Math.*;\n+\n+public class HaversineDistDegreeGroupByFunction extends DoubleFunction implements GroupByFunction, BinaryFunction {\n+\n+    private final static double EARTH_RADIUS = 6371.088;\n+    private final Function latDegree;\n+    private final Function lonDegree;\n+    private int valueIndex;\n+\n+    public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDegree, @NotNull Function lonDegree) {\n+        super(position);\n+        this.latDegree = latDegree;\n+        this.lonDegree = lonDegree;\n+    }\n+\n+    @Override\n+    public void computeFirst(MapValue mapValue, Record record) {\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 2, 0);\n+    }\n+\n+    @Override\n+    public void computeNext(MapValue mapValue, Record record) {\n+        double lat1 = toRad(mapValue.getDouble(valueIndex));\n+        double lon1 = toRad(mapValue.getDouble(valueIndex + 1));\n+        double lat2 = toRad(this.latDegree.getDouble(record));\n+        double lon2 = toRad(this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        if (Double.isNaN(lat1) || Double.isNaN(lat2) || Double.isNaN(lon1) || Double.isNaN(lon2)) {", "originalCommit": "54196d724bb9b6b5cd32953fabe590a44382cb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0OTU4NQ==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485849585", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-09T19:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzNzEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzODI3Ng==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485638276", "bodyText": "when can storedDistance be NaN?", "author": "bluestreak01", "createdAt": "2020-09-09T14:04:33Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.ArrayColumnTypes;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.map.MapValue;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.griffin.engine.functions.BinaryFunction;\n+import io.questdb.griffin.engine.functions.DoubleFunction;\n+import io.questdb.griffin.engine.functions.GroupByFunction;\n+import org.jetbrains.annotations.NotNull;\n+\n+import static java.lang.Math.*;\n+\n+public class HaversineDistDegreeGroupByFunction extends DoubleFunction implements GroupByFunction, BinaryFunction {\n+\n+    private final static double EARTH_RADIUS = 6371.088;\n+    private final Function latDegree;\n+    private final Function lonDegree;\n+    private int valueIndex;\n+\n+    public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDegree, @NotNull Function lonDegree) {\n+        super(position);\n+        this.latDegree = latDegree;\n+        this.lonDegree = lonDegree;\n+    }\n+\n+    @Override\n+    public void computeFirst(MapValue mapValue, Record record) {\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 2, 0);\n+    }\n+\n+    @Override\n+    public void computeNext(MapValue mapValue, Record record) {\n+        double lat1 = toRad(mapValue.getDouble(valueIndex));\n+        double lon1 = toRad(mapValue.getDouble(valueIndex + 1));\n+        double lat2 = toRad(this.latDegree.getDouble(record));\n+        double lon2 = toRad(this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        if (Double.isNaN(lat1) || Double.isNaN(lat2) || Double.isNaN(lon1) || Double.isNaN(lon2)) {\n+            return;\n+        }\n+        double halfLatDist = (lat2 - lat1) / 2;\n+        double halfLonDist = (lon2 - lon1) / 2;\n+        double a = sin(halfLatDist) * sin(halfLatDist) + cos(lat1) * cos(lat2) * sin(halfLonDist) * sin(halfLonDist);\n+        double c = 2 * atan2(sqrt(a), sqrt(1 - a));\n+        double storedDistance = mapValue.getDouble(this.valueIndex + 2);\n+        double distance = Double.isNaN(storedDistance) ? 0 : storedDistance;", "originalCommit": "54196d724bb9b6b5cd32953fabe590a44382cb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0OTY1MA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485849650", "bodyText": "removed check", "author": "jaugsburger", "createdAt": "2020-09-09T19:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzODI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0MDQ0NA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485640444", "bodyText": "the value is interpolated between two points. For example at T1 distance was X and at T2 distance was Y.\nvalue is linear interpolation of T1,X and T2,Y. I think it should be assigned to \"distance\" rather than coordinates.\nThis puts tests in question though?", "author": "bluestreak01", "createdAt": "2020-09-09T14:07:15Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.ArrayColumnTypes;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.map.MapValue;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.griffin.engine.functions.BinaryFunction;\n+import io.questdb.griffin.engine.functions.DoubleFunction;\n+import io.questdb.griffin.engine.functions.GroupByFunction;\n+import org.jetbrains.annotations.NotNull;\n+\n+import static java.lang.Math.*;\n+\n+public class HaversineDistDegreeGroupByFunction extends DoubleFunction implements GroupByFunction, BinaryFunction {\n+\n+    private final static double EARTH_RADIUS = 6371.088;\n+    private final Function latDegree;\n+    private final Function lonDegree;\n+    private int valueIndex;\n+\n+    public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDegree, @NotNull Function lonDegree) {\n+        super(position);\n+        this.latDegree = latDegree;\n+        this.lonDegree = lonDegree;\n+    }\n+\n+    @Override\n+    public void computeFirst(MapValue mapValue, Record record) {\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 2, 0);\n+    }\n+\n+    @Override\n+    public void computeNext(MapValue mapValue, Record record) {\n+        double lat1 = toRad(mapValue.getDouble(valueIndex));\n+        double lon1 = toRad(mapValue.getDouble(valueIndex + 1));\n+        double lat2 = toRad(this.latDegree.getDouble(record));\n+        double lon2 = toRad(this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        if (Double.isNaN(lat1) || Double.isNaN(lat2) || Double.isNaN(lon1) || Double.isNaN(lon2)) {\n+            return;\n+        }\n+        double halfLatDist = (lat2 - lat1) / 2;\n+        double halfLonDist = (lon2 - lon1) / 2;\n+        double a = sin(halfLatDist) * sin(halfLatDist) + cos(lat1) * cos(lat2) * sin(halfLonDist) * sin(halfLonDist);\n+        double c = 2 * atan2(sqrt(a), sqrt(1 - a));\n+        double storedDistance = mapValue.getDouble(this.valueIndex + 2);\n+        double distance = Double.isNaN(storedDistance) ? 0 : storedDistance;\n+        distance += EARTH_RADIUS * c;\n+        mapValue.putDouble(this.valueIndex + 2, distance);\n+    }\n+\n+    @Override\n+    public void pushValueTypes(ArrayColumnTypes columnTypes) {\n+        this.valueIndex = columnTypes.getColumnCount();\n+        columnTypes.add(ColumnType.DOUBLE);\n+        columnTypes.add(ColumnType.DOUBLE);\n+        columnTypes.add(ColumnType.DOUBLE);\n+    }\n+\n+    @Override\n+    public void setDouble(MapValue mapValue, double value) {\n+        mapValue.putDouble(this.valueIndex, value);\n+        mapValue.putDouble(this.valueIndex + 1, value);\n+        mapValue.putDouble(this.valueIndex + 2, 0.0);", "originalCommit": "54196d724bb9b6b5cd32953fabe590a44382cb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MDE5Ng==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485850196", "bodyText": "this is strange, this method is not being called in the tests, I'm looking into it", "author": "jaugsburger", "createdAt": "2020-09-09T19:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0MDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzUxMA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492097510", "bodyText": "fixed", "author": "jaugsburger", "createdAt": "2020-09-21T14:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0MDQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0MTU3MA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485641570", "bodyText": "the name should probably be \"deg\" or \"degrees\".", "author": "bluestreak01", "createdAt": "2020-09-09T14:08:44Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunctionFactory.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.std.ObjList;\n+\n+public class HaversineDistDegreeGroupByFunctionFactory implements FunctionFactory {\n+    @Override\n+    public String getSignature() {\n+        return \"haversine_dist_degree(DD)\";", "originalCommit": "54196d724bb9b6b5cd32953fabe590a44382cb59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MDM0OA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485850348", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-09T19:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY0MTU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxOTY2Mw==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485719663", "bodyText": "Function should be optimised for happy path, e.g. none are null. There will be two branch misprediction most of the time in current impl", "author": "bluestreak01", "createdAt": "2020-09-09T15:51:47Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.groupby;\n+\n+import io.questdb.cairo.ArrayColumnTypes;\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.cairo.map.MapValue;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.cairo.sql.Record;\n+import io.questdb.griffin.engine.functions.BinaryFunction;\n+import io.questdb.griffin.engine.functions.DoubleFunction;\n+import io.questdb.griffin.engine.functions.GroupByFunction;\n+import org.jetbrains.annotations.NotNull;\n+\n+import static java.lang.Math.*;\n+\n+public class HaversineDistDegreeGroupByFunction extends DoubleFunction implements GroupByFunction, BinaryFunction {\n+\n+    private final static double EARTH_RADIUS = 6371.088;\n+    private final Function latDegree;\n+    private final Function lonDegree;\n+    private int valueIndex;\n+\n+    public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDegree, @NotNull Function lonDegree) {\n+        super(position);\n+        this.latDegree = latDegree;\n+        this.lonDegree = lonDegree;\n+    }\n+\n+    @Override\n+    public void computeFirst(MapValue mapValue, Record record) {\n+        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n+        mapValue.putDouble(this.valueIndex + 2, 0);\n+    }\n+\n+    @Override\n+    public void computeNext(MapValue mapValue, Record record) {\n+        double lat1 = toRad(mapValue.getDouble(valueIndex));\n+        double lon1 = toRad(mapValue.getDouble(valueIndex + 1));\n+        double lat2 = toRad(this.latDegree.getDouble(record));\n+        double lon2 = toRad(this.lonDegree.getDouble(record));\n+        if (Double.isNaN(lat1) || Double.isNaN(lon1)) {", "originalCommit": "8aef318a64e9b7ca41cdff3d51bac602ce26b33b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MDQ3Mg==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r485850472", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-09T19:11:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTcxOTY2Mw=="}], "type": "inlineReview"}, {"oid": "7f38ca22955cf69c22e928bce96f4ad5567ab248", "url": "https://github.com/questdb/questdb/commit/7f38ca22955cf69c22e928bce96f4ad5567ab248", "message": "feat(griffin): haversine distance function - PR comments", "committedDate": "2020-09-09T19:08:47Z", "type": "commit"}, {"oid": "9e049638fbd0b0607aa04b0835329e8dffe154bb", "url": "https://github.com/questdb/questdb/commit/9e049638fbd0b0607aa04b0835329e8dffe154bb", "message": "feat(griffin): haversine distance function - interpolation changes", "committedDate": "2020-09-15T09:25:28Z", "type": "commit"}, {"oid": "5b8b14ebd734c9b104b623be9f29f9304ed23904", "url": "https://github.com/questdb/questdb/commit/5b8b14ebd734c9b104b623be9f29f9304ed23904", "message": "feat(griffin): haversine distance function - interpolation of boundaries and gaps", "committedDate": "2020-09-18T17:55:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkyNTk2OQ==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r491925969", "bodyText": "please add comment here", "author": "bluestreak01", "createdAt": "2020-09-21T10:04:56Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -435,20 +498,51 @@ protected RecordCursor initFunctionsAndCursor(\n         return cursor;\n     }\n \n+    private void interpolateBoundaryRange(long x1, long x2, Record record) {\n+        //interpolating boundary\n+        for (int i = 0, m = groupByDistanceFunctions.size(); i < m; i++) {\n+            GroupByFunction function = groupByDistanceFunctions.getQuick(i);\n+            MapValue value1 = findDataMapValue2(record, x1);", "originalCommit": "5b8b14ebd734c9b104b623be9f29f9304ed23904", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d64418ffa5999c215f48b978fd395dec30d70f8", "url": "https://github.com/questdb/questdb/commit/7d64418ffa5999c215f48b978fd395dec30d70f8", "message": "feat(griffin): haversine distance function - PR comments", "committedDate": "2020-09-21T13:38:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4NjExNA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492086114", "bodyText": "\"Latitude\"", "author": "bluestreak01", "createdAt": "2020-09-21T14:20:01Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -52,164 +53,148 @@ public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDeg\n     }\n \n     @Override\n-    public Function getCenter() {\n-        return this.lonDegree;\n+    public double getDouble(Record rec) {\n+        return getDistance(rec);\n     }\n \n     @Override\n-    public Function getRight() {\n-        return this.timestamp;\n+    public Function getLeft() {\n+        return this.latDegree;\n     }\n \n     @Override\n-    public double getDouble(Record rec) {\n-        return rec.getDouble(this.valueIndex + 6);\n+    public Function getCenter() {\n+        return this.lonDegree;\n     }\n \n     @Override\n-    public void interpolateGap(MapValue result,\n-                               MapValue value1,\n-                               MapValue value2,\n-                               long gapSize) {\n-\n-        //value1\n-        double lat1Degrees = value1.getDouble(valueIndex + 3);\n-        double lon1Degrees = value1.getDouble(valueIndex + 4);\n-        long ts1 = value1.getTimestamp(valueIndex + 5);\n-\n-        //value2\n-        double lat2Degrees = value2.getDouble(valueIndex);\n-        double lon2Degrees = value2.getDouble(valueIndex + 1);\n-        long ts2 = value2.getTimestamp(valueIndex + 2);\n-\n-        double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, 0);\n-        double interpolatedGapDistance = (gapSize * distance) / (ts2 - ts1);\n-\n-        result.putDouble(this.valueIndex + 6, interpolatedGapDistance);\n+    public Function getRight() {\n+        return this.timestamp;\n     }\n \n     @Override\n     public void interpolateBoundary(\n             MapValue value1,\n             MapValue value2,\n             long boundaryTimestamp,\n-            boolean isEndOfBoundary) {\n+            boolean isEndOfBoundary\n+    ) {\n \n-        //value1\n-        double lat1Degrees = value1.getDouble(valueIndex + 3);\n-        double lon1Degrees = value1.getDouble(valueIndex + 4);\n-        long ts1 = value1.getTimestamp(valueIndex + 5);\n-\n-        //value2 - the first item in this sampling interval\n-        double lat2Degrees = value2.getDouble(valueIndex);\n-        double lon2Degrees = value2.getDouble(valueIndex + 1);\n-        long ts2 = value2.getTimestamp(valueIndex + 2);\n-\n-        double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, 0);\n-        long boundaryLength;\n-        if (isEndOfBoundary) {\n-            boundaryLength = boundaryTimestamp - ts1;\n-        } else {\n-            boundaryLength = ts2 - boundaryTimestamp;\n-        }\n+        double distance = calculateHaversineDistance(value1, value2);\n+        //interpolate\n+        long ts1 = getLastTimestamp(value1);\n+        long ts2 = getFirstTimestamp(value2);\n+        long boundaryLength = isEndOfBoundary ? boundaryTimestamp - ts1 : ts2 - boundaryTimestamp;\n         double interpolatedBoundaryDistance = (boundaryLength * distance) / (ts2 - ts1);\n+        //save\n+        MapValue result = isEndOfBoundary ? value1 : value2;\n+        saveDistance(interpolatedBoundaryDistance, result, getDistance(result));\n+    }\n \n-        MapValue result;\n-        if (isEndOfBoundary) {\n-            result = value1;\n-        } else {\n-            result = value2;\n-        }\n+    @Override\n+    public void interpolateGap(\n+            MapValue result,\n+            MapValue value1,\n+            MapValue value2,\n+            long gapSize\n+    ) {\n+\n+        double distance = calculateHaversineDistance(value1, value2);\n \n-        double currentDistance = result.getDouble(valueIndex + 6);\n-        result.putDouble(this.valueIndex + 6, currentDistance + interpolatedBoundaryDistance);\n+        //interpolate\n+        long ts1 = getLastTimestamp(value1);\n+        long ts2 = getFirstTimestamp(value2);\n+        double interpolatedGapDistance = (gapSize * distance) / (ts2 - ts1);\n+\n+        saveDistance(result, interpolatedGapDistance);\n+    }\n+\n+    @Override\n+    public boolean isScalar() {\n+        return false;\n     }\n \n     @Override\n     public void computeFirst(MapValue mapValue, Record record) {\n         //first item\n-        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n-        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n-        mapValue.putTimestamp(this.valueIndex + 2, this.timestamp.getTimestamp(record));\n+        saveFirstItem(mapValue, this.latDegree.getDouble(record), this.lonDegree.getDouble(record), this.timestamp.getTimestamp(record));\n         //last item\n-        mapValue.putDouble(this.valueIndex + 3, this.latDegree.getDouble(record));\n-        mapValue.putDouble(this.valueIndex + 4, this.lonDegree.getDouble(record));\n-        mapValue.putTimestamp(this.valueIndex + 5, this.timestamp.getTimestamp(record));\n+        saveLastItem(mapValue, this.latDegree.getDouble(record), this.lonDegree.getDouble(record), this.timestamp.getTimestamp(record));\n         //result\n-        mapValue.putDouble(this.valueIndex + 6, 0);\n+        saveDistance(mapValue, 0);\n     }\n \n     @Override\n     public void computeNext(MapValue mapValue, Record record) {\n-        double lat1Degrees = mapValue.getDouble(valueIndex + 3);\n-        double lon1Degrees = mapValue.getDouble(valueIndex + 4);\n+        double lat1Degrees = getLastLatitute(mapValue);\n+        double lon1Degrees = getLastLongitude(mapValue);\n+        long timestamp1 = getLastTimestamp(mapValue);\n         double lat2Degrees = this.latDegree.getDouble(record);\n         double lon2Degrees = this.lonDegree.getDouble(record);\n-        long timestamp = this.timestamp.getTimestamp(record);\n-        if (!Double.isNaN(lat1Degrees) && !Double.isNaN(lon1Degrees)) {\n-            if (!Double.isNaN(lat2Degrees) && !Double.isNaN(lon2Degrees)) {\n-                double currentTotalDistance = mapValue.getDouble(this.valueIndex + 6);\n-                double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, currentTotalDistance);\n-                mapValue.putDouble(this.valueIndex + 3, lat2Degrees);\n-                mapValue.putDouble(this.valueIndex + 4, lon2Degrees);\n-                mapValue.putTimestamp(this.valueIndex + 5, timestamp);\n-                mapValue.putDouble(this.valueIndex + 6, distance);\n+        long timestamp2 = this.timestamp.getTimestamp(record);\n+        if (!Double.isNaN(lat1Degrees) && !Double.isNaN(lon1Degrees) && timestamp1 != Numbers.LONG_NaN) {\n+            if (!Double.isNaN(lat2Degrees) && !Double.isNaN(lon2Degrees) && timestamp2 != Numbers.LONG_NaN) {\n+                double currentTotalDistance = getDistance(mapValue);\n+                double distance = calculateHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, currentTotalDistance);\n+                saveLastItem(mapValue, lat2Degrees, lon2Degrees, timestamp2);\n+                saveDistance(mapValue, distance);\n             }\n         } else {\n-            mapValue.putDouble(this.valueIndex + 3, lat2Degrees);\n-            mapValue.putDouble(this.valueIndex + 4, lon2Degrees);\n-            mapValue.putTimestamp(this.valueIndex + 5, timestamp);\n+            saveLastItem(mapValue, lat2Degrees, lon2Degrees, timestamp2);\n         }\n     }\n \n-    @Override\n-    public boolean isScalar() {\n-        return false;\n-    }\n-\n     @Override\n     public void pushValueTypes(ArrayColumnTypes columnTypes) {\n         this.valueIndex = columnTypes.getColumnCount();\n+        //first item\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.LONG);\n+        //last item\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.LONG);\n         //result\n         columnTypes.add(ColumnType.DOUBLE);\n     }\n \n-    @Override\n-    public Function getLeft() {\n-        return this.latDegree;\n-    }\n-\n     @Override\n     public void setDouble(MapValue mapValue, double value) {\n-        mapValue.putDouble(this.valueIndex + 6, value);\n+        saveDistance(mapValue, value);\n     }\n \n     @Override\n     public void setNull(MapValue mapValue) {\n-        mapValue.putDouble(this.valueIndex, Double.NaN);\n-        mapValue.putDouble(this.valueIndex + 1, Double.NaN);\n-        mapValue.putTimestamp(this.valueIndex + 2, 0L);\n-        mapValue.putDouble(this.valueIndex + 3, Double.NaN);\n-        mapValue.putDouble(this.valueIndex + 4, Double.NaN);\n-        mapValue.putTimestamp(this.valueIndex + 5, 0L);\n-        mapValue.putDouble(this.valueIndex + 6, 0.0);\n+        //set null to first item\n+        saveFirstItem(mapValue, Double.NaN, Double.NaN, Numbers.LONG_NaN);\n+        //set null to last item\n+        saveLastItem(mapValue, Double.NaN, Double.NaN, Numbers.LONG_NaN);\n+        //\n+        saveDistance(mapValue, 0.0);\n     }\n \n-    private double getHaversineDistanceFromDegrees(double lat1Degrees, double lon1Degrees, double lat2Degrees, double lon2Degrees, double currentTotalDistance) {\n+    private double calculateHaversineDistance(MapValue value1, MapValue value2) {\n+        //value1\n+        double lat1Degrees = getLastLatitute(value1);", "originalCommit": "7d64418ffa5999c215f48b978fd395dec30d70f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA5NzY4OQ==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492097689", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-21T14:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4NjExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4NzE4MA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492087180", "bodyText": "under which circumstances would this be called?", "author": "bluestreak01", "createdAt": "2020-09-21T14:21:19Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/groupby/HaversineDistDegreeGroupByFunction.java", "diffHunk": "@@ -52,164 +53,148 @@ public HaversineDistDegreeGroupByFunction(int position, @NotNull Function latDeg\n     }\n \n     @Override\n-    public Function getCenter() {\n-        return this.lonDegree;\n+    public double getDouble(Record rec) {\n+        return getDistance(rec);\n     }\n \n     @Override\n-    public Function getRight() {\n-        return this.timestamp;\n+    public Function getLeft() {\n+        return this.latDegree;\n     }\n \n     @Override\n-    public double getDouble(Record rec) {\n-        return rec.getDouble(this.valueIndex + 6);\n+    public Function getCenter() {\n+        return this.lonDegree;\n     }\n \n     @Override\n-    public void interpolateGap(MapValue result,\n-                               MapValue value1,\n-                               MapValue value2,\n-                               long gapSize) {\n-\n-        //value1\n-        double lat1Degrees = value1.getDouble(valueIndex + 3);\n-        double lon1Degrees = value1.getDouble(valueIndex + 4);\n-        long ts1 = value1.getTimestamp(valueIndex + 5);\n-\n-        //value2\n-        double lat2Degrees = value2.getDouble(valueIndex);\n-        double lon2Degrees = value2.getDouble(valueIndex + 1);\n-        long ts2 = value2.getTimestamp(valueIndex + 2);\n-\n-        double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, 0);\n-        double interpolatedGapDistance = (gapSize * distance) / (ts2 - ts1);\n-\n-        result.putDouble(this.valueIndex + 6, interpolatedGapDistance);\n+    public Function getRight() {\n+        return this.timestamp;\n     }\n \n     @Override\n     public void interpolateBoundary(\n             MapValue value1,\n             MapValue value2,\n             long boundaryTimestamp,\n-            boolean isEndOfBoundary) {\n+            boolean isEndOfBoundary\n+    ) {\n \n-        //value1\n-        double lat1Degrees = value1.getDouble(valueIndex + 3);\n-        double lon1Degrees = value1.getDouble(valueIndex + 4);\n-        long ts1 = value1.getTimestamp(valueIndex + 5);\n-\n-        //value2 - the first item in this sampling interval\n-        double lat2Degrees = value2.getDouble(valueIndex);\n-        double lon2Degrees = value2.getDouble(valueIndex + 1);\n-        long ts2 = value2.getTimestamp(valueIndex + 2);\n-\n-        double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, 0);\n-        long boundaryLength;\n-        if (isEndOfBoundary) {\n-            boundaryLength = boundaryTimestamp - ts1;\n-        } else {\n-            boundaryLength = ts2 - boundaryTimestamp;\n-        }\n+        double distance = calculateHaversineDistance(value1, value2);\n+        //interpolate\n+        long ts1 = getLastTimestamp(value1);\n+        long ts2 = getFirstTimestamp(value2);\n+        long boundaryLength = isEndOfBoundary ? boundaryTimestamp - ts1 : ts2 - boundaryTimestamp;\n         double interpolatedBoundaryDistance = (boundaryLength * distance) / (ts2 - ts1);\n+        //save\n+        MapValue result = isEndOfBoundary ? value1 : value2;\n+        saveDistance(interpolatedBoundaryDistance, result, getDistance(result));\n+    }\n \n-        MapValue result;\n-        if (isEndOfBoundary) {\n-            result = value1;\n-        } else {\n-            result = value2;\n-        }\n+    @Override\n+    public void interpolateGap(\n+            MapValue result,\n+            MapValue value1,\n+            MapValue value2,\n+            long gapSize\n+    ) {\n+\n+        double distance = calculateHaversineDistance(value1, value2);\n \n-        double currentDistance = result.getDouble(valueIndex + 6);\n-        result.putDouble(this.valueIndex + 6, currentDistance + interpolatedBoundaryDistance);\n+        //interpolate\n+        long ts1 = getLastTimestamp(value1);\n+        long ts2 = getFirstTimestamp(value2);\n+        double interpolatedGapDistance = (gapSize * distance) / (ts2 - ts1);\n+\n+        saveDistance(result, interpolatedGapDistance);\n+    }\n+\n+    @Override\n+    public boolean isScalar() {\n+        return false;\n     }\n \n     @Override\n     public void computeFirst(MapValue mapValue, Record record) {\n         //first item\n-        mapValue.putDouble(this.valueIndex, this.latDegree.getDouble(record));\n-        mapValue.putDouble(this.valueIndex + 1, this.lonDegree.getDouble(record));\n-        mapValue.putTimestamp(this.valueIndex + 2, this.timestamp.getTimestamp(record));\n+        saveFirstItem(mapValue, this.latDegree.getDouble(record), this.lonDegree.getDouble(record), this.timestamp.getTimestamp(record));\n         //last item\n-        mapValue.putDouble(this.valueIndex + 3, this.latDegree.getDouble(record));\n-        mapValue.putDouble(this.valueIndex + 4, this.lonDegree.getDouble(record));\n-        mapValue.putTimestamp(this.valueIndex + 5, this.timestamp.getTimestamp(record));\n+        saveLastItem(mapValue, this.latDegree.getDouble(record), this.lonDegree.getDouble(record), this.timestamp.getTimestamp(record));\n         //result\n-        mapValue.putDouble(this.valueIndex + 6, 0);\n+        saveDistance(mapValue, 0);\n     }\n \n     @Override\n     public void computeNext(MapValue mapValue, Record record) {\n-        double lat1Degrees = mapValue.getDouble(valueIndex + 3);\n-        double lon1Degrees = mapValue.getDouble(valueIndex + 4);\n+        double lat1Degrees = getLastLatitute(mapValue);\n+        double lon1Degrees = getLastLongitude(mapValue);\n+        long timestamp1 = getLastTimestamp(mapValue);\n         double lat2Degrees = this.latDegree.getDouble(record);\n         double lon2Degrees = this.lonDegree.getDouble(record);\n-        long timestamp = this.timestamp.getTimestamp(record);\n-        if (!Double.isNaN(lat1Degrees) && !Double.isNaN(lon1Degrees)) {\n-            if (!Double.isNaN(lat2Degrees) && !Double.isNaN(lon2Degrees)) {\n-                double currentTotalDistance = mapValue.getDouble(this.valueIndex + 6);\n-                double distance = getHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, currentTotalDistance);\n-                mapValue.putDouble(this.valueIndex + 3, lat2Degrees);\n-                mapValue.putDouble(this.valueIndex + 4, lon2Degrees);\n-                mapValue.putTimestamp(this.valueIndex + 5, timestamp);\n-                mapValue.putDouble(this.valueIndex + 6, distance);\n+        long timestamp2 = this.timestamp.getTimestamp(record);\n+        if (!Double.isNaN(lat1Degrees) && !Double.isNaN(lon1Degrees) && timestamp1 != Numbers.LONG_NaN) {\n+            if (!Double.isNaN(lat2Degrees) && !Double.isNaN(lon2Degrees) && timestamp2 != Numbers.LONG_NaN) {\n+                double currentTotalDistance = getDistance(mapValue);\n+                double distance = calculateHaversineDistanceFromDegrees(lat1Degrees, lon1Degrees, lat2Degrees, lon2Degrees, currentTotalDistance);\n+                saveLastItem(mapValue, lat2Degrees, lon2Degrees, timestamp2);\n+                saveDistance(mapValue, distance);\n             }\n         } else {\n-            mapValue.putDouble(this.valueIndex + 3, lat2Degrees);\n-            mapValue.putDouble(this.valueIndex + 4, lon2Degrees);\n-            mapValue.putTimestamp(this.valueIndex + 5, timestamp);\n+            saveLastItem(mapValue, lat2Degrees, lon2Degrees, timestamp2);\n         }\n     }\n \n-    @Override\n-    public boolean isScalar() {\n-        return false;\n-    }\n-\n     @Override\n     public void pushValueTypes(ArrayColumnTypes columnTypes) {\n         this.valueIndex = columnTypes.getColumnCount();\n+        //first item\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.LONG);\n+        //last item\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.DOUBLE);\n         columnTypes.add(ColumnType.LONG);\n         //result\n         columnTypes.add(ColumnType.DOUBLE);\n     }\n \n-    @Override\n-    public Function getLeft() {\n-        return this.latDegree;\n-    }\n-\n     @Override\n     public void setDouble(MapValue mapValue, double value) {\n-        mapValue.putDouble(this.valueIndex + 6, value);\n+        saveDistance(mapValue, value);", "originalCommit": "7d64418ffa5999c215f48b978fd395dec30d70f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4ODU2OQ==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492088569", "bodyText": "we should come up with nomenclature for these functions and use it consistently", "author": "bluestreak01", "createdAt": "2020-09-21T14:23:05Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -363,6 +383,7 @@ public RecordCursor getCursor(SqlExecutionContext executionContext) {\n                                                     // group-by function\n                                                     // use current 'value' for record\n                                                     computeYPoints(mapRecord, x1, x2value);\n+                                                    interpolateDistanceRange(x1, x2, loSample, x1, mapRecord);", "originalCommit": "7d64418ffa5999c215f48b978fd395dec30d70f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4OTg0Ng==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492089846", "bodyText": "This is excessive hash map scan. In some cases map values are already known, we shouldn't be looking up things that we don't have to", "author": "bluestreak01", "createdAt": "2020-09-21T14:24:51Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -500,24 +522,24 @@ protected RecordCursor initFunctionsAndCursor(\n \n     private void interpolateBoundaryRange(long x1, long x2, Record record) {\n         //interpolating boundary\n-        for (int i = 0, m = groupByDistanceFunctions.size(); i < m; i++) {\n-            GroupByFunction function = groupByDistanceFunctions.getQuick(i);\n-            MapValue value1 = findDataMapValue2(record, x1);\n-            MapValue value2 = findDataMapValue3(record, x2);\n-            interpolatorBoundaryDistanceFunctions.getQuick(i).interpolateBoundaryAndStore(function, sampler.nextTimestamp(x1), value1, value2, true);\n-            interpolatorBoundaryDistanceFunctions.getQuick(i).interpolateBoundaryAndStore(function, x2, value1, value2, false);\n+        for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n+            GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n+            MapValue startValue = findDataMapValue2(record, x1);\n+            MapValue endValue = findDataMapValue3(record, x2);\n+            interpolatorBoundaryTwoPointFunctions.getQuick(i).interpolateBoundaryAndStore(function, sampler.nextTimestamp(x1), startValue, endValue, true);\n+            interpolatorBoundaryTwoPointFunctions.getQuick(i).interpolateBoundaryAndStore(function, x2, startValue, endValue, false);\n         }\n     }\n \n     private void interpolateDistanceRange(long x1, long x2, long lo, long hi, Record record) {\n         for (long x = lo; x < hi; x = sampler.nextTimestamp(x)) {\n-            final MapValue xValue = findDataMapValue(record, x);\n-            assert xValue != null && xValue.getByte(0) == 1;\n-            for (int i = 0, m = groupByDistanceFunctions.size(); i < m; i++) {\n-                GroupByFunction function = groupByDistanceFunctions.getQuick(i);\n-                MapValue value1 = findDataMapValue2(record, x1);\n-                MapValue value2 = findDataMapValue3(record, x2);\n-                interpolatorGapDistanceFunctions.getQuick(i).interpolateGapAndStore(function, xValue, sampler.getBucketSize(), value1, value2);\n+            final MapValue result = findDataMapValue(record, x);\n+            assert result != null && result.getByte(0) == 1;\n+            for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n+                GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n+                MapValue startValue = findDataMapValue2(record, x1);", "originalCommit": "7d64418ffa5999c215f48b978fd395dec30d70f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEyNTAyOQ==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r492125029", "bodyText": "done", "author": "jaugsburger", "createdAt": "2020-09-21T15:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA4OTg0Ng=="}], "type": "inlineReview"}, {"oid": "c41bc2194e6712305e59bf23221ff9cf78ac4381", "url": "https://github.com/questdb/questdb/commit/c41bc2194e6712305e59bf23221ff9cf78ac4381", "message": "feat(griffin): haversine distance function - more PR comments", "committedDate": "2020-09-21T15:07:20Z", "type": "commit"}, {"oid": "b584f10a9a44dafd41330c44c6bbc3762d8cf93b", "url": "https://github.com/questdb/questdb/commit/b584f10a9a44dafd41330c44c6bbc3762d8cf93b", "message": "feat(griffin): haversine distance function - removing extra map lookup", "committedDate": "2020-09-21T18:12:06Z", "type": "commit"}, {"oid": "c2d756095648cf838d1163f8577ae3e34df9ff1e", "url": "https://github.com/questdb/questdb/commit/c2d756095648cf838d1163f8577ae3e34df9ff1e", "message": "feat(griffin): haversine distance function - removing extra method call", "committedDate": "2020-09-21T18:40:02Z", "type": "commit"}, {"oid": "915f76335d256a07f774006258fd2f3de37e3101", "url": "https://github.com/questdb/questdb/commit/915f76335d256a07f774006258fd2f3de37e3101", "message": "feat(griffin): haversine distance function - tidy up of interpolation method calls and new list of scalar functions", "committedDate": "2020-09-22T12:48:12Z", "type": "commit"}, {"oid": "e1b44cbec15a9c16d5fc05f9ab63966766d7af82", "url": "https://github.com/questdb/questdb/commit/e1b44cbec15a9c16d5fc05f9ab63966766d7af82", "message": "feat(griffin): haversine distance function - fixing tests", "committedDate": "2020-09-22T18:09:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMTMxMg==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r493531312", "bodyText": "The \"two point\" function interpolation API is the same for every result type.\nWhat is the point of having collections of function references here?", "author": "bluestreak01", "createdAt": "2020-09-23T12:30:07Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -142,13 +164,47 @@ public SampleByInterpolateRecordCursorFactory(\n                     interpolatorFunctions.add(InterpolationUtil.INTERPOLATE_FLOAT);\n                     break;\n                 default:\n-                    Misc.freeObjList(groupByFunctions);\n+                    Misc.freeObjList(groupByScalarFunctions);\n+                    throw SqlException.$(function.getPosition(), \"Unsupported type: \").put(ColumnType.nameOf(function.getType()));\n+            }\n+        }\n+\n+        this.groupByTwoPointFunctionCount = groupByTwoPointFunctions.size();\n+        for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n+            GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n+            switch (function.getType()) {\n+                case ColumnType.BYTE:\n+                    interpolatorGapTwoPointFunctions.add(InterpolationUtil.INTERPOLATE_GAP_BYTE);", "originalCommit": "e1b44cbec15a9c16d5fc05f9ab63966766d7af82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwOTUxNA==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r493609514", "bodyText": "fixed", "author": "jaugsburger", "createdAt": "2020-09-23T13:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzUzMTMxMg=="}], "type": "inlineReview"}, {"oid": "9fdf2441358836bd1405dddb8af31cc9ebcfe2a7", "url": "https://github.com/questdb/questdb/commit/9fdf2441358836bd1405dddb8af31cc9ebcfe2a7", "message": "feat(griffin): haversine distance function - removing superfluous collection of interpolation functions", "committedDate": "2020-09-23T13:50:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxOTcwNg==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r493619706", "bodyText": "inline", "author": "bluestreak01", "createdAt": "2020-09-23T14:04:06Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -525,25 +490,14 @@ protected RecordCursor initFunctionsAndCursor(\n         return cursor;\n     }\n \n-    private void interpolateBoundaryRange(long x1, long x2, Record record) {\n-        //interpolating boundary\n-        for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n-            GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n-            MapValue startValue = findDataMapValue2(record, x1);\n-            MapValue endValue = findDataMapValue3(record, x2);\n-            interpolatorBoundaryTwoPointFunctions.getQuick(i).interpolateBoundaryAndStore(function, sampler.nextTimestamp(x1), startValue, endValue, true);\n-            interpolatorBoundaryTwoPointFunctions.getQuick(i).interpolateBoundaryAndStore(function, x2, startValue, endValue, false);\n-        }\n-    }\n-\n     private void interpolate(long lo, long hi, Record mapRecord, long x1, long x2, MapValue x1Value, MapValue x2value) {\n         computeYPoints(x1Value, x2value);\n         for (long x = lo; x < hi; x = sampler.nextTimestamp(x)) {\n             final MapValue result = findDataMapValue3(mapRecord, x);\n             assert result != null && result.getByte(0) == 1;\n             for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n                 GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n-                interpolatorGapTwoPointFunctions.getQuick(i).interpolateGapAndStore(function, result, sampler.getBucketSize(), x1Value, x2value);\n+                InterpolationUtil.INTERPOLATE_GAP.interpolateGapAndStore(function, result, sampler.getBucketSize(), x1Value, x2value);", "originalCommit": "9fdf2441358836bd1405dddb8af31cc9ebcfe2a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYxOTc4Mw==", "url": "https://github.com/questdb/questdb/pull/597#discussion_r493619783", "bodyText": "inline", "author": "bluestreak01", "createdAt": "2020-09-23T14:04:12Z", "path": "core/src/main/java/io/questdb/griffin/engine/groupby/SampleByInterpolateRecordCursorFactory.java", "diffHunk": "@@ -553,6 +507,17 @@ private void interpolate(long lo, long hi, Record mapRecord, long x1, long x2, M\n         }\n     }\n \n+    private void interpolateBoundaryRange(long x1, long x2, Record record) {\n+        //interpolating boundary\n+        for (int i = 0; i < groupByTwoPointFunctionCount; i++) {\n+            GroupByFunction function = groupByTwoPointFunctions.getQuick(i);\n+            MapValue startValue = findDataMapValue2(record, x1);\n+            MapValue endValue = findDataMapValue3(record, x2);\n+            InterpolationUtil.INTERPOLATE_BOUNDARY.interpolateBoundaryAndStore(function, sampler.nextTimestamp(x1), startValue, endValue, true);", "originalCommit": "9fdf2441358836bd1405dddb8af31cc9ebcfe2a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9691cd50f3a99fa006fcaec2c9f1409e55368bad", "url": "https://github.com/questdb/questdb/commit/9691cd50f3a99fa006fcaec2c9f1409e55368bad", "message": "feat(griffin): haversine distance function - inlined lambdas", "committedDate": "2020-09-23T14:12:47Z", "type": "commit"}, {"oid": "484cf354dc2930a6a20bb7d966eceffa23e0e7a8", "url": "https://github.com/questdb/questdb/commit/484cf354dc2930a6a20bb7d966eceffa23e0e7a8", "message": "feat(griffin): haversine distance function - removed unused interfaces", "committedDate": "2020-09-23T14:14:26Z", "type": "commit"}]}