{"pr_number": 9480, "pr_title": "Support to export/import multiple custom mediation policies attached to an API through APICTL", "pr_createdAt": "2020-12-08T12:18:45Z", "pr_url": "https://github.com/wso2/carbon-apimgt/pull/9480", "timeline": [{"oid": "e12444e15afdf7c6ee12cedf020291f2929b7fac", "url": "https://github.com/wso2/carbon-apimgt/commit/e12444e15afdf7c6ee12cedf020291f2929b7fac", "message": "Support importing/exporting multiple medations attached to an API", "committedDate": "2020-12-09T19:04:34Z", "type": "commit"}, {"oid": "63d3b62755d69f37a943c332f9a775162b698377", "url": "https://github.com/wso2/carbon-apimgt/commit/63d3b62755d69f37a943c332f9a775162b698377", "message": "Remove unnecessary code related to import/export mediations", "committedDate": "2020-12-09T19:04:34Z", "type": "commit"}, {"oid": "c3a09c77113115bb688a0326421039071f6ae9c2", "url": "https://github.com/wso2/carbon-apimgt/commit/c3a09c77113115bb688a0326421039071f6ae9c2", "message": "Modify constants related to in/out/fault sequences", "committedDate": "2020-12-09T19:04:34Z", "type": "commit"}, {"oid": "7eef4e01259aec730c42c9746179e984e6a05492", "url": "https://github.com/wso2/carbon-apimgt/commit/7eef4e01259aec730c42c9746179e984e6a05492", "message": "Fix certificate import error when a full certificate is passed", "committedDate": "2020-12-09T19:04:34Z", "type": "commit"}, {"oid": "1da860639b4edf0d79a9435dff46c3d949c10e9c", "url": "https://github.com/wso2/carbon-apimgt/commit/1da860639b4edf0d79a9435dff46c3d949c10e9c", "message": "Format addAPISpecificSequences function", "committedDate": "2020-12-09T19:04:34Z", "type": "commit"}, {"oid": "1da860639b4edf0d79a9435dff46c3d949c10e9c", "url": "https://github.com/wso2/carbon-apimgt/commit/1da860639b4edf0d79a9435dff46c3d949c10e9c", "message": "Format addAPISpecificSequences function", "committedDate": "2020-12-09T19:04:34Z", "type": "forcePushed"}, {"oid": "1b4914061864d871ff52059c3105b76bbf910b2a", "url": "https://github.com/wso2/carbon-apimgt/commit/1b4914061864d871ff52059c3105b76bbf910b2a", "message": "Fix the error when update import an API if operations are empty", "committedDate": "2020-12-10T14:23:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MjIwNA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540752204", "bodyText": "IOException has been Swallowed", "author": "uvindra", "createdAt": "2020-12-11T07:49:47Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ExportUtils.java", "diffHunk": "@@ -506,150 +502,91 @@ public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentif\n      * @param apiIdentifier API Identifier\n      * @param apiDto        API DTO\n      * @param registry      Current tenant registry\n+     * @param apiProvider   API Provider\n      * @throws APIImportExportException If an error occurs while exporting sequences\n      */\n     public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n-            Registry registry) throws APIImportExportException {\n+            Registry registry, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException, RegistryException {\n \n         String seqArchivePath = archivePath.concat(File.separator + ImportExportConstants.SEQUENCES_RESOURCE);\n         List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n-        if (!apiDto.getMediationPolicies().isEmpty()) {\n+\n+        if (!mediationPolicyDtos.isEmpty()) {\n             CommonUtil.createDirectory(seqArchivePath);\n             for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n-                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n-                String sequenceName = mediationPolicyDto.getName();\n-                String direction = mediationPolicyDto.getType().toLowerCase();\n-                String pathToExportedSequence =\n-                        seqArchivePath + File.separator + direction + \"-sequence\" + File.separator;\n-                if (sequenceName != null) {\n-                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n-                    if (sequenceDetails == null) {\n-                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n-                        // specific registry path\n-                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n-                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                if (mediationPolicyDto.isShared()) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediationPolicyDto.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n-                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    //Get registry resource correspond to identifier\n+                    Resource mediationResource = apiProvider\n+                            .getCustomMediationResourceFromUuid(mediationPolicyDto.getId());\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediationPolicyDto.getName(), apiIdentifier);\n                 }\n             }\n-        } else if (log.isDebugEnabled()) {\n-            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n-                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n-                    + \". Skipping custom sequence export.\");\n-        }\n-    }\n-\n-    /**\n-     * Retrieve custom sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n-            Registry registry) throws APIImportExportException {\n-\n-        String regPath = null;\n-        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n-        }\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n \n-    /**\n-     * Retrieve API Specific sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n-            String sequenceName, String type, Registry registry) throws APIImportExportException {\n-\n-        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n-                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR + api\n-                .getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n-\n-    /**\n-     * Retrieve sequence details from registry by given registry path.\n-     *\n-     * @param sequenceName Sequence Name\n-     * @param regPath      Registry path\n-     * @param registry     Registry\n-     * @return Sequence details as a simple entry\n-     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n-            String regPath, Registry registry) throws APIImportExportException {\n-\n-        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n-        Collection seqCollection;\n-\n-        try {\n-            seqCollection = (Collection) registry.get(regPath);\n-            if (seqCollection != null) {\n-                String[] childPaths = seqCollection.getChildren();\n-                for (String childPath : childPaths) {\n-                    Resource sequence = registry.get(childPath);\n-                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n-                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n-                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n-                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n-                        break;\n+            // Getting list of API specific custom mediation policies\n+            List<Mediation> apiSpecificMediationList = apiProvider.getAllApiSpecificMediationPolicies(apiIdentifier);\n+            if (!apiSpecificMediationList.isEmpty()) {\n+                for (Mediation mediation : apiSpecificMediationList) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediation.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX + File.separator\n+                                    + ImportExportConstants.CUSTOM_TYPE;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n+                    // Get registry resource correspond to identifier\n+                    String apiResourcePath = APIUtil.getAPIPath(apiIdentifier);\n+                    apiResourcePath = apiResourcePath.substring(0, apiResourcePath.lastIndexOf(\"/\"));\n+                    Resource mediationResource = apiProvider\n+                            .getApiSpecificMediationResourceFromUuid(apiIdentifier, mediation.getUuid(),\n+                                    apiResourcePath);\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediation.getName(), apiIdentifier);\n                 }\n             }\n-        } catch (RegistryException e) {\n-            throw new APIImportExportException(\n-                    \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath, e);\n-        } catch (Exception e) {\n-            // APIUtil.buildOMElement() throws a generic exception\n-            throw new APIImportExportException(\n-                    \"Error while reading content for sequence: \" + sequenceName + \" from the registry\", e);\n         }\n-        return sequenceDetails;\n     }\n \n     /**\n-     * Store API Specific or custom sequences in the archive directory.\n+     * Write the sequence to API archive.\n      *\n-     * @param sequenceDetails Details of the sequence\n-     * @param apiIdentifier   ID of the requesting API\n-     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n-     *                                  archive directory\n+     * @param mediationResource Mediation resource\n+     * @param individualSequenceExportPath         Path to export the mediation sequence\n+     * @param registry     Current tenant registry\n+     * @param mediationName     Name of the mediation policy\n+     * @param apiIdentifier     API Identifier\n+     * @throws RegistryException If an error occurs while retrieving registry elements\n+     * @throws APIManagementException If an error occurs while writing the mediation policy to file\n      */\n-    private static void writeSequenceToFile(String pathToExportedSequence,\n-            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails, APIIdentifier apiIdentifier)\n-            throws APIImportExportException {\n-\n-        if (sequenceDetails != null) {\n-            String sequenceFileName = sequenceDetails.getKey();\n-            OMElement sequenceConfig = sequenceDetails.getValue();\n-            CommonUtil.createDirectory(pathToExportedSequence);\n-            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n-            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n-                sequenceConfig.serialize(outputStream);\n-                if (log.isDebugEnabled()) {\n-                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+    private static void writeSequenceToArchive(Resource mediationResource, String individualSequenceExportPath,\n+            Registry registry, String mediationName, APIIdentifier apiIdentifier)\n+            throws RegistryException, APIManagementException {\n+        if (mediationResource != null) {\n+            // Get the registry resource path\n+            String resourcePath = mediationResource.getPath();\n+            // Check whether resource exists in the registry\n+            if (registry.resourceExists(resourcePath)) {\n+                Resource mediationFile = registry.get(resourcePath);\n+                try (OutputStream outputStream = new FileOutputStream(\n+                        individualSequenceExportPath + File.separator + mediationName + APIConstants.DOT\n+                                + APIConstants.XML_DOC_EXTENSION);\n+                        InputStream fileInputStream = mediationFile.getContentStream()) {\n+                    IOUtils.copy(fileInputStream, outputStream);\n+                } catch (IOException e) {\n+                    throw new APIManagementException(\"Error while writing the mediation sequence\"+ mediationName+ \"to file\");", "originalCommit": "1b4914061864d871ff52059c3105b76bbf910b2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDg0MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540864841", "bodyText": "Fixed via d1a9950", "author": "wasuradananjith", "createdAt": "2020-12-11T10:59:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MjIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1Mjg4OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540752889", "bodyText": "Should this be logged as an error since this is a valid scenario?", "author": "uvindra", "createdAt": "2020-12-11T07:51:08Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ExportUtils.java", "diffHunk": "@@ -506,150 +502,91 @@ public static void addWSDLtoArchive(String archivePath, APIIdentifier apiIdentif\n      * @param apiIdentifier API Identifier\n      * @param apiDto        API DTO\n      * @param registry      Current tenant registry\n+     * @param apiProvider   API Provider\n      * @throws APIImportExportException If an error occurs while exporting sequences\n      */\n     public static void addSequencesToArchive(String archivePath, APIIdentifier apiIdentifier, APIDTO apiDto,\n-            Registry registry) throws APIImportExportException {\n+            Registry registry, APIProvider apiProvider)\n+            throws APIImportExportException, APIManagementException, RegistryException {\n \n         String seqArchivePath = archivePath.concat(File.separator + ImportExportConstants.SEQUENCES_RESOURCE);\n         List<MediationPolicyDTO> mediationPolicyDtos = apiDto.getMediationPolicies();\n-        if (!apiDto.getMediationPolicies().isEmpty()) {\n+\n+        if (!mediationPolicyDtos.isEmpty()) {\n             CommonUtil.createDirectory(seqArchivePath);\n             for (MediationPolicyDTO mediationPolicyDto : mediationPolicyDtos) {\n-                AbstractMap.SimpleEntry<String, OMElement> sequenceDetails;\n-                String sequenceName = mediationPolicyDto.getName();\n-                String direction = mediationPolicyDto.getType().toLowerCase();\n-                String pathToExportedSequence =\n-                        seqArchivePath + File.separator + direction + \"-sequence\" + File.separator;\n-                if (sequenceName != null) {\n-                    sequenceDetails = getCustomSequence(sequenceName, direction, registry);\n-                    if (sequenceDetails == null) {\n-                        // If sequence doesn't exist in 'apimgt/customsequences/{in/out/fault}' directory check in API\n-                        // specific registry path\n-                        sequenceDetails = getAPISpecificSequence(apiIdentifier, sequenceName, direction, registry);\n-                        pathToExportedSequence += ImportExportConstants.CUSTOM_TYPE + File.separator;\n+                if (mediationPolicyDto.isShared()) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediationPolicyDto.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n-                    writeSequenceToFile(pathToExportedSequence, sequenceDetails, apiIdentifier);\n+                    //Get registry resource correspond to identifier\n+                    Resource mediationResource = apiProvider\n+                            .getCustomMediationResourceFromUuid(mediationPolicyDto.getId());\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediationPolicyDto.getName(), apiIdentifier);\n                 }\n             }\n-        } else if (log.isDebugEnabled()) {\n-            log.debug(\"No custom sequences available for API: \" + apiIdentifier.getApiName() + StringUtils.SPACE\n-                    + APIConstants.API_DATA_VERSION + \": \" + apiIdentifier.getVersion()\n-                    + \". Skipping custom sequence export.\");\n-        }\n-    }\n-\n-    /**\n-     * Retrieve custom sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getCustomSequence(String sequenceName, String type,\n-            Registry registry) throws APIImportExportException {\n-\n-        String regPath = null;\n-        if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_IN.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_INSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_OUT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_OUTSEQUENCE_LOCATION;\n-        } else if (APIConstants.API_CUSTOM_SEQUENCE_TYPE_FAULT.equals(type)) {\n-            regPath = APIConstants.API_CUSTOM_FAULTSEQUENCE_LOCATION;\n-        }\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n \n-    /**\n-     * Retrieve API Specific sequence details from the registry.\n-     *\n-     * @param sequenceName Name of the sequence\n-     * @param type         Sequence type\n-     * @param registry     Current tenant registry\n-     * @return Registry resource name of the sequence and its content\n-     * @throws APIImportExportException If an error occurs while retrieving registry elements\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getAPISpecificSequence(APIIdentifier api,\n-            String sequenceName, String type, Registry registry) throws APIImportExportException {\n-\n-        String regPath = APIConstants.API_ROOT_LOCATION + RegistryConstants.PATH_SEPARATOR + api.getProviderName()\n-                + RegistryConstants.PATH_SEPARATOR + api.getApiName() + RegistryConstants.PATH_SEPARATOR + api\n-                .getVersion() + RegistryConstants.PATH_SEPARATOR + type;\n-        return getSeqDetailsFromRegistry(sequenceName, regPath, registry);\n-    }\n-\n-    /**\n-     * Retrieve sequence details from registry by given registry path.\n-     *\n-     * @param sequenceName Sequence Name\n-     * @param regPath      Registry path\n-     * @param registry     Registry\n-     * @return Sequence details as a simple entry\n-     * @throws APIImportExportException If an error occurs while retrieving sequence details from registry\n-     */\n-    private static AbstractMap.SimpleEntry<String, OMElement> getSeqDetailsFromRegistry(String sequenceName,\n-            String regPath, Registry registry) throws APIImportExportException {\n-\n-        AbstractMap.SimpleEntry<String, OMElement> sequenceDetails = null;\n-        Collection seqCollection;\n-\n-        try {\n-            seqCollection = (Collection) registry.get(regPath);\n-            if (seqCollection != null) {\n-                String[] childPaths = seqCollection.getChildren();\n-                for (String childPath : childPaths) {\n-                    Resource sequence = registry.get(childPath);\n-                    OMElement seqElement = APIUtil.buildOMElement(sequence.getContentStream());\n-                    if (sequenceName.equals(seqElement.getAttributeValue(new QName(\"name\")))) {\n-                        String sequenceFileName = sequenceName + APIConstants.XML_EXTENSION;\n-                        sequenceDetails = new AbstractMap.SimpleEntry<>(sequenceFileName, seqElement);\n-                        break;\n+            // Getting list of API specific custom mediation policies\n+            List<Mediation> apiSpecificMediationList = apiProvider.getAllApiSpecificMediationPolicies(apiIdentifier);\n+            if (!apiSpecificMediationList.isEmpty()) {\n+                for (Mediation mediation : apiSpecificMediationList) {\n+                    String individualSequenceExportPath =\n+                            seqArchivePath + File.separator + mediation.getType().toLowerCase()\n+                                    + ImportExportConstants.SEQUENCE_LOCATION_POSTFIX + File.separator\n+                                    + ImportExportConstants.CUSTOM_TYPE;\n+                    if (!CommonUtil.checkFileExistence(individualSequenceExportPath)) {\n+                        CommonUtil.createDirectory(individualSequenceExportPath);\n                     }\n+                    // Get registry resource correspond to identifier\n+                    String apiResourcePath = APIUtil.getAPIPath(apiIdentifier);\n+                    apiResourcePath = apiResourcePath.substring(0, apiResourcePath.lastIndexOf(\"/\"));\n+                    Resource mediationResource = apiProvider\n+                            .getApiSpecificMediationResourceFromUuid(apiIdentifier, mediation.getUuid(),\n+                                    apiResourcePath);\n+                    writeSequenceToArchive(mediationResource, individualSequenceExportPath, registry,\n+                            mediation.getName(), apiIdentifier);\n                 }\n             }\n-        } catch (RegistryException e) {\n-            throw new APIImportExportException(\n-                    \"Error while retrieving sequence: \" + sequenceName + \" from the path: \" + regPath, e);\n-        } catch (Exception e) {\n-            // APIUtil.buildOMElement() throws a generic exception\n-            throw new APIImportExportException(\n-                    \"Error while reading content for sequence: \" + sequenceName + \" from the registry\", e);\n         }\n-        return sequenceDetails;\n     }\n \n     /**\n-     * Store API Specific or custom sequences in the archive directory.\n+     * Write the sequence to API archive.\n      *\n-     * @param sequenceDetails Details of the sequence\n-     * @param apiIdentifier   ID of the requesting API\n-     * @throws APIImportExportException If an error occurs while serializing XML stream or storing in\n-     *                                  archive directory\n+     * @param mediationResource Mediation resource\n+     * @param individualSequenceExportPath         Path to export the mediation sequence\n+     * @param registry     Current tenant registry\n+     * @param mediationName     Name of the mediation policy\n+     * @param apiIdentifier     API Identifier\n+     * @throws RegistryException If an error occurs while retrieving registry elements\n+     * @throws APIManagementException If an error occurs while writing the mediation policy to file\n      */\n-    private static void writeSequenceToFile(String pathToExportedSequence,\n-            AbstractMap.SimpleEntry<String, OMElement> sequenceDetails, APIIdentifier apiIdentifier)\n-            throws APIImportExportException {\n-\n-        if (sequenceDetails != null) {\n-            String sequenceFileName = sequenceDetails.getKey();\n-            OMElement sequenceConfig = sequenceDetails.getValue();\n-            CommonUtil.createDirectory(pathToExportedSequence);\n-            String exportedSequenceFile = pathToExportedSequence + sequenceFileName;\n-            try (OutputStream outputStream = new FileOutputStream(exportedSequenceFile)) {\n-                sequenceConfig.serialize(outputStream);\n-                if (log.isDebugEnabled()) {\n-                    log.debug(sequenceFileName + \" of API: \" + apiIdentifier.getApiName() + \" retrieved successfully\");\n+    private static void writeSequenceToArchive(Resource mediationResource, String individualSequenceExportPath,\n+            Registry registry, String mediationName, APIIdentifier apiIdentifier)\n+            throws RegistryException, APIManagementException {\n+        if (mediationResource != null) {\n+            // Get the registry resource path\n+            String resourcePath = mediationResource.getPath();\n+            // Check whether resource exists in the registry\n+            if (registry.resourceExists(resourcePath)) {\n+                Resource mediationFile = registry.get(resourcePath);\n+                try (OutputStream outputStream = new FileOutputStream(\n+                        individualSequenceExportPath + File.separator + mediationName + APIConstants.DOT\n+                                + APIConstants.XML_DOC_EXTENSION);\n+                        InputStream fileInputStream = mediationFile.getContentStream()) {\n+                    IOUtils.copy(fileInputStream, outputStream);\n+                } catch (IOException e) {\n+                    throw new APIManagementException(\"Error while writing the mediation sequence\"+ mediationName+ \"to file\");\n                 }\n-            } catch (IOException e) {\n-                throw new APIImportExportException(\"Unable to find file: \" + exportedSequenceFile, e);\n-            } catch (XMLStreamException e) {\n-                throw new APIImportExportException(\"Error while processing XML stream \", e);\n+            } else {\n+                // Log error and avoid throwing as we give capability to export an API without sequences\n+                log.error(\"Sequence resource for API/API Product: \" + apiIdentifier.getName() + \" not found in \"", "originalCommit": "1b4914061864d871ff52059c3105b76bbf910b2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDcwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540864708", "bodyText": "Fixed via d1a9950", "author": "wasuradananjith", "createdAt": "2020-12-11T10:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1Mjg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MzMzOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540753338", "bodyText": "Code formatting issue in '='", "author": "uvindra", "createdAt": "2020-12-11T07:52:01Z", "path": "components/apimgt/org.wso2.carbon.apimgt.rest.api.publisher.v1.common/src/main/java/org/wso2/carbon/apimgt/rest/api/publisher/v1/common/mappings/ImportUtils.java", "diffHunk": "@@ -277,6 +285,21 @@ public static API importApi(String extractedFolderPath, APIDTO importedApiDTO, B\n         }\n     }\n \n+    /**\n+     * This method sets the operations which were retrieved from the swagger definition to the API DTO.\n+     *\n+     * @param apiDto             API DTO\n+     * @param response          API Validation Response\n+     * @throws APIManagementException If an error occurs when retrieving the URI templates\n+     */\n+    private static void setOperationsToDTO(APIDTO apiDto, APIDefinitionValidationResponse response)\n+            throws APIManagementException {\n+        List<URITemplate> uriTemplates = new ArrayList<>();\n+        uriTemplates.addAll(response.getParser().getURITemplates(response.getJsonContent()));\n+        List<APIOperationsDTO> apiOperationsDtos =APIMappingUtil.fromURITemplateListToOprationList(uriTemplates);", "originalCommit": "1b4914061864d871ff52059c3105b76bbf910b2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg2NDU3MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/9480#discussion_r540864570", "bodyText": "Fixed via 5348d62", "author": "wasuradananjith", "createdAt": "2020-12-11T10:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1MzMzOA=="}], "type": "inlineReview"}, {"oid": "5348d62a58ef3f675074a88af5b2e2bf607660db", "url": "https://github.com/wso2/carbon-apimgt/commit/5348d62a58ef3f675074a88af5b2e2bf607660db", "message": "Format setOperationsToDTO function", "committedDate": "2020-12-11T10:47:16Z", "type": "commit"}, {"oid": "d1a9950578cb6e9db87036e285e0448a53bebb42", "url": "https://github.com/wso2/carbon-apimgt/commit/d1a9950578cb6e9db87036e285e0448a53bebb42", "message": "Modify exceptions for mediation export errors", "committedDate": "2020-12-11T10:55:56Z", "type": "commit"}]}