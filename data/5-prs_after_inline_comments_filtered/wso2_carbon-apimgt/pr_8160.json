{"pr_number": 8160, "pr_title": "Recommendation Feature additional changes", "pr_createdAt": "2020-02-07T09:58:06Z", "pr_url": "https://github.com/wso2/carbon-apimgt/pull/8160", "timeline": [{"oid": "459c130d62badf3a2019e44b8f9849f3e3e0fda3", "url": "https://github.com/wso2/carbon-apimgt/commit/459c130d62badf3a2019e44b8f9849f3e3e0fda3", "message": "New adapter to push events using oauth2", "committedDate": "2020-02-02T17:13:56Z", "type": "commit"}, {"oid": "315f14ca0d0d001c27c1f3f0cf05e9a2a78cd1da", "url": "https://github.com/wso2/carbon-apimgt/commit/315f14ca0d0d001c27c1f3f0cf05e9a2a78cd1da", "message": "Changes in recommendation feature", "committedDate": "2020-02-02T18:09:49Z", "type": "commit"}, {"oid": "2bc88abf05d5b070b8b32ca53d3c78e899d89a1a", "url": "https://github.com/wso2/carbon-apimgt/commit/2bc88abf05d5b070b8b32ca53d3c78e899d89a1a", "message": "Merge remote-tracking branch 'remotes/upstream/master'", "committedDate": "2020-02-02T18:11:04Z", "type": "commit"}, {"oid": "91375e79ae0576ab78770f7cba9394c0bf5f30b6", "url": "https://github.com/wso2/carbon-apimgt/commit/91375e79ae0576ab78770f7cba9394c0bf5f30b6", "message": "minor changes in recommendation feature", "committedDate": "2020-02-04T05:34:27Z", "type": "commit"}, {"oid": "58627bb45324f710077cb3edfc950ddb2b7e8693", "url": "https://github.com/wso2/carbon-apimgt/commit/58627bb45324f710077cb3edfc950ddb2b7e8693", "message": "removed accessTokenGenerator from output adapter and places inside impl package", "committedDate": "2020-02-05T16:19:52Z", "type": "commit"}, {"oid": "013839e42900234ee6a655db46cd2278a7bac651", "url": "https://github.com/wso2/carbon-apimgt/commit/013839e42900234ee6a655db46cd2278a7bac651", "message": "Added license and fixed minor issues", "committedDate": "2020-02-05T16:20:54Z", "type": "commit"}, {"oid": "0c4da27c86f25898b42fcacb988565915eb82ec6", "url": "https://github.com/wso2/carbon-apimgt/commit/0c4da27c86f25898b42fcacb988565915eb82ec6", "message": "Added new properties related to oauth", "committedDate": "2020-02-05T16:21:47Z", "type": "commit"}, {"oid": "9bc58aee449828cf7c2e3f78e95d8fb9fd9cd945", "url": "https://github.com/wso2/carbon-apimgt/commit/9bc58aee449828cf7c2e3f78e95d8fb9fd9cd945", "message": "Added basic oauth support for recommendation server", "committedDate": "2020-02-05T16:34:27Z", "type": "commit"}, {"oid": "41dd4e604269328a8a0f606e784fc04f6b0ec42b", "url": "https://github.com/wso2/carbon-apimgt/commit/41dd4e604269328a8a0f606e784fc04f6b0ec42b", "message": "minor bug fixes", "committedDate": "2020-02-05T16:35:06Z", "type": "commit"}, {"oid": "22608a858b568d23d7af5a533a4bab34f7ddbec3", "url": "https://github.com/wso2/carbon-apimgt/commit/22608a858b568d23d7af5a533a4bab34f7ddbec3", "message": "Added support to enable feature with a tenat configuration", "committedDate": "2020-02-07T06:26:09Z", "type": "commit"}, {"oid": "cefac0ab637c7778c2cae97474d409f26e6d6222", "url": "https://github.com/wso2/carbon-apimgt/commit/cefac0ab637c7778c2cae97474d409f26e6d6222", "message": "Updated the license text", "committedDate": "2020-02-07T07:18:18Z", "type": "commit"}, {"oid": "08a65835ccdda55b65f6c7c0c124f2ddff1754d2", "url": "https://github.com/wso2/carbon-apimgt/commit/08a65835ccdda55b65f6c7c0c124f2ddff1754d2", "message": "Added tests for Extended Http output event adapter", "committedDate": "2020-02-07T09:06:20Z", "type": "commit"}, {"oid": "60d6c22c5ec86ae47847be921b7c5792e068f831", "url": "https://github.com/wso2/carbon-apimgt/commit/60d6c22c5ec86ae47847be921b7c5792e068f831", "message": "Removed faulty exclusions", "committedDate": "2020-02-07T09:48:20Z", "type": "commit"}, {"oid": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "url": "https://github.com/wso2/carbon-apimgt/commit/723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "message": "Merge remote-tracking branch 'remotes/upstream/master'", "committedDate": "2020-02-07T09:49:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjQ1Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306457", "bodyText": "no wild card imports", "author": "harsha89", "createdAt": "2020-02-07T09:59:21Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapterFactory.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+import org.wso2.carbon.event.output.adapter.core.*;\n+\n+import java.util.*;", "originalCommit": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzA1Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953053", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-10T09:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjcyNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376306725", "bodyText": "Don't catch throwables", "author": "harsha89", "createdAt": "2020-02-07T09:59:56Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the output recommendation event adaptor service\");\n+            }\n+        } catch (Throwable e) {", "originalCommit": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzA4OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953089", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-10T09:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzM2Nw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376307367", "bodyText": "log with a message", "author": "harsha89", "createdAt": "2020-02-07T10:01:20Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,96 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                JSONObject apiTenantConfig = null;\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        JSONParser parser = new JSONParser();\n+                        apiTenantConfig = (JSONObject) parser.parse(content);\n+                    }\n+                    return getTenantConfigValue(tenantDomain, apiTenantConfig,\n+                            APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                } catch (UserStoreException e) {\n+                    log.error(\"UserStoreException thrown when getting API tenant config from registry\", e);\n+                } catch (RegistryException e) {\n+                    log.error(\"RegistryException thrown when getting API tenant config from registry\", e);\n+                } catch (ParseException e) {\n+                    log.error(\"ParseException thrown when passing API tenant config from registry\", e);\n+                } catch (APIManagementException e) {\n+                    log.debug(e.getMessage());", "originalCommit": "723f1a0c55cf9cf15f1a78cf432a514c5e41a6cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1MzE0Mw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376953143", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-10T09:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMwNzM2Nw=="}], "type": "inlineReview"}, {"oid": "3eed836f29a7bc284cdeee5b51ce21f5b0e0984b", "url": "https://github.com/wso2/carbon-apimgt/commit/3eed836f29a7bc284cdeee5b51ce21f5b0e0984b", "message": "Merge remote-tracking branch 'remotes/upstream/master'\n\n# Conflicts:\n#\tcomponents/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConstants.java", "committedDate": "2020-02-10T09:24:59Z", "type": "commit"}, {"oid": "5df1baeb6039d4fa1e7482bea6223cc40ec0a97c", "url": "https://github.com/wso2/carbon-apimgt/commit/5df1baeb6039d4fa1e7482bea6223cc40ec0a97c", "message": "Addressed the review comments and minor changes in component", "committedDate": "2020-02-10T09:29:00Z", "type": "commit"}, {"oid": "eb6d09a65f0bf56b5c18ad644f2144b1e1a8d794", "url": "https://github.com/wso2/carbon-apimgt/commit/eb6d09a65f0bf56b5c18ad644f2144b1e1a8d794", "message": "Added new log messages", "committedDate": "2020-02-10T09:29:44Z", "type": "commit"}, {"oid": "0d5014d906e05b1902b868fd19e6646a7bee0058", "url": "https://github.com/wso2/carbon-apimgt/commit/0d5014d906e05b1902b868fd19e6646a7bee0058", "message": "Added EnableRecommendation as a tenant config", "committedDate": "2020-02-10T09:30:10Z", "type": "commit"}, {"oid": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "url": "https://github.com/wso2/carbon-apimgt/commit/d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "message": "Added a new table to db scripts", "committedDate": "2020-02-10T09:30:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODI4Mg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958282", "bodyText": "seems 'e' is missing", "author": "ruks", "createdAt": "2020-02-10T09:50:54Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDYwOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894609", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T14:29:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODkwMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376958902", "bodyText": "We can use constants for MIME types", "author": "ruks", "createdAt": "2020-02-10T09:51:55Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDY2OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894669", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T14:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTQ3MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959470", "bodyText": "We can use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty() here.", "author": "ruks", "createdAt": "2020-02-10T09:52:53Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDU0MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864541", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTk4OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376959988", "bodyText": "please explain reason to catch the generic exception.", "author": "ruks", "createdAt": "2020-02-10T09:53:45Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDY4OA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864688", "bodyText": "Removed the exception", "author": "1akshitha", "createdAt": "2020-02-13T13:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk1OTk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzMwMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963303", "bodyText": "We can use isBlank() or isEmpty() frunction in https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/StringUtils.html", "author": "ruks", "createdAt": "2020-02-10T09:59:37Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NDgyNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378864825", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzYwOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376963608", "bodyText": "please use constants for security schemes.", "author": "ruks", "createdAt": "2020-02-10T10:00:12Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/ExtendedHTTPEventAdapter.java", "diffHunk": "@@ -0,0 +1,367 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth;\n+\n+import org.apache.axiom.om.util.Base64;\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.commons.httpclient.HostConfiguration;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpConnectionManager;\n+import org.apache.commons.httpclient.MultiThreadedHttpConnectionManager;\n+import org.apache.commons.httpclient.methods.EntityEnclosingMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.apache.commons.httpclient.methods.StringRequestEntity;\n+import org.apache.http.HttpHost;\n+import org.apache.http.conn.params.ConnRoutePNames;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds.ServiceReferenceHolder;\n+import org.wso2.carbon.context.PrivilegedCarbonContext;\n+import org.wso2.carbon.event.output.adapter.core.EventAdapterUtil;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapter;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterConfiguration;\n+import org.wso2.carbon.event.output.adapter.core.exception.OutputEventAdapterException;\n+import org.wso2.carbon.event.output.adapter.core.exception.TestConnectionNotSupportedException;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.util.ExtendedHTTPEventAdapterConstants;\n+\n+\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.*;\n+\n+/**\n+ * The recommendation event adapter is used to publish events to recommendation server\n+ */\n+public class ExtendedHTTPEventAdapter implements OutputEventAdapter {\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapter.class);\n+    private OutputEventAdapterConfiguration eventAdapterConfiguration;\n+    private Map<String, String> globalProperties;\n+    private static ExecutorService executorService;\n+    private String clientMethod;\n+    private int tenantId;\n+\n+    private String contentType;\n+    private static HttpConnectionManager connectionManager;\n+    private static HttpClient httpClient = null;\n+    private HostConfiguration hostConfiguration = null;\n+\n+    public ExtendedHTTPEventAdapter(OutputEventAdapterConfiguration eventAdapterConfiguration,\n+                                    Map<String, String> globalProperties) {\n+        this.eventAdapterConfiguration = eventAdapterConfiguration;\n+        this.globalProperties = globalProperties;\n+        this.clientMethod = eventAdapterConfiguration.getStaticProperties()\n+                .get(ExtendedHTTPEventAdapterConstants.ADAPTER_HTTP_CLIENT_METHOD);\n+    }\n+\n+    @Override\n+    public void init() throws OutputEventAdapterException {\n+        tenantId = PrivilegedCarbonContext.getThreadLocalCarbonContext().getTenantId();\n+\n+        //ExecutorService will be assigned  if it is null\n+        if (executorService == null) {\n+            int minThread;\n+            int maxThread;\n+            long defaultKeepAliveTime;\n+            int jobQueSize;\n+\n+            //If global properties are available those will be assigned else constant values will be assigned\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME) != null) {\n+                minThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                minThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MIN_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME) != null) {\n+                maxThread = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE_NAME));\n+            } else {\n+                maxThread = ExtendedHTTPEventAdapterConstants.ADAPTER_MAX_THREAD_POOL_SIZE;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME) != null) {\n+                defaultKeepAliveTime = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_KEEP_ALIVE_TIME_NAME));\n+            } else {\n+                defaultKeepAliveTime = ExtendedHTTPEventAdapterConstants.DEFAULT_KEEP_ALIVE_TIME_IN_MILLIS;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME) != null) {\n+                jobQueSize = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE_NAME));\n+            } else {\n+                jobQueSize = ExtendedHTTPEventAdapterConstants.ADAPTER_EXECUTOR_JOB_QUEUE_SIZE;\n+            }\n+            executorService = new ThreadPoolExecutor(minThread, maxThread, defaultKeepAliveTime, TimeUnit.MILLISECONDS,\n+                    new LinkedBlockingQueue<Runnable>(jobQueSize));\n+\n+            //configurations for the httpConnectionManager which will be shared by every http adapter\n+            int defaultMaxConnectionsPerHost;\n+            int maxTotalConnections;\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST) != null) {\n+                defaultMaxConnectionsPerHost = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_CONNECTIONS_PER_HOST));\n+            } else {\n+                defaultMaxConnectionsPerHost = ExtendedHTTPEventAdapterConstants.DEFAULT_DEFAULT_MAX_CONNECTIONS_PER_HOST;\n+            }\n+\n+            if (globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS) != null) {\n+                maxTotalConnections = Integer\n+                        .parseInt(globalProperties.get(ExtendedHTTPEventAdapterConstants.MAX_TOTAL_CONNECTIONS));\n+            } else {\n+                maxTotalConnections = ExtendedHTTPEventAdapterConstants.DEFAULT_MAX_TOTAL_CONNECTIONS;\n+            }\n+\n+            connectionManager = new MultiThreadedHttpConnectionManager();\n+            connectionManager.getParams().setDefaultMaxConnectionsPerHost(defaultMaxConnectionsPerHost);\n+            connectionManager.getParams().setMaxTotalConnections(maxTotalConnections);\n+        }\n+    }\n+\n+    @Override\n+    public void testConnect() throws TestConnectionNotSupportedException {\n+        throw new TestConnectionNotSupportedException(\"Test connection is not available\");\n+    }\n+\n+    @Override\n+    public void connect() {\n+        this.checkHTTPClientInit(eventAdapterConfiguration.getStaticProperties());\n+    }\n+\n+    @Override\n+    public void publish(Object message, Map<String, String> dynamicProperties) {\n+        //Load dynamic properties\n+        String url = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_MESSAGE_URL);\n+        String username = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_USERNAME);\n+        String password = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PASSWORD);\n+        String oauthUrl = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_URL);\n+        String consumerKey = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_KEY);\n+        String consumerSecret = dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_OAUTH_CONSUMER_SECRET);\n+\n+        Map<String, String> headers = this\n+                .extractHeaders(dynamicProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_HEADERS));\n+        String payload = message.toString();\n+\n+        try {\n+            if (username != null && password != null) {\n+                executorService.submit(new HTTPSender(url, payload, username, password, headers, httpClient));\n+            } else if(oauthUrl != null && consumerKey != null && consumerSecret != null ) {\n+                String accessToken = ServiceReferenceHolder.getInstance().getAccessTokenGenerator().getAccessToken(oauthUrl,consumerKey,\n+                        consumerSecret);\n+                executorService.submit(new HTTPSender(url, payload, accessToken, headers, httpClient));\n+            }\n+        } catch (RejectedExecutionException e) {\n+            EventAdapterUtil\n+                    .logAndDrop(eventAdapterConfiguration.getName(), message, \"Job queue is full\", e, log, tenantId);\n+        }\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        //not required\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        //not required\n+    }\n+\n+    @Override\n+    public boolean isPolled() {\n+        return false;\n+    }\n+\n+    private void checkHTTPClientInit(Map<String, String> staticProperties) {\n+\n+        if (this.httpClient != null) {\n+            return;\n+        }\n+\n+        synchronized (ExtendedHTTPEventAdapter.class) {\n+            if (this.httpClient != null) {\n+                return;\n+            }\n+\n+            httpClient = new HttpClient(connectionManager);\n+            String proxyHost = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_HOST);\n+            String proxyPort = staticProperties.get(ExtendedHTTPEventAdapterConstants.ADAPTER_PROXY_PORT);\n+            if (proxyHost != null && proxyHost.trim().length() > 0) {\n+                try {\n+                    HttpHost host = new HttpHost(proxyHost, Integer.parseInt(proxyPort));\n+                    this.httpClient.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, host);\n+                } catch (NumberFormatException e) {\n+                    log.error(\"Invalid proxy port: \" + proxyPort + \", \"\n+                            + \"ignoring proxy settings for HTTP output event adaptor...\");\n+                }\n+            }\n+\n+            String messageFormat = eventAdapterConfiguration.getMessageFormat();\n+            if (messageFormat.equalsIgnoreCase(\"json\")) {\n+                contentType = \"application/json\";\n+            } else if (messageFormat.equalsIgnoreCase(\"text\")) {\n+                contentType = \"text/plain\";\n+            } else {\n+                contentType = \"text/xml\";\n+            }\n+\n+        }\n+\n+    }\n+\n+    private Map<String, String> extractHeaders(String headers) {\n+        if (headers == null || headers.trim().length() == 0) {\n+            return null;\n+        }\n+\n+        String[] entries = headers.split(ExtendedHTTPEventAdapterConstants.HEADER_SEPARATOR);\n+        String[] keyValue;\n+        Map<String, String> result = new HashMap<String, String>();\n+        for (String header : entries) {\n+            try {\n+                keyValue = header.split(ExtendedHTTPEventAdapterConstants.ENTRY_SEPARATOR, 2);\n+                result.put(keyValue[0].trim(), keyValue[1].trim());\n+            } catch (Exception e) {\n+                log.warn(\"Header property '\" + header + \"' is not defined in the correct format.\", e);\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+    /**\n+     * This class represents a job to send an HTTP request to a target URL.\n+     */\n+    class HTTPSender implements Runnable {\n+\n+        private String url;\n+\n+        private String payload;\n+\n+        private String accessToken;\n+\n+        private String userName;\n+\n+        private String password;\n+\n+        private Map<String, String> headers;\n+\n+        private HttpClient httpClient;\n+\n+        public HTTPSender(String url, String payload, String accessToken, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.accessToken = accessToken;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        /**\n+         * If user name and password is given, basic auth is used. If not OAuth2 is used.\n+         */\n+        public HTTPSender(String url, String payload, String userName, String password, Map<String, String> headers,\n+                          HttpClient httpClient) {\n+            this.url = url;\n+            this.payload = payload;\n+            this.userName = userName;\n+            this.password = password;\n+            this.headers = headers;\n+            this.httpClient = httpClient;\n+        }\n+\n+        public String getUrl() {\n+            return url;\n+        }\n+\n+        public String getPayload() {\n+            return payload;\n+        }\n+\n+        public String getAccessToken() {\n+            return accessToken;\n+        }\n+\n+        public Map<String, String> getHeaders() {\n+            return headers;\n+        }\n+\n+        public HttpClient getHttpClient() {\n+            return httpClient;\n+        }\n+\n+        public String getUserName() {\n+            return userName;\n+        }\n+\n+        public String getPassword() {\n+            return password;\n+        }\n+\n+        public void run() {\n+\n+            EntityEnclosingMethod method = null;\n+\n+            try {\n+                if (clientMethod.equalsIgnoreCase(ExtendedHTTPEventAdapterConstants.CONSTANT_HTTP_PUT)) {\n+                    method = new PutMethod(this.getUrl());\n+                } else {\n+                    method = new PostMethod(this.getUrl());\n+                }\n+\n+                if (hostConfiguration == null) {\n+                    URL hostUrl = new URL(this.getUrl());\n+                    hostConfiguration = new HostConfiguration();\n+                    hostConfiguration.setHost(hostUrl.getHost(), hostUrl.getPort(), hostUrl.getProtocol());\n+                }\n+\n+                method.setRequestEntity(new StringRequestEntity(this.getPayload(), contentType, \"UTF-8\"));\n+\n+                if (this.getAccessToken() != null && this.getAccessToken().trim().length() > 0) {\n+                    method.setRequestHeader(\"Authorization\", \"Bearer \" + this.getAccessToken());", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDcxOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894718", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T14:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2MzYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDEyMw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964123", "bodyText": "Please mention the reason to use generic exception", "author": "ruks", "createdAt": "2020-02-10T10:01:01Z", "path": "components/apimgt/org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth/src/main/java/org/wso2/carbon/apimgt/event/output/adapter/http/extended/oauth/internal/ds/ExtendedHTTPEventAdapterServiceDS.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.internal.ds;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.component.annotations.ReferenceCardinality;\n+import org.osgi.service.component.annotations.ReferencePolicy;\n+import org.wso2.carbon.apimgt.event.output.adapter.http.extended.oauth.ExtendedHTTPEventAdapterFactory;\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+import org.wso2.carbon.event.output.adapter.core.OutputEventAdapterFactory;\n+\n+@Component(\n+        name = \"output.http.extended.AdapterService.component\",\n+        immediate = true)\n+public class ExtendedHTTPEventAdapterServiceDS {\n+\n+    private static final Log log = LogFactory.getLog(ExtendedHTTPEventAdapterServiceDS.class);\n+\n+    @Activate\n+    protected void activate(ComponentContext context) {\n+\n+        try {\n+            ExtendedHTTPEventAdapterFactory extendedHttpEventAdaptorFactory = new ExtendedHTTPEventAdapterFactory();\n+            BundleContext bundleContext = context.getBundleContext();\n+            bundleContext.registerService(OutputEventAdapterFactory.class.getName(),\n+                    extendedHttpEventAdaptorFactory, null);\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Successfully deployed the Extended Http event adaptor service\");\n+            }\n+        } catch (Exception e) {\n+            log.error(\"Can not create the Extended Http event event adaptor service: \" + e.getMessage(), e);", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5NDkwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378894905", "bodyText": "Removed the unnecessary try-catch block", "author": "1akshitha", "createdAt": "2020-02-13T14:30:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDEyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDcwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376964705", "bodyText": "please use constants", "author": "ruks", "createdAt": "2020-02-10T10:02:08Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIConsumerImpl.java", "diffHunk": "@@ -5758,54 +5763,92 @@ public void publishClickedAPI(ApiTypeWrapper clickedApi, String username) {\n         }\n     }\n \n-    public boolean isRecommendationEnabled() {\n-        boolean recommendationEnabled = false;\n+    /**\n+     * To check whether the API recommendation is enabled. It can be either enabled globally or tenant vice.\n+     *\n+     * @param tenantDomain Tenant domain\n+     * @return whether recommendation is enabled or not\n+     */\n+\n+    public boolean isRecommendationEnabled(String tenantDomain) {\n \n         if (recommendationEnvironment != null) {\n-            recommendationEnabled = true;\n+            if (recommendationEnvironment.isApplyForAllTenants()) {\n+                return true;\n+            } else {\n+                try {\n+                    String content = apimRegistryService\n+                            .getConfigRegistryResourceContent(tenantDomain, APIConstants.API_TENANT_CONF_LOCATION);\n+                    if (content != null) {\n+                        org.json.JSONObject apiTenantConfig = new org.json.JSONObject(content);\n+                        if (apiTenantConfig != null) {\n+                            if (apiTenantConfig.has(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY)) {\n+                                Object value = apiTenantConfig.get(APIConstants.API_TENANT_CONF_ENABLE_RECOMMENDATION_KEY);\n+                                return Boolean.parseBoolean(value.toString());\n+                            }\n+                        }\n+                    }\n+                } catch (UserStoreException | RegistryException e) {\n+                    log.error(\"Error occurred when getting API tenant config from registry\", e);\n+                }\n+            }\n         }\n-        return recommendationEnabled;\n+        return false;\n     }\n \n-    public String getApiRecommendations(String userName) {\n-        if (userName != null && requestedTenant != null && recommendationEnvironment != null) {\n-            String recommendationEndpointURL = recommendationEnvironment.getRecommendationEndpointURL();\n-            String adminUsername = recommendationEnvironment.getUsername();\n-            String adminPassword = recommendationEnvironment.getPassword();\n+    /**\n+     * Get recommendations for the user by connecting with the recommendation engine.\n+     *\n+     * @param userName     User's Name\n+     * @param tenantDomain tenantDomain\n+     * @return List of APIs recommended for the user\n+     */\n+    public String getApiRecommendations(String userName, String tenantDomain) {\n+\n+        if (isRecommendationEnabled(tenantDomain)) {\n+            String recommendationEndpointURL = recommendationEnvironment.getRecommendationServerURL()\n+                    + APIConstants.RECOMMENDATIONS_GET_RESOURCE;\n             try {\n+                String userID = apiMgtDAO.getUserID(userName);\n                 URL serverURL = new URL(recommendationEndpointURL);\n                 int serverPort = serverURL.getPort();\n                 String serverProtocol = serverURL.getProtocol();\n \n                 HttpGet method = new HttpGet(recommendationEndpointURL);\n                 HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n-\n-                byte[] credentials = org.apache.commons.codec.binary.Base64\n-                        .encodeBase64((adminUsername + \":\" + adminPassword).getBytes(StandardCharsets.UTF_8));\n-\n-                method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n-                method.setHeader(\"User\", userName);\n-                method.setHeader(\"Account\", requestedTenant);\n+                if (recommendationEnvironment.getOauthURL() != null) {\n+                    String accessToken = AccessTokenGeneratorImpl.getInstance().getAccessToken(\n+                                    recommendationEnvironment.getOauthURL(),\n+                                    recommendationEnvironment.getConsumerKey(),\n+                                    recommendationEnvironment.getConsumerSecret());\n+                    method.setHeader(APIConstants.AUTHORIZATION_HEADER_DEFAULT, \"Bearer \" + accessToken);\n+                } else {\n+                    byte[] credentials = org.apache.commons.codec.binary.Base64.encodeBase64(\n+                            (recommendationEnvironment.getUserName() + \":\" + recommendationEnvironment.getPassword())\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                    method.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTEzOA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865138", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NDcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTQzNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965436", "bodyText": "please use https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#equals(java.lang.Object) instead of ==", "author": "ruks", "createdAt": "2020-02-10T10:03:34Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTQxOQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865419", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTY5MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r376965691", "bodyText": "Move \"access_token\" to a constant", "author": "ruks", "createdAt": "2020-02-10T10:04:05Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGeneratorImpl.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGeneratorImpl implements AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGeneratorImpl.class);\n+\n+    private static volatile AccessTokenGeneratorImpl accessTokenGenerator = null;\n+    long generatedTime = 0;\n+    long validityPeriod = 3600000;\n+    String accessToken = null;\n+    String oauthUrl = null;\n+    String consumerKey = null;\n+    String consumerSecret = null;\n+\n+    public AccessTokenGeneratorImpl() {\n+\n+    }\n+\n+    public static AccessTokenGeneratorImpl getInstance() {\n+\n+        if (accessTokenGenerator == null) {\n+            synchronized (AccessTokenGeneratorImpl.class) {\n+                if (accessTokenGenerator == null) {\n+                    accessTokenGenerator = new AccessTokenGeneratorImpl();\n+                }\n+            }\n+        }\n+        return accessTokenGenerator;\n+    }\n+\n+    @Override\n+    public String getAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if (this.oauthUrl == oauthUrl && this.consumerKey == consumerKey && this.consumerSecret == consumerSecret\n+                && this.accessToken != null) {\n+            if (System.currentTimeMillis() > (this.generatedTime + this.validityPeriod)) {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Access token expired. New token requested\");\n+                }\n+                return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+            } else {\n+                if(log.isDebugEnabled()) {\n+                    log.debug(\"Valid Access Token already available for the provided application\");\n+                }\n+                return this.accessToken;\n+            }\n+        } else {\n+            this.oauthUrl = oauthUrl;\n+            this.consumerKey = consumerKey;\n+            this.consumerSecret = consumerSecret;\n+            if(log.isDebugEnabled()) {\n+                log.debug(\"Valid Access token not found for the application. New token requested\");\n+            }\n+            return generateNewAccessToken(oauthUrl, consumerKey, consumerSecret);\n+        }\n+    }\n+\n+    public String generateNewAccessToken(String oauthUrl, String consumerKey, String consumerSecret) {\n+\n+        if(oauthUrl != null && consumerKey != null && consumerSecret != null) {\n+            try {\n+                URL oauthURL = new URL(oauthUrl);\n+                int serverPort = oauthURL.getPort();\n+                String serverProtocol = oauthURL.getProtocol();\n+\n+                HttpPost request = new HttpPost(oauthUrl);\n+                HttpClient httpClient = APIUtil.getHttpClient(serverPort, serverProtocol);\n+\n+                byte[] credentials = org.apache.commons.codec.binary.Base64\n+                        .encodeBase64((consumerKey + \":\" + consumerSecret).getBytes(StandardCharsets.UTF_8));\n+\n+                request.setHeader(\"Authorization\", \"Basic \" + new String(credentials, StandardCharsets.UTF_8));\n+                request.setHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n+\n+                List<BasicNameValuePair> urlParameters = new ArrayList<>();\n+                urlParameters.add(new BasicNameValuePair(\"grant_type\", \"client_credentials\"));\n+                request.setEntity(new UrlEncodedFormEntity(urlParameters));\n+                HttpResponse httpResponse = httpClient.execute(request);\n+\n+                if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n+                    String payload = EntityUtils.toString(httpResponse.getEntity());\n+                    JSONObject response = new JSONObject(payload);\n+                    this.accessToken = (String) response.get(\"access_token\");", "originalCommit": "d85acfeac98f78a02c0ef7d9dbe156e94ad6e68c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2NTIyNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378865225", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk2NTY5MQ=="}], "type": "inlineReview"}, {"oid": "35abec0172330393313c54e7dad553a8f3ac46db", "url": "https://github.com/wso2/carbon-apimgt/commit/35abec0172330393313c54e7dad553a8f3ac46db", "message": "Changed the module name of the http adapter and few changes after review", "committedDate": "2020-02-12T05:43:20Z", "type": "commit"}, {"oid": "bbac35548057090d1ef83620c811aff2116fae11", "url": "https://github.com/wso2/carbon-apimgt/commit/bbac35548057090d1ef83620c811aff2116fae11", "message": "Changes after the code review", "committedDate": "2020-02-12T05:44:48Z", "type": "commit"}, {"oid": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5", "url": "https://github.com/wso2/carbon-apimgt/commit/a63789776f5b5be6ba6a106aa5a9feed68b0e5f5", "message": "Removed the singleton methodology", "committedDate": "2020-02-12T05:46:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0NTg4MA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378645880", "bodyText": "This isn't a service reference holder anymore right? Also, this doesn't have to be inside internal package since this isn't an osgi activator class", "author": "fazlan-nazeem", "createdAt": "2020-02-13T04:29:50Z", "path": "components/apimgt/org.wso2.carbon.apimgt.output.adapter.http/src/main/java/org/wso2/carbon/apimgt/output/adapter/http/internal/ds/ServiceReferenceHolder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.output.adapter.http.internal.ds;\n+\n+import org.wso2.carbon.apimgt.impl.recommendationmgt.AccessTokenGenerator;\n+\n+public class ServiceReferenceHolder {", "originalCommit": "a63789776f5b5be6ba6a106aa5a9feed68b0e5f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg1OTgwMA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378859800", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T13:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0NTg4MA=="}], "type": "inlineReview"}, {"oid": "ccb1b23f766b2344c53467137d718c562d4326cc", "url": "https://github.com/wso2/carbon-apimgt/commit/ccb1b23f766b2344c53467137d718c562d4326cc", "message": "Added a new cache for tenant-config", "committedDate": "2020-02-13T11:56:24Z", "type": "commit"}, {"oid": "61c53760a3cf5be32c86501e6f03eaf71211ff8d", "url": "https://github.com/wso2/carbon-apimgt/commit/61c53760a3cf5be32c86501e6f03eaf71211ff8d", "message": "Fixed minor bugs and log messages", "committedDate": "2020-02-13T11:56:51Z", "type": "commit"}, {"oid": "3100f53a8a1a82170c98349eda6edaec313ba57b", "url": "https://github.com/wso2/carbon-apimgt/commit/3100f53a8a1a82170c98349eda6edaec313ba57b", "message": "Fixed issue when returing cross tenant recommendations", "committedDate": "2020-02-13T12:29:26Z", "type": "commit"}, {"oid": "e926468c9b3359dc331916fce1133b29edce1a32", "url": "https://github.com/wso2/carbon-apimgt/commit/e926468c9b3359dc331916fce1133b29edce1a32", "message": "Removed unused class", "committedDate": "2020-02-13T12:56:07Z", "type": "commit"}, {"oid": "d9ca4ec985cb0adca3b887bf665df1ef7d9d5b3f", "url": "https://github.com/wso2/carbon-apimgt/commit/d9ca4ec985cb0adca3b887bf665df1ef7d9d5b3f", "message": "Merge remote-tracking branch 'upstream/master'", "committedDate": "2020-02-13T12:58:42Z", "type": "commit"}, {"oid": "ace930e71474cc2869dee51146a25ccea3f2832b", "url": "https://github.com/wso2/carbon-apimgt/commit/ace930e71474cc2869dee51146a25ccea3f2832b", "message": "New component version fix", "committedDate": "2020-02-13T13:00:41Z", "type": "commit"}, {"oid": "8a6d35b102f86f69df0a8d33fd329210ebca9760", "url": "https://github.com/wso2/carbon-apimgt/commit/8a6d35b102f86f69df0a8d33fd329210ebca9760", "message": "minor changes", "committedDate": "2020-02-13T13:29:55Z", "type": "commit"}, {"oid": "7ea7057baec23fc858d1487f358f4f725b266920", "url": "https://github.com/wso2/carbon-apimgt/commit/7ea7057baec23fc858d1487f358f4f725b266920", "message": "Addressed review comments", "committedDate": "2020-02-13T14:26:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMjgyMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378912822", "bodyText": "please check line legnth", "author": "ruks", "createdAt": "2020-02-13T14:58:13Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/APIManagerConfiguration.java", "diffHunk": "@@ -1203,6 +1194,78 @@ private void setMonetizationAdditionalAttributes(OMElement element) {\n         }\n     }\n \n+    /**\n+     * To populate recommendation related configurations\n+     * @param element\n+     */\n+    private void setRecommendationConfigurations(OMElement element) {\n+        OMElement recommendationSeverEndpointElement = element.getFirstChildWithName(new QName(APIConstants.RECOMMENDATION_ENDPOINT));", "originalCommit": "7ea7057baec23fc858d1487f358f4f725b266920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0ODkzNg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378948936", "bodyText": "fixed", "author": "1akshitha", "createdAt": "2020-02-13T15:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxMjgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDgwNw==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378914807", "bodyText": "looks length is exceeded.", "author": "ruks", "createdAt": "2020-02-13T15:01:13Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();", "originalCommit": "7ea7057baec23fc858d1487f358f4f725b266920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTAwNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949005", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T15:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNDgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378915002", "bodyText": "formatting issue", "author": "ruks", "createdAt": "2020-02-13T15:01:30Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/internal/APIManagerComponent.java", "diffHunk": "@@ -698,5 +706,18 @@ private void configureRecommendationEventPublisherProperties() {\n             }\n         }\n     }\n+\n+    private void setupAccessTokenGenerator(){\n+\n+        RecommendationEnvironment recommendationEnvironment =\n+                ServiceReferenceHolder.getInstance().getAPIManagerConfigurationService().getAPIManagerConfiguration().getApiRecommendationEnvironment();\n+        if (recommendationEnvironment != null && recommendationEnvironment.getOauthURL()!= null){", "originalCommit": "7ea7057baec23fc858d1487f358f4f725b266920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0ODU4MQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378948581", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T15:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTIyNQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949225", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T15:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNTAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzY0OQ==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378917649", "bodyText": "can we define appropriate access identifiers private or protected", "author": "ruks", "createdAt": "2020-02-13T15:05:35Z", "path": "components/apimgt/org.wso2.carbon.apimgt.impl/src/main/java/org/wso2/carbon/apimgt/impl/recommendationmgt/AccessTokenGenerator.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ */\n+\n+package org.wso2.carbon.apimgt.impl.recommendationmgt;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.client.HttpClient;\n+import org.apache.http.client.entity.UrlEncodedFormEntity;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.message.BasicNameValuePair;\n+import org.apache.http.util.EntityUtils;\n+import org.json.JSONObject;\n+import org.wso2.carbon.apimgt.impl.APIConstants;\n+import org.wso2.carbon.apimgt.impl.utils.APIUtil;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class AccessTokenGenerator {\n+\n+    private static final Log log = LogFactory.getLog(AccessTokenGenerator.class);\n+\n+    private static volatile AccessTokenGenerator accessTokenGenerator = null;\n+    long expiryTime = 0;", "originalCommit": "7ea7057baec23fc858d1487f358f4f725b266920", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0OTI5NA==", "url": "https://github.com/wso2/carbon-apimgt/pull/8160#discussion_r378949294", "bodyText": "Fixed", "author": "1akshitha", "createdAt": "2020-02-13T15:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkxNzY0OQ=="}], "type": "inlineReview"}, {"oid": "4cec104bd1cea39b67b0e03b16cf1516412c8e0b", "url": "https://github.com/wso2/carbon-apimgt/commit/4cec104bd1cea39b67b0e03b16cf1516412c8e0b", "message": "Version bump", "committedDate": "2020-02-13T15:50:40Z", "type": "commit"}, {"oid": "f4b13b66462890868baaccac4303579604b480e5", "url": "https://github.com/wso2/carbon-apimgt/commit/f4b13b66462890868baaccac4303579604b480e5", "message": "Address review commits", "committedDate": "2020-02-13T15:50:54Z", "type": "commit"}, {"oid": "521beed8ab675bc1ce8c32bbba6bacbf8be92267", "url": "https://github.com/wso2/carbon-apimgt/commit/521beed8ab675bc1ce8c32bbba6bacbf8be92267", "message": "Fixed incorrect tenant domain issue", "committedDate": "2020-02-13T17:13:34Z", "type": "commit"}, {"oid": "198ea1e7371c806b1b07f90b45dc2c26578b9755", "url": "https://github.com/wso2/carbon-apimgt/commit/198ea1e7371c806b1b07f90b45dc2c26578b9755", "message": "only recommendations related to tenat of the user will be visible", "committedDate": "2020-02-14T03:46:06Z", "type": "commit"}]}