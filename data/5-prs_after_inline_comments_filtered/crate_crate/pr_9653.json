{"pr_number": 9653, "pr_title": "Add sequence and version tests", "pr_createdAt": "2020-02-12T15:02:34Z", "pr_url": "https://github.com/crate/crate/pull/9653", "timeline": [{"oid": "1cf47fa3ef6f87e127e3706423885ff3b7a3eea9", "url": "https://github.com/crate/crate/commit/1cf47fa3ef6f87e127e3706423885ff3b7a3eea9", "message": "Remove uneeded imports", "committedDate": "2020-02-14T10:42:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzMjM1Ng==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379432356", "bodyText": "primary_term and seq_no from the response must be used.\nAlso this should not be version.seqNo + 1, bit just the responded seq_no", "author": "seut", "createdAt": "2020-02-14T13:36:03Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/ConcurrentSeqNoVersioningIT.java", "diffHunk": "@@ -0,0 +1,756 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.disruption.discovery.AbstractDisruptionTestCase;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.cluster.coordination.LinearizabilityChecker;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.InputStreamStreamInput;\n+import org.elasticsearch.common.io.stream.NamedWriteable;\n+import org.elasticsearch.common.io.stream.NamedWriteableAwareStreamInput;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.disruption.ServiceDisruptionScheme;\n+import org.junit.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+\n+\n+/**\n+ * This test stress tests CAS updates using sequence number based versioning (ifPrimaryTerm/ifSeqNo).\n+ *\n+ * <p>The following is a summary of the expected CAS write behaviour of the system:</p>\n+ *\n+ * <ul>\n+ *     <li>acknowledged CAS writes are guaranteed to have taken place between invocation and response and cannot be lost. It is\n+ *     guaranteed that the previous value had the specified primaryTerm and seqNo</li>\n+ *     <li>CAS writes resulting in a VersionConflictEngineException might or might not have taken place or may take place in the future\n+ *     provided the primaryTerm and seqNo still matches. The reason we cannot assume it will not take place after receiving the failure\n+ *     is that a request can fork into two because of retries on disconnect, and now race against itself. The retry might complete (and do a\n+ *     dirty or stale read) before the forked off request gets to execute, and that one might still subsequently succeed.\n+ *\n+ *     Such writes are not necessarily fully replicated and can be lost. There is no\n+ *     guarantee that the previous value did not have the specified primaryTerm and seqNo</li>\n+ *     <li>CAS writes with other exceptions might or might not have taken place. If they have taken place, then after invocation but not\n+ *     necessarily before response. Such writes are not necessarily fully replicated and can be lost.\n+ *     </li>\n+ * </ul>\n+ *\n+ * A deeper technical explanation of the behaviour is given here:\n+ *\n+ * <ul>\n+ *     <li>A CAS can fail on its own write in at least two ways. In both cases, the write might have taken place even though we get a\n+ *     version conflict response. Even though we might observe the write (by reading (not done in this test) or another CAS write), the\n+ *     write could be lost since it is not fully replicated. Details:\n+ *     <ul>\n+ *         <li>A write is successfully stored on primary and one replica (r1). Replication to second replica fails, primary is demoted\n+ *         and r1 is promoted to primary. The request is repeated on r1, but this time the request fails due to its own write.</li>\n+ *         <li>A coordinator sends write to primary, which stores write successfully (and replicates it). Connection is lost before\n+ *         response is sent back. Once connection is back, coordinator will retry against either same or new primary, but this time the\n+ *         request will fail due to its own write.\n+ *         </li>\n+ *     </ul>\n+ *     </li>\n+ *     <li>A CAS can fail on stale reads. A CAS failure is only checked on the supposedly primary node. However, the primary might not be\n+ *     the newest primary (could be isolated or just not have been told yet). So a CAS check is suspect to stale reads (like any\n+ *     read) and can thus fail due to reading stale data. Notice that a CAS success is fully replicated and thus guaranteed to not\n+ *     suffer from stale (or dirty) reads.\n+ *     </li>\n+ *     <li>A CAS can fail on a dirty read, i.e., a non-replicated write that ends up being discarded.</li>\n+ *     <li>For any other failure, we do not know if the write will succeed after the failure. However, we do know that if we\n+ *     subsequently get back a CAS success with seqNo s, any previous failures with ifSeqNo &lt; s will not be able to succeed (but could\n+ *     produce dirty writes on a stale primary).\n+ *     </li>\n+ *     <li>A CAS failure or any other failure can eventually succeed after receiving the failure response due to reroute and retries,\n+ *     see above.</li>\n+ *     <li>A CAS failure throws a VersionConflictEngineException which does not directly contain the current seqno/primary-term to use for\n+ *     the next request. It is contained in the message (and we parse it out in the test), but notice that the numbers given here could be\n+ *     stale or dirty, i.e., come from a stale primary or belong to a write that ends up being discarded.</li>\n+ * </ul>\n+ */\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, minNumDataNodes = 4, maxNumDataNodes = 6)\n+public class ConcurrentSeqNoVersioningIT extends AbstractDisruptionTestCase {\n+\n+    // Test info: disrupt network for up to 8s in a number of rounds and check that we only get true positive CAS results when running\n+    // multiple threads doing CAS updates.\n+    // Wait up to 1 minute (+10s in thread to ensure it does not time out) for threads to complete previous round before initiating next\n+    // round.\n+    @Test\n+    public void testSeqNoCASLinearizability() {\n+        final int disruptTimeSeconds = scaledRandomIntBetween(1, 8);\n+\n+        int numberOfShards = between(1, 3);\n+        int numberOfReplicas = randomInt(3);\n+        logger.info(\"creating table with {} shards and {} replicas\", numberOfShards, numberOfReplicas);\n+        execute(\"create table t (id int primary key, x string) clustered into \" + numberOfShards +\n+                \" shards with (number_of_replicas = \" + numberOfReplicas + \", \\\"write.wait_for_active_shards\\\" = 1)\");\n+        ensureGreen();\n+\n+        int numberOfKeys = randomIntBetween(1, 10);\n+\n+        logger.info(\"--> Indexing initial doc for {} keys\", numberOfKeys);\n+        List<Partition> partitions =\n+            IntStream.range(0, numberOfKeys)\n+                .mapToObj(i -> {\n+                    execute(\"insert into t (id, x) values (?, ?) returning  _primary_term, _seq_no\", new Object[]{i, \"value \" + i});\n+                    long primaryTerm = (long) response.rows()[0][0];\n+                    long seqNo = (long) response.rows()[0][1];\n+                    return new Partition(Integer.toString(i), new Version(primaryTerm, seqNo));\n+                })\n+                .collect(Collectors.toList());\n+\n+        int threadCount = randomIntBetween(3, 20);\n+        CyclicBarrier roundBarrier = new CyclicBarrier(threadCount + 1); // +1 for main thread.\n+\n+        List<CASUpdateThread> threads =\n+            IntStream.range(0, threadCount)\n+                .mapToObj(i -> new CASUpdateThread(i, roundBarrier, partitions, disruptTimeSeconds + 1))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"--> Starting {} threads\", threadCount);\n+        threads.forEach(Thread::start);\n+\n+        try {\n+            int rounds = randomIntBetween(1, 3);\n+\n+            logger.info(\"--> Running {} rounds\", rounds);\n+\n+            for (int i = 0; i < rounds; ++i) {\n+                ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme();\n+                roundBarrier.await(1, TimeUnit.MINUTES);\n+                disruptionScheme.startDisrupting();\n+                logger.info(\"--> round {}\", i);\n+                try {\n+                    roundBarrier.await(disruptTimeSeconds, TimeUnit.SECONDS);\n+                } catch (TimeoutException e) {\n+                    roundBarrier.reset();\n+                }\n+                internalCluster().clearDisruptionScheme(false);\n+                // heal cluster faster to reduce test time.\n+                ensureFullyConnectedCluster();\n+            }\n+        } catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+            logger.error(\"Timed out, dumping stack traces of all threads:\");\n+            threads.forEach(\n+                thread -> logger.info(thread.toString() + \":\\n\" + ExceptionsHelper.formatStackTrace(thread.getStackTrace())));\n+            throw new RuntimeException(e);\n+        } finally {\n+            logger.info(\"--> terminating test\");\n+            threads.forEach(CASUpdateThread::terminate);\n+            threads.forEach(CASUpdateThread::await);\n+            threads.stream().filter(Thread::isAlive).forEach(t -> fail(\"Thread still alive: \" + t));\n+        }\n+\n+        partitions.forEach(Partition::assertLinearizable);\n+    }\n+\n+\n+    private class CASUpdateThread extends Thread {\n+        private final CyclicBarrier roundBarrier;\n+        private final List<Partition> partitions;\n+        private final int timeoutSeconds;\n+\n+        private volatile boolean stop;\n+        private final Random random = new Random(randomLong());\n+\n+        private CASUpdateThread(int threadNum, CyclicBarrier roundBarrier, List<Partition> partitions, int timeoutSeconds) {\n+            super(\"CAS-Update-\" + threadNum);\n+            this.roundBarrier = roundBarrier;\n+            this.partitions = partitions;\n+            this.timeoutSeconds = timeoutSeconds;\n+            setDaemon(true);\n+        }\n+\n+        public void run() {\n+            while (stop == false) {\n+                try {\n+                    roundBarrier.await(70, TimeUnit.SECONDS);\n+\n+                    int numberOfUpdates = randomIntBetween(3, 13)  * partitions.size();\n+                    for (int i = 0; i < numberOfUpdates; ++i) {\n+                        final int keyIndex = random.nextInt(partitions.size());\n+                        final Partition partition = partitions.get(keyIndex);\n+\n+                        final int seqNoChangePct = random.nextInt(100);\n+\n+                        // we use either the latest observed or the latest successful version, to increase chance of getting successful\n+                        // CAS'es and races. If we were to use only the latest successful version, any CAS fail on own write would mean that\n+                        // all future CAS'es would fail unless we guess the seqno/term below. On the other hand, using latest observed\n+                        // version exclusively we risk a single CAS fail on a dirty read to cause the same. Doing both randomly and adding\n+                        // variance to seqno/term should ensure we progress fine in most runs.\n+                        Version version = random.nextBoolean() ? partition.latestObservedVersion() : partition.latestSuccessfulVersion();\n+\n+                        if (seqNoChangePct < 10) {\n+                            version = version.nextSeqNo(random.nextInt(4) + 1);\n+                        } else if (seqNoChangePct < 15) {\n+                            version = version.previousSeqNo(random.nextInt(4) + 1);\n+                        }\n+\n+                        final int termChangePct = random.nextInt(100);\n+                        if (termChangePct < 5) {\n+                            version = version.nextTerm();\n+                        } else if (termChangePct < 10) {\n+                            version = version.previousTerm();\n+                        }\n+\n+                        Consumer<HistoryOutput> historyResponse = partition.invoke(version);\n+                        try {\n+                            execute(\"update t set x = ? where id = ? and _seq_no = ? and _primary_term = ?\",\n+                                    new Object[]{random.nextInt(), partition.id, version.seqNo, version.primaryTerm},\n+                                    TimeValue.timeValueSeconds(timeoutSeconds));\n+\n+                            if (response.rowCount() > 0) {\n+                                IndexResponseHistoryOutput historyOutput = new IndexResponseHistoryOutput(new Version(\n+                                    version.primaryTerm,\n+                                    version.seqNo + 1));", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNDc5OA==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379504798", "bodyText": "Great catch, thanks.", "author": "mkleen", "createdAt": "2020-02-14T15:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzMjM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzNjMwNQ==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379436305", "bodyText": "looks like this is only used in assertLinearizable so we could merge both methods (actually the original code at ES does only have the assertLinearizable method.", "author": "seut", "createdAt": "2020-02-14T13:44:34Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/ConcurrentSeqNoVersioningIT.java", "diffHunk": "@@ -0,0 +1,756 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.disruption.discovery.AbstractDisruptionTestCase;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.cluster.coordination.LinearizabilityChecker;\n+import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.InputStreamStreamInput;\n+import org.elasticsearch.common.io.stream.NamedWriteable;\n+import org.elasticsearch.common.io.stream.NamedWriteableAwareStreamInput;\n+import org.elasticsearch.common.io.stream.NamedWriteableRegistry;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.disruption.ServiceDisruptionScheme;\n+import org.junit.Test;\n+\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Random;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+\n+\n+/**\n+ * This test stress tests CAS updates using sequence number based versioning (ifPrimaryTerm/ifSeqNo).\n+ *\n+ * <p>The following is a summary of the expected CAS write behaviour of the system:</p>\n+ *\n+ * <ul>\n+ *     <li>acknowledged CAS writes are guaranteed to have taken place between invocation and response and cannot be lost. It is\n+ *     guaranteed that the previous value had the specified primaryTerm and seqNo</li>\n+ *     <li>CAS writes resulting in a VersionConflictEngineException might or might not have taken place or may take place in the future\n+ *     provided the primaryTerm and seqNo still matches. The reason we cannot assume it will not take place after receiving the failure\n+ *     is that a request can fork into two because of retries on disconnect, and now race against itself. The retry might complete (and do a\n+ *     dirty or stale read) before the forked off request gets to execute, and that one might still subsequently succeed.\n+ *\n+ *     Such writes are not necessarily fully replicated and can be lost. There is no\n+ *     guarantee that the previous value did not have the specified primaryTerm and seqNo</li>\n+ *     <li>CAS writes with other exceptions might or might not have taken place. If they have taken place, then after invocation but not\n+ *     necessarily before response. Such writes are not necessarily fully replicated and can be lost.\n+ *     </li>\n+ * </ul>\n+ *\n+ * A deeper technical explanation of the behaviour is given here:\n+ *\n+ * <ul>\n+ *     <li>A CAS can fail on its own write in at least two ways. In both cases, the write might have taken place even though we get a\n+ *     version conflict response. Even though we might observe the write (by reading (not done in this test) or another CAS write), the\n+ *     write could be lost since it is not fully replicated. Details:\n+ *     <ul>\n+ *         <li>A write is successfully stored on primary and one replica (r1). Replication to second replica fails, primary is demoted\n+ *         and r1 is promoted to primary. The request is repeated on r1, but this time the request fails due to its own write.</li>\n+ *         <li>A coordinator sends write to primary, which stores write successfully (and replicates it). Connection is lost before\n+ *         response is sent back. Once connection is back, coordinator will retry against either same or new primary, but this time the\n+ *         request will fail due to its own write.\n+ *         </li>\n+ *     </ul>\n+ *     </li>\n+ *     <li>A CAS can fail on stale reads. A CAS failure is only checked on the supposedly primary node. However, the primary might not be\n+ *     the newest primary (could be isolated or just not have been told yet). So a CAS check is suspect to stale reads (like any\n+ *     read) and can thus fail due to reading stale data. Notice that a CAS success is fully replicated and thus guaranteed to not\n+ *     suffer from stale (or dirty) reads.\n+ *     </li>\n+ *     <li>A CAS can fail on a dirty read, i.e., a non-replicated write that ends up being discarded.</li>\n+ *     <li>For any other failure, we do not know if the write will succeed after the failure. However, we do know that if we\n+ *     subsequently get back a CAS success with seqNo s, any previous failures with ifSeqNo &lt; s will not be able to succeed (but could\n+ *     produce dirty writes on a stale primary).\n+ *     </li>\n+ *     <li>A CAS failure or any other failure can eventually succeed after receiving the failure response due to reroute and retries,\n+ *     see above.</li>\n+ *     <li>A CAS failure throws a VersionConflictEngineException which does not directly contain the current seqno/primary-term to use for\n+ *     the next request. It is contained in the message (and we parse it out in the test), but notice that the numbers given here could be\n+ *     stale or dirty, i.e., come from a stale primary or belong to a write that ends up being discarded.</li>\n+ * </ul>\n+ */\n+@ESIntegTestCase.ClusterScope(scope = ESIntegTestCase.Scope.TEST, minNumDataNodes = 4, maxNumDataNodes = 6)\n+public class ConcurrentSeqNoVersioningIT extends AbstractDisruptionTestCase {\n+\n+    // Test info: disrupt network for up to 8s in a number of rounds and check that we only get true positive CAS results when running\n+    // multiple threads doing CAS updates.\n+    // Wait up to 1 minute (+10s in thread to ensure it does not time out) for threads to complete previous round before initiating next\n+    // round.\n+    @Test\n+    public void testSeqNoCASLinearizability() {\n+        final int disruptTimeSeconds = scaledRandomIntBetween(1, 8);\n+\n+        int numberOfShards = between(1, 3);\n+        int numberOfReplicas = randomInt(3);\n+        logger.info(\"creating table with {} shards and {} replicas\", numberOfShards, numberOfReplicas);\n+        execute(\"create table t (id int primary key, x string) clustered into \" + numberOfShards +\n+                \" shards with (number_of_replicas = \" + numberOfReplicas + \", \\\"write.wait_for_active_shards\\\" = 1)\");\n+        ensureGreen();\n+\n+        int numberOfKeys = randomIntBetween(1, 10);\n+\n+        logger.info(\"--> Indexing initial doc for {} keys\", numberOfKeys);\n+        List<Partition> partitions =\n+            IntStream.range(0, numberOfKeys)\n+                .mapToObj(i -> {\n+                    execute(\"insert into t (id, x) values (?, ?) returning  _primary_term, _seq_no\", new Object[]{i, \"value \" + i});\n+                    long primaryTerm = (long) response.rows()[0][0];\n+                    long seqNo = (long) response.rows()[0][1];\n+                    return new Partition(Integer.toString(i), new Version(primaryTerm, seqNo));\n+                })\n+                .collect(Collectors.toList());\n+\n+        int threadCount = randomIntBetween(3, 20);\n+        CyclicBarrier roundBarrier = new CyclicBarrier(threadCount + 1); // +1 for main thread.\n+\n+        List<CASUpdateThread> threads =\n+            IntStream.range(0, threadCount)\n+                .mapToObj(i -> new CASUpdateThread(i, roundBarrier, partitions, disruptTimeSeconds + 1))\n+                .collect(Collectors.toList());\n+\n+        logger.info(\"--> Starting {} threads\", threadCount);\n+        threads.forEach(Thread::start);\n+\n+        try {\n+            int rounds = randomIntBetween(1, 3);\n+\n+            logger.info(\"--> Running {} rounds\", rounds);\n+\n+            for (int i = 0; i < rounds; ++i) {\n+                ServiceDisruptionScheme disruptionScheme = addRandomDisruptionScheme();\n+                roundBarrier.await(1, TimeUnit.MINUTES);\n+                disruptionScheme.startDisrupting();\n+                logger.info(\"--> round {}\", i);\n+                try {\n+                    roundBarrier.await(disruptTimeSeconds, TimeUnit.SECONDS);\n+                } catch (TimeoutException e) {\n+                    roundBarrier.reset();\n+                }\n+                internalCluster().clearDisruptionScheme(false);\n+                // heal cluster faster to reduce test time.\n+                ensureFullyConnectedCluster();\n+            }\n+        } catch (InterruptedException | BrokenBarrierException | TimeoutException e) {\n+            logger.error(\"Timed out, dumping stack traces of all threads:\");\n+            threads.forEach(\n+                thread -> logger.info(thread.toString() + \":\\n\" + ExceptionsHelper.formatStackTrace(thread.getStackTrace())));\n+            throw new RuntimeException(e);\n+        } finally {\n+            logger.info(\"--> terminating test\");\n+            threads.forEach(CASUpdateThread::terminate);\n+            threads.forEach(CASUpdateThread::await);\n+            threads.stream().filter(Thread::isAlive).forEach(t -> fail(\"Thread still alive: \" + t));\n+        }\n+\n+        partitions.forEach(Partition::assertLinearizable);\n+    }\n+\n+\n+    private class CASUpdateThread extends Thread {\n+        private final CyclicBarrier roundBarrier;\n+        private final List<Partition> partitions;\n+        private final int timeoutSeconds;\n+\n+        private volatile boolean stop;\n+        private final Random random = new Random(randomLong());\n+\n+        private CASUpdateThread(int threadNum, CyclicBarrier roundBarrier, List<Partition> partitions, int timeoutSeconds) {\n+            super(\"CAS-Update-\" + threadNum);\n+            this.roundBarrier = roundBarrier;\n+            this.partitions = partitions;\n+            this.timeoutSeconds = timeoutSeconds;\n+            setDaemon(true);\n+        }\n+\n+        public void run() {\n+            while (stop == false) {\n+                try {\n+                    roundBarrier.await(70, TimeUnit.SECONDS);\n+\n+                    int numberOfUpdates = randomIntBetween(3, 13)  * partitions.size();\n+                    for (int i = 0; i < numberOfUpdates; ++i) {\n+                        final int keyIndex = random.nextInt(partitions.size());\n+                        final Partition partition = partitions.get(keyIndex);\n+\n+                        final int seqNoChangePct = random.nextInt(100);\n+\n+                        // we use either the latest observed or the latest successful version, to increase chance of getting successful\n+                        // CAS'es and races. If we were to use only the latest successful version, any CAS fail on own write would mean that\n+                        // all future CAS'es would fail unless we guess the seqno/term below. On the other hand, using latest observed\n+                        // version exclusively we risk a single CAS fail on a dirty read to cause the same. Doing both randomly and adding\n+                        // variance to seqno/term should ensure we progress fine in most runs.\n+                        Version version = random.nextBoolean() ? partition.latestObservedVersion() : partition.latestSuccessfulVersion();\n+\n+                        if (seqNoChangePct < 10) {\n+                            version = version.nextSeqNo(random.nextInt(4) + 1);\n+                        } else if (seqNoChangePct < 15) {\n+                            version = version.previousSeqNo(random.nextInt(4) + 1);\n+                        }\n+\n+                        final int termChangePct = random.nextInt(100);\n+                        if (termChangePct < 5) {\n+                            version = version.nextTerm();\n+                        } else if (termChangePct < 10) {\n+                            version = version.previousTerm();\n+                        }\n+\n+                        Consumer<HistoryOutput> historyResponse = partition.invoke(version);\n+                        try {\n+                            execute(\"update t set x = ? where id = ? and _seq_no = ? and _primary_term = ?\",\n+                                    new Object[]{random.nextInt(), partition.id, version.seqNo, version.primaryTerm},\n+                                    TimeValue.timeValueSeconds(timeoutSeconds));\n+\n+                            if (response.rowCount() > 0) {\n+                                IndexResponseHistoryOutput historyOutput = new IndexResponseHistoryOutput(new Version(\n+                                    version.primaryTerm,\n+                                    version.seqNo + 1));\n+\n+                                // update was successful\n+                                historyResponse.accept(historyOutput);\n+                                // validate version and seqNo strictly increasing for successful CAS to avoid that overhead during\n+                                // linearizability checking.\n+                                assertThat(historyOutput.outputVersion, greaterThan(version));\n+                                assertThat(historyOutput.outputVersion.seqNo, greaterThan(version.seqNo));\n+                            }\n+                        } catch (RuntimeException e) {\n+                            if (version.compareTo(partition.latestSuccessfulVersion()) <= 0) {\n+                                historyResponse.accept(new FailureHistoryOutput());\n+                            }\n+                            logger.info(\n+                                new ParameterizedMessage(\"Received failure for request on id [{}], version [{}]\",\n+                                                         partition.id,\n+                                                         version),\n+                                e);\n+                            if (stop) {\n+                                // interrupt often comes as a RuntimeException so check to stop here too.\n+                                return;\n+                            }\n+                        }\n+                    }\n+                } catch (InterruptedException e) {\n+                    assert stop : \"should only be interrupted when stopped\";\n+                } catch (BrokenBarrierException e) {\n+                    // a thread can go here either because it completed before disruption ended, timeout on main thread causes broken\n+                    // barrier\n+                } catch (TimeoutException e) {\n+                    // this is timeout on the barrier, unexpected.\n+                    throw new AssertionError(\"Unexpected timeout in thread: \" + Thread.currentThread(), e);\n+                }\n+            }\n+        }\n+\n+        void terminate() {\n+            stop = true;\n+            this.interrupt();\n+        }\n+\n+        void await() {\n+            try {\n+                join(60000);\n+            } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Our version, which is primaryTerm,seqNo.\n+     */\n+    private static final class Version implements NamedWriteable, Comparable<Version> {\n+        final long primaryTerm;\n+        final long seqNo;\n+\n+        Version(long primaryTerm, long seqNo) {\n+            this.primaryTerm = primaryTerm;\n+            this.seqNo = seqNo;\n+        }\n+\n+        Version(StreamInput input) throws IOException {\n+            this.primaryTerm = input.readLong();\n+            this.seqNo = input.readLong();\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Version version = (Version) o;\n+            return primaryTerm == version.primaryTerm &&\n+                   seqNo == version.seqNo;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(primaryTerm, seqNo);\n+        }\n+\n+        @Override\n+        public int compareTo(Version other) {\n+            int termCompare = Long.compare(primaryTerm, other.primaryTerm);\n+            if (termCompare != 0)\n+                return termCompare;\n+            return Long.compare(seqNo, other.seqNo);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"{\" + \"primaryTerm=\" + primaryTerm + \", seqNo=\" + seqNo + '}';\n+        }\n+\n+        Version nextSeqNo(int increment) {\n+            return new Version(primaryTerm, seqNo + increment);\n+        }\n+\n+        Version previousSeqNo(int decrement) {\n+            return new Version(primaryTerm, Math.max(seqNo - decrement, 0));\n+        }\n+\n+        @Override\n+        public String getWriteableName() {\n+            return \"version\";\n+        }\n+\n+        public void writeTo(StreamOutput out) throws IOException {\n+            out.writeLong(primaryTerm);\n+            out.writeLong(seqNo);\n+        }\n+\n+        Version previousTerm() {\n+            return new Version(primaryTerm - 1, seqNo);\n+        }\n+\n+        Version nextTerm() {\n+            return new Version(primaryTerm + 1, seqNo);\n+        }\n+    }\n+\n+    private static class AtomicVersion {\n+        private final AtomicReference<Version> current;\n+\n+        private AtomicVersion(Version initialVersion) {\n+            this.current = new AtomicReference<>(initialVersion);\n+        }\n+\n+        public Version get() {\n+            return current.get();\n+        }\n+\n+        public void consume(Version version) {\n+            if (version == null)\n+                return;\n+            this.current.updateAndGet(current -> version.compareTo(current) <= 0 ? current : version);\n+        }\n+    }\n+\n+    private class Partition {\n+        private final String id;\n+        private final AtomicVersion latestSuccessfulVersion;\n+        private final AtomicVersion latestObservedVersion;\n+        private final Version initialVersion;\n+        private final LinearizabilityChecker.History history = new LinearizabilityChecker.History();\n+\n+        private Partition(String id, Version initialVersion) {\n+            this.id = id;\n+            this.latestSuccessfulVersion = new AtomicVersion(initialVersion);\n+            this.latestObservedVersion = new AtomicVersion(initialVersion);\n+            this.initialVersion = initialVersion;\n+        }\n+\n+        // latest version that was observed, possibly dirty read of a write that does not survive\n+        Version latestObservedVersion() {\n+            return latestObservedVersion.get();\n+        }\n+\n+        // latest version for which we got a successful response on a write.\n+        Version latestSuccessfulVersion() {\n+            return latestSuccessfulVersion.get();\n+        }\n+\n+        Consumer<HistoryOutput> invoke(Version version) {\n+            int eventId = history.invoke(version);\n+            logger.debug(\"invocation partition ({}) event ({}) version ({})\", id, eventId, version);\n+            return output -> consumeOutput(output, eventId);\n+        }\n+\n+        private void consumeOutput(HistoryOutput output, int eventId) {\n+            history.respond(eventId, output);\n+            logger.debug(\"response partition ({}) event ({}) output ({})\", id, eventId, output);\n+            latestObservedVersion.consume(output.getVersion());\n+            if (output instanceof IndexResponseHistoryOutput) {\n+                latestSuccessfulVersion.consume(output.getVersion());\n+            }\n+        }\n+\n+        boolean isLinearizable() {", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTQ5NQ==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379439495", "bodyText": "This assertion is missing but would be good to have I think https://github.com/elastic/elasticsearch/blob/master/server/src/test/java/org/elasticsearch/versioning/SimpleVersioningIT.java#L286", "author": "seut", "createdAt": "2020-02-14T13:51:30Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/SimpleVersioningIT.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.SQLTransportIntegrationTest;\n+import org.junit.Test;\n+\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class SimpleVersioningIT extends SQLTransportIntegrationTest {\n+\n+    @Test\n+    public void test_compare_and_set() {\n+\n+        execute(\"create table test (id integer primary key, value string)\");\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no, _primary_term\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        long primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(0L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(1L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 1 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test where id = 1\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        // select with versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term, _version from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+            assertThat(response.rows()[0][2], equalTo(2L));\n+        }\n+\n+        // select without versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(1L));\n+", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4NjA1Mw==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379486053", "bodyText": "The reason why i left it out is, because the row is already deleted here.", "author": "mkleen", "createdAt": "2020-02-14T15:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ4NzE1Nw==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379487157", "bodyText": "the additional assertions should validate that the row is already deleted in any case, see es code", "author": "seut", "createdAt": "2020-02-14T15:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQzOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MDA5Nw==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379440097", "bodyText": "a refresh is missing here in between the updates", "author": "seut", "createdAt": "2020-02-14T13:52:46Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/SimpleVersioningIT.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.SQLTransportIntegrationTest;\n+import org.junit.Test;\n+\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class SimpleVersioningIT extends SQLTransportIntegrationTest {\n+\n+    @Test\n+    public void test_compare_and_set() {\n+\n+        execute(\"create table test (id integer primary key, value string)\");\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no, _primary_term\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        long primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(0L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(1L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 1 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test where id = 1\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        // select with versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term, _version from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+            assertThat(response.rows()[0][2], equalTo(2L));\n+        }\n+\n+        // select without versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(1L));\n+\n+    }\n+\n+    public void test_simple_version_with_refresh() throws Exception {\n+        execute(\"create table test (id integer primary key, value string)\");\n+\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(1L));\n+\n+", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTA4MA==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379441080", "bodyText": "this is original run 10 times: https://github.com/elastic/elasticsearch/blob/master/server/src/test/java/org/elasticsearch/versioning/SimpleVersioningIT.java#L310\nany reason we don't do so as well?", "author": "seut", "createdAt": "2020-02-14T13:54:47Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/SimpleVersioningIT.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.SQLTransportIntegrationTest;\n+import org.junit.Test;\n+\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class SimpleVersioningIT extends SQLTransportIntegrationTest {\n+\n+    @Test\n+    public void test_compare_and_set() {\n+\n+        execute(\"create table test (id integer primary key, value string)\");\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no, _primary_term\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        long primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(0L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(1L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 1 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test where id = 1\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        // select with versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term, _version from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+            assertThat(response.rows()[0][2], equalTo(2L));\n+        }\n+\n+        // select without versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(1L));\n+\n+    }\n+\n+    public void test_simple_version_with_refresh() throws Exception {\n+        execute(\"create table test (id integer primary key, value string)\");\n+\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 0 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"select _version from test where id=1\");\n+        assertThat(response.rows()[0][0], equalTo(2L));", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTgzMg==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379441832", "bodyText": "also this run 10 times: https://github.com/elastic/elasticsearch/blob/master/server/src/test/java/org/elasticsearch/versioning/SimpleVersioningIT.java#L316\nAlso not sure if that is really needed/adds additional scenarios to cover, any reasoning from your side to do or not do it?", "author": "seut", "createdAt": "2020-02-14T13:56:19Z", "path": "sql/src/test/java/io/crate/integrationtests/disruption/seqno/SimpleVersioningIT.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.crate.integrationtests.disruption.seqno;\n+\n+import io.crate.integrationtests.SQLTransportIntegrationTest;\n+import org.junit.Test;\n+\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class SimpleVersioningIT extends SQLTransportIntegrationTest {\n+\n+    @Test\n+    public void test_compare_and_set() {\n+\n+        execute(\"create table test (id integer primary key, value string)\");\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no, _primary_term\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        long primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(0L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        primaryTerm = (long) response.rows()[0][1];\n+\n+        assertThat(seqNo, equalTo(1L));\n+        assertThat(primaryTerm, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 10 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 1 and _primary_term = 2 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 10 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 2\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test where id = 1\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        // select with versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term, _version from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+            assertThat(response.rows()[0][2], equalTo(2L));\n+        }\n+\n+        // select without versioning\n+        for (int i = 0; i < 10; i++) {\n+            execute(\"select _seq_no, _primary_term from test\");\n+            assertThat(response.rows()[0][0], equalTo(1L));\n+            assertThat(response.rows()[0][1], equalTo(1L));\n+        }\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 1 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(1L));\n+\n+    }\n+\n+    public void test_simple_version_with_refresh() throws Exception {\n+        execute(\"create table test (id integer primary key, value string)\");\n+\n+        ensureGreen();\n+\n+        execute(\"insert into test (id, value) values (?, ?) returning _seq_no\", new Object[]{1, \"value1_1\"});\n+\n+        long seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(0L));\n+\n+        execute(\"refresh table test\");\n+\n+        execute(\"update test set value = 'value1_2' where id = 1 returning _seq_no, _primary_term\");\n+\n+        seqNo = (long) response.rows()[0][0];\n+        assertThat(seqNo, equalTo(1L));\n+\n+\n+        execute(\"update test set value = 'value1_1' where id = 1 and _seq_no = 0 and _primary_term = 1 returning _seq_no, _primary_term\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"delete from test where id = 1 and _seq_no = 0 and _primary_term = 1\");\n+        assertThat(response.rowCount(), equalTo(0L));\n+\n+        execute(\"select _version from test where id=1\");\n+        assertThat(response.rows()[0][0], equalTo(2L));\n+\n+        execute(\"refresh table test\");\n+\n+        execute(\"select _version, _seq_no from test\");\n+        assertThat(response.rows()[0][0], equalTo(2L));\n+        assertThat(response.rows()[0][1], equalTo(1L));", "originalCommit": "12acf7d91f5f4dcbc9f10fc24afa0b38df3969a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ5NjkwOA==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379496908", "bodyText": "i think the main reason of running something 10 times is to proof that it is deterministic, i left out on this testcase because the operations seem really simple. What do you think ?", "author": "mkleen", "createdAt": "2020-02-14T15:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTgzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwOTAzNA==", "url": "https://github.com/crate/crate/pull/9653#discussion_r379509034", "bodyText": "i think the intention is to valide that reads from possible replicas behave correctly so i\u2018d keep the loop", "author": "seut", "createdAt": "2020-02-14T15:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTQ0MTgzMg=="}], "type": "inlineReview"}, {"oid": "3b920371a1ae92e5d3d97475ddcf0ace72794bdd", "url": "https://github.com/crate/crate/commit/3b920371a1ae92e5d3d97475ddcf0ace72794bdd", "message": "Reduce threads", "committedDate": "2020-02-15T05:36:24Z", "type": "forcePushed"}, {"oid": "06b07c7e6f6f1ec5daa4e1af6c9caa3709e00bdc", "url": "https://github.com/crate/crate/commit/06b07c7e6f6f1ec5daa4e1af6c9caa3709e00bdc", "message": "fixup! Add tests for sequence and versioning", "committedDate": "2020-02-18T14:24:12Z", "type": "forcePushed"}, {"oid": "acf524cdd5e5bd258e618cce76fe32ddb957cea2", "url": "https://github.com/crate/crate/commit/acf524cdd5e5bd258e618cce76fe32ddb957cea2", "message": "Add tests for sequence and versioning", "committedDate": "2020-02-21T11:17:40Z", "type": "commit"}, {"oid": "acf524cdd5e5bd258e618cce76fe32ddb957cea2", "url": "https://github.com/crate/crate/commit/acf524cdd5e5bd258e618cce76fe32ddb957cea2", "message": "Add tests for sequence and versioning", "committedDate": "2020-02-21T11:17:40Z", "type": "forcePushed"}]}