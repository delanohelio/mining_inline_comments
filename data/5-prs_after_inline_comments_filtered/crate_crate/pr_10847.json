{"pr_number": 10847, "pr_title": "Add postgres syntax compatible parser for to_char scalarfunction for timestamps", "pr_createdAt": "2020-12-04T13:56:58Z", "pr_url": "https://github.com/crate/crate/pull/10847", "timeline": [{"oid": "23041e5c3d8f25f8f7fe23d9b6ae693b9ca86c76", "url": "https://github.com/crate/crate/commit/23041e5c3d8f25f8f7fe23d9b6ae693b9ca86c76", "message": "Replace basic naive parser with a tree based one for better performance", "committedDate": "2020-12-04T17:01:26Z", "type": "forcePushed"}, {"oid": "11ff3821bb5aa93dd52f22a9a9aaad39ba45f167", "url": "https://github.com/crate/crate/commit/11ff3821bb5aa93dd52f22a9a9aaad39ba45f167", "message": "Replace basic naive parser with a tree based one for better performance", "committedDate": "2020-12-04T17:02:22Z", "type": "forcePushed"}, {"oid": "69bfeaa58a704a4a21c25f5d9238b1e19fe50839", "url": "https://github.com/crate/crate/commit/69bfeaa58a704a4a21c25f5d9238b1e19fe50839", "message": "Replace basic naive parser with a tree based one for better performance", "committedDate": "2020-12-07T11:40:41Z", "type": "forcePushed"}, {"oid": "d066bfe86df89d4014e02ba3516f163127414310", "url": "https://github.com/crate/crate/commit/d066bfe86df89d4014e02ba3516f163127414310", "message": "Add postgres syntax compatible parser for to_char scalar function\n\nReplace basic naive parser with a tree based one for better performance", "committedDate": "2020-12-07T11:40:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3NjQ5Mg==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537476492", "bodyText": "Looks like we already have an implementation for this which seems more efficient as well:\n\n  \n    \n      crate/server/src/main/java/org/elasticsearch/common/Strings.java\n    \n    \n        Lines 713 to 728\n      in\n      134389b\n    \n    \n    \n    \n\n        \n          \n           public static String padStart(String s, int minimumLength, char c) { \n        \n\n        \n          \n               if (s == null) { \n        \n\n        \n          \n                   throw new NullPointerException(\"s\"); \n        \n\n        \n          \n               } \n        \n\n        \n          \n               if (s.length() >= minimumLength) { \n        \n\n        \n          \n                   return s; \n        \n\n        \n          \n               } else { \n        \n\n        \n          \n                   StringBuilder sb = new StringBuilder(minimumLength); \n        \n\n        \n          \n                   for (int i = s.length(); i < minimumLength; i++) { \n        \n\n        \n          \n                       sb.append(c); \n        \n\n        \n          \n                   } \n        \n\n        \n          \n            \n        \n\n        \n          \n                   sb.append(s); \n        \n\n        \n          \n                   return sb.toString(); \n        \n\n        \n          \n               } \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nString.format has to parse/tokenize the format string, so it's quite expensive to use for appending characters.\nMaybe you could re-work the rightPad method to use a similar implementation?\nWould probably also make sense to merge StringUtils  and Strings as a separate PR.", "author": "mfussenegger", "createdAt": "2020-12-07T12:42:39Z", "path": "libs/shared/src/main/java/io/crate/common/StringUtils.java", "diffHunk": "@@ -68,4 +69,24 @@ public static boolean isBlank(String string, int start, int end) {\n         }\n         return true;\n     }\n+\n+    public static String capitalize(String string) {\n+        return string.substring(0,1).toUpperCase(Locale.ENGLISH) + string.substring(1).toLowerCase(Locale.ENGLISH);\n+    }\n+\n+    public static String rightpad(String string, int length, Character character) {\n+        if (string.length() >= length) {\n+            return string;\n+        } else {\n+            return String.format(Locale.ENGLISH, \"%-\" + length + \"s\", string).replace(' ', character);\n+        }\n+    }\n+\n+    public static String leftpad(String string, int length, Character character) {", "originalCommit": "d066bfe86df89d4014e02ba3516f163127414310", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NDE1MA==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537594150", "bodyText": "Turns out theres an identical implementation in com.google.common.base, with a complementary implementation of rightPad, so i'll just use those.", "author": "autophagy", "createdAt": "2020-12-07T15:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3NjQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU5NjQ0NA==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537596444", "bodyText": "We're trying to get rid of guava, so adding our own implementation wouldn't hurt.", "author": "mfussenegger", "createdAt": "2020-12-07T15:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ3NjQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4MTA0MA==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537481040", "bodyText": "I think this could be changed to do a .get once and check the result against null. It's a bit cheaper than doing a containsKey - which computes the hashcode and might have to do equal comparisons, and then follow up with a .get - which does the same again.", "author": "mfussenegger", "createdAt": "2020-12-07T12:49:34Z", "path": "server/src/main/java/io/crate/expression/scalar/formatting/DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.formatting;\n+\n+import io.crate.common.StringUtils;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.TextStyle;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalField;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+\n+public class DateTimeFormatter {\n+\n+    private enum Token {\n+        HOUR_OF_DAY(\"HH\"),\n+        HOUR_OF_DAY12(\"HH12\"),\n+        HOUR_OF_DAY24(\"HH24\"),\n+        MINUTE(\"MI\"),\n+        SECOND(\"SS\"),\n+        MILLISECOND(\"MS\"),\n+        MICROSECOND(\"US\"),\n+        TENTH_OF_SECOND(\"FF1\"),\n+        HUNDREDTH_OF_SECOND(\"FF2\"),\n+        MILLISECOND_FF(\"FF3\"),\n+        TENTH_OF_MILLISECOND(\"FF4\"),\n+        HUNDREDTH_OF_MILLISECOND(\"FF5\"),\n+        MICROSECOND_FF(\"FF6\"),\n+        SECONDS_PAST_MIDNIGHT(\"SSSS\"),\n+        SECONDS_PAST_MIDNIGHT_S(\"SSSSS\"),\n+        AM_UPPER(\"AM\"),\n+        AM_LOWER(\"am\"),\n+        PM_UPPER(\"PM\"),\n+        PM_LOWER(\"pm\"),\n+        A_M_UPPER(\"A.M.\"),\n+        A_M_LOWER(\"a.m.\"),\n+        P_M_UPPER(\"P.M.\"),\n+        P_M_LOWER(\"p.m.\"),\n+        YEAR_WITH_COMMA(\"Y,YYY\"),\n+        YEAR_YYYY(\"YYYY\"),\n+        YEAR_YYY(\"YYY\"),\n+        YEAR_YY(\"YY\"),\n+        YEAR_Y(\"Y\"),\n+        ISO_YEAR_YYY(\"IYYY\"),\n+        ISO_YEAR_YY(\"IYY\"),\n+        ISO_YEAR_Y(\"IY\"),\n+        ISO_YEAR(\"I\"),\n+        BC_ERA_UPPER(\"BC\"),\n+        BC_ERA_LOWER(\"bc\"),\n+        AD_ERA_UPPER(\"AD\"),\n+        AD_ERA_LOWER(\"ad\"),\n+        B_C_ERA_UPPER(\"B.C\"),\n+        B_C_ERA_LOWER(\"b.c\"),\n+        A_D_ERA_UPPER(\"A.D\"),\n+        A_D_ERA_LOWER(\"a.d\"),\n+        MONTH_UPPER(\"MONTH\"),\n+        MONTH_CAPITALIZED(\"Month\"),\n+        MONTH_LOWER(\"month\"),\n+        ABBREVIATED_MONTH_UPPER(\"MON\"),\n+        ABBREVIATED_MONTH_CAPITALIZED(\"Mon\"),\n+        ABBREVIATED_MONTH_LOWER(\"mon\"),\n+        MONTH_NUMBER(\"MM\"),\n+        DAY_UPPER(\"DAY\"),\n+        DAY_CAPITALIZED(\"Day\"),\n+        DAY_LOWER(\"day\"),\n+        ABBREVIATED_DAY_UPPER(\"DY\"),\n+        ABBREVIATED_DAY_CAPITALIZED(\"Dy\"),\n+        ABBREVIATED_DAY_LOWER(\"dy\"),\n+        DAY_OF_YEAR(\"DDD\"),\n+        DAY_OF_ISO_WEEK_NUMBERING_YEAR(\"IDDD\"),\n+        DAY_OF_MONTH(\"DD\"),\n+        DAY_OF_WEEK(\"D\"),\n+        ISO_DAY_OF_WEEK(\"ID\"),\n+        WEEK_OF_MONTH(\"W\"),\n+        WEEK_NUMBER_OF_YEAR(\"WW\"),\n+        WEEK_NUMBER_OF_ISO_YEAR(\"IW\"),\n+        CENTURY(\"CC\"),\n+        JULIAN_DAY(\"J\"),\n+        QUARTER(\"Q\"),\n+        ROMAN_MONTH_UPPER(\"RM\"),\n+        ROMAN_MONTH_LOWER(\"rm\"),\n+        TIMEZONE_UPPER(\"TZ\"),\n+        TIMEZONE_LOWER(\"tz\"),\n+        TIMEZONE_HOURS(\"TZH\"),\n+        TIMEZONE_MINUTES(\"TZM\"),\n+        TIMEZONE_OFFSET_FROM_UTC(\"OF\"),;\n+\n+        private final String token;\n+\n+        Token(final String token) {\n+            this.token = token;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.token;\n+        }\n+\n+    }\n+\n+    static class TokenNode {\n+        private final Map<Character, TokenNode> children = new HashMap<>();\n+        private Token token;\n+        public final TokenNode parent;\n+\n+        public TokenNode() {\n+            this.token = null;\n+            this.parent = null;\n+        }\n+\n+        private TokenNode(String tokenString, Token token, TokenNode parent) {\n+            this.parent = parent;\n+            if (tokenString.length() == 1) {\n+                // Last character of the token string, so a terminal leaf.\n+                this.token = token;\n+            } else {\n+                this.token = null;\n+                this.addChild(tokenString.substring(1), token);\n+            }\n+        }\n+\n+        public void addChild(Token token) {\n+            this.addChild(token.toString(), token);\n+        }\n+\n+        private void addChild(String tokenString, Token token) {\n+            // If a child for the first character of the string exists, add the rest of the string to it as a child.\n+            if (this.children.containsKey(tokenString.charAt(0))) {", "originalCommit": "d066bfe86df89d4014e02ba3516f163127414310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4Mzk1MA==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537483950", "bodyText": "I think tokens could be changed to a list and then you could use Lists2.joinOn for this.\nRepeated string concatenation with str + str can be problematic for performance compared to using a StringJoiner or a StringBuilder", "author": "mfussenegger", "createdAt": "2020-12-07T12:54:20Z", "path": "server/src/main/java/io/crate/expression/scalar/formatting/DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.formatting;\n+\n+import io.crate.common.StringUtils;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.TextStyle;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalField;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+\n+public class DateTimeFormatter {\n+\n+    private enum Token {\n+        HOUR_OF_DAY(\"HH\"),\n+        HOUR_OF_DAY12(\"HH12\"),\n+        HOUR_OF_DAY24(\"HH24\"),\n+        MINUTE(\"MI\"),\n+        SECOND(\"SS\"),\n+        MILLISECOND(\"MS\"),\n+        MICROSECOND(\"US\"),\n+        TENTH_OF_SECOND(\"FF1\"),\n+        HUNDREDTH_OF_SECOND(\"FF2\"),\n+        MILLISECOND_FF(\"FF3\"),\n+        TENTH_OF_MILLISECOND(\"FF4\"),\n+        HUNDREDTH_OF_MILLISECOND(\"FF5\"),\n+        MICROSECOND_FF(\"FF6\"),\n+        SECONDS_PAST_MIDNIGHT(\"SSSS\"),\n+        SECONDS_PAST_MIDNIGHT_S(\"SSSSS\"),\n+        AM_UPPER(\"AM\"),\n+        AM_LOWER(\"am\"),\n+        PM_UPPER(\"PM\"),\n+        PM_LOWER(\"pm\"),\n+        A_M_UPPER(\"A.M.\"),\n+        A_M_LOWER(\"a.m.\"),\n+        P_M_UPPER(\"P.M.\"),\n+        P_M_LOWER(\"p.m.\"),\n+        YEAR_WITH_COMMA(\"Y,YYY\"),\n+        YEAR_YYYY(\"YYYY\"),\n+        YEAR_YYY(\"YYY\"),\n+        YEAR_YY(\"YY\"),\n+        YEAR_Y(\"Y\"),\n+        ISO_YEAR_YYY(\"IYYY\"),\n+        ISO_YEAR_YY(\"IYY\"),\n+        ISO_YEAR_Y(\"IY\"),\n+        ISO_YEAR(\"I\"),\n+        BC_ERA_UPPER(\"BC\"),\n+        BC_ERA_LOWER(\"bc\"),\n+        AD_ERA_UPPER(\"AD\"),\n+        AD_ERA_LOWER(\"ad\"),\n+        B_C_ERA_UPPER(\"B.C\"),\n+        B_C_ERA_LOWER(\"b.c\"),\n+        A_D_ERA_UPPER(\"A.D\"),\n+        A_D_ERA_LOWER(\"a.d\"),\n+        MONTH_UPPER(\"MONTH\"),\n+        MONTH_CAPITALIZED(\"Month\"),\n+        MONTH_LOWER(\"month\"),\n+        ABBREVIATED_MONTH_UPPER(\"MON\"),\n+        ABBREVIATED_MONTH_CAPITALIZED(\"Mon\"),\n+        ABBREVIATED_MONTH_LOWER(\"mon\"),\n+        MONTH_NUMBER(\"MM\"),\n+        DAY_UPPER(\"DAY\"),\n+        DAY_CAPITALIZED(\"Day\"),\n+        DAY_LOWER(\"day\"),\n+        ABBREVIATED_DAY_UPPER(\"DY\"),\n+        ABBREVIATED_DAY_CAPITALIZED(\"Dy\"),\n+        ABBREVIATED_DAY_LOWER(\"dy\"),\n+        DAY_OF_YEAR(\"DDD\"),\n+        DAY_OF_ISO_WEEK_NUMBERING_YEAR(\"IDDD\"),\n+        DAY_OF_MONTH(\"DD\"),\n+        DAY_OF_WEEK(\"D\"),\n+        ISO_DAY_OF_WEEK(\"ID\"),\n+        WEEK_OF_MONTH(\"W\"),\n+        WEEK_NUMBER_OF_YEAR(\"WW\"),\n+        WEEK_NUMBER_OF_ISO_YEAR(\"IW\"),\n+        CENTURY(\"CC\"),\n+        JULIAN_DAY(\"J\"),\n+        QUARTER(\"Q\"),\n+        ROMAN_MONTH_UPPER(\"RM\"),\n+        ROMAN_MONTH_LOWER(\"rm\"),\n+        TIMEZONE_UPPER(\"TZ\"),\n+        TIMEZONE_LOWER(\"tz\"),\n+        TIMEZONE_HOURS(\"TZH\"),\n+        TIMEZONE_MINUTES(\"TZM\"),\n+        TIMEZONE_OFFSET_FROM_UTC(\"OF\"),;\n+\n+        private final String token;\n+\n+        Token(final String token) {\n+            this.token = token;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.token;\n+        }\n+\n+    }\n+\n+    static class TokenNode {\n+        private final Map<Character, TokenNode> children = new HashMap<>();\n+        private Token token;\n+        public final TokenNode parent;\n+\n+        public TokenNode() {\n+            this.token = null;\n+            this.parent = null;\n+        }\n+\n+        private TokenNode(String tokenString, Token token, TokenNode parent) {\n+            this.parent = parent;\n+            if (tokenString.length() == 1) {\n+                // Last character of the token string, so a terminal leaf.\n+                this.token = token;\n+            } else {\n+                this.token = null;\n+                this.addChild(tokenString.substring(1), token);\n+            }\n+        }\n+\n+        public void addChild(Token token) {\n+            this.addChild(token.toString(), token);\n+        }\n+\n+        private void addChild(String tokenString, Token token) {\n+            // If a child for the first character of the string exists, add the rest of the string to it as a child.\n+            if (this.children.containsKey(tokenString.charAt(0))) {\n+                // If the length of token string is 1, the child node is upgraded to a terminal token node.\n+                if (tokenString.length() == 1) {\n+                    this.children.get(tokenString.charAt(0)).token = token;\n+                } else {\n+                    this.children.get(tokenString.charAt(0)).addChild(tokenString.substring(1), token);\n+                }\n+            } else {\n+                this.children.put(tokenString.charAt(0), new TokenNode(tokenString, token, this));\n+            }\n+        }\n+\n+        public boolean isTokenNode() {\n+            return this.token != null;\n+        }\n+\n+        public boolean isRootNode() {\n+            return this.parent == null;\n+        }\n+\n+    }\n+\n+    private static final TreeMap<Integer, String> ROMAN_NUMERALS = new TreeMap<>();\n+\n+    static {\n+        ROMAN_NUMERALS.put(1000, \"M\");\n+        ROMAN_NUMERALS.put(800, \"CM\");\n+        ROMAN_NUMERALS.put(500, \"D\");\n+        ROMAN_NUMERALS.put(400, \"CD\");\n+        ROMAN_NUMERALS.put(100, \"C\");\n+        ROMAN_NUMERALS.put(80, \"XC\");\n+        ROMAN_NUMERALS.put(50, \"L\");\n+        ROMAN_NUMERALS.put(40, \"XL\");\n+        ROMAN_NUMERALS.put(10, \"X\");\n+        ROMAN_NUMERALS.put(9, \"IX\");\n+        ROMAN_NUMERALS.put(5, \"V\");\n+        ROMAN_NUMERALS.put(4, \"IV\");\n+        ROMAN_NUMERALS.put(1, \"I\");\n+    }\n+\n+    private static final TokenNode ROOT_TOKEN_NODE = new TokenNode();\n+\n+    static {\n+        for (Token token: Token.values()) {\n+            ROOT_TOKEN_NODE.addChild(token);\n+        }\n+    }\n+\n+    private final Object[] tokens;\n+\n+    private static final TemporalField WEEK_OF_YEAR = WeekFields.of(Locale.ENGLISH).weekOfWeekBasedYear();\n+\n+    public DateTimeFormatter(String pattern) {\n+        this.tokens = DateTimeFormatter.parse(pattern);\n+    }\n+\n+    private static Object[] parse(String pattern) {\n+        ArrayList<Object> tokens = new ArrayList<>();\n+        String pattern_to_consume = pattern;\n+        int idx = 0;\n+\n+        TokenNode currentTokenNode = ROOT_TOKEN_NODE;\n+        TokenNode nextTokenNode;\n+\n+        while (idx <= pattern_to_consume.length() && pattern_to_consume.length() > 0) {\n+\n+            if (idx == pattern_to_consume.length()) {\n+                nextTokenNode = null;\n+            } else {\n+                nextTokenNode = currentTokenNode.children.get(pattern_to_consume.charAt(idx));\n+            }\n+\n+            if (nextTokenNode == null && idx > 0) {\n+                // No next step along the tree, so the parser should terminate and reset.\n+                if (currentTokenNode.isTokenNode()) {\n+                    // If the current node is a token, then a valid token is found and added to the list.\n+                    // The token will then be removed from the rest of the string to parse.\n+                    tokens.add(currentTokenNode.token);\n+                } else {\n+                    // If the current node is not a token, the parser then traverses back up the tree until it either\n+                    // finds a token node, or the root.\n+                    int depth = idx;\n+\n+                    while (depth > 0) {\n+                        depth -= 1;\n+                        currentTokenNode = currentTokenNode.parent;\n+\n+                        if (currentTokenNode.isTokenNode()) {\n+                            // We have found the valid token, it should be added to the stack and the remaining rest\n+                            // of the parsed pattern should be added as a string.\n+                            tokens.add(currentTokenNode.token);\n+                            break;\n+                        }\n+                    }\n+\n+                    tokens.add(pattern_to_consume.substring(depth, idx));\n+                }\n+\n+                pattern_to_consume = pattern_to_consume.substring(idx);\n+                currentTokenNode = ROOT_TOKEN_NODE;\n+                idx = 0;\n+            } else if (nextTokenNode == null) {\n+                // If there is no path forward and index is 0, then we're at at the beginning, parsing a non-valid\n+                // character. Add as a string.\n+                tokens.add(pattern_to_consume.substring(0, idx + 1));\n+                pattern_to_consume = pattern_to_consume.substring(idx + 1);\n+            } else {\n+                idx += 1;\n+                currentTokenNode = nextTokenNode;\n+            }\n+        }\n+\n+        return tokens.toArray();\n+    }\n+\n+    public String format(LocalDateTime datetime) {\n+        String result = (String) Arrays.stream(this.tokens).sequential().reduce(", "originalCommit": "d066bfe86df89d4014e02ba3516f163127414310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4NzY1NA==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537487654", "bodyText": "Nice use of the TreeMap.\nIt's probably not worth to optimize this - but if you feel like it:\nI think you could use modulo to avoid the memory overhead of the map and also turn the recursion into a loop that uses a StringBuilder to create the result. That would avoid some allocations.", "author": "mfussenegger", "createdAt": "2020-12-07T13:00:01Z", "path": "server/src/main/java/io/crate/expression/scalar/formatting/DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.formatting;\n+\n+import io.crate.common.StringUtils;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.TextStyle;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalField;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+\n+public class DateTimeFormatter {\n+\n+    private enum Token {\n+        HOUR_OF_DAY(\"HH\"),\n+        HOUR_OF_DAY12(\"HH12\"),\n+        HOUR_OF_DAY24(\"HH24\"),\n+        MINUTE(\"MI\"),\n+        SECOND(\"SS\"),\n+        MILLISECOND(\"MS\"),\n+        MICROSECOND(\"US\"),\n+        TENTH_OF_SECOND(\"FF1\"),\n+        HUNDREDTH_OF_SECOND(\"FF2\"),\n+        MILLISECOND_FF(\"FF3\"),\n+        TENTH_OF_MILLISECOND(\"FF4\"),\n+        HUNDREDTH_OF_MILLISECOND(\"FF5\"),\n+        MICROSECOND_FF(\"FF6\"),\n+        SECONDS_PAST_MIDNIGHT(\"SSSS\"),\n+        SECONDS_PAST_MIDNIGHT_S(\"SSSSS\"),\n+        AM_UPPER(\"AM\"),\n+        AM_LOWER(\"am\"),\n+        PM_UPPER(\"PM\"),\n+        PM_LOWER(\"pm\"),\n+        A_M_UPPER(\"A.M.\"),\n+        A_M_LOWER(\"a.m.\"),\n+        P_M_UPPER(\"P.M.\"),\n+        P_M_LOWER(\"p.m.\"),\n+        YEAR_WITH_COMMA(\"Y,YYY\"),\n+        YEAR_YYYY(\"YYYY\"),\n+        YEAR_YYY(\"YYY\"),\n+        YEAR_YY(\"YY\"),\n+        YEAR_Y(\"Y\"),\n+        ISO_YEAR_YYY(\"IYYY\"),\n+        ISO_YEAR_YY(\"IYY\"),\n+        ISO_YEAR_Y(\"IY\"),\n+        ISO_YEAR(\"I\"),\n+        BC_ERA_UPPER(\"BC\"),\n+        BC_ERA_LOWER(\"bc\"),\n+        AD_ERA_UPPER(\"AD\"),\n+        AD_ERA_LOWER(\"ad\"),\n+        B_C_ERA_UPPER(\"B.C\"),\n+        B_C_ERA_LOWER(\"b.c\"),\n+        A_D_ERA_UPPER(\"A.D\"),\n+        A_D_ERA_LOWER(\"a.d\"),\n+        MONTH_UPPER(\"MONTH\"),\n+        MONTH_CAPITALIZED(\"Month\"),\n+        MONTH_LOWER(\"month\"),\n+        ABBREVIATED_MONTH_UPPER(\"MON\"),\n+        ABBREVIATED_MONTH_CAPITALIZED(\"Mon\"),\n+        ABBREVIATED_MONTH_LOWER(\"mon\"),\n+        MONTH_NUMBER(\"MM\"),\n+        DAY_UPPER(\"DAY\"),\n+        DAY_CAPITALIZED(\"Day\"),\n+        DAY_LOWER(\"day\"),\n+        ABBREVIATED_DAY_UPPER(\"DY\"),\n+        ABBREVIATED_DAY_CAPITALIZED(\"Dy\"),\n+        ABBREVIATED_DAY_LOWER(\"dy\"),\n+        DAY_OF_YEAR(\"DDD\"),\n+        DAY_OF_ISO_WEEK_NUMBERING_YEAR(\"IDDD\"),\n+        DAY_OF_MONTH(\"DD\"),\n+        DAY_OF_WEEK(\"D\"),\n+        ISO_DAY_OF_WEEK(\"ID\"),\n+        WEEK_OF_MONTH(\"W\"),\n+        WEEK_NUMBER_OF_YEAR(\"WW\"),\n+        WEEK_NUMBER_OF_ISO_YEAR(\"IW\"),\n+        CENTURY(\"CC\"),\n+        JULIAN_DAY(\"J\"),\n+        QUARTER(\"Q\"),\n+        ROMAN_MONTH_UPPER(\"RM\"),\n+        ROMAN_MONTH_LOWER(\"rm\"),\n+        TIMEZONE_UPPER(\"TZ\"),\n+        TIMEZONE_LOWER(\"tz\"),\n+        TIMEZONE_HOURS(\"TZH\"),\n+        TIMEZONE_MINUTES(\"TZM\"),\n+        TIMEZONE_OFFSET_FROM_UTC(\"OF\"),;\n+\n+        private final String token;\n+\n+        Token(final String token) {\n+            this.token = token;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.token;\n+        }\n+\n+    }\n+\n+    static class TokenNode {\n+        private final Map<Character, TokenNode> children = new HashMap<>();\n+        private Token token;\n+        public final TokenNode parent;\n+\n+        public TokenNode() {\n+            this.token = null;\n+            this.parent = null;\n+        }\n+\n+        private TokenNode(String tokenString, Token token, TokenNode parent) {\n+            this.parent = parent;\n+            if (tokenString.length() == 1) {\n+                // Last character of the token string, so a terminal leaf.\n+                this.token = token;\n+            } else {\n+                this.token = null;\n+                this.addChild(tokenString.substring(1), token);\n+            }\n+        }\n+\n+        public void addChild(Token token) {\n+            this.addChild(token.toString(), token);\n+        }\n+\n+        private void addChild(String tokenString, Token token) {\n+            // If a child for the first character of the string exists, add the rest of the string to it as a child.\n+            if (this.children.containsKey(tokenString.charAt(0))) {\n+                // If the length of token string is 1, the child node is upgraded to a terminal token node.\n+                if (tokenString.length() == 1) {\n+                    this.children.get(tokenString.charAt(0)).token = token;\n+                } else {\n+                    this.children.get(tokenString.charAt(0)).addChild(tokenString.substring(1), token);\n+                }\n+            } else {\n+                this.children.put(tokenString.charAt(0), new TokenNode(tokenString, token, this));\n+            }\n+        }\n+\n+        public boolean isTokenNode() {\n+            return this.token != null;\n+        }\n+\n+        public boolean isRootNode() {\n+            return this.parent == null;\n+        }\n+\n+    }\n+\n+    private static final TreeMap<Integer, String> ROMAN_NUMERALS = new TreeMap<>();\n+\n+    static {\n+        ROMAN_NUMERALS.put(1000, \"M\");\n+        ROMAN_NUMERALS.put(800, \"CM\");\n+        ROMAN_NUMERALS.put(500, \"D\");\n+        ROMAN_NUMERALS.put(400, \"CD\");\n+        ROMAN_NUMERALS.put(100, \"C\");\n+        ROMAN_NUMERALS.put(80, \"XC\");\n+        ROMAN_NUMERALS.put(50, \"L\");\n+        ROMAN_NUMERALS.put(40, \"XL\");\n+        ROMAN_NUMERALS.put(10, \"X\");\n+        ROMAN_NUMERALS.put(9, \"IX\");\n+        ROMAN_NUMERALS.put(5, \"V\");\n+        ROMAN_NUMERALS.put(4, \"IV\");\n+        ROMAN_NUMERALS.put(1, \"I\");\n+    }\n+\n+    private static final TokenNode ROOT_TOKEN_NODE = new TokenNode();\n+\n+    static {\n+        for (Token token: Token.values()) {\n+            ROOT_TOKEN_NODE.addChild(token);\n+        }\n+    }\n+\n+    private final Object[] tokens;\n+\n+    private static final TemporalField WEEK_OF_YEAR = WeekFields.of(Locale.ENGLISH).weekOfWeekBasedYear();\n+\n+    public DateTimeFormatter(String pattern) {\n+        this.tokens = DateTimeFormatter.parse(pattern);\n+    }\n+\n+    private static Object[] parse(String pattern) {\n+        ArrayList<Object> tokens = new ArrayList<>();\n+        String pattern_to_consume = pattern;\n+        int idx = 0;\n+\n+        TokenNode currentTokenNode = ROOT_TOKEN_NODE;\n+        TokenNode nextTokenNode;\n+\n+        while (idx <= pattern_to_consume.length() && pattern_to_consume.length() > 0) {\n+\n+            if (idx == pattern_to_consume.length()) {\n+                nextTokenNode = null;\n+            } else {\n+                nextTokenNode = currentTokenNode.children.get(pattern_to_consume.charAt(idx));\n+            }\n+\n+            if (nextTokenNode == null && idx > 0) {\n+                // No next step along the tree, so the parser should terminate and reset.\n+                if (currentTokenNode.isTokenNode()) {\n+                    // If the current node is a token, then a valid token is found and added to the list.\n+                    // The token will then be removed from the rest of the string to parse.\n+                    tokens.add(currentTokenNode.token);\n+                } else {\n+                    // If the current node is not a token, the parser then traverses back up the tree until it either\n+                    // finds a token node, or the root.\n+                    int depth = idx;\n+\n+                    while (depth > 0) {\n+                        depth -= 1;\n+                        currentTokenNode = currentTokenNode.parent;\n+\n+                        if (currentTokenNode.isTokenNode()) {\n+                            // We have found the valid token, it should be added to the stack and the remaining rest\n+                            // of the parsed pattern should be added as a string.\n+                            tokens.add(currentTokenNode.token);\n+                            break;\n+                        }\n+                    }\n+\n+                    tokens.add(pattern_to_consume.substring(depth, idx));\n+                }\n+\n+                pattern_to_consume = pattern_to_consume.substring(idx);\n+                currentTokenNode = ROOT_TOKEN_NODE;\n+                idx = 0;\n+            } else if (nextTokenNode == null) {\n+                // If there is no path forward and index is 0, then we're at at the beginning, parsing a non-valid\n+                // character. Add as a string.\n+                tokens.add(pattern_to_consume.substring(0, idx + 1));\n+                pattern_to_consume = pattern_to_consume.substring(idx + 1);\n+            } else {\n+                idx += 1;\n+                currentTokenNode = nextTokenNode;\n+            }\n+        }\n+\n+        return tokens.toArray();\n+    }\n+\n+    public String format(LocalDateTime datetime) {\n+        String result = (String) Arrays.stream(this.tokens).sequential().reduce(\n+            \"\", (str, elem) -> {\n+                if (elem instanceof Token) {\n+                    str = str + getElement((Token) elem, datetime);\n+                } else if (elem instanceof String) {\n+                    str = str + String.valueOf(elem);\n+                }\n+                return str;\n+            }\n+        );\n+\n+        return result;\n+    }\n+\n+    private static String getElement(Token element, LocalDateTime datetime) {\n+        switch (element) {\n+            case HOUR_OF_DAY:\n+            case HOUR_OF_DAY12:\n+                if (datetime.getHour() >= 12) {\n+                    return StringUtils.leftpad(\n+                        String.valueOf(datetime.getHour() - 12),\n+                        2,\n+                        '0');\n+                } else {\n+                    return StringUtils.leftpad(String.valueOf(datetime.getHour()), 2, '0');\n+                }\n+            case HOUR_OF_DAY24:\n+                return StringUtils.leftpad(String.valueOf(datetime.getHour()), 2, '0');\n+            case MINUTE:\n+                return StringUtils.leftpad(String.valueOf(datetime.getMinute()), 2, '0');\n+            case SECOND:\n+                return StringUtils.leftpad(String.valueOf(datetime.getSecond()), 2, '0');\n+            case MILLISECOND:\n+                return StringUtils.leftpad(String.valueOf(datetime.getNano() / 1000000), 3, '0');\n+            case MICROSECOND:\n+                return StringUtils.leftpad(String.valueOf(datetime.getNano() / 1000), 6, '0');\n+            case TENTH_OF_SECOND:\n+                return String.valueOf(datetime.getNano() / 100000000);\n+            case HUNDREDTH_OF_SECOND:\n+                return String.valueOf(datetime.getNano() / 10000000);\n+            case MILLISECOND_FF:\n+                return String.valueOf(datetime.getNano() / 1000000);\n+            case TENTH_OF_MILLISECOND:\n+                return String.valueOf(datetime.getNano() / 100000);\n+            case HUNDREDTH_OF_MILLISECOND:\n+                return String.valueOf(datetime.getNano() / 10000);\n+            case MICROSECOND_FF:\n+                return String.valueOf(datetime.getNano() / 1000);\n+            case SECONDS_PAST_MIDNIGHT:\n+            case SECONDS_PAST_MIDNIGHT_S:\n+                Instant midnight = datetime.toLocalDate().atStartOfDay().toInstant(ZoneOffset.UTC);\n+                return String.valueOf(Duration.between(midnight, datetime.toInstant(ZoneOffset.UTC)).getSeconds());\n+            case AM_UPPER:\n+            case PM_UPPER:\n+                return datetime.getHour() >= 12 ? \"PM\" : \"AM\";\n+            case AM_LOWER:\n+            case PM_LOWER:\n+                return datetime.getHour() >= 12 ? \"pm\" : \"am\";\n+            case A_M_UPPER:\n+            case P_M_UPPER:\n+                return datetime.getHour() >= 12 ? \"P.M.\" : \"A.M.\";\n+            case A_M_LOWER:\n+            case P_M_LOWER:\n+                return datetime.getHour() >= 12 ? \"p.m.\" : \"a.m.\";\n+            case YEAR_WITH_COMMA:\n+                String s = String.valueOf(datetime.getYear());\n+                return s.substring(0, 1) + \",\" + s.substring(1);\n+            case YEAR_YYYY:\n+                return String.valueOf(datetime.getYear());\n+            case YEAR_YYY:\n+                s = String.valueOf(datetime.getYear());\n+                return s.substring(s.length() - 3);\n+            case YEAR_YY:\n+                s = String.valueOf(datetime.getYear());\n+                return s.substring(s.length() - 2);\n+            case YEAR_Y:\n+                s = String.valueOf(datetime.getYear());\n+                return s.substring(s.length() - 1);\n+            case ISO_YEAR_YYY:\n+                return String.valueOf(datetime.get(IsoFields.WEEK_BASED_YEAR));\n+            case ISO_YEAR_YY:\n+                s = String.valueOf(datetime.get(IsoFields.WEEK_BASED_YEAR));\n+                return s.substring(s.length() - 3);\n+            case ISO_YEAR_Y:\n+                s = String.valueOf(datetime.get(IsoFields.WEEK_BASED_YEAR));\n+                return s.substring(s.length() - 2);\n+            case ISO_YEAR:\n+                s = String.valueOf(datetime.get(IsoFields.WEEK_BASED_YEAR));\n+                return s.substring(s.length() - 1);\n+            case BC_ERA_UPPER:\n+            case AD_ERA_UPPER:\n+                return datetime.getYear() >= 1 ? \"AD\" : \"BC\";\n+            case BC_ERA_LOWER:\n+            case AD_ERA_LOWER:\n+                return datetime.getYear() >= 1 ? \"ad\" : \"bc\";\n+            case B_C_ERA_UPPER:\n+            case A_D_ERA_UPPER:\n+                return datetime.getYear() >= 1 ? \"A.D\" : \"B.C\";\n+            case B_C_ERA_LOWER:\n+            case A_D_ERA_LOWER:\n+                return datetime.getYear() >= 1 ? \"a.d\" : \"b.c\";\n+            case MONTH_UPPER:\n+                return StringUtils.rightpad(\n+                    datetime.getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH),\n+                    7,' '\n+                ).toUpperCase();\n+            case MONTH_CAPITALIZED:\n+                return StringUtils.capitalize(\n+                    StringUtils.rightpad(\n+                        datetime.getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH),\n+                        7, ' '\n+                    )\n+                );\n+            case MONTH_LOWER:\n+                return StringUtils.rightpad(\n+                    datetime.getMonth().getDisplayName(TextStyle.FULL, Locale.ENGLISH),\n+                    7, ' '\n+                ).toLowerCase();\n+            case ABBREVIATED_MONTH_UPPER:\n+                return datetime.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH).toUpperCase();\n+            case ABBREVIATED_MONTH_CAPITALIZED:\n+                return StringUtils.capitalize(\n+                    datetime.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH)\n+                );\n+            case ABBREVIATED_MONTH_LOWER:\n+                return datetime.getMonth().getDisplayName(TextStyle.SHORT, Locale.ENGLISH).toLowerCase();\n+            case MONTH_NUMBER:\n+                return StringUtils.leftpad(\n+                    String.valueOf(datetime.getMonth().getValue()),\n+                    2,\n+                    '0'\n+                );\n+            case DAY_UPPER:\n+                return StringUtils.rightpad(\n+                    datetime.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH),\n+                    8, ' '\n+                ).toUpperCase();\n+            case DAY_CAPITALIZED:\n+                return StringUtils.rightpad(\n+                    StringUtils.capitalize(\n+                        datetime.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH)\n+                    ), 8, ' ');\n+            case DAY_LOWER:\n+                return StringUtils.rightpad(\n+                    datetime.getDayOfWeek().getDisplayName(TextStyle.FULL, Locale.ENGLISH),\n+                    8,\n+                    ' '\n+                ).toLowerCase();\n+            case ABBREVIATED_DAY_UPPER:\n+                return datetime.getDayOfWeek().getDisplayName(TextStyle.SHORT, Locale.ENGLISH).toUpperCase();\n+            case ABBREVIATED_DAY_CAPITALIZED:\n+                return StringUtils.capitalize(\n+                    datetime.getDayOfWeek().getDisplayName(TextStyle.SHORT, Locale.ENGLISH)\n+                );\n+            case ABBREVIATED_DAY_LOWER:\n+                return datetime.getDayOfWeek().getDisplayName(TextStyle.SHORT, Locale.ENGLISH).toLowerCase();\n+            case DAY_OF_YEAR:\n+                return StringUtils.leftpad(\n+                    String.valueOf(datetime.getDayOfYear()),\n+                    3,\n+                    '0'\n+                );\n+            case DAY_OF_ISO_WEEK_NUMBERING_YEAR:\n+                return StringUtils.leftpad(\n+                    String.valueOf(\n+                        ((datetime.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR) - 1) * 7) + datetime.getDayOfWeek().getValue()),\n+                    3,\n+                    '0'\n+                );\n+            case DAY_OF_MONTH:\n+                return StringUtils.leftpad(\n+                    String.valueOf(datetime.getDayOfMonth()),\n+                    2,\n+                    '0'\n+                );\n+            case DAY_OF_WEEK:\n+                return String.valueOf((datetime.getDayOfWeek().getValue() % 7) + 1);\n+            case ISO_DAY_OF_WEEK:\n+                return String.valueOf(datetime.getDayOfWeek().getValue());\n+            case WEEK_OF_MONTH:\n+                return String.valueOf((datetime.getDayOfMonth() / 7) + 1);\n+            case WEEK_NUMBER_OF_YEAR:\n+                return StringUtils.leftpad(\n+                    String.valueOf(datetime.get(WEEK_OF_YEAR)),\n+                    2,\n+                    '0'\n+                );\n+            case WEEK_NUMBER_OF_ISO_YEAR:\n+                return StringUtils.leftpad(\n+                    String.valueOf(datetime.get(IsoFields.WEEK_OF_WEEK_BASED_YEAR)),\n+                    2,\n+                    '0'\n+                );\n+            case CENTURY:\n+                return String.valueOf(((datetime.getYear() - 1) / 100) + 1);\n+            case JULIAN_DAY:\n+                return String.valueOf(datetime.getLong(JulianFields.JULIAN_DAY));\n+            case QUARTER:\n+                return String.valueOf((datetime.getMonthValue() + 2) / 3);\n+            case ROMAN_MONTH_UPPER:\n+                return StringUtils.rightpad(\n+                    toRoman(datetime.getMonthValue()).toUpperCase(),\n+                    4,\n+                    ' '\n+                );\n+            case ROMAN_MONTH_LOWER:\n+                return StringUtils.rightpad(\n+                    toRoman(datetime.getMonthValue()).toLowerCase(),\n+                    4,\n+                    ' '\n+                );\n+            case TIMEZONE_UPPER:\n+            case TIMEZONE_LOWER:\n+            case TIMEZONE_HOURS:\n+            case TIMEZONE_MINUTES:\n+            case TIMEZONE_OFFSET_FROM_UTC:\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private static String toRoman(int number) {\n+        int l = ROMAN_NUMERALS.floorKey(number);\n+        if (number == l) {\n+            return ROMAN_NUMERALS.get(number);\n+        }\n+        return ROMAN_NUMERALS.get(l) + toRoman(number - l);", "originalCommit": "d066bfe86df89d4014e02ba3516f163127414310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ4ODExNw==", "url": "https://github.com/crate/crate/pull/10847#discussion_r537488117", "bodyText": "If you want to play with newer language features - I think this would be suited for a switch expression: https://docs.oracle.com/en/java/javase/13/language/switch-expressions.html", "author": "mfussenegger", "createdAt": "2020-12-07T13:00:46Z", "path": "server/src/main/java/io/crate/expression/scalar/formatting/DateTimeFormatter.java", "diffHunk": "@@ -0,0 +1,503 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.formatting;\n+\n+import io.crate.common.StringUtils;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.TextStyle;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.JulianFields;\n+import java.time.temporal.TemporalField;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+\n+public class DateTimeFormatter {\n+\n+    private enum Token {\n+        HOUR_OF_DAY(\"HH\"),\n+        HOUR_OF_DAY12(\"HH12\"),\n+        HOUR_OF_DAY24(\"HH24\"),\n+        MINUTE(\"MI\"),\n+        SECOND(\"SS\"),\n+        MILLISECOND(\"MS\"),\n+        MICROSECOND(\"US\"),\n+        TENTH_OF_SECOND(\"FF1\"),\n+        HUNDREDTH_OF_SECOND(\"FF2\"),\n+        MILLISECOND_FF(\"FF3\"),\n+        TENTH_OF_MILLISECOND(\"FF4\"),\n+        HUNDREDTH_OF_MILLISECOND(\"FF5\"),\n+        MICROSECOND_FF(\"FF6\"),\n+        SECONDS_PAST_MIDNIGHT(\"SSSS\"),\n+        SECONDS_PAST_MIDNIGHT_S(\"SSSSS\"),\n+        AM_UPPER(\"AM\"),\n+        AM_LOWER(\"am\"),\n+        PM_UPPER(\"PM\"),\n+        PM_LOWER(\"pm\"),\n+        A_M_UPPER(\"A.M.\"),\n+        A_M_LOWER(\"a.m.\"),\n+        P_M_UPPER(\"P.M.\"),\n+        P_M_LOWER(\"p.m.\"),\n+        YEAR_WITH_COMMA(\"Y,YYY\"),\n+        YEAR_YYYY(\"YYYY\"),\n+        YEAR_YYY(\"YYY\"),\n+        YEAR_YY(\"YY\"),\n+        YEAR_Y(\"Y\"),\n+        ISO_YEAR_YYY(\"IYYY\"),\n+        ISO_YEAR_YY(\"IYY\"),\n+        ISO_YEAR_Y(\"IY\"),\n+        ISO_YEAR(\"I\"),\n+        BC_ERA_UPPER(\"BC\"),\n+        BC_ERA_LOWER(\"bc\"),\n+        AD_ERA_UPPER(\"AD\"),\n+        AD_ERA_LOWER(\"ad\"),\n+        B_C_ERA_UPPER(\"B.C\"),\n+        B_C_ERA_LOWER(\"b.c\"),\n+        A_D_ERA_UPPER(\"A.D\"),\n+        A_D_ERA_LOWER(\"a.d\"),\n+        MONTH_UPPER(\"MONTH\"),\n+        MONTH_CAPITALIZED(\"Month\"),\n+        MONTH_LOWER(\"month\"),\n+        ABBREVIATED_MONTH_UPPER(\"MON\"),\n+        ABBREVIATED_MONTH_CAPITALIZED(\"Mon\"),\n+        ABBREVIATED_MONTH_LOWER(\"mon\"),\n+        MONTH_NUMBER(\"MM\"),\n+        DAY_UPPER(\"DAY\"),\n+        DAY_CAPITALIZED(\"Day\"),\n+        DAY_LOWER(\"day\"),\n+        ABBREVIATED_DAY_UPPER(\"DY\"),\n+        ABBREVIATED_DAY_CAPITALIZED(\"Dy\"),\n+        ABBREVIATED_DAY_LOWER(\"dy\"),\n+        DAY_OF_YEAR(\"DDD\"),\n+        DAY_OF_ISO_WEEK_NUMBERING_YEAR(\"IDDD\"),\n+        DAY_OF_MONTH(\"DD\"),\n+        DAY_OF_WEEK(\"D\"),\n+        ISO_DAY_OF_WEEK(\"ID\"),\n+        WEEK_OF_MONTH(\"W\"),\n+        WEEK_NUMBER_OF_YEAR(\"WW\"),\n+        WEEK_NUMBER_OF_ISO_YEAR(\"IW\"),\n+        CENTURY(\"CC\"),\n+        JULIAN_DAY(\"J\"),\n+        QUARTER(\"Q\"),\n+        ROMAN_MONTH_UPPER(\"RM\"),\n+        ROMAN_MONTH_LOWER(\"rm\"),\n+        TIMEZONE_UPPER(\"TZ\"),\n+        TIMEZONE_LOWER(\"tz\"),\n+        TIMEZONE_HOURS(\"TZH\"),\n+        TIMEZONE_MINUTES(\"TZM\"),\n+        TIMEZONE_OFFSET_FROM_UTC(\"OF\"),;\n+\n+        private final String token;\n+\n+        Token(final String token) {\n+            this.token = token;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return this.token;\n+        }\n+\n+    }\n+\n+    static class TokenNode {\n+        private final Map<Character, TokenNode> children = new HashMap<>();\n+        private Token token;\n+        public final TokenNode parent;\n+\n+        public TokenNode() {\n+            this.token = null;\n+            this.parent = null;\n+        }\n+\n+        private TokenNode(String tokenString, Token token, TokenNode parent) {\n+            this.parent = parent;\n+            if (tokenString.length() == 1) {\n+                // Last character of the token string, so a terminal leaf.\n+                this.token = token;\n+            } else {\n+                this.token = null;\n+                this.addChild(tokenString.substring(1), token);\n+            }\n+        }\n+\n+        public void addChild(Token token) {\n+            this.addChild(token.toString(), token);\n+        }\n+\n+        private void addChild(String tokenString, Token token) {\n+            // If a child for the first character of the string exists, add the rest of the string to it as a child.\n+            if (this.children.containsKey(tokenString.charAt(0))) {\n+                // If the length of token string is 1, the child node is upgraded to a terminal token node.\n+                if (tokenString.length() == 1) {\n+                    this.children.get(tokenString.charAt(0)).token = token;\n+                } else {\n+                    this.children.get(tokenString.charAt(0)).addChild(tokenString.substring(1), token);\n+                }\n+            } else {\n+                this.children.put(tokenString.charAt(0), new TokenNode(tokenString, token, this));\n+            }\n+        }\n+\n+        public boolean isTokenNode() {\n+            return this.token != null;\n+        }\n+\n+        public boolean isRootNode() {\n+            return this.parent == null;\n+        }\n+\n+    }\n+\n+    private static final TreeMap<Integer, String> ROMAN_NUMERALS = new TreeMap<>();\n+\n+    static {\n+        ROMAN_NUMERALS.put(1000, \"M\");\n+        ROMAN_NUMERALS.put(800, \"CM\");\n+        ROMAN_NUMERALS.put(500, \"D\");\n+        ROMAN_NUMERALS.put(400, \"CD\");\n+        ROMAN_NUMERALS.put(100, \"C\");\n+        ROMAN_NUMERALS.put(80, \"XC\");\n+        ROMAN_NUMERALS.put(50, \"L\");\n+        ROMAN_NUMERALS.put(40, \"XL\");\n+        ROMAN_NUMERALS.put(10, \"X\");\n+        ROMAN_NUMERALS.put(9, \"IX\");\n+        ROMAN_NUMERALS.put(5, \"V\");\n+        ROMAN_NUMERALS.put(4, \"IV\");\n+        ROMAN_NUMERALS.put(1, \"I\");\n+    }\n+\n+    private static final TokenNode ROOT_TOKEN_NODE = new TokenNode();\n+\n+    static {\n+        for (Token token: Token.values()) {\n+            ROOT_TOKEN_NODE.addChild(token);\n+        }\n+    }\n+\n+    private final Object[] tokens;\n+\n+    private static final TemporalField WEEK_OF_YEAR = WeekFields.of(Locale.ENGLISH).weekOfWeekBasedYear();\n+\n+    public DateTimeFormatter(String pattern) {\n+        this.tokens = DateTimeFormatter.parse(pattern);\n+    }\n+\n+    private static Object[] parse(String pattern) {\n+        ArrayList<Object> tokens = new ArrayList<>();\n+        String pattern_to_consume = pattern;\n+        int idx = 0;\n+\n+        TokenNode currentTokenNode = ROOT_TOKEN_NODE;\n+        TokenNode nextTokenNode;\n+\n+        while (idx <= pattern_to_consume.length() && pattern_to_consume.length() > 0) {\n+\n+            if (idx == pattern_to_consume.length()) {\n+                nextTokenNode = null;\n+            } else {\n+                nextTokenNode = currentTokenNode.children.get(pattern_to_consume.charAt(idx));\n+            }\n+\n+            if (nextTokenNode == null && idx > 0) {\n+                // No next step along the tree, so the parser should terminate and reset.\n+                if (currentTokenNode.isTokenNode()) {\n+                    // If the current node is a token, then a valid token is found and added to the list.\n+                    // The token will then be removed from the rest of the string to parse.\n+                    tokens.add(currentTokenNode.token);\n+                } else {\n+                    // If the current node is not a token, the parser then traverses back up the tree until it either\n+                    // finds a token node, or the root.\n+                    int depth = idx;\n+\n+                    while (depth > 0) {\n+                        depth -= 1;\n+                        currentTokenNode = currentTokenNode.parent;\n+\n+                        if (currentTokenNode.isTokenNode()) {\n+                            // We have found the valid token, it should be added to the stack and the remaining rest\n+                            // of the parsed pattern should be added as a string.\n+                            tokens.add(currentTokenNode.token);\n+                            break;\n+                        }\n+                    }\n+\n+                    tokens.add(pattern_to_consume.substring(depth, idx));\n+                }\n+\n+                pattern_to_consume = pattern_to_consume.substring(idx);\n+                currentTokenNode = ROOT_TOKEN_NODE;\n+                idx = 0;\n+            } else if (nextTokenNode == null) {\n+                // If there is no path forward and index is 0, then we're at at the beginning, parsing a non-valid\n+                // character. Add as a string.\n+                tokens.add(pattern_to_consume.substring(0, idx + 1));\n+                pattern_to_consume = pattern_to_consume.substring(idx + 1);\n+            } else {\n+                idx += 1;\n+                currentTokenNode = nextTokenNode;\n+            }\n+        }\n+\n+        return tokens.toArray();\n+    }\n+\n+    public String format(LocalDateTime datetime) {\n+        String result = (String) Arrays.stream(this.tokens).sequential().reduce(\n+            \"\", (str, elem) -> {\n+                if (elem instanceof Token) {\n+                    str = str + getElement((Token) elem, datetime);\n+                } else if (elem instanceof String) {\n+                    str = str + String.valueOf(elem);\n+                }\n+                return str;\n+            }\n+        );\n+\n+        return result;\n+    }\n+\n+    private static String getElement(Token element, LocalDateTime datetime) {\n+        switch (element) {", "originalCommit": "d066bfe86df89d4014e02ba3516f163127414310", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "926eee043d6028ac9694c88b34e83175f50a176d", "url": "https://github.com/crate/crate/commit/926eee043d6028ac9694c88b34e83175f50a176d", "message": "Remove roman numeral tree map, replace with sb/for loop\n\nAlso, reduce the number roman characters since this function is only used for month numbers, which are 1-12", "committedDate": "2020-12-09T10:33:43Z", "type": "forcePushed"}, {"oid": "bf94fdc573366f32b6104ae92a8dcd60d54cc406", "url": "https://github.com/crate/crate/commit/bf94fdc573366f32b6104ae92a8dcd60d54cc406", "message": "Add postgres syntax compatible parser for to_char scalar function", "committedDate": "2020-12-09T15:07:01Z", "type": "commit"}, {"oid": "bf94fdc573366f32b6104ae92a8dcd60d54cc406", "url": "https://github.com/crate/crate/commit/bf94fdc573366f32b6104ae92a8dcd60d54cc406", "message": "Add postgres syntax compatible parser for to_char scalar function", "committedDate": "2020-12-09T15:07:01Z", "type": "forcePushed"}]}