{"pr_number": 9763, "pr_title": "Add new signature based function registry ", "pr_createdAt": "2020-03-13T14:46:42Z", "pr_url": "https://github.com/crate/crate/pull/9763", "timeline": [{"oid": "e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "url": "https://github.com/crate/crate/commit/e527fde3d0223d0db1a1c00b185ccbca7c1e48a9", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [] Support iteration over registered function incl. all info\u2019s required by `pg_proc`\n - [x] Use type precendence and cast if needed\n - [] Move (down-)cast lucene optimization to a rule", "committedDate": "2020-03-13T15:04:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392279860", "bodyText": "I think we output this in information_schema tables, so this may be a breaking change. If we do need to change it, maybe we  could go with innerType.getName() + '[]' for improved PostgreSQL compatibility?", "author": "mfussenegger", "createdAt": "2020-03-13T14:57:26Z", "path": "common/src/main/java/io/crate/types/ArrayType.java", "diffHunk": "@@ -83,7 +93,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n     @Override\n     public String getName() {\n-        return innerType.getName() + \"_\" + NAME;\n+        return NAME + \"(\" + innerType.getName() + \")\";", "originalCommit": "55fcc69ceb8ce55c02e299716218664eb06c6052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkwMDQzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392900431", "bodyText": "I think we should change it as parsing a E_array (for declaring generic array type signatures) may be error prone, and also it is not good human readable IMO.\nTotally agree that we should try to change it in the right direction, will try to implement it using E[].", "author": "seut", "createdAt": "2020-03-16T10:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxOTIwOQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392919209", "bodyText": "Once you've confirmed that E[] works, could we extract the change into a dedicated PR?", "author": "mfussenegger", "createdAt": "2020-03-16T10:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkyOTkyMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392929921", "bodyText": "Or maybe we split this into internalName() / externalName() and defer the breaking change to 5.0?", "author": "mfussenegger", "createdAt": "2020-03-16T10:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjk0ODEyMg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392948122", "bodyText": "I've just figured out that we don't need to change that as I've handling array signature resolving in concrete way anyway already. So changing this representation would be out of scope for the new signature binding.", "author": "seut", "createdAt": "2020-03-16T11:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI3OTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392281372", "bodyText": "What do you think of going for module.register(signature, types -> impl), and omit the FuncResolver from the register API?", "author": "mfussenegger", "createdAt": "2020-03-13T14:59:52Z", "path": "sql/src/main/java/io/crate/expression/scalar/ConcatFunction.java", "diffHunk": "@@ -21,36 +21,81 @@\n \n package io.crate.expression.scalar;\n \n-import com.google.common.base.Preconditions;\n import io.crate.data.Input;\n-import io.crate.exceptions.ConversionException;\n-import io.crate.expression.symbol.FuncArg;\n import io.crate.expression.symbol.Function;\n import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.FuncResolver;\n import io.crate.metadata.FunctionIdent;\n-import io.crate.metadata.FunctionImplementation;\n import io.crate.metadata.FunctionInfo;\n-import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.FunctionName;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n-import io.crate.metadata.functions.params.FuncParams;\n-import io.crate.metadata.functions.params.Param;\n-import io.crate.types.ArrayType;\n-import io.crate.types.DataType;\n+import io.crate.metadata.functions.Signature;\n import io.crate.types.DataTypes;\n \n-import javax.annotation.Nullable;\n+import java.util.Collections;\n import java.util.List;\n-import java.util.Locale;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n \n public abstract class ConcatFunction extends Scalar<String, String> {\n \n     public static final String NAME = \"concat\";\n     private FunctionInfo functionInfo;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        FunctionName name = new FunctionName(null, NAME);\n+\n+        module.register(\n+            new FuncResolver(", "originalCommit": "55fcc69ceb8ce55c02e299716218664eb06c6052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg5NzM1OA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392897358", "bodyText": "You mean to create a FuncResolver instance only internally? Sure good point, we just need this class internally for the resolving anyway.", "author": "seut", "createdAt": "2020-03-16T09:55:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjkxOTUzOQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r392919539", "bodyText": "You mean to create a FuncResolver instance only internally?\n\nyes", "author": "mfussenegger", "createdAt": "2020-03-16T10:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4MTM3Mg=="}], "type": "inlineReview"}, {"oid": "a40611b8f14b1a4784ce0e26461ce5effffef895", "url": "https://github.com/crate/crate/commit/a40611b8f14b1a4784ce0e26461ce5effffef895", "message": "fixup! WIP: refactor function registration and resolving", "committedDate": "2020-03-16T21:31:02Z", "type": "forcePushed"}, {"oid": "9a7922b487370f2b3c300b8d2b34104445ac3241", "url": "https://github.com/crate/crate/commit/9a7922b487370f2b3c300b8d2b34104445ac3241", "message": "fixup! WIP: refactor function registration and resolving", "committedDate": "2020-03-16T21:33:28Z", "type": "forcePushed"}, {"oid": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "url": "https://github.com/crate/crate/commit/93edb2cb269dd2510ffe9de10ccc94961994a0c2", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed", "committedDate": "2020-03-20T13:27:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r395640311", "bodyText": "This is not really correct, depending on the argument types it will change to object(text, V, text, V2, ...) where V and V2 may be bound to different types.\nCurrently the return type is not used so it won't matter, but will be later used for information of all registered functions (pg_proc).\nNot sure, shall we define it as object() (undefined inner types)? We could also discuss/change it when adding the signature information to pg_proc.", "author": "seut", "createdAt": "2020-03-20T13:37:11Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/MapFunction.java", "diffHunk": "@@ -90,7 +78,17 @@ public final Object evaluate(TransactionContext txnCtx, Input<Object>... args) {\n         return m;\n     }\n \n-    public static void register(ScalarFunctionModule scalarFunctionModule) {\n-        scalarFunctionModule.register(NAME, RESOLVER);\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.builder()\n+                .name(new FunctionName(null, NAME))\n+                .kind(FunctionInfo.Type.SCALAR)\n+                .typeVariableConstraints(List.of(typeVariableOfAnyType(\"V\")))\n+                .argumentTypes(parseTypeSignature(\"text\"), parseTypeSignature(\"V\"))\n+                .returnType(parseTypeSignature(\"object(text, V)\"))", "originalCommit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxODczMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396318731", "bodyText": "Not sure how to deal with this, but maybe meanwhile add a comment inline to point this out.", "author": "mfussenegger", "createdAt": "2020-03-23T09:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTIwOQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r395641209", "bodyText": "This class will supersede the FunctionResolver class once all functions are changed to the new signature based registration.", "author": "seut", "createdAt": "2020-03-20T13:38:39Z", "path": "sql/src/main/java/io/crate/metadata/FuncResolver.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata;\n+\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.function.Function;\n+\n+public class FuncResolver implements Function<List<DataType>, FunctionImplementation> {", "originalCommit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r395641751", "bodyText": "This class just acts a Map holder, we could also use the map directly and remove this class. I tend to keep it mainly for readability reasons inside the SignatureBinder. Any input?", "author": "seut", "createdAt": "2020-03-20T13:39:29Z", "path": "sql/src/main/java/io/crate/metadata/functions/BoundVariables.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.types.DataType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+public class BoundVariables {\n+\n+    private final Map<String, DataType<?>> typeVariables;", "originalCommit": "93edb2cb269dd2510ffe9de10ccc94961994a0c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTYzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319631", "bodyText": "I think it is okay to keep it, but if so it should fully encapsulate typeVariables. Currently it also leaks the map via  public Map<String, DataType<?>> getTypeVariables() {", "author": "mfussenegger", "createdAt": "2020-03-23T09:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0MTc1MQ=="}], "type": "inlineReview"}, {"oid": "046cc3051132bb213b51dc22a8097c824d9129e4", "url": "https://github.com/crate/crate/commit/046cc3051132bb213b51dc22a8097c824d9129e4", "message": "WIP: refactor function registration and resolving\n\n - [x] Support function overloading\n - [x] Use type precendence and cast if needed", "committedDate": "2020-03-20T13:40:11Z", "type": "forcePushed"}, {"oid": "856c4ce868244694941c78ac38b2369da550943c", "url": "https://github.com/crate/crate/commit/856c4ce868244694941c78ac38b2369da550943c", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or \nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted, \nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-20T14:13:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5OTI0Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396299247", "bodyText": "Would it make sense to have this method in TypeSignature ? signature.createType() or something like that?", "author": "mfussenegger", "createdAt": "2020-03-23T09:05:09Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMDE0OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396300149", "bodyText": "I'd inline this. It's a shallow method that adds no additional meaning.", "author": "mfussenegger", "createdAt": "2020-03-23T09:06:48Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMjg4MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396302880", "bodyText": "Maybe make this top-level. I think if we move the getType into TypeSignature we could get rid of the TypeSignatures \"utils\" style class and expose the getCommonSuperType as part of the (then top-level) TypeCompatibility class. This would make the responsibility imho a bit clearer.", "author": "mfussenegger", "createdAt": "2020-03-23T09:11:48Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMzI0NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396303245", "bodyText": "Is the cyclic dependency here really needed (TypeSignatureParameter has a reference to TypeSignature, TypeSignature has references to TypeSignatureParameter)", "author": "mfussenegger", "createdAt": "2020-03-23T09:12:33Z", "path": "common/src/main/java/io/crate/types/TypeSignatureParameter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.Objects;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class TypeSignatureParameter {\n+\n+    private final TypeSignature value;\n+\n+    public static TypeSignatureParameter of(TypeSignature typeSignature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMjg1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396312851", "bodyText": "I think we could remove TypeSignatureParameter at all as it won't add any functionality.", "author": "seut", "createdAt": "2020-03-23T09:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwMzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwNzQ2NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396307465", "bodyText": "Maybe clarify that base is (part of) the type name.", "author": "mfussenegger", "createdAt": "2020-03-23T09:19:57Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignatureParameter> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(format(Locale.ENGLISH, \"Bad type signature: '%s'\", signature));\n+    }\n+\n+    private static TypeSignatureParameter parseTypeSignatureParameter(String signature, int begin, int end) {\n+        String parameterName = signature.substring(begin, end).trim();\n+        return TypeSignatureParameter.of(parseTypeSignature(parameterName));\n+    }\n+\n+    private final String base;\n+    private final List<TypeSignatureParameter> parameters;\n+\n+    public TypeSignature(String base) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwODQ3Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396308477", "bodyText": "Could you add a comment somewhere that explains why we \"default\" to covariant?  (This is not configurable so far as part of the Signature building, right?)", "author": "mfussenegger", "createdAt": "2020-03-23T09:21:49Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4ODI3OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396488279", "bodyText": "I've changed this slightly and removed some other covariant logic as I think a covariant or invariant can already expressed by type variables.", "author": "seut", "createdAt": "2020-03-23T14:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMwODQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMDg0OA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396310848", "bodyText": "I'm not sure if superType is the right term, as we have no type hierarchies (?). So far in other places we used targetType - not sure if that's better.", "author": "mfussenegger", "createdAt": "2020-03-23T09:25:43Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxMjc1Mw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396312753", "bodyText": "Would it make sense to have the getBase()  directly in DataType ? E.g. type.getBaseName(). Would make sure that we don't construct the TypeSignature multiple times.", "author": "mfussenegger", "createdAt": "2020-03-23T09:28:42Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDU3Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314577", "bodyText": "I think a \"why\" comment would be more useful here. Explain why the commonSuperType logic above can fail and which cases are enabled here.", "author": "mfussenegger", "createdAt": "2020-03-23T09:31:49Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNDg1Nw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396314857", "bodyText": "This could probably be a singleton.", "author": "mfussenegger", "createdAt": "2020-03-23T09:32:18Z", "path": "common/src/main/java/io/crate/types/TypeSignatures.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class TypeSignatures {\n+\n+    /**\n+     * Gets the type with the specified signature.\n+     */\n+    public static DataType<?> getType(TypeSignature signature) {\n+        String base = signature.getBase();\n+        List<TypeSignatureParameter> parameters = signature.getParameters();\n+        if (base.equalsIgnoreCase(ArrayType.NAME)) {\n+            if (parameters.size() == 0) {\n+                return new ArrayType<>(UndefinedType.INSTANCE);\n+            }\n+            DataType<?> innerType = getType(parameters.get(0).getTypeSignature());\n+            return new ArrayType<>(innerType);\n+        }\n+        if (base.equalsIgnoreCase(ObjectType.NAME)) {\n+            var builder = ObjectType.builder();\n+            for (int i = 0; i < parameters.size() - 1;) {\n+                var valTypeSignature = parameters.get(i + 1);\n+                builder.setInnerType(String.valueOf(i), getType(valTypeSignature.getTypeSignature()));\n+                i += 2;\n+            }\n+            return builder.build();\n+        }\n+        return DataTypes.ofName(signature.getBase());\n+    }\n+\n+    @Nullable\n+    public static DataType<?> getCommonSuperType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonSuperType();\n+    }\n+\n+    public static boolean canCoerce(DataType<?> fromType, DataType<?> toType) {\n+        return fromType.isConvertableTo(toType);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+        String fromTypeBaseName = fromType.getTypeSignature().getBase();\n+        String toTypeBaseName = toType.getTypeSignature().getBase();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            if (isCovariantParametrizedType(fromType)) {\n+                return typeCompatibilityForCovariantParametrizedType(fromType, toType);\n+            }\n+            return TypeCompatibility.compatible(fromType, false);\n+        }\n+\n+        // Use possible common super type (safe conversion)\n+        DataType<?> commonSuperType = convertTypeByPrecedence(fromType, toType);\n+        if (commonSuperType != null) {\n+            return TypeCompatibility.compatible(commonSuperType, commonSuperType.equals(toType));\n+        }\n+\n+        // Try to force conversion, first to the target type or if fails to the source type (possible unsafe conversion)\n+        DataType<?> coercedType = coerceTypeBase(fromType, toType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            return compatibility(coercedType, toType);\n+        }\n+\n+        coercedType = coerceTypeBase(toType, fromType.getTypeSignature().getBase());\n+        if (coercedType != null) {\n+            TypeCompatibility typeCompatibility = compatibility(fromType, coercedType);\n+            if (!typeCompatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            return TypeCompatibility.compatible(typeCompatibility.getCommonSuperType(), false);\n+        }\n+\n+        return TypeCompatibility.incompatible();\n+    }\n+\n+    @Nullable\n+    private static DataType<?> convertTypeByPrecedence(DataType<?> arg1, DataType<?> arg2) {\n+        final DataType<?> higherPrecedenceArg;\n+        final DataType<?> lowerPrecedenceArg;\n+        if (arg1.precedes(arg2)) {\n+            higherPrecedenceArg = arg1;\n+            lowerPrecedenceArg = arg2;\n+        } else {\n+            higherPrecedenceArg = arg2;\n+            lowerPrecedenceArg = arg1;\n+        }\n+\n+        final boolean lowerPrecedenceCastable = lowerPrecedenceArg.isConvertableTo(higherPrecedenceArg);\n+        final boolean higherPrecedenceCastable = higherPrecedenceArg.isConvertableTo(lowerPrecedenceArg);\n+\n+        if (lowerPrecedenceCastable) {\n+            return higherPrecedenceArg;\n+        } else if (higherPrecedenceCastable) {\n+            return lowerPrecedenceArg;\n+        }\n+\n+        return null;\n+    }\n+\n+    @Nullable\n+    private static DataType<?> coerceTypeBase(DataType<?> sourceType, String resultTypeBase) {\n+        DataType<?> resultType = getType(parseTypeSignature(resultTypeBase));\n+        if (resultType.equals(sourceType)) {\n+            return sourceType;\n+        }\n+        return convertTypeByPrecedence(sourceType, resultType);\n+    }\n+\n+    private static boolean isCovariantParametrizedType(DataType<?> type) {\n+        // if we ever introduce contravariant, this function should be changed to return an enumeration: INVARIANT, COVARIANT, CONTRAVARIANT\n+        return type instanceof ObjectType || type instanceof ArrayType;\n+    }\n+\n+    private static TypeCompatibility typeCompatibilityForCovariantParametrizedType(DataType<?> fromType, DataType<?> toType) {\n+        ArrayList<TypeSignatureParameter> commonParameterTypes = new ArrayList<>();\n+        List<DataType<?>> fromTypeParameters = fromType.getTypeParameters();\n+        List<DataType<?>> toTypeParameters = toType.getTypeParameters();\n+\n+        if (fromTypeParameters.size() != toTypeParameters.size()) {\n+            return TypeCompatibility.incompatible();\n+        }\n+\n+        boolean coercible = true;\n+        for (int i = 0; i < fromTypeParameters.size(); i++) {\n+            TypeCompatibility compatibility = compatibility(fromTypeParameters.get(i), toTypeParameters.get(i));\n+            if (!compatibility.isCompatible()) {\n+                return TypeCompatibility.incompatible();\n+            }\n+            coercible &= compatibility.isCoercible();\n+            commonParameterTypes.add(TypeSignatureParameter.of(compatibility.getCommonSuperType().getTypeSignature()));\n+        }\n+        String typeBase = fromType.getTypeSignature().getBase();\n+        return TypeCompatibility.compatible(\n+            getType(new TypeSignature(typeBase, Collections.unmodifiableList(commonParameterTypes))),\n+            coercible);\n+    }\n+\n+    public static class TypeCompatibility {\n+        @Nullable\n+        private final DataType<?> commonSuperType;\n+        private final boolean coercible;\n+\n+        private TypeCompatibility(DataType<?> commonSuperType, boolean coercible) {\n+            this.commonSuperType = commonSuperType;\n+            this.coercible = coercible;\n+        }\n+\n+        private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+            return new TypeCompatibility(commonSuperType, coercible);\n+        }\n+\n+        private static TypeCompatibility incompatible() {\n+            return new TypeCompatibility(null, false);", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTk0Ng==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396315946", "bodyText": "Do you think it would make sense to have a shortcut for the common case?\nLike Signature.scalar(NAME, DataType<?> ... types) where the last type is the return type.", "author": "mfussenegger", "createdAt": "2020-03-23T09:33:55Z", "path": "sql/src/main/java/io/crate/expression/scalar/ArrayCatFunction.java", "diffHunk": "@@ -53,7 +54,17 @@ public static FunctionInfo createInfo(List<DataType> types) {\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        module.register(\n+            Signature.builder()", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ4OTMwNw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396489307", "bodyText": "Yes sure, I've planned to add them later on when moving more functions to the new registry but maybe its worth doing already", "author": "seut", "createdAt": "2020-03-23T14:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNTk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxNzYzNQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396317635", "bodyText": "I think the signature here should be documented. For example that array and object is treated in a special way is important (via TypeSignatures.getType).", "author": "mfussenegger", "createdAt": "2020-03-23T09:36:45Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    public static TypeSignature parseTypeSignature(String signature) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTA4NA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396319084", "bodyText": "Can this TODO be resolved?", "author": "mfussenegger", "createdAt": "2020-03-23T09:38:58Z", "path": "sql/src/main/java/io/crate/metadata/Functions.java", "diffHunk": "@@ -169,13 +193,51 @@ private FunctionImplementation getBuiltin(FunctionName functionName, List<DataTy\n     private FunctionImplementation getBuiltinByArgs(FunctionName functionName,\n                                                     List<? extends FuncArg> argumentsTypes,\n                                                     SearchPath searchPath) {\n+        // V2\n+        FunctionImplementation impl = resolveFunctionBySignature(\n+            functionName,\n+            Lists2.map(argumentsTypes, FuncArg::valueType),\n+            searchPath\n+        );\n+        if (impl != null) {\n+            return impl;\n+        }\n+\n         FunctionResolver resolver = lookupFunctionResolver(functionName, searchPath, functionResolvers::get);\n         if (resolver == null) {\n             return null;\n         }\n         return resolveFunctionForArgumentTypes(argumentsTypes, resolver);\n     }\n \n+    @Nullable\n+    private FunctionImplementation resolveFunctionBySignature(FunctionName name,\n+                                                              List<DataType> arguments,\n+                                                              SearchPath searchPath) {\n+        var candidates = functionImplementations.get(name);\n+        if (candidates == null && name.schema() == null) {\n+            for (String pathSchema : searchPath) {\n+                FunctionName searchPathFunctionName = new FunctionName(pathSchema, name.name());\n+                candidates = functionImplementations.get(searchPathFunctionName);\n+                if (candidates != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        if (candidates != null) {\n+            for (FuncResolver candidate : candidates) {\n+                Signature boundSignature = new SignatureBinder(candidate.getSignature(), true)\n+                    .bind(arguments);\n+                if (boundSignature != null) {\n+                    // TODO: check for more specific function", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ5NjExNw==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396496117", "bodyText": "I'll follow up on here later, maybe even on a dedicated commit.", "author": "seut", "createdAt": "2020-03-23T14:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMxOTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDQzMQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320431", "bodyText": "Can you add some assertions that make sure all required properties are set? (name, kind, argument types..)", "author": "mfussenegger", "createdAt": "2020-03-23T09:41:08Z", "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMyMDkzNg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396320936", "bodyText": "No need to change but fyi: I recently added a Lists2.joinOn", "author": "mfussenegger", "createdAt": "2020-03-23T09:42:01Z", "path": "sql/src/main/java/io/crate/metadata/functions/Signature.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionName;\n+import io.crate.types.TypeSignature;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Signature {\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static class Builder {\n+        private FunctionName name;\n+        private FunctionInfo.Type kind;\n+        private List<TypeSignature> argumentTypes = Collections.emptyList();\n+        private TypeSignature returnType;\n+        private List<TypeVariableConstraint> typeVariableConstraints = Collections.emptyList();\n+        private List<TypeSignature> variableArityGroup = Collections.emptyList();\n+        private boolean variableArity = false;\n+\n+        public Builder name(String name) {\n+            return name(new FunctionName(null, name));\n+        }\n+\n+        public Builder name(FunctionName name) {\n+            this.name = name;\n+            return this;\n+        }\n+\n+        public Builder kind(FunctionInfo.Type kind) {\n+            this.kind = kind;\n+            return this;\n+        }\n+\n+        public Builder argumentTypes(TypeSignature... argumentTypes) {\n+            return argumentTypes(List.of(argumentTypes));\n+        }\n+\n+        public Builder argumentTypes(List<TypeSignature> argumentTypes) {\n+            this.argumentTypes = argumentTypes;\n+            return this;\n+        }\n+\n+        public Builder returnType(TypeSignature returnType) {\n+            this.returnType = returnType;\n+            return this;\n+        }\n+\n+        public Builder typeVariableConstraints(TypeVariableConstraint... typeVariableConstraints) {\n+            return typeVariableConstraints(List.of(typeVariableConstraints));\n+        }\n+\n+        public Builder typeVariableConstraints(List<TypeVariableConstraint> typeVariableConstraints) {\n+            this.typeVariableConstraints = typeVariableConstraints;\n+            return this;\n+        }\n+\n+        public Builder variableArityGroup(List<TypeSignature> variableArityGroup) {\n+            this.variableArityGroup = variableArityGroup;\n+            this.variableArity = !variableArityGroup.isEmpty();\n+            return this;\n+        }\n+\n+        public Builder setVariableArity(boolean variableArity) {\n+            this.variableArity = variableArity;\n+            return this;\n+        }\n+\n+        public Signature build() {\n+            return new Signature(\n+                name,\n+                kind,\n+                typeVariableConstraints,\n+                argumentTypes,\n+                returnType,\n+                variableArityGroup,\n+                variableArity);\n+        }\n+    }\n+\n+\n+    private final FunctionName name;\n+    private final FunctionInfo.Type kind;\n+    private final List<TypeSignature> argumentTypes;\n+    private final TypeSignature returnType;\n+    private final List<TypeVariableConstraint> typeVariableConstraints;\n+    private final List<TypeSignature> variableArityGroup;\n+    private final boolean variableArity;\n+\n+    private Signature(FunctionName name,\n+                      FunctionInfo.Type kind,\n+                      List<TypeVariableConstraint> typeVariableConstraints,\n+                      List<TypeSignature> argumentTypes,\n+                      TypeSignature returnType,\n+                      List<TypeSignature> variableArityGroup,\n+                      boolean variableArity) {\n+        this.name = name;\n+        this.kind = kind;\n+        this.argumentTypes = argumentTypes;\n+        this.typeVariableConstraints = typeVariableConstraints;\n+        this.returnType = returnType;\n+        this.variableArityGroup = variableArityGroup;\n+        this.variableArity = variableArity;\n+    }\n+\n+    public FunctionName getName() {\n+        return name;\n+    }\n+\n+    public FunctionInfo.Type getKind() {\n+        return kind;\n+    }\n+\n+    public List<TypeSignature> getArgumentTypes() {\n+        return argumentTypes;\n+    }\n+\n+    public TypeSignature getReturnType() {\n+        return returnType;\n+    }\n+\n+    public List<TypeVariableConstraint> getTypeVariableConstraints() {\n+        return typeVariableConstraints;\n+    }\n+\n+    public List<TypeSignature> getVariableArityGroup() {\n+        return variableArityGroup;\n+    }\n+\n+    public boolean isVariableArity() {\n+        return variableArity;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        List<String> allConstraints = Lists2.map(typeVariableConstraints, TypeVariableConstraint::toString);\n+\n+        return name + (allConstraints.isEmpty() ? \"\" : \"<\" + String.join(\",\", allConstraints) + \">\") +\n+               \"(\" + String.join(\",\", Lists2.map(argumentTypes, TypeSignature::toString)) + \"):\" + returnType;", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjM5MzI4OQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396393289", "bodyText": "Given that there are already static constructors for both cases I think this overload could be removed", "author": "mfussenegger", "createdAt": "2020-03-23T11:49:08Z", "path": "sql/src/main/java/io/crate/metadata/functions/TypeVariableConstraint.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import java.util.Objects;\n+\n+public class TypeVariableConstraint {\n+\n+    public static TypeVariableConstraint typeVariable(String name) {\n+        return new TypeVariableConstraint(name);\n+    }\n+\n+    public static TypeVariableConstraint typeVariableOfAnyType(String name) {\n+        return new TypeVariableConstraint(name, true);\n+    }\n+\n+    private final String name;\n+    private final boolean anyAllowed;\n+\n+    private TypeVariableConstraint(String name) {", "originalCommit": "92f1a651aeaa65ecdec7d30f318e9e33eec4ecfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjA2NA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396516064", "bodyText": "Shouldn't this be compatible?", "author": "mfussenegger", "createdAt": "2020-03-23T15:00:00Z", "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);\n+        if (!compatibility.isCompatible()) {\n+            return null;\n+        }\n+        return compatibility.getCommonType();\n+    }\n+\n+    private static TypeCompatibility compatible(DataType<?> commonSuperType, boolean coercible) {\n+        return new TypeCompatibility(commonSuperType, coercible);\n+    }\n+\n+    private static TypeCompatibility compatibility(DataType<?> fromType, DataType<?> toType) {\n+        if (fromType.equals(toType)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (fromType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(toType, true);\n+        }\n+\n+        if (toType.equals(UndefinedType.INSTANCE)) {\n+            return compatible(fromType, false);\n+        }\n+\n+        String fromTypeBaseName = fromType.getTypeSignature().getBaseTypeName();\n+        String toTypeBaseName = toType.getTypeSignature().getBaseTypeName();\n+        if (fromTypeBaseName.equals(toTypeBaseName)) {\n+            // If given types share the same base, e.g. arrays, parameter types must be compatible.\n+            if (!fromType.getTypeParameters().isEmpty() || !toType.getTypeParameters().isEmpty()) {\n+                return typeCompatibilityForParametrizedType(fromType, toType);\n+            }\n+            return compatible(fromType, false);", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3OTQxMg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396579412", "bodyText": "It's compatible as both base names are equal and no parameters e.g. text and text.", "author": "seut", "createdAt": "2020-03-23T16:22:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxNjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUxODQ0NQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396518445", "bodyText": "Not sure if it's worth changing, but I think for common cases the TypeCompatibility creation  could be avoided (if types match,  undefined  case,  maybe even the \"by precedence\" case)", "author": "mfussenegger", "createdAt": "2020-03-23T15:03:06Z", "path": "common/src/main/java/io/crate/types/TypeCompatibility.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class TypeCompatibility {\n+\n+    private static final TypeCompatibility INCOMPATIBLE = new TypeCompatibility(null, false);\n+\n+    @Nullable\n+    public static DataType<?> getCommonType(DataType<?> firstType, DataType<?> secondType) {\n+        TypeCompatibility compatibility = compatibility(firstType, secondType);", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTM1MQ==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396521351", "bodyText": "Does/ should this work for nested cases?", "author": "mfussenegger", "createdAt": "2020-03-23T15:07:14Z", "path": "common/src/main/java/io/crate/types/TypeSignature.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import static java.lang.String.format;\n+\n+public class TypeSignature {\n+\n+    /**\n+     * Creates a type signature out of the given signature string.\n+     * A signature type string may contain parameters inside parenthesis:\n+     * <p>\n+     *   base_type_name(parameter [, parameter])\n+     * </p>\n+     *\n+     * Custom parameterized type handling must also be supported by {@link #createType()}.\n+     *\n+     * Some examples:\n+     * <p>\n+     *      integer\n+     *      array(integer)\n+     *      array(E)\n+     *      object(text, integer)\n+     *      object(text, V)\n+     * <p>\n+     */\n+    public static TypeSignature parseTypeSignature(String signature) {\n+        if (!signature.contains(\"(\")) {\n+            return new TypeSignature(signature);\n+        }\n+\n+        String baseName = null;\n+        List<TypeSignature> parameters = new ArrayList<>();\n+        int parameterStart = -1;\n+        int bracketCount = 0;\n+\n+        for (int i = 0; i < signature.length(); i++) {\n+            char c = signature.charAt(i);\n+            if (c == '(') {\n+                if (bracketCount == 0) {\n+                    assert baseName == null : \"Expected baseName to be null\";\n+                    baseName = signature.substring(0, i);\n+                    parameterStart = i + 1;\n+                }\n+                bracketCount++;\n+            } else if (c == ')') {\n+                bracketCount--;\n+                if (bracketCount == 0) {\n+                    assert parameterStart >= 0 : \"Expected parameter start to be >= 0\";\n+                    parameters.add(parseTypeSignatureParameter(signature, parameterStart, i));\n+                    parameterStart = i + 1;\n+                    if (i == signature.length() - 1) {\n+                        return new TypeSignature(baseName, parameters);\n+                    }\n+                }\n+            } else if (c == ',') {\n+                if (bracketCount == 1) {", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MTYwNg==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396591606", "bodyText": "Yes it does, I've added a test case.", "author": "seut", "createdAt": "2020-03-23T16:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyMTM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUyNDk5MA==", "url": "https://github.com/crate/crate/pull/9763#discussion_r396524990", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:\n          \n          \n            \n                    // The logic can be summarized as finding the right most item (based on the list below) seen so far:", "author": "mfussenegger", "createdAt": "2020-03-23T15:11:56Z", "path": "sql/src/main/java/io/crate/metadata/functions/SignatureBinder.java", "diffHunk": "@@ -0,0 +1,518 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata.functions;\n+\n+import io.crate.common.collections.Lists2;\n+import io.crate.types.DataType;\n+import io.crate.types.TypeSignature;\n+import io.crate.types.UndefinedType;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.common.logging.Loggers;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariableOfAnyType;\n+import static io.crate.types.TypeCompatibility.getCommonType;\n+import static java.lang.String.format;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+\n+/**\n+ * Determines whether, and how, a callsite matches a generic function signature.\n+ * Which is equivalent to finding assignments for the variables in the generic signature,\n+ * such that all of the function's declared parameters are super types of the corresponding\n+ * arguments, and also satisfy the declared constraints (such as a given type parameter must\n+ * be of the same type or not)\n+ */\n+public class SignatureBinder {\n+    // 4 is chosen arbitrarily here. This limit is set to avoid having infinite loops in iterative solving.\n+    private static final int SOLVE_ITERATION_LIMIT = 4;\n+\n+    private static final Logger LOGGER = Loggers.getLogger(SignatureBinder.class);\n+\n+    private final Signature declaredSignature;\n+    private final boolean allowCoercion;\n+    private final Map<String, TypeVariableConstraint> typeVariableConstraints;\n+\n+    public SignatureBinder(Signature declaredSignature, boolean allowCoercion) {\n+        this.declaredSignature = declaredSignature;\n+        this.allowCoercion = allowCoercion;\n+        this.typeVariableConstraints = declaredSignature.getTypeVariableConstraints().stream()\n+            .collect(toMap(TypeVariableConstraint::getName, identity()));\n+    }\n+\n+    @Nullable\n+    public Signature bind(List<DataType> actualArgumentTypes) {\n+        BoundVariables boundVariables = bindVariables(Lists2.map(actualArgumentTypes, DataType::getTypeSignature));\n+        if (boundVariables == null) {\n+            return null;\n+        }\n+        return applyBoundVariables(declaredSignature, boundVariables, typeVariableConstraints, actualArgumentTypes.size());\n+    }\n+\n+    @Nullable\n+    BoundVariables bindVariables(List<TypeSignature> actualArgumentTypes) {\n+        ArrayList<TypeConstraintSolver> constraintSolvers = new ArrayList<>();\n+        if (!appendConstraintSolversForArguments(constraintSolvers, actualArgumentTypes)) {\n+            return null;\n+        }\n+\n+        return iterativeSolve(Collections.unmodifiableList(constraintSolvers));\n+    }\n+\n+    private static Signature applyBoundVariables(Signature signature,\n+                                                 BoundVariables boundVariables,\n+                                                 Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                 int arity) {\n+        List<TypeSignature> argumentSignatures;\n+        if (signature.isVariableArity()) {\n+            argumentSignatures = expandVarargFormalTypeSignature(\n+                signature.getArgumentTypes(),\n+                signature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                arity);\n+            if (argumentSignatures == null) {\n+                throw new IllegalArgumentException(\n+                    \"Size of argument types does not match a multiple of the defined variable arguments\");\n+            }\n+        } else {\n+            if (signature.getArgumentTypes().size() != arity) {\n+                throw new IllegalArgumentException(\"Size of argument types does not match given arity\");\n+            }\n+            argumentSignatures = signature.getArgumentTypes();\n+        }\n+        List<TypeSignature> boundArgumentSignatures = applyBoundVariables(argumentSignatures, boundVariables);\n+        TypeSignature boundReturnTypeSignature = applyBoundVariables(signature.getReturnType(), boundVariables);\n+\n+        return Signature.builder()\n+            .name(signature.getName())\n+            .kind(signature.getKind())\n+            .argumentTypes(boundArgumentSignatures)\n+            .returnType(boundReturnTypeSignature)\n+            .setVariableArity(false)\n+            .build();\n+    }\n+\n+    private static List<TypeSignature> applyBoundVariables(List<TypeSignature> typeSignatures,\n+                                                           BoundVariables boundVariables) {\n+        ArrayList<TypeSignature> builder = new ArrayList<>();\n+        for (TypeSignature typeSignature : typeSignatures) {\n+            builder.add(applyBoundVariables(typeSignature, boundVariables));\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static TypeSignature applyBoundVariables(TypeSignature typeSignature, BoundVariables boundVariables) {\n+        String baseType = typeSignature.getBaseTypeName();\n+        if (boundVariables.containsTypeVariable(baseType)) {\n+            if (typeSignature.getParameters().isEmpty() == false) {\n+                throw new IllegalStateException(\"Type parameters cannot have parameters\");\n+            }\n+            return boundVariables.getTypeVariable(baseType).getTypeSignature();\n+        }\n+\n+        List<TypeSignature> parameters = Lists2.map(\n+            typeSignature.getParameters(),\n+            typeSignatureParameter -> applyBoundVariables(typeSignatureParameter, boundVariables));\n+\n+        return new TypeSignature(baseType, parameters);\n+    }\n+\n+    private boolean appendConstraintSolversForArguments(List<TypeConstraintSolver> resultBuilder,\n+                                                        List<TypeSignature> actualTypeSignatures) {\n+        boolean variableArity = declaredSignature.isVariableArity();\n+        List<TypeSignature> formalTypeSignatures = declaredSignature.getArgumentTypes();\n+        if (variableArity) {\n+            int variableGroupCount = declaredSignature.getVariableArityGroup().size();\n+            int variableArgumentCount = variableGroupCount > 0 ? variableGroupCount : 1;\n+            if (actualTypeSignatures.size() < formalTypeSignatures.size() - variableArgumentCount) {\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\n+                        \"Given signature size {} is not smaller than minimum variableArity of formal signature size {}\",\n+                        actualTypeSignatures.size(),\n+                        formalTypeSignatures.size() - variableArgumentCount);\n+                }\n+                return false;\n+            }\n+            formalTypeSignatures = expandVarargFormalTypeSignature(\n+                formalTypeSignatures,\n+                declaredSignature.getVariableArityGroup(),\n+                typeVariableConstraints,\n+                actualTypeSignatures.size());\n+            if (formalTypeSignatures == null) {\n+                // var args expanding detected a no-match\n+                return false;\n+            }\n+        }\n+\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            appendTypeRelationshipConstraintSolver(resultBuilder,\n+                                                   formalTypeSignatures.get(i),\n+                                                   actualTypeSignatures.get(i),\n+                                                   allowCoercion);\n+        }\n+\n+        return appendConstraintSolvers(resultBuilder, formalTypeSignatures, actualTypeSignatures, allowCoercion);\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            List<? extends TypeSignature> formalTypeSignatures,\n+                                            List<TypeSignature> actualTypeSignatures,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignatures.size() != actualTypeSignatures.size()) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Given signature size {} does not match formal signature size {}\",\n+                             actualTypeSignatures.size(), formalTypeSignatures.size());\n+            }\n+            return false;\n+        }\n+        for (int i = 0; i < formalTypeSignatures.size(); i++) {\n+            if (!appendConstraintSolvers(resultBuilder,\n+                                         formalTypeSignatures.get(i),\n+                                         actualTypeSignatures.get(i),\n+                                         allowCoercion)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean appendConstraintSolvers(List<TypeConstraintSolver> resultBuilder,\n+                                            TypeSignature formalTypeSignature,\n+                                            TypeSignature actualTypeSignature,\n+                                            boolean allowCoercion) {\n+        if (formalTypeSignature.getParameters().isEmpty()) {\n+            TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(formalTypeSignature.getBaseTypeName());\n+            if (typeVariableConstraint == null) {\n+                return true;\n+            }\n+            resultBuilder.add(new TypeParameterSolver(formalTypeSignature.getBaseTypeName(), actualTypeSignature.createType()));\n+            return true;\n+        }\n+\n+        DataType<?> actualType = actualTypeSignature.createType();\n+\n+        List<TypeSignature> actualTypeParametersTypeSignatureProvider;\n+        if (UndefinedType.ID == actualType.id()) {\n+            actualTypeParametersTypeSignatureProvider = Collections.nCopies(formalTypeSignature.getParameters().size(),\n+                                                                            UndefinedType.INSTANCE.getTypeSignature());\n+        } else {\n+            actualTypeParametersTypeSignatureProvider = Lists2.map(\n+                actualType.getTypeParameters(),\n+                DataType::getTypeSignature\n+            );\n+        }\n+\n+        return appendConstraintSolvers(\n+            resultBuilder,\n+            Collections.unmodifiableList(formalTypeSignature.getParameters()),\n+            actualTypeParametersTypeSignatureProvider,\n+            allowCoercion);\n+    }\n+\n+    private void appendTypeRelationshipConstraintSolver(List<TypeConstraintSolver> resultBuilder,\n+                                                        TypeSignature formalTypeSignature,\n+                                                        TypeSignature actualTypeSignature,\n+                                                        boolean allowCoercion) {\n+        Set<String> typeVariables = typeVariablesOf(formalTypeSignature);\n+        resultBuilder.add(new TypeRelationshipConstraintSolver(\n+            formalTypeSignature,\n+            typeVariables,\n+            actualTypeSignature.createType(),\n+            allowCoercion));\n+    }\n+\n+    private Set<String> typeVariablesOf(TypeSignature typeSignature) {\n+        if (typeVariableConstraints.containsKey(typeSignature.getBaseTypeName())) {\n+            return Set.of(typeSignature.getBaseTypeName());\n+        }\n+        HashSet<String> variables = new HashSet<>();\n+        for (TypeSignature parameter : typeSignature.getParameters()) {\n+            variables.addAll(typeVariablesOf(parameter));\n+        }\n+\n+        return variables;\n+    }\n+\n+    @Nullable\n+    private BoundVariables iterativeSolve(List<TypeConstraintSolver> constraints) {\n+        BoundVariables.Builder boundVariablesBuilder = BoundVariables.builder();\n+        for (int i = 0; true; i++) {\n+            if (i == SOLVE_ITERATION_LIMIT) {\n+                throw new IllegalStateException(format(\n+                    Locale.ENGLISH,\n+                    \"SignatureBinder.iterativeSolve does not converge after %d iterations.\",\n+                    SOLVE_ITERATION_LIMIT));\n+            }\n+            SolverReturnStatusMerger statusMerger = new SolverReturnStatusMerger();\n+            for (TypeConstraintSolver constraint : constraints) {\n+                var constraintStatus = constraint.update(boundVariablesBuilder);\n+                if (LOGGER.isTraceEnabled()) {\n+                    LOGGER.trace(\"Status after updating constraint={}: {}\", constraint, constraintStatus);\n+                }\n+                statusMerger.add(constraintStatus);\n+                if (statusMerger.getCurrent() == SolverReturnStatus.UNSOLVABLE) {\n+                    if (LOGGER.isTraceEnabled()) {\n+                        LOGGER.trace(\"Status merger resulted in UNSOLVABLE state\");\n+                    }\n+                    return null;\n+                }\n+            }\n+            switch (statusMerger.getCurrent()) {\n+                case UNCHANGED_SATISFIED:\n+                    break;\n+                case UNCHANGED_NOT_SATISFIED:\n+                    return null;\n+                case CHANGED:\n+                    continue;\n+                default:\n+                case UNSOLVABLE:\n+                    throw new UnsupportedOperationException(\"Signature binding unsolvable\");\n+            }\n+            break;\n+        }\n+\n+        BoundVariables boundVariables = boundVariablesBuilder.build();\n+        if (!allTypeVariablesBound(boundVariables)) {\n+            if (LOGGER.isTraceEnabled()) {\n+                LOGGER.trace(\"Not all variables are bound. Defined variables={}, bound={}\",\n+                             typeVariableConstraints,\n+                             boundVariables);\n+            }\n+            return null;\n+        }\n+        return boundVariables;\n+    }\n+\n+    private boolean allTypeVariablesBound(BoundVariables boundVariables) {\n+        return boundVariables.getTypeVariableNames().equals(typeVariableConstraints.keySet());\n+    }\n+\n+    @Nullable\n+    private static List<TypeSignature> expandVarargFormalTypeSignature(List<TypeSignature> formalTypeSignatures,\n+                                                                       List<TypeSignature> variableArityGroup,\n+                                                                       Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                                                       int actualArity) {\n+        int variableArityGroupCount = variableArityGroup.size();\n+        if (variableArityGroupCount > 0 && actualArity % variableArityGroupCount != 0) {\n+            // no match\n+            return null;\n+        }\n+        int arityCountIncludedInsideFormalSignature = variableArityGroupCount == 0 ? 1 : variableArityGroupCount;\n+        int variableArityArgumentsCount = actualArity - formalTypeSignatures.size() + arityCountIncludedInsideFormalSignature;\n+        if (variableArityArgumentsCount == 0) {\n+            return formalTypeSignatures.subList(0, formalTypeSignatures.size() - arityCountIncludedInsideFormalSignature);\n+        }\n+        if (variableArityArgumentsCount == arityCountIncludedInsideFormalSignature) {\n+            return formalTypeSignatures;\n+        }\n+        if (variableArityArgumentsCount > arityCountIncludedInsideFormalSignature && formalTypeSignatures.isEmpty()) {\n+            throw new IllegalArgumentException(\"Found variable argument(s) but list of formal type signatures is empty\");\n+        }\n+\n+        ArrayList<TypeSignature> builder = new ArrayList<>(formalTypeSignatures);\n+        if (variableArityGroup.isEmpty()) {\n+            TypeSignature lastTypeSignature = formalTypeSignatures.get(formalTypeSignatures.size() - 1);\n+            for (int i = 1; i < variableArityArgumentsCount; i++) {\n+                addVarArgTypeSignature(lastTypeSignature, typeVariableConstraints, builder, i);\n+            }\n+        } else {\n+            for (int i = 0; i < variableArityArgumentsCount - formalTypeSignatures.size(); ) {\n+                i += variableArityGroupCount;\n+                for (var typeSignature : variableArityGroup) {\n+                    addVarArgTypeSignature(typeSignature, typeVariableConstraints, builder, i);\n+                }\n+            }\n+        }\n+        return Collections.unmodifiableList(builder);\n+    }\n+\n+    private static void addVarArgTypeSignature(TypeSignature typeSignature,\n+                                               Map<String, TypeVariableConstraint> typeVariableConstraints,\n+                                               List<TypeSignature> builder,\n+                                               int actualArity) {\n+        TypeVariableConstraint typeVariableConstraint = typeVariableConstraints.get(typeSignature.getBaseTypeName());\n+        if (typeVariableConstraint != null && typeVariableConstraint.isAnyAllowed()) {\n+            // Type variables defaults to be bound to the same type.\n+            // To support independent variable type arguments, each vararg must be bound to a dedicated type variable.\n+            String constraintName = \"_generated_\" + typeSignature.getBaseTypeName() + actualArity;\n+            TypeSignature newTypeSignature = new TypeSignature(constraintName);\n+            typeVariableConstraints.put(constraintName, typeVariableOfAnyType(constraintName));\n+            builder.add(newTypeSignature);\n+        } else {\n+            builder.add(typeSignature);\n+        }\n+\n+    }\n+\n+    private static boolean satisfiesCoercion(boolean allowCoercion,\n+                                             DataType<?> fromType,\n+                                             TypeSignature toTypeSignature) {\n+        if (allowCoercion) {\n+            return fromType.isConvertableTo(toTypeSignature.createType());\n+        } else {\n+            return fromType.getTypeSignature().equals(toTypeSignature);\n+        }\n+    }\n+\n+    private interface TypeConstraintSolver {\n+        SolverReturnStatus update(BoundVariables.Builder bindings);\n+    }\n+\n+    private enum SolverReturnStatus {\n+        UNCHANGED_SATISFIED,\n+        UNCHANGED_NOT_SATISFIED,\n+        CHANGED,\n+        UNSOLVABLE,\n+    }\n+\n+    private static class SolverReturnStatusMerger {\n+        // This class gives the overall status when multiple status are seen from different parts.\n+        // The logic is simple and can be summarized as finding the right most item (based on the list below) seen so far:", "originalCommit": "db3a746648da697fda8b505be150876822d39d5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "url": "https://github.com/crate/crate/commit/4bf2c8a842408e969ff0f7da5cfc65eee504a1db", "message": "Implement new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T08:31:46Z", "type": "forcePushed"}, {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T10:02:45Z", "type": "commit"}, {"oid": "507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "url": "https://github.com/crate/crate/commit/507cf5d7320b6d2cb29290fd72a0b7076a8c4842", "message": "Add new signature based function registry\n\nSignatures can be defined with type variables constraints to support\nconstraints across given argument types, e.g. a `array(E), array(E)`\nsignature requires all `E` types to either have a common super type or\nbeing convertible.\nSpecial logic of literal downcasts (avoid table-scans) is omitted,\nthis should be re-implemented decoupled later on.\n\nEach function can be registered with different signatures (function overloading).\nThe registry can be iterated to get all registered signatures.", "committedDate": "2020-03-24T10:02:45Z", "type": "forcePushed"}]}