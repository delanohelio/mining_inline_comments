{"pr_number": 10061, "pr_title": "Add scalar function CURRENT_TIME returning current time UTC with microsecond precision", "pr_createdAt": "2020-06-08T14:58:49Z", "pr_url": "https://github.com/crate/crate/pull/10061", "timeline": [{"oid": "477c70fee5515cdce653fe8d993bc5f50111600b", "url": "https://github.com/crate/crate/commit/477c70fee5515cdce653fe8d993bc5f50111600b", "message": "Fix checkStyle", "committedDate": "2020-06-09T19:41:27Z", "type": "forcePushed"}, {"oid": "14110f04b39c4c48455c36db3c578890bb735034", "url": "https://github.com/crate/crate/commit/14110f04b39c4c48455c36db3c578890bb735034", "message": "Fixup", "committedDate": "2020-06-10T20:10:49Z", "type": "forcePushed"}, {"oid": "734b3b9670d5578918c5f550da673467512a3f1a", "url": "https://github.com/crate/crate/commit/734b3b9670d5578918c5f550da673467512a3f1a", "message": "Add documentation and unrelease notes", "committedDate": "2020-06-10T22:10:09Z", "type": "forcePushed"}, {"oid": "3617d1e404f05a771584d64bf948264a3b29cea8", "url": "https://github.com/crate/crate/commit/3617d1e404f05a771584d64bf948264a3b29cea8", "message": "Add documentation and unrelease notes", "committedDate": "2020-06-11T08:53:47Z", "type": "forcePushed"}, {"oid": "b5caad074e7ecb7e8559848768ea2c75ee4cf48e", "url": "https://github.com/crate/crate/commit/b5caad074e7ecb7e8559848768ea2c75ee4cf48e", "message": "Add documentation and unrelease notes", "committedDate": "2020-06-15T12:33:22Z", "type": "forcePushed"}, {"oid": "a819a4d5cbb078d0a7e82c9d26485005bed5ec58", "url": "https://github.com/crate/crate/commit/a819a4d5cbb078d0a7e82c9d26485005bed5ec58", "message": "Add documentation and unrelease notes", "committedDate": "2020-06-16T10:19:57Z", "type": "forcePushed"}, {"oid": "6c65ae7944a5179d0e38490df3078c7c4d657989", "url": "https://github.com/crate/crate/commit/6c65ae7944a5179d0e38490df3078c7c4d657989", "message": "fixup", "committedDate": "2020-06-16T11:43:48Z", "type": "forcePushed"}, {"oid": "b57049633424710e1a82007f39b37ef022a1af05", "url": "https://github.com/crate/crate/commit/b57049633424710e1a82007f39b37ef022a1af05", "message": "Cosmetic fixup", "committedDate": "2020-06-17T08:06:29Z", "type": "forcePushed"}, {"oid": "f32cfb4ac683157bf303a195ea13f099505a6acb", "url": "https://github.com/crate/crate/commit/f32cfb4ac683157bf303a195ea13f099505a6acb", "message": "Fix graddle issue whereby I  accidentally pushed changes", "committedDate": "2020-06-18T14:31:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MTk3MQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442671971", "bodyText": "I think a single conditional would make this a bit easier to parse. Maybe with something like this?\nString funcName;\nint defaultPrecision;\nswitch (type) {\n    case CurrentTime.Type.TIMESTAMP:\n        funcName = ...\n        break;\n\n    case CurrentTime.Type.TIME:\n        funcName = ...\n        break;\n\n\n    default:\n      return visitExpression(node, context);\n}\nreturn allocateFunction(...\nI think it would also be an option to make the default precision argument optional and keep the \"what value is the default\" knowledge encapsulated within the function itself. So that the expression analyzer doesn't add the argument if it is not specified.", "author": "mfussenegger", "createdAt": "2020-06-19T07:15:00Z", "path": "server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java", "diffHunk": "@@ -459,13 +460,20 @@ protected Symbol visitExpression(Expression node, ExpressionAnalysisContext cont\n \n         @Override\n         protected Symbol visitCurrentTime(CurrentTime node, ExpressionAnalysisContext context) {\n-            if (!node.getType().equals(CurrentTime.Type.TIMESTAMP)) {\n+            CurrentTime.Type type = node.getType();\n+            if (!(type.equals(CurrentTime.Type.TIMESTAMP) || type.equals(CurrentTime.Type.TIME))) {\n                 visitExpression(node, context);\n             }\n+            String funcName = CurrentTimestampFunction.NAME;\n+            int defaultPrecision = CurrentTimestampFunction.DEFAULT_PRECISION;\n+            if (type.equals(CurrentTime.Type.TIME)) {\n+                funcName = CurrentTimeFunction.NAME;\n+                defaultPrecision = CurrentTimeFunction.DEFAULT_PRECISION;\n+            }", "originalCommit": "318a08f1ca28ca01f4b2ed67fc0dc69d591ceca9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3MjUyOA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442672528", "bodyText": "Not sure if the extension of the TransactionContext is valuable here. A abstract class definition with the currentTimeMicros would be sufficient for the benchmark. Or even just define the two different methods directly without any classes at all", "author": "mfussenegger", "createdAt": "2020-06-19T07:16:19Z", "path": "benchmarks/src/test/java/io/crate/execution/TimePrecisionIncreaseTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution;\n+\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.settings.SessionSettings;\n+import org.joda.time.DateTimeUtils;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Timeout;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1)\n+@Measurement(iterations = 4)\n+@Timeout(time=30000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 2, time = 10000, timeUnit = TimeUnit.MILLISECONDS)\n+public class TimePrecisionIncreaseTest {\n+\n+    static abstract class TCtxBase extends TransactionContext {\n+\n+        TCtxBase() {\n+            super(null);\n+        }\n+\n+        @Override\n+        public long currentTimeMicros() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public SessionSettings sessionSettings() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }", "originalCommit": "318a08f1ca28ca01f4b2ed67fc0dc69d591ceca9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY3OTcyMw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442679723", "bodyText": "I think it would be cool if we could de-couple more of the time related logic into more specific components. The TransactionContext should only be concerned about caching the value retrieved to ensure the same value is re-used across the transaction. It shouldn't know too much about how that value is produced.\nFor example we could introduce a Clocks class that encapsulates the logic about fixing/mocking the current time.\nMaybe even work with the Clock classes directly instead of the Supplier<Long>.\nThere is both\nClock.systemUTC();\nClock.fixed(..);", "author": "mfussenegger", "createdAt": "2020-06-19T07:32:19Z", "path": "server/src/main/java/io/crate/metadata/TransactionContext.java", "diffHunk": "@@ -23,38 +23,77 @@\n package io.crate.metadata;\n \n import io.crate.metadata.settings.SessionSettings;\n-import org.joda.time.DateTimeUtils;\n \n-public interface TransactionContext {\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n \n-    static TransactionContext of(SessionSettings sessionSettings) {\n-        return new StaticTransactionContext(sessionSettings);\n+public class TransactionContext {\n+\n+    public static TransactionContext of(SessionSettings sessionSettings) {\n+        return new TransactionContext(sessionSettings);\n     }\n \n-    long currentTimeMillis();\n+    private static final AtomicReference<Supplier<Long>> MILLIS_PROVIDER = new AtomicReference<>(null);", "originalCommit": "318a08f1ca28ca01f4b2ed67fc0dc69d591ceca9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjQ0OQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442702449", "bodyText": "the function always has one argument, so this check is probably obsolete?", "author": "kovrus", "createdAt": "2020-06-19T08:19:26Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import com.google.common.math.LongMath;\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TimeTZ;\n+\n+import javax.annotation.Nullable;\n+import java.math.RoundingMode;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+public class CurrentTimeFunction extends Scalar<TimeTZ, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+    public static final int DEFAULT_PRECISION = 6; // micro seconds\n+    private static final Signature SIGNATURE = Signature.scalar(\n+        NAME,\n+        DataTypes.INTEGER.getTypeSignature(),\n+        DataTypes.TIMETZ.getTypeSignature()\n+    );\n+\n+    private static final FunctionInfo INFO = new FunctionInfo(\n+        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n+        DataTypes.TIMETZ,\n+        FunctionInfo.Type.SCALAR,\n+        Collections.emptySet());\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(SIGNATURE, (signature, args) -> new CurrentTimeFunction());\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final TimeTZ evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        Integer precision = DEFAULT_PRECISION;\n+        if (args.length == 1) {", "originalCommit": "318a08f1ca28ca01f4b2ed67fc0dc69d591ceca9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgwNzk3MA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442807970", "bodyText": "I have corrected this, the function can have no arguments indeed, so I am registering two signatures, one with and integer arg, the other with no args, that way defaults are defined in the function implementing classes, and the number of args needs to be checked.", "author": "marregui", "createdAt": "2020-06-19T12:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMjQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNTY3Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442705677", "bodyText": "minor: imho, we can probably fail early in the analyzer in the case when the precision is provided and it is wrong. Otherwise, we allocate a function call with the already known wrong precision value. Also, if the function is called without precision, this condition is unnecessary. That's why i thought that analyzer is a better place for it, but don't know.", "author": "kovrus", "createdAt": "2020-06-19T08:25:55Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import com.google.common.math.LongMath;\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TimeTZ;\n+\n+import javax.annotation.Nullable;\n+import java.math.RoundingMode;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+public class CurrentTimeFunction extends Scalar<TimeTZ, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+    public static final int DEFAULT_PRECISION = 6; // micro seconds\n+    private static final Signature SIGNATURE = Signature.scalar(\n+        NAME,\n+        DataTypes.INTEGER.getTypeSignature(),\n+        DataTypes.TIMETZ.getTypeSignature()\n+    );\n+\n+    private static final FunctionInfo INFO = new FunctionInfo(\n+        new FunctionIdent(NAME, List.of(DataTypes.INTEGER)),\n+        DataTypes.TIMETZ,\n+        FunctionInfo.Type.SCALAR,\n+        Collections.emptySet());\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(SIGNATURE, (signature, args) -> new CurrentTimeFunction());\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final TimeTZ evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        Integer precision = DEFAULT_PRECISION;\n+        if (args.length == 1) {\n+            precision = args[0].value();\n+            if (precision == null) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH, \"NULL precision not supported for %s\", NAME));\n+            }\n+        }\n+        if (precision < 0 || precision > DEFAULT_PRECISION) {", "originalCommit": "318a08f1ca28ca01f4b2ed67fc0dc69d591ceca9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNzQxMA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442707410", "bodyText": "I don't think we should micro optimize for error cases like that. I think it is more important to encapsulate / narrow the responsibility. The ExpressionAnalyzer should be concerned with converting the parser expression to symbols and not know too much details about internals of functions and so on.\nSo I'd be in favor of keeping this logic here inside the function (see also my other comment about also moving the knowledge about the default value)", "author": "mfussenegger", "createdAt": "2020-06-19T08:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNTY3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxMTM5OA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442711398", "bodyText": "right, makes sense, otherwise, it would scatter the function's logic across analyzer and function implementation.", "author": "kovrus", "createdAt": "2020-06-19T08:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNTY3Nw=="}], "type": "inlineReview"}, {"oid": "3a8d32282f4d929bd3b53638f4d2632c1e6a18e8", "url": "https://github.com/crate/crate/commit/3a8d32282f4d929bd3b53638f4d2632c1e6a18e8", "message": "Decouple TransactionContect from SystemClock and document it", "committedDate": "2020-06-19T13:05:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgzOTYwOA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442839608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final AtomicReference<Clock> SYSTEM_CLOCK = new AtomicReference<>(DEFAULT_CLOCK);\n          \n          \n            \n                private static final AtomicReference<Clock> CURRENT_CLOCK = new AtomicReference<>(Clock.systemUTC());\n          \n      \n    \n    \n  \n\nIt's not necessarily pointing to the system clock.", "author": "mfussenegger", "createdAt": "2020-06-19T13:27:01Z", "path": "server/src/main/java/io/crate/metadata/SystemClock.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class SystemClock {\n+\n+    private static final Clock DEFAULT_CLOCK = Clock.systemUTC();\n+\n+    private static final AtomicReference<Clock> SYSTEM_CLOCK = new AtomicReference<>(DEFAULT_CLOCK);", "originalCommit": "3a8d32282f4d929bd3b53638f4d2632c1e6a18e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg0MDU2Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442840567", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Clock DEFAULT_CLOCK = Clock.systemUTC();\n          \n          \n            \n                private static final Clock SYTEM_CLOCK = Clock.systemUTC();\n          \n      \n    \n    \n  \n\nor\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Clock DEFAULT_CLOCK = Clock.systemUTC();\n          \n      \n    \n    \n  \n\nand use Clock.systemUTC directly, it's already a singleton - so there is no gain by the assignment to a different constant.", "author": "mfussenegger", "createdAt": "2020-06-19T13:28:54Z", "path": "server/src/main/java/io/crate/metadata/SystemClock.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class SystemClock {\n+\n+    private static final Clock DEFAULT_CLOCK = Clock.systemUTC();", "originalCommit": "3a8d32282f4d929bd3b53638f4d2632c1e6a18e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg0MTk0Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442841947", "bodyText": "btw. was this behavior to still fall-through to the remaining code even correct before? Looks like the code outside the switch would fail if the default case was hit.", "author": "mfussenegger", "createdAt": "2020-06-19T13:31:24Z", "path": "server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java", "diffHunk": "@@ -460,20 +460,23 @@ protected Symbol visitExpression(Expression node, ExpressionAnalysisContext cont\n \n         @Override\n         protected Symbol visitCurrentTime(CurrentTime node, ExpressionAnalysisContext context) {\n-            CurrentTime.Type type = node.getType();\n-            if (!(type.equals(CurrentTime.Type.TIMESTAMP) || type.equals(CurrentTime.Type.TIME))) {\n-                visitExpression(node, context);\n-            }\n             String funcName = CurrentTimestampFunction.NAME;\n-            int defaultPrecision = CurrentTimestampFunction.DEFAULT_PRECISION;\n-            if (type.equals(CurrentTime.Type.TIME)) {\n-                funcName = CurrentTimeFunction.NAME;\n-                defaultPrecision = CurrentTimeFunction.DEFAULT_PRECISION;\n+            switch (node.getType()) {\n+                case TIMESTAMP:\n+                    break;\n+\n+                case TIME:\n+                    funcName = CurrentTimeFunction.NAME;\n+                    break;\n+\n+                default:\n+                    visitExpression(node, context);", "originalCommit": "6d7607f1f76923985d8928f49d9295f2e6c923b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NzI5Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442867297", "bodyText": "The missing case is DATE for scalar function current_date, which at present is unsupported:\ncr> select current_date;\nSQLActionException[UnsupportedFeatureException: Unsupported expression current_date]\n\nso the default will fail launch, throwing an exception:\n @Override\n        protected Symbol visitExpression(Expression node, ExpressionAnalysisContext context) {\n            throw new UnsupportedOperationException(String.format(Locale.ENGLISH,\n                \"Unsupported expression %s\", ExpressionFormatter.formatStandaloneExpression(node)));\n        }", "author": "marregui", "createdAt": "2020-06-19T14:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg0MTk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg1MTQ0MA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r442851440", "bodyText": "Is this the same result as Clock.systemUTC().instant().get(ChronoField.MICRO_OF_DAY); would return?\nIf so, maybe the TransactionContext could be changed to cache the instant instead (afaik it's a singleton, so would be safe).", "author": "mfussenegger", "createdAt": "2020-06-19T13:48:58Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import com.google.common.math.LongMath;\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TimeTZ;\n+\n+import javax.annotation.Nullable;\n+import java.math.RoundingMode;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+\n+public class CurrentTimeFunction extends Scalar<TimeTZ, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+    public static final int DEFAULT_PRECISION = 6; // micro seconds\n+\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.TIMETZ.getTypeSignature()),\n+            (signature, args) -> new CurrentTimeFunction(signature));\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.TIMETZ.getTypeSignature()),\n+            (signature, args) -> new CurrentTimeFunction(signature));\n+    }\n+\n+\n+    private final Signature signature;\n+    private final FunctionInfo info;\n+\n+    public CurrentTimeFunction(Signature signature) {\n+        this.signature = signature;\n+        this.info = new FunctionInfo(\n+            new FunctionIdent(\n+                NAME,\n+                signature.getArgumentTypes().isEmpty() ? List.of() : List.of(DataTypes.INTEGER)),\n+            DataTypes.TIMETZ,\n+            FunctionInfo.Type.SCALAR,\n+            Collections.emptySet());\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final TimeTZ evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        Integer precision = DEFAULT_PRECISION;\n+        if (args.length == 1) {\n+            precision = args[0].value();\n+            if (precision == null) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH, \"NULL precision not supported for %s\", NAME));\n+            }\n+        }\n+        if (precision < 0 || precision > DEFAULT_PRECISION) {\n+            throw new IllegalArgumentException(String.format(\n+                Locale.ENGLISH, \"precision must range between [0..%d]\", DEFAULT_PRECISION));\n+        }\n+        long currentTimeMicros = txnCtx.currentTimeMicros();\n+        long dateDeltaMillis = Instant.ofEpochMilli(currentTimeMicros / 1000L).truncatedTo(ChronoUnit.DAYS).toEpochMilli();\n+        long microsFromUTC = currentTimeMicros - (dateDeltaMillis * 1000L);\n+        long f = (long) Math.pow(10, 6 - precision);\n+        microsFromUTC = LongMath.divide(microsFromUTC, f, RoundingMode.DOWN) * f;", "originalCommit": "fd1658f4f44a5401b8955e744da82b67df3ff1be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b86dc3090d8b73a06f38fe389ec73e815b89bf36", "url": "https://github.com/crate/crate/commit/b86dc3090d8b73a06f38fe389ec73e815b89bf36", "message": "Enhance available system clock functionality, simplifying function implementation", "committedDate": "2020-06-19T15:04:36Z", "type": "forcePushed"}, {"oid": "16c0ecec49bfc5324138905ec1909012ea9494eb", "url": "https://github.com/crate/crate/commit/16c0ecec49bfc5324138905ec1909012ea9494eb", "message": "Cosmetics", "committedDate": "2020-06-19T17:40:53Z", "type": "forcePushed"}, {"oid": "458741978ae9fc6253e7348bca148b053a187e5a", "url": "https://github.com/crate/crate/commit/458741978ae9fc6253e7348bca148b053a187e5a", "message": "Readability improvements CurrentTimestampFunction", "committedDate": "2020-06-20T20:13:46Z", "type": "forcePushed"}, {"oid": "645c60d5a34904b3e0ab54d73efcd57d12d221b6", "url": "https://github.com/crate/crate/commit/645c60d5a34904b3e0ab54d73efcd57d12d221b6", "message": "Readability improvements CurrentTimestampFunction", "committedDate": "2020-06-20T20:33:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjAwOQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r443516009", "bodyText": "It's kinda hard to understand what Integer, Integer here are referring to in logic\nWhy the big diverge from the prior solution?", "author": "mfussenegger", "createdAt": "2020-06-22T12:16:53Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/TimeFunction.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+\n+import javax.annotation.Nullable;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.function.BiFunction;\n+\n+abstract class TimeFunction<R> extends Scalar<R, Integer> {\n+\n+    private final Signature signature;\n+    private final FunctionInfo info;\n+    private final int defaultPrecision;\n+    private final BiFunction<Instant, Integer, R> logic;\n+\n+    TimeFunction(Signature signature, int defaultPrecision, BiFunction<Instant, Integer, R> logic) {", "originalCommit": "645c60d5a34904b3e0ab54d73efcd57d12d221b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTUyODU5MQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445528591", "bodyText": "There are three related functions:\n\nNowFunction extends TimeFunction<Long>\nCurrentTimestampFunction extends TimeFunction<Long>\nCurrentTimeFunction extends TimeFunction<TimeTZ>\n\nMost of their logic is shared, except when it comes to user specified precision (can differ from max available precision for the function, and comes from args).\nIn the three functions:\n\nSystemClock::currentTimeMillis -> public static long currentTimeMillis(Instant i, int precision)\nSystemClock::currentTimeMillis ->  same as above\n(i, p) -> new TimeTZ(microsFromMidnightUTC(i, p), 0) -> public static long microsFromMidnightUTC(Instant i, int precision)\n\nThis leaves the extending classes for TimeFunction the responsibility of registering the signature/implementation and defining the logic. I think it is a nice simplification. I disagree that this is any more unreadable.", "author": "marregui", "createdAt": "2020-06-25T12:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYxNDAxMQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445614011", "bodyText": "I feel like this is confusing boilerplate (creating signature data structures) with duplicating logic.\nYes, NowFunction and CurrentTimestampFunction could probably share the same implementation for the zero argument case - but in that case they could actually return the exact same instance, instead of introducing a common base class.\nCurrentTimeFunction has little to do with current_timestamp. The signatures look similar - but that's about it.\nThe TimeFunction instances are not interchangeable (substitution principle). So the reason for this abstraction is only to \"share common code\" which is the signature definitions.\nThere are better ways than inheritance to achieve that.", "author": "mfussenegger", "createdAt": "2020-06-25T14:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjg2NA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r443516864", "bodyText": "Is this broad API surface really necessary? The prior version had a narrower surface, why was the extension necessary?", "author": "mfussenegger", "createdAt": "2020-06-22T12:18:33Z", "path": "server/src/main/java/io/crate/metadata/SystemClock.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.metadata;\n+\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.time.ZoneOffset;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public final class SystemClock {\n+\n+    public static int MICRO_PRECISION = 6; // microseconds\n+    public static int MILLI_PRECISION = 3; // milliseconds\n+\n+    private static final AtomicReference<Clock> CURRENT_CLOCK = new AtomicReference<>(Clock.systemUTC());\n+\n+    public static void setClock(Clock newClock) {\n+        CURRENT_CLOCK.set(newClock);\n+    }\n+\n+    public static void setCurrentMillisFixedUTC(long millis) {\n+        setClock(Clock.fixed(Instant.ofEpochMilli(millis), ZoneOffset.UTC));\n+    }\n+\n+    public static void setCurrentMillisSystemUTC() {\n+        setClock(Clock.systemUTC());\n+    }\n+\n+    public static Instant currentInstant() {\n+        return CURRENT_CLOCK.get().instant();\n+    }\n+\n+    public static long currentTimeMillis() {\n+        return toMillis(currentInstant());\n+    }\n+\n+    public static long currentTimeMillis(Instant i) {\n+        return toMillis(i);\n+    }\n+\n+    public static long currentTimeMillis(Instant i, int precision) {\n+        return withPrecision(toMillis(i), precision, MILLI_PRECISION);\n+    }\n+\n+    public static long microsFromMidnightUTC(Instant i) {\n+        return toMicros(i) - (extractDateMillis(i) * 1000L);\n+    }\n+\n+    public static long microsFromMidnightUTC(Instant i, int precision) {\n+        return withPrecision(microsFromMidnightUTC(i), precision, MICRO_PRECISION);\n+    }\n+\n+    private static long toMicros(Instant i) {\n+        return (i.getEpochSecond() * 1000_000_000L + i.getNano()) / 1000L;\n+    }\n+\n+    private static long toMillis(Instant i) {\n+        return (i.getEpochSecond() * 1000_000_000L + i.getNano()) / 1000_000L;\n+    }", "originalCommit": "645c60d5a34904b3e0ab54d73efcd57d12d221b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU0MjI4Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445542287", "bodyText": "My line of thinking is that all the logic in this class, now, is related to obtaining current time in either micros/millis precision, and then with user defined (additional) precision. For the case of current_time the date needs to be removed, leaving the API:\n\npublic static void setClock(Clock newClock): your own clock, maybe you have the need to buy an actual atomic clock and you want to hook it up.\npublic static void setCurrentMillisFixedUTC(long millis): so that you control what is returned, for tests.\npublic static void setCurrentMillisSystemUTC(): to restore the default system clock.\npublic static Instant currentInstant():  This is what the transaction context will end up caching, and is used to produce millis/micros.\npublic static long currentTimeMillis():  current millis now, no cached value of instant.\npublic static long currentTimeMillis(Instant i): current millis from potentially a cached value of instant.\npublic static long currentTimeMillis(Instant i, int precision): as above, with additional user defined precision.\npublic static long microsFromMidnightUTC(Instant i): current micros from potentially a cached value of instant. In the code there is no need for public static long microsFromMidnightUTC(), so I am not adding surface here.\npublic static long microsFromMidnightUTC(Instant i, int precision): as above, but with additional user defined precision.\n\nThe rest of the methods are not accessible, they are private.\nAll clock logic required for the time related functions is put together in this simple class.", "author": "marregui", "createdAt": "2020-06-25T13:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYxMDU2NA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445610564", "bodyText": "I think it is pushing too much of what the scalar functions should do into the SystemClock class.\nMy initial comment suggesting a Clocks class was to have a class that is only providing the functionality to get a Clock instance or an Instant instance - and being able to adjust what kind of Clock is returned and used. Single responsibility.\nThe precision handling is specific to current_timestamp and current_time and has no generic use. So I think it doesn't belong into a generic Clocks or SystemClock class.", "author": "mfussenegger", "createdAt": "2020-06-25T14:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYxNDUwNw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445614507", "bodyText": "ok, will amend :)", "author": "marregui", "createdAt": "2020-06-25T14:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNjg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzg5Ng==", "url": "https://github.com/crate/crate/pull/10061#discussion_r443517896", "bodyText": "Could we keep this as an itnerface?\nDue to the change to caching the Instant I think the remaining changes to share more logic are no longer necessary.\nThat would avoid the super(null); in the CoordinatorTxnCtx  which seems like a hack?", "author": "mfussenegger", "createdAt": "2020-06-22T12:20:27Z", "path": "server/src/main/java/io/crate/metadata/TransactionContext.java", "diffHunk": "@@ -23,38 +23,31 @@\n package io.crate.metadata;\n \n import io.crate.metadata.settings.SessionSettings;\n-import org.joda.time.DateTimeUtils;\n \n-public interface TransactionContext {\n+import java.time.Instant;\n \n-    static TransactionContext of(SessionSettings sessionSettings) {\n-        return new StaticTransactionContext(sessionSettings);\n-    }\n-\n-    long currentTimeMillis();\n+public class TransactionContext {", "originalCommit": "645c60d5a34904b3e0ab54d73efcd57d12d221b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU1MzEwMA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r445553100", "bodyText": "I agree, it looks like a hack... changing.", "author": "marregui", "createdAt": "2020-06-25T13:21:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxNzg5Ng=="}], "type": "inlineReview"}, {"oid": "56518b5641f19ff516ed0d080da9e5bf0e6486e5", "url": "https://github.com/crate/crate/commit/56518b5641f19ff516ed0d080da9e5bf0e6486e5", "message": "Restore TransactionContext to being an interface and remove a hack", "committedDate": "2020-06-25T13:38:16Z", "type": "forcePushed"}, {"oid": "968f0cc25d9479fb816b805a18c04831d60c2553", "url": "https://github.com/crate/crate/commit/968f0cc25d9479fb816b805a18c04831d60c2553", "message": "Simplify SystemClock and remove TimeFunction", "committedDate": "2020-06-26T13:04:45Z", "type": "forcePushed"}, {"oid": "25c6f6db2f9e73af980c87437fce691312888f6f", "url": "https://github.com/crate/crate/commit/25c6f6db2f9e73af980c87437fce691312888f6f", "message": "Simplify SystemClock and remove TimeFunction", "committedDate": "2020-06-26T13:08:19Z", "type": "forcePushed"}, {"oid": "65a2b7cc662ad224a2bf5fc536fff55962116b5a", "url": "https://github.com/crate/crate/commit/65a2b7cc662ad224a2bf5fc536fff55962116b5a", "message": "Simplify SystemClock and remove TimeFunction", "committedDate": "2020-06-29T12:21:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDUwNw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447040507", "bodyText": "Would something like this works?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Instant i = txnCtx.currentInstant();\n          \n          \n            \n                    long dateTimeMicros = (i.getEpochSecond() * 1000_000_000L + i.getNano()) / 1000L;\n          \n          \n            \n                    long dateMicros = i.truncatedTo(ChronoUnit.DAYS).toEpochMilli() * 1000L;\n          \n          \n            \n                    long f = (long) Math.pow(10, MICRO_PRECISION - precision);\n          \n          \n            \n                    return new TimeTZ(((dateTimeMicros - dateMicros) / f) * f, 0);\n          \n          \n            \n                    Instant currentInstant = txnCtx.currentInstant();\n          \n          \n            \n                    long microsSinceMidnight = ChronoUnit.MICROS.between(currentInstant.truncatedTo(ChronoUnit.DAYS), currentInstant);\n          \n          \n            \n                    long factor = (long) Math.pow(10, MICRO_PRECISION - precision);\n          \n          \n            \n                    return new TimeTZ((microsSinceMidnight / factor) * factor, 0);\n          \n      \n    \n    \n  \n\nThis would make the conversion a bit more declarative and with that probably a bit easier to read.", "author": "mfussenegger", "createdAt": "2020-06-29T15:03:29Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -21,38 +21,81 @@\n \n package io.crate.expression.scalar.timestamp;\n \n+import io.crate.data.Input;\n import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.metadata.SystemClock;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.Signature;\n import io.crate.types.DataTypes;\n import io.crate.types.TimeTZ;\n \n-import static io.crate.metadata.SystemClock.microsFromMidnightUTC;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Locale;\n \n-public class CurrentTimeFunction extends TimeFunction<TimeTZ> {\n+public class CurrentTimeFunction extends Scalar<TimeTZ, Integer> {\n \n     public static final String NAME = \"current_time\";\n+    private static final int MICRO_PRECISION = 6; // microseconds\n \n     public static void register(ScalarFunctionModule module) {\n         module.register(\n             Signature.scalar(\n                 NAME,\n                 DataTypes.INTEGER.getTypeSignature(),\n-                DataTypes.TIMETZ.getTypeSignature()),\n-            (signature, args) -> new CurrentTimeFunction(signature));\n+                DataTypes.TIMETZ.getTypeSignature()\n+            ),\n+            CurrentTimeFunction::new\n+        );\n         module.register(\n             Signature.scalar(\n                 NAME,\n-                DataTypes.TIMETZ.getTypeSignature()),\n-            (signature, args) -> new CurrentTimeFunction(signature));\n+                DataTypes.TIMETZ.getTypeSignature()\n+            ),\n+            CurrentTimeFunction::new\n+        );\n     }\n \n-    private CurrentTimeFunction(Signature signature) {\n-        super(signature, SystemClock.MICRO_PRECISION, (i, p) -> new TimeTZ(microsFromMidnightUTC(i, p), 0));\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private CurrentTimeFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final TimeTZ evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        Integer precision = MICRO_PRECISION;\n+        if (args.length == 1) {\n+            precision = args[0].value();\n+            if (precision == null) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"NULL precision not supported for %s\",\n+                    signature.getName().name()));\n+            }\n+        }\n+        if (precision < 0 || precision > MICRO_PRECISION) {\n+            throw new IllegalArgumentException(String.format(\n+                Locale.ENGLISH, \"precision must be between [0..%d]\", MICRO_PRECISION));\n+        }\n+\n+        Instant i = txnCtx.currentInstant();\n+        long dateTimeMicros = (i.getEpochSecond() * 1000_000_000L + i.getNano()) / 1000L;\n+        long dateMicros = i.truncatedTo(ChronoUnit.DAYS).toEpochMilli() * 1000L;\n+        long f = (long) Math.pow(10, MICRO_PRECISION - precision);\n+        return new TimeTZ(((dateTimeMicros - dateMicros) / f) * f, 0);", "originalCommit": "65a2b7cc662ad224a2bf5fc536fff55962116b5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4OTI5MA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447589290", "bodyText": "oh! yes, higher abstraction is better. For me it is more readable the way I wrote it, but that is subjective. If allowed I will go functional.", "author": "marregui", "createdAt": "2020-06-30T10:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MDUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MTM3Nw==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447041377", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return applyPrecision(toMillis(txnCtx.currentInstant()), precision);\n          \n          \n            \n                    return applyPrecision(ChronoUnit.MILLIS.between(Instant.EPOCH, txnCtx.currentInstant()), precision);", "author": "mfussenegger", "createdAt": "2020-06-29T15:04:43Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimestampFunction.java", "diffHunk": "@@ -69,7 +75,11 @@ public final Long evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n                     \"NULL precision not supported for %s\", NAME));\n             }\n         }\n-        return applyPrecision(millis, precision);\n+        return applyPrecision(toMillis(txnCtx.currentInstant()), precision);", "originalCommit": "65a2b7cc662ad224a2bf5fc536fff55962116b5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MjY1NA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447042654", "bodyText": "Why did this change?  Could it be that this is flaky because the ORDER BY is only on the name?", "author": "mfussenegger", "createdAt": "2020-06-29T15:06:24Z", "path": "server/src/test/java/io/crate/integrationtests/PgCatalogITest.java", "diffHunk": "@@ -173,8 +173,8 @@ public void test_pg_proc_select_variadic_and_non_variadic_functions() {\n             \"ORDER BY proname\");\n         assertThat(printedTable(response.rows()), is(\n             \"-395638146| array_difference| -1861355723| 1000.0| 0| false| false| true| 2277| [2277, 2277]| NULL| array_difference\\n\" +\n-            \"726540318| current_timestamp| -1861355723| 0.0| 0| false| false| false| 1184| [23]| NULL| current_timestamp\\n\" +\n             \"726540318| current_timestamp| -1861355723| 0.0| 0| false| false| false| 1184| []| NULL| current_timestamp\\n\" +\n+            \"726540318| current_timestamp| -1861355723| 0.0| 0| false| false| false| 1184| [23]| NULL| current_timestamp\\n\" +", "originalCommit": "65a2b7cc662ad224a2bf5fc536fff55962116b5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MjYyMA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447592620", "bodyText": "CurrentTimestampFunction has now two signatures being registered, to cover the case current_timestamp as well as current_timestamp(3). It is flaky in  the sense that if I change the order of signature registration, I have to change the test. I will make it resilient, thank you for spotting this.", "author": "marregui", "createdAt": "2020-06-30T10:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA0MjY1NA=="}], "type": "inlineReview"}, {"oid": "cde05c819653600a27fe33ffa4ce42a65a1a2ca0", "url": "https://github.com/crate/crate/commit/cde05c819653600a27fe33ffa4ce42a65a1a2ca0", "message": "Sort result by name and then by increasing args len, to prevent flakyness", "committedDate": "2020-06-30T13:44:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NDE2OA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447774168", "bodyText": "This could move into the previous if block. We know that the precision is valid if it comes from the default value if there are 0 arguments.", "author": "mfussenegger", "createdAt": "2020-06-30T15:28:12Z", "path": "server/src/main/java/io/crate/expression/scalar/timestamp/CurrentTimeFunction.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.timestamp;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.TimeTZ;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Locale;\n+\n+public class CurrentTimeFunction extends Scalar<TimeTZ, Integer> {\n+\n+    public static final String NAME = \"current_time\";\n+    private static final int MICRO_PRECISION = 6; // microseconds\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.TIMETZ.getTypeSignature()\n+            ),\n+            CurrentTimeFunction::new\n+        );\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.TIMETZ.getTypeSignature()\n+            ),\n+            CurrentTimeFunction::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private CurrentTimeFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    @SafeVarargs\n+    public final TimeTZ evaluate(TransactionContext txnCtx, Input<Integer>... args) {\n+        Integer precision = MICRO_PRECISION;\n+        if (args.length == 1) {\n+            precision = args[0].value();\n+            if (precision == null) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"NULL precision not supported for %s\",\n+                    signature.getName().name()));\n+            }\n+        }\n+        if (precision < 0 || precision > MICRO_PRECISION) {", "originalCommit": "65b32b6ec97c78a97e5551116e5945834628e1e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NDk4OQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447774989", "bodyText": "Before currentTimeMillis wasn't volatile, so it shouldn't be necessary for currentInstant to be volatile now.", "author": "mfussenegger", "createdAt": "2020-06-30T15:29:19Z", "path": "server/src/main/java/io/crate/metadata/CoordinatorTxnCtx.java", "diffHunk": "@@ -37,7 +37,7 @@\n public final class CoordinatorTxnCtx implements TransactionContext {\n \n     private final SessionContext sessionContext;\n-    private Long currentTimeMillis = null;\n+    private volatile Instant currentInstant;", "originalCommit": "65b32b6ec97c78a97e5551116e5945834628e1e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NjIwNA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447776204", "bodyText": "This change kinda invalidates the comment further below: assertThat(generatedColumnsMapping.get(\"ts\"), is(\"current_timestamp(3)\")); // 3 is the default precision. Either the change should be reverted or the comment removed.", "author": "mfussenegger", "createdAt": "2020-06-30T15:30:49Z", "path": "server/src/test/java/io/crate/analyze/CreateAlterTableStatementAnalyzerTest.java", "diffHunk": "@@ -1052,7 +1052,7 @@ public void testCreateTableGeneratedColumnWithCast() {\n     @Test\n     public void testCreateTableWithCurrentTimestampAsGeneratedColumnIsntNormalized() {\n         BoundCreateTable analysis = analyze(\n-            \"create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp)\");\n+            \"create table foo (ts timestamp with time zone GENERATED ALWAYS as current_timestamp(3))\");", "originalCommit": "65b32b6ec97c78a97e5551116e5945834628e1e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NzEzMQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447777131", "bodyText": "Why the change here? Semantics should still be the same?", "author": "mfussenegger", "createdAt": "2020-06-30T15:32:05Z", "path": "server/src/test/java/io/crate/integrationtests/TransportSQLActionClassLifecycleTest.java", "diffHunk": "@@ -590,7 +567,7 @@ public void selectWhereEqualCurrentTimestamp() throws Exception {\n         SQLResponse response = execute(\"select * from sys.cluster where current_timestamp = current_timestamp\");\n         assertThat(response.rowCount(), is(1L));\n \n-        SQLResponse newResponse = execute(\"select * from sys.cluster where current_timestamp > current_timestamp\");\n+        SQLResponse newResponse = execute(\"select * from sys.cluster where current_timestamp < current_timestamp\");", "originalCommit": "65b32b6ec97c78a97e5551116e5945834628e1e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMjg1OA==", "url": "https://github.com/crate/crate/pull/10061#discussion_r448202858", "bodyText": "yes, they are the same", "author": "marregui", "createdAt": "2020-07-01T08:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NzEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc3NzI1OQ==", "url": "https://github.com/crate/crate/pull/10061#discussion_r447777259", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.carrotsearch.randomizedtesting.annotations.Seed;", "author": "mfussenegger", "createdAt": "2020-06-30T15:32:16Z", "path": "server/src/test/java/io/crate/metadata/doc/DocIndexMetaDataTest.java", "diffHunk": "@@ -1,5 +1,6 @@\n package io.crate.metadata.doc;\n \n+import com.carrotsearch.randomizedtesting.annotations.Seed;", "originalCommit": "65b32b6ec97c78a97e5551116e5945834628e1e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3503489e7ca058172c553b05a073d1be39f9f33c", "url": "https://github.com/crate/crate/commit/3503489e7ca058172c553b05a073d1be39f9f33c", "message": "Final touches", "committedDate": "2020-07-01T08:29:37Z", "type": "forcePushed"}, {"oid": "90d24e41c51d81e3c0a9f26e2c81c08a97f65d6f", "url": "https://github.com/crate/crate/commit/90d24e41c51d81e3c0a9f26e2c81c08a97f65d6f", "message": "Add scalar function current_time>\n\nThis function returns the system's time as microseconds since midnight\nUTC, at the time the SQL statement is handled. The actual return type\nis the new data type timetz.", "committedDate": "2020-07-01T09:13:44Z", "type": "forcePushed"}, {"oid": "90ba1e1d4a38f31db1f4a02a797e06c83d0dd3a2", "url": "https://github.com/crate/crate/commit/90ba1e1d4a38f31db1f4a02a797e06c83d0dd3a2", "message": "Add scalar function current_time\n\nThis function returns the system's time as microseconds since midnight\nUTC, at the time the SQL statement is handled. The actual return type\nis the new data type timetz.", "committedDate": "2020-07-01T09:15:13Z", "type": "forcePushed"}, {"oid": "d84eeae39a610f361530cae75aac98a425deab76", "url": "https://github.com/crate/crate/commit/d84eeae39a610f361530cae75aac98a425deab76", "message": "Add scalar function current_time\n\nThis function returns the system's time as microseconds since midnight\nUTC, at the time the SQL statement is handled. The actual return type\nis the new data type timetz.", "committedDate": "2020-07-01T16:17:59Z", "type": "commit"}, {"oid": "d84eeae39a610f361530cae75aac98a425deab76", "url": "https://github.com/crate/crate/commit/d84eeae39a610f361530cae75aac98a425deab76", "message": "Add scalar function current_time\n\nThis function returns the system's time as microseconds since midnight\nUTC, at the time the SQL statement is handled. The actual return type\nis the new data type timetz.", "committedDate": "2020-07-01T16:17:59Z", "type": "forcePushed"}]}