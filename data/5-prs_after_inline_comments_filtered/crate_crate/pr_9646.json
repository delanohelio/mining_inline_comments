{"pr_number": 9646, "pr_title": "Add the ``trunc`` scalar function", "pr_createdAt": "2020-02-11T10:40:17Z", "pr_url": "https://github.com/crate/crate/pull/9646", "timeline": [{"oid": "fdb5dba316ecbaa6fe93fed45a1ed0048423175d", "url": "https://github.com/crate/crate/commit/fdb5dba316ecbaa6fe93fed45a1ed0048423175d", "message": "Fixup", "committedDate": "2020-02-11T10:56:41Z", "type": "forcePushed"}, {"oid": "a781eeac7100685a108f3f57d4fc129f7b35d9c9", "url": "https://github.com/crate/crate/commit/a781eeac7100685a108f3f57d4fc129f7b35d9c9", "message": "Fixup", "committedDate": "2020-02-11T14:35:11Z", "type": "forcePushed"}, {"oid": "925f98aa1922d23808c2166294ab8945ea0ea786", "url": "https://github.com/crate/crate/commit/925f98aa1922d23808c2166294ab8945ea0ea786", "message": "Fixup", "committedDate": "2020-02-11T14:35:57Z", "type": "forcePushed"}, {"oid": "6a99db2a2567d0b0cd3367a81118e5bf139b8d40", "url": "https://github.com/crate/crate/commit/6a99db2a2567d0b0cd3367a81118e5bf139b8d40", "message": "Fix tests now that the return type is not directly BigDecimal", "committedDate": "2020-02-11T15:33:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNDUzMQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378114531", "bodyText": "Using floor like that wouldn't return the correct values for negative numbers:\nselect trunc(-29.99);\n\nexpected:  -29\ngot:       -30", "author": "seut", "createdAt": "2020-02-12T08:59:15Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);\n+            }\n+        });\n+    }\n+\n+\n+    private static class OneParamTrunc extends UnaryScalar<Number, Number> {\n+\n+        OneParamTrunc(DataType argType, DataType returnType) {\n+            super(NAME, argType, returnType, n -> evaluate(n, returnType));\n+        }\n+\n+        static Number evaluate(Object n, DataType returnType) {\n+            return (Number) returnType.value(Math.floor(((Number) n).doubleValue()));", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNTA5NQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378115095", "bodyText": "Same floor issue with negative numbers as described before.", "author": "seut", "createdAt": "2020-02-12T09:00:22Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);\n+            }\n+        });\n+    }\n+\n+\n+    private static class OneParamTrunc extends UnaryScalar<Number, Number> {\n+\n+        OneParamTrunc(DataType argType, DataType returnType) {\n+            super(NAME, argType, returnType, n -> evaluate(n, returnType));\n+        }\n+\n+        static Number evaluate(Object n, DataType returnType) {\n+            return (Number) returnType.value(Math.floor(((Number) n).doubleValue()));\n+        }\n+    }\n+\n+    private static class TwoParamTrunc extends Scalar<Number, Number> {\n+\n+        private final FunctionInfo info;\n+        private final DataType returnType;\n+\n+        TwoParamTrunc(DataType argType, DataType returnType) {\n+            info = new FunctionInfo(new FunctionIdent(\n+                NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n+            this.returnType = returnType;\n+        }\n+\n+        @Override\n+        public FunctionInfo info() {\n+            return info;\n+        }\n+\n+        @Override\n+        public Number evaluate(TransactionContext txnCtx, Input<Number>... args) {\n+            Number n = args[0].value();\n+            int numDecimals = args[1].value().intValue();\n+            if (0 == numDecimals) {\n+                return OneParamTrunc.evaluate(n, returnType);\n+            } else {\n+                return BigDecimal.valueOf(n.doubleValue()).setScale(numDecimals, RoundingMode.FLOOR).doubleValue();", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjA4Ng==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378116086", "bodyText": "not sure if we really need this additional integration tests, I think the scalar unit tests are enough. Or do I miss some by unit tests not covered scenarios?", "author": "seut", "createdAt": "2020-02-12T09:02:11Z", "path": "sql/src/test/java/io/crate/integrationtests/ArithmeticIntegrationTest.java", "diffHunk": "@@ -70,6 +72,14 @@ public void testSelectWhereArithmeticScalar() throws Exception {\n         assertThat(response.rowCount(), is(1L));\n         assertThat((Long) response.rows()[0][0], is(2L));\n \n+        execute(\"select trunc(d) from t where trunc(d, 1) = 2.2\");\n+        assertThat(response.rowCount(), is(1L));\n+        assertThat((Long) response.rows()[0][0], is(2L));\n+\n+        execute(\"select trunc(d) from t where trunc(d, 2) = 29.19\");", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExOTE4Mw==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378119183", "bodyText": "I agree, the unit tests should cover all scenarios.", "author": "marregui", "createdAt": "2020-02-12T09:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExNjk0OA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378116948", "bodyText": "Is this worth having 2 implementations? Maybe we can just use 1 with a default val of 0.", "author": "seut", "createdAt": "2020-02-12T09:03:47Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == argsLen ?\n+                    new OneParamTrunc(argType, returnType) : new TwoParamTrunc(argType, returnType);", "originalCommit": "96c058f04bfd449a02c326bf3db9f51a07692c26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e23661f58619ab3133c8d709ee19d908af18533d", "url": "https://github.com/crate/crate/commit/e23661f58619ab3133c8d709ee19d908af18533d", "message": "Add test for trunc'ing negatives", "committedDate": "2020-02-12T09:54:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTEzMA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179130", "bodyText": "all input args must be checked for NULL values, otherwise this results in an NPE.", "author": "seut", "createdAt": "2020-02-12T10:58:22Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }\n+                return new Scalar<Number, Number>() {\n+\n+                    @Override\n+                    public FunctionInfo info() {\n+                        return info;\n+                    }\n+\n+                    @Override\n+                    public Number evaluate(TransactionContext txnCtx, Input<Number>... args) {\n+                        Number n = args[0].value();\n+                        int numDecimals = args.length > 1 ? args[1].value().intValue() : 0;\n+                        double val = n.doubleValue();", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTQ4MQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179481", "bodyText": "this should result in  isLiteral(29L).\nin general, normalizing using literals should always result in a literal, pls fix all normalize tests here please.", "author": "seut", "createdAt": "2020-02-12T10:58:59Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE3OTY4Ng==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378179686", "bodyText": "should result in isLiteral(null, DataTypes.LONG)", "author": "seut", "createdAt": "2020-02-12T10:59:24Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE, DataTypes.INTEGER)));\n+        assertNormalize(\"trunc(cast(null as double))\", isFunction(TruncFunction.NAME, List.of(DataTypes.DOUBLE)));", "originalCommit": "e23661f58619ab3133c8d709ee19d908af18533d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5a39228042bcfd455e54cb294c91895a1b850804", "url": "https://github.com/crate/crate/commit/5a39228042bcfd455e54cb294c91895a1b850804", "message": "Result should be literal", "committedDate": "2020-02-12T13:01:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNDYyMg==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378334622", "bodyText": "don't we want to treat trunc(number, 0) the same as trunc(number)?  At least pgsql behaves like this..", "author": "seut", "createdAt": "2020-02-12T15:43:37Z", "path": "sql/src/test/java/io/crate/expression/scalar/arithmetic/TruncFunctionTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+import static io.crate.testing.SymbolMatchers.isFunction;\n+import static io.crate.testing.SymbolMatchers.isLiteral;\n+\n+public class TruncFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test\n+    public void testNormalizeOnDouble() throws Exception {\n+        assertNormalize(\"trunc(29.1947)\", isLiteral(29L));\n+        assertNormalize(\"trunc(-29.1947)\", isLiteral(-29L));\n+        assertNormalize(\"trunc(29.1947, 0)\", isLiteral(29.0d));", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0MzAxOQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378343019", "bodyText": "You can use BaseFunctionResolver.", "author": "kovrus", "createdAt": "2020-02-12T15:55:58Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0OTUzOA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378349538", "bodyText": "thank you for that", "author": "marregui", "createdAt": "2020-02-12T16:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0MzAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0NDE5NA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378344194", "bodyText": "why do we need to assert it here, FunctionResolver#getSignature does it already.", "author": "kovrus", "createdAt": "2020-02-12T15:57:33Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378346994", "bodyText": "would it be simpler to replace it with UnaryScalar and BinaryScalar, so we can delegate null checks and inputs materialization to those classes.", "author": "kovrus", "createdAt": "2020-02-12T16:01:32Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.symbol.FuncArg;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.FunctionResolver;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new FunctionResolver() {\n+\n+            @Override\n+            public List<DataType> getSignature(List<? extends FuncArg> funcArgs) {\n+                return SIGNATURE.match(funcArgs);\n+            }\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                assert argsLen > 0 && argsLen <= 2 : \"number of args must be up to 2\";\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }\n+                return new Scalar<Number, Number>() {", "originalCommit": "5a39228042bcfd455e54cb294c91895a1b850804", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1MzkxNA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378353914", "bodyText": "thought of that, but then\npublic BinaryScalar(BinaryOperator<T> func, String name, DataType<T> type, Set<FunctionInfo.Feature> feature) {\n        this.func = func;\n        this.info = new FunctionInfo(new FunctionIdent(name, Arrays.asList(type, type)), type, FunctionInfo.Type.SCALAR, feature);\n        this.type = type;\n    }\n\nI need to fine tune the info.", "author": "marregui", "createdAt": "2020-02-12T16:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM1ODI4OA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r378358288", "bodyText": "we can add a new ctor like:\nBinaryScalar(BinaryOperator<T> func, String name, List<DataType<T>> argTypes, DataType<T> returnType)\n\nbut maybe too much for this PR", "author": "kovrus", "createdAt": "2020-02-12T16:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3NDk0MQ==", "url": "https://github.com/crate/crate/pull/9646#discussion_r379374941", "bodyText": "I think, I'd prefer to use a dedicated UnaryScalar for the 1 argument case, with 2 args we could always use the BigDecimal.valueOf(val).setScale(numDecimals, mode).doubleValue() logic, even with precision 0 it should work as defined.\nI'd use the concrete scalar impl only for the 2 args case. Adjusting the BinaryScalar to support different argtypes and return types violates a bit its semantic imho.", "author": "seut", "createdAt": "2020-02-14T11:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM0Njk5NA=="}], "type": "inlineReview"}, {"oid": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "url": "https://github.com/crate/crate/commit/a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "message": "Reference simplification/improvements", "committedDate": "2020-02-14T10:46:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTM3MjYyNg==", "url": "https://github.com/crate/crate/pull/9646#discussion_r379372626", "bodyText": "This could be a bit simplified (2nd arg is already ensured to be an INTEGER by the SIGNATURE):\nDataType returnType = types.size() == 1 ? DataTypes.getIntegralReturnType(argType) : DataTypes.DOUBLE;\nFunctionInfo info = new FunctionInfo(new FunctionIdent(NAME, types), returnType);", "author": "seut", "createdAt": "2020-02-14T11:03:20Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                int argsLen = types.size();\n+                DataType argType = types.get(0);\n+                DataType returnTypeSingleArg = DataTypes.getIntegralReturnType(argType);\n+                FunctionInfo info;\n+                if (1 == argsLen) {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType)),\n+                        returnTypeSingleArg);\n+                } else {\n+                    info = new FunctionInfo(\n+                        new FunctionIdent(NAME, List.of(argType, DataTypes.INTEGER)),\n+                        DataTypes.DOUBLE);\n+                }", "originalCommit": "a909d1f123d83dfd3b3631d2bf5e63e95a2da263", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a29b75425577b37252f8a3a203cfadc941f5a760", "url": "https://github.com/crate/crate/commit/a29b75425577b37252f8a3a203cfadc941f5a760", "message": "Simplify info construction", "committedDate": "2020-02-14T14:54:14Z", "type": "forcePushed"}, {"oid": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "url": "https://github.com/crate/crate/commit/057d3da6b0de3c51de6cec9fce2f9766c73601ee", "message": "Add Basti's suggestion of having a UnaryScalar and a Scalar\n\nfor the two different implementations.", "committedDate": "2020-02-17T10:03:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMjY3Mw==", "url": "https://github.com/crate/crate/pull/9646#discussion_r380122673", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);\n          \n          \n            \n                                        NAME, types), DataTypes.DOUBLE);", "author": "seut", "createdAt": "2020-02-17T11:14:39Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == types.size() ?\n+                    new UnaryScalar<Number, Number>(NAME, argType, returnType, n -> {\n+                        double val = n.doubleValue();\n+                        Function<Double, Double> f = val >= 0 ? Math::floor : Math::ceil;\n+                        return (Number) returnType.value(f.apply(val));\n+                    })\n+                    :\n+                    new Scalar<Number, Number>() {\n+\n+                        FunctionInfo info = new FunctionInfo(new FunctionIdent(\n+                            NAME, List.of(argType, DataTypes.INTEGER)), DataTypes.DOUBLE);", "originalCommit": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMjk2MA==", "url": "https://github.com/crate/crate/pull/9646#discussion_r380122960", "bodyText": "I'd prefer if/else for readability.", "author": "seut", "createdAt": "2020-02-17T11:15:17Z", "path": "sql/src/main/java/io/crate/expression/scalar/arithmetic/TruncFunction.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar.arithmetic;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.UnaryScalar;\n+import io.crate.metadata.BaseFunctionResolver;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionImplementation;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.params.FuncParams;\n+import io.crate.metadata.functions.params.Param;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.List;\n+import java.util.function.Function;\n+\n+\n+public final class TruncFunction {\n+\n+    public static final String NAME = \"trunc\";\n+    private static final FuncParams SIGNATURE = FuncParams\n+        .builder(Param.NUMERIC)\n+        .withVarArgs(Param.INTEGER)\n+        .limitVarArgOccurrences(1)\n+        .build();\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(NAME, new BaseFunctionResolver(SIGNATURE) {\n+\n+            @Override\n+            public FunctionImplementation getForTypes(List<DataType> types) throws IllegalArgumentException {\n+                DataType argType = types.get(0);\n+                DataType returnType = DataTypes.getIntegralReturnType(argType);\n+                return 1 == types.size() ?\n+                    new UnaryScalar<Number, Number>(NAME, argType, returnType, n -> {\n+                        double val = n.doubleValue();\n+                        Function<Double, Double> f = val >= 0 ? Math::floor : Math::ceil;\n+                        return (Number) returnType.value(f.apply(val));\n+                    })\n+                    :", "originalCommit": "057d3da6b0de3c51de6cec9fce2f9766c73601ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3e7c51cd96858799530566f9777bb4c7566a7f1f", "url": "https://github.com/crate/crate/commit/3e7c51cd96858799530566f9777bb4c7566a7f1f", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:02:49Z", "type": "forcePushed"}, {"oid": "1500b2a40db5f18b0632c48eb2deb23fdb330307", "url": "https://github.com/crate/crate/commit/1500b2a40db5f18b0632c48eb2deb23fdb330307", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:05:39Z", "type": "forcePushed"}, {"oid": "73c3d0ca2541a6294e15bde15861ec7722cccfac", "url": "https://github.com/crate/crate/commit/73c3d0ca2541a6294e15bde15861ec7722cccfac", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:07:47Z", "type": "commit"}, {"oid": "73c3d0ca2541a6294e15bde15861ec7722cccfac", "url": "https://github.com/crate/crate/commit/73c3d0ca2541a6294e15bde15861ec7722cccfac", "message": "Add the ``trunc`` scalar function", "committedDate": "2020-02-17T12:07:47Z", "type": "forcePushed"}]}