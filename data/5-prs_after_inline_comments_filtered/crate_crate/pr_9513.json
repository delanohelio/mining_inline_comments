{"pr_number": 9513, "pr_title": "Add missing object casts in the insert from subquery cast projection ", "pr_createdAt": "2020-01-15T10:07:44Z", "pr_url": "https://github.com/crate/crate/pull/9513", "timeline": [{"oid": "3248dc69a003c1d363798533e7a286ca5997ea31", "url": "https://github.com/crate/crate/commit/3248dc69a003c1d363798533e7a286ca5997ea31", "message": "Add missing object casts in insert from suqquery cast projection.", "committedDate": "2020-01-15T10:10:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366795809", "bodyText": "Added this condition just for now, so we always generated cast to object... Do you think we have to have a proper equal and isConvertible for object types, by proper i mean taking into account inner types and considering cases with different fields, undefined types, etc. I am not sure how straightforward that can be, coz isConvertible depends on equals now, but that would be now the way to go for object types and we would need to have a special handling for it. Probably, we have to do that anyways, just want to get some input on it.", "author": "kovrus", "createdAt": "2020-01-15T10:19:02Z", "path": "sql/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -58,7 +59,9 @@ public final Symbol cast(DataType<?> targetType) {\n      * @return An instance of {@link Function} which casts this symbol.\n      */\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n-        if (targetType.equals(valueType())) {\n+        // TODO implement is convertible for objects", "originalCommit": "3248dc69a003c1d363798533e7a286ca5997ea31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NzI5MA==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366857290", "bodyText": "Can you elaborate on the isConvertible relationship to equals?\nI think we should override equals on ObjectType to take inner-types into consideration.", "author": "mfussenegger", "createdAt": "2020-01-15T12:49:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkyNDc2MA==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366924760", "bodyText": "because isConvertableTo uses equals. We can have cases where we check whether some literal of an object type that missing the inner types info checked whether it can be converted to target object type with some inner types. It can also be other way around, where the source type has inner types and the target type missing them. I'd say that it is still ok to covert object to object if one missing the inner type info completely, but implementing the equal in this way seems to be not that correct. Therefore, i was talking about special handling of object types in isConvertible, but not sure :/", "author": "kovrus", "createdAt": "2020-01-15T15:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5NTgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366855622", "bodyText": "Would it make sense to always encode the return type into the cast function and generally remove the notion of having per type cast function names?\nSo that we don't have to treat object casts in a special way.", "author": "mfussenegger", "createdAt": "2020-01-15T12:45:00Z", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunctionResolver.java", "diffHunk": "@@ -21,70 +21,80 @@\n \n package io.crate.expression.scalar.cast;\n \n-import io.crate.common.collections.Lists2;\n import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.metadata.FunctionIdent;\n import io.crate.metadata.FunctionInfo;\n import io.crate.types.ArrayType;\n import io.crate.types.DataType;\n-import io.crate.types.ObjectType;\n \n import java.util.HashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n \n-import static io.crate.types.DataTypes.GEO_POINT;\n-import static io.crate.types.DataTypes.GEO_SHAPE;\n-import static io.crate.types.DataTypes.PRIMITIVE_TYPES;\n+import static io.crate.types.DataTypes.OBJECT;\n \n public class CastFunctionResolver {\n \n     static final String TRY_CAST_PREFIX = \"try_\";\n     private static final String TO_PREFIX = \"to_\";\n \n-    static final Map<DataType, String> CAST_SIGNATURES; // data type -> name\n-\n-    static {\n-        List<DataType> CAST_FUNC_TYPES = Lists2.concat(\n-            PRIMITIVE_TYPES,\n-            List.of(GEO_SHAPE, GEO_POINT, ObjectType.untyped()));\n-\n-        CAST_SIGNATURES = new HashMap<>((CAST_FUNC_TYPES.size()) * 2);\n-        for (var type : CAST_FUNC_TYPES) {\n-            CAST_SIGNATURES.put(type, castFuncName(type));\n-\n-            var arrayType = new ArrayType<>(type);\n-            CAST_SIGNATURES.put(arrayType, castFuncName(arrayType));\n-        }\n-    }\n-\n-    private static String castFuncName(DataType type) {\n-        return TO_PREFIX + type.getName();\n-    }\n-\n     public static Symbol generateCastFunction(Symbol sourceSymbol, DataType targetType, boolean tryCast) {\n         DataType sourceType = sourceSymbol.valueType();\n-        FunctionInfo functionInfo = functionInfo(sourceType, targetType, tryCast);\n-        return new Function(functionInfo, List.of(sourceSymbol));\n+        if (ArrayType.unnest(targetType).id() == OBJECT.id()) {\n+            // Currently, it is not possible to resolve a function based on\n+            // its return type which is required to create the `to_object` cast\n+            // function that would be able to utilize the inner object types.\n+            // Therefore, we register a dedicated `to object` cast function with\n+            // two arguments, where the second argument carries information about\n+            // the object target type and its inner types.\n+            return new Function(\n+                functionInfo(List.of(sourceType, targetType), targetType, tryCast),\n+                // the null literal is passed as an argument to match the method signature\n+                List.of(sourceSymbol, Literal.NULL));\n+        } else {\n+            return new Function(\n+                functionInfo(List.of(sourceType), targetType, tryCast),\n+                List.of(sourceSymbol));\n+        }", "originalCommit": "3248dc69a003c1d363798533e7a286ca5997ea31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg2ODMzMA==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366868330", "bodyText": "we can only provide the return type as a function argument, because at this step https://github.com/crate/crate/blob/master/sql/src/main/java/io/crate/expression/BaseImplementationSymbolVisitor.java#L56 when we resolve a function the return type info from the FunctionInfo is discarded. Thus, we would then need to make all the cast functions to take two arguments (source symbol and target type), and build Function with arguments like List.of(sourceSymbol, Literal.NULL)). But actually then we don't have to distinguish between cast and cast object functions. So do you suggest to go with the changing of the cast function signatures to take two args?", "author": "kovrus", "createdAt": "2020-01-15T13:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MDk5OQ==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366870999", "bodyText": "So do you suggest to go with the changing of the cast function signatures to take two args?\n\nYes. It is also a hack, but so is encoding the return type into the function name. And I think we're better off with a single hack than multiple hacks + using a different hack depending on which type.", "author": "mfussenegger", "createdAt": "2020-01-15T13:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg3MTQyNA==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366871424", "bodyText": "But we'll probably have to make sure that if a <4.0.12 node creates a plan with a old cast function name, it will still resolve on a node that includes this fix.", "author": "mfussenegger", "createdAt": "2020-01-15T13:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkxNTI4Mg==", "url": "https://github.com/crate/crate/pull/9513#discussion_r366915282", "bodyText": "maybe smth like that 4d7dcc3. it also stay backward compatible, coz resolvers either pick the provided pre-registered return data type or get it from the data types.", "author": "kovrus", "createdAt": "2020-01-15T14:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1NTYyMg=="}], "type": "inlineReview"}, {"oid": "4d7dcc32ff86e7668a2821a5250379546d45e288", "url": "https://github.com/crate/crate/commit/4d7dcc32ff86e7668a2821a5250379546d45e288", "message": "fixup! Register a dedicated cast function for object types.", "committedDate": "2020-01-15T14:45:05Z", "type": "forcePushed"}, {"oid": "f3ed6e3f814933b6f87605ace2efacbfa995977c", "url": "https://github.com/crate/crate/commit/f3ed6e3f814933b6f87605ace2efacbfa995977c", "message": "Add missing object casts in insert from suqquery cast projection.", "committedDate": "2020-01-20T09:46:20Z", "type": "forcePushed"}, {"oid": "9a01d11d050409da2d37eb985ab6daa4b6152ee9", "url": "https://github.com/crate/crate/commit/9a01d11d050409da2d37eb985ab6daa4b6152ee9", "message": "Merge CastFunction and TryCastFunction classes.", "committedDate": "2020-01-20T15:47:46Z", "type": "commit"}, {"oid": "666827543d2cf6a488899832a91fe16d312e0b19", "url": "https://github.com/crate/crate/commit/666827543d2cf6a488899832a91fe16d312e0b19", "message": "Add test for insert from subquery/values into the same partition.", "committedDate": "2020-01-20T15:57:26Z", "type": "forcePushed"}, {"oid": "f95392fd33cd050d580f6920b50662d9f1bf2526", "url": "https://github.com/crate/crate/commit/f95392fd33cd050d580f6920b50662d9f1bf2526", "message": "Add test for insert from subquery/values into the same partition.", "committedDate": "2020-01-20T22:12:42Z", "type": "forcePushed"}, {"oid": "cb399038aa6078b97df005d5a705d7af0ffac963", "url": "https://github.com/crate/crate/commit/cb399038aa6078b97df005d5a705d7af0ffac963", "message": "Add test for insert from subquery/values into the same partition.", "committedDate": "2020-01-20T22:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjIyMg==", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862222", "bodyText": "isn't it always 1 or 2 arguments?", "author": "seut", "createdAt": "2020-01-21T08:25:03Z", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "originalCommit": "cb399038aa6078b97df005d5a705d7af0ffac963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MjM4Mw==", "url": "https://github.com/crate/crate/pull/9513#discussion_r368862383", "bodyText": "Same here, I think this should be limited to 1 or 2 arguments", "author": "seut", "createdAt": "2020-01-21T08:25:25Z", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());", "originalCommit": "cb399038aa6078b97df005d5a705d7af0ffac963", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ==", "url": "https://github.com/crate/crate/pull/9513#discussion_r368876625", "bodyText": "Do we still need the CAST_SIGNATURES in the current form? I thought we're going to remove the to_<typeName> notation. Or is it still required for BWC?", "author": "mfussenegger", "createdAt": "2020-01-21T08:59:17Z", "path": "sql/src/main/java/io/crate/expression/scalar/cast/CastFunction.java", "diffHunk": "@@ -126,34 +125,93 @@ public boolean formatArgs(Function function) {\n         return true;\n     }\n \n-    private static class Resolver extends BaseFunctionResolver {\n+    private static class CastResolver extends BaseFunctionResolver {\n \n+        private final DataType<?> type;\n         private final String name;\n-        private final DataType targetType;\n \n-        Resolver(DataType targetType, String name) {\n-            super(FuncParams.builder(Param.ANY).build());\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> {\n+                throw new ConversionException(argument, returnType);\n+            };\n+\n+        CastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n             this.name = name;\n-            this.targetType = targetType;\n         }\n \n-        void checkPreconditions(List<DataType> dataTypes) {\n-            DataType convertFrom = dataTypes.get(0);\n-            if (!convertFrom.isConvertableTo(targetType)) {\n-                throw new ConversionException(convertFrom, targetType);\n+        @Override\n+        public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            DataType<?> sourceType = dataTypes.get(0);\n+            if (!sourceType.isConvertableTo(targetType)) {\n+                throw new ConversionException(sourceType, targetType);\n             }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n+        }\n+    }\n+\n+    private static class TryCastResolver extends BaseFunctionResolver {\n+\n+        private final DataType<?> type;\n+        private final String name;\n+\n+        private final BiFunction<Symbol, DataType<?>, Symbol> castOnNormalizeException =\n+            (argument, returnType) -> Literal.NULL;\n+        private final BiFunction<Object, DataType<?>, Object> castOnEvaluateException =\n+            (argument, returnType) -> null;\n+\n+        TryCastResolver(DataType type, String name) {\n+            super(FuncParams.builder().withIndependentVarArgs(Param.ANY).build());\n+            this.type = type;\n+            this.name = name;\n         }\n \n         @Override\n         public FunctionImplementation getForTypes(List<DataType> dataTypes) {\n-            checkPreconditions(dataTypes);\n-            return new CastFunction(new FunctionInfo(new FunctionIdent(name, dataTypes), targetType));\n+            DataType<?> targetType;\n+            if (dataTypes.size() > 1) {\n+                var targetTypeViaArg = dataTypes.get(1);\n+                targetType = targetTypeViaArg.id() != UndefinedType.ID ? targetTypeViaArg : type;\n+            } else {\n+                targetType = type;\n+            }\n+\n+            return new CastFunction(\n+                new FunctionInfo(new FunctionIdent(name, dataTypes), targetType),\n+                castOnNormalizeException,\n+                castOnEvaluateException\n+            );\n         }\n     }\n \n     public static void register(ScalarFunctionModule module) {\n-        for (Map.Entry<String, DataType> function : CastFunctionResolver.CAST_SIGNATURES.entrySet()) {\n-            module.register(function.getKey(), new Resolver(function.getValue(), function.getKey()));\n+        for (Map.Entry<String, DataType> function : CAST_SIGNATURES.entrySet()) {", "originalCommit": "cb399038aa6078b97df005d5a705d7af0ffac963", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5NDQ4MA==", "url": "https://github.com/crate/crate/pull/9513#discussion_r368894480", "bodyText": "It is actually needed for bwc.", "author": "kovrus", "createdAt": "2020-01-21T09:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkwMTM3Mg==", "url": "https://github.com/crate/crate/pull/9513#discussion_r368901372", "bodyText": "Could you add a comment about this? Also noting at which point we can remove it.", "author": "mfussenegger", "createdAt": "2020-01-21T09:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg3NjYyNQ=="}], "type": "inlineReview"}, {"oid": "4459e5196875cf00672efe86729c136119ce634d", "url": "https://github.com/crate/crate/commit/4459e5196875cf00672efe86729c136119ce634d", "message": "fixup! Pass the return type info as a second argument of cast functions.", "committedDate": "2020-01-21T09:34:25Z", "type": "forcePushed"}, {"oid": "5a242fadab4d74a5b5cce957778f311c8ee050ce", "url": "https://github.com/crate/crate/commit/5a242fadab4d74a5b5cce957778f311c8ee050ce", "message": "fixup! Pass the return type info as a second argument of cast functions.", "committedDate": "2020-01-21T09:39:30Z", "type": "forcePushed"}, {"oid": "d7a528e3d774fbd11d2b1fa9a7ae9ce9356df8b0", "url": "https://github.com/crate/crate/commit/d7a528e3d774fbd11d2b1fa9a7ae9ce9356df8b0", "message": "Pass the return type info as a second argument of cast functions.\n\nCurrently, it is not possible to resolve a function based on\nits return type. For instance, it won't be possible to generated\nan object cast function with the return type which inner types\nhave to be considered. Therefore, to bypass this limitation we\nencode the return type info as a second argument of a cast function\nand resolve the return type based on it.", "committedDate": "2020-01-21T10:36:33Z", "type": "commit"}, {"oid": "f04eceada1129575042cba85f72d18169df0ee4a", "url": "https://github.com/crate/crate/commit/f04eceada1129575042cba85f72d18169df0ee4a", "message": "Add test for insert from subquery/values into the same partition.", "committedDate": "2020-01-21T10:36:34Z", "type": "commit"}, {"oid": "f04eceada1129575042cba85f72d18169df0ee4a", "url": "https://github.com/crate/crate/commit/f04eceada1129575042cba85f72d18169df0ee4a", "message": "Add test for insert from subquery/values into the same partition.", "committedDate": "2020-01-21T10:36:34Z", "type": "forcePushed"}]}