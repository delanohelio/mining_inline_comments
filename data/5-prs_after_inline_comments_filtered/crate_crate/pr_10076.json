{"pr_number": 10076, "pr_title": "Add query optimizer incl. rules for cast optimizations", "pr_createdAt": "2020-06-11T15:46:23Z", "pr_url": "https://github.com/crate/crate/pull/10076", "timeline": [{"oid": "3efa9b457e875100a2dbf2534202086f68c29177", "url": "https://github.com/crate/crate/commit/3efa9b457e875100a2dbf2534202086f68c29177", "message": "Add query optimizer incl. rules for cast optimizations\n\nThis replaces the special literal downcast logic inside the deprecated/old\nfunction matching which caused bugs on arithmetics.\n\nThe optimizer runs before creating any `RoutedCollectPhase` while building\nexecution plans and thus only runs once per query.", "committedDate": "2020-06-11T16:02:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyNDg0Nw==", "url": "https://github.com/crate/crate/pull/10076#discussion_r438924847", "bodyText": "I wonder if we should trigger it inside the WhereClauseOptimizer instead to avoid to trigger it in 3 (select/update/delete) plans.", "author": "seut", "createdAt": "2020-06-11T16:42:24Z", "path": "server/src/main/java/io/crate/planner/operators/Collect.java", "diffHunk": "@@ -258,7 +260,7 @@ private RoutedCollectPhase createPhase(PlannerContext plannerContext, java.util.\n                 ? Lists2.map(boundOutputs, DocReferences::toSourceLookup)\n                 : boundOutputs,\n             Collections.emptyList(),\n-            where.queryOrFallback(),\n+            Optimizer.optimizeQuery(plannerContext, where.queryOrFallback()),", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA2OTk4NQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439069985", "bodyText": "Maybe we could create a new symbol or expression package within optimizer.\nThis stuff isn't necessarily reserved for the collect pieces.", "author": "mfussenegger", "createdAt": "2020-06-11T21:04:24Z", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDQ4Nw==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439070487", "bodyText": "() -> Version.CURRENT isn't the minNodeVersionInCluster. Is this correct?", "author": "mfussenegger", "createdAt": "2020-06-11T21:05:37Z", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.analyze.expressions.ExpressionAnalyzer;\n+import io.crate.common.collections.Lists2;\n+import io.crate.exceptions.ConversionException;\n+import io.crate.expression.symbol.FunctionCopyVisitor;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.PlannerContext;\n+import io.crate.planner.optimizer.collect.rule.MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveSubscriptOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Match;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class Optimizer {\n+\n+    public static Symbol optimizeQuery(PlannerContext plannerContext, Symbol query) {\n+        Optimizer optimizer = new Optimizer(\n+            plannerContext.functions(),\n+            plannerContext.transactionContext(),\n+            () -> Version.CURRENT,", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MDI0OA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439360248", "bodyText": "Yep, good catch.", "author": "seut", "createdAt": "2020-06-12T11:17:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MDQ4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MTAyMQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439071021", "bodyText": "Based on the types and name it is hard to guess what String and List<Symbol>, Symbol here are referring to. Maybe it would be worth to introduce a named specific interface?", "author": "mfussenegger", "createdAt": "2020-06-11T21:06:49Z", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Optimizer.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.analyze.expressions.ExpressionAnalyzer;\n+import io.crate.common.collections.Lists2;\n+import io.crate.exceptions.ConversionException;\n+import io.crate.expression.symbol.FunctionCopyVisitor;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.PlannerContext;\n+import io.crate.planner.optimizer.collect.rule.MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference;\n+import io.crate.planner.optimizer.collect.rule.MoveSubscriptOnReferenceCastToLiteralCastInsideOperators;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Match;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class Optimizer {\n+\n+    public static Symbol optimizeQuery(PlannerContext plannerContext, Symbol query) {\n+        Optimizer optimizer = new Optimizer(\n+            plannerContext.functions(),\n+            plannerContext.transactionContext(),\n+            () -> Version.CURRENT,\n+            List.of(\n+                MoveReferenceCastToLiteralCastInsideOperators::new,\n+                MoveReferenceCastToLiteralCastOnAnyOperatorsWhenRightIsReference::new,\n+                MoveReferenceCastToLiteralCastOnAnyOperatorsWhenLeftIsReference::new,\n+                MoveSubscriptOnReferenceCastToLiteralCastInsideOperators::new,\n+                MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators::new\n+            )\n+        );\n+        return optimizer.optimize(query);\n+    }\n+\n+    private static final Logger LOGGER = LogManager.getLogger(Optimizer.class);\n+\n+    private final List<Rule<?>> rules;\n+    private final Supplier<Version> minNodeVersionInCluster;\n+    private final Functions functions;\n+    private final Visitor visitor = new Visitor();\n+\n+    public Optimizer(Functions functions,\n+                     CoordinatorTxnCtx coordinatorTxnCtx,\n+                     Supplier<Version> minNodeVersionInCluster,\n+                     List<Function<BiFunction<String, List<Symbol>, Symbol>, Rule<?>>> rules) {\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver =", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439072834", "bodyText": "Should we try to create some \"matcher\" functions, similar to how isFunction(name, argMatcher...) works that we use in the tests?", "author": "mfussenegger", "createdAt": "2020-06-11T21:11:07Z", "path": "server/src/main/java/io/crate/planner/optimizer/collect/rule/MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect.rule;\n+\n+import io.crate.expression.scalar.ArrayUpperFunction;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.collect.Rule;\n+import io.crate.planner.optimizer.matcher.Capture;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import io.crate.types.DataType;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+\n+import static io.crate.expression.operator.Operators.COMPARISON_OPERATORS;\n+import static io.crate.expression.scalar.cast.CastFunctionResolver.CAST_FUNCTION_NAMES;\n+import static io.crate.planner.optimizer.matcher.Pattern.typeOf;\n+\n+\n+public class MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators implements Rule<Function> {\n+\n+    private final Capture<Function> castCapture;\n+    private final Pattern<Function> pattern;\n+    private final BiFunction<String, List<Symbol>, Symbol> functionResolver;\n+    private volatile boolean enabled = true;\n+\n+    public MoveArrayLengthOnReferenceCastToLiteralCastInsideOperators(\n+        BiFunction<String, List<Symbol>, Symbol> functionResolver\n+    ) {\n+        this.functionResolver = functionResolver;\n+        this.castCapture = new Capture<>();\n+        this.pattern = typeOf(Function.class)\n+            .with(f -> COMPARISON_OPERATORS.contains(f.info().ident().name()))\n+            .with(f -> f.arguments().get(1).symbolType() == SymbolType.LITERAL)\n+            .with(f -> Optional.of(f.arguments().get(0)), typeOf(Function.class).capturedAs(castCapture)", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMyMDc4NA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439320784", "bodyText": "Good idea, will try.", "author": "seut", "createdAt": "2020-06-12T09:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNTkyMA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440025920", "bodyText": "I'd suggest to do this as a follow up so we first could get this functionality merged in and finish up the complete function registry overhaul (move missing functions, afaik only operators left).", "author": "seut", "createdAt": "2020-06-15T08:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3MjgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439075771", "bodyText": "Is this to assign the name with the predicate? (Just to make sure I understand why this is being changed)\nI'm not sure I see the benefit of doing this in this new way?", "author": "mfussenegger", "createdAt": "2020-06-11T21:18:13Z", "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxMDEyNA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439310124", "bodyText": "We need to match inside the rule predicates again a list of all full-qualified internal operator names. (https://github.com/crate/crate/pull/10076/files#diff-cc8e036acde8edb2dfa2dd74f78d3336R40)\nAlso by doing it this way we just can loop over the enum to register the operators.\nWe could also do this in a concrete way (like it was before) and additionally store a list of the operator names. I guess this is a bit of personal preference, no strong opinion here.", "author": "seut", "createdAt": "2020-06-12T09:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMDY4Ng==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440000686", "bodyText": "We need to match inside the rule predicates again a list of all full-qualified internal operator names\n\nAh I missed that.\nCould we now also remove the Names class and refer to the enum directly instead?", "author": "mfussenegger", "createdAt": "2020-06-15T08:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3NzM4MQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439077381", "bodyText": "Looks like this is only used in tests. Maybe annotate with @VisibleForTesting", "author": "mfussenegger", "createdAt": "2020-06-11T21:22:04Z", "path": "server/src/main/java/io/crate/expression/operator/any/AnyOperators.java", "diffHunk": "@@ -22,42 +22,73 @@\n \n package io.crate.expression.operator.any;\n \n+import io.crate.common.collections.Lists2;\n+import io.crate.expression.operator.LikeOperators;\n import io.crate.expression.operator.OperatorModule;\n import io.crate.sql.tree.ComparisonExpression;\n \n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.List;\n import java.util.Locale;\n+import java.util.function.IntPredicate;\n \n import static io.crate.expression.operator.any.AnyOperator.OPERATOR_PREFIX;\n-import static io.crate.expression.operator.any.AnyOperators.Names.EQ;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.GTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LT;\n-import static io.crate.expression.operator.any.AnyOperators.Names.LTE;\n-import static io.crate.expression.operator.any.AnyOperators.Names.NEQ;\n \n public final class AnyOperators {\n \n-    private AnyOperators() {\n-    }\n+    public static final List<String> OPERATOR_NAMES = Lists2.concat(\n+        AnyOperators.Type.fullQualifiedNames(),\n+        List.of(\n+            LikeOperators.ANY_LIKE,\n+            LikeOperators.ANY_ILIKE,\n+            LikeOperators.ANY_NOT_LIKE,\n+            LikeOperators.ANY_NOT_ILIKE\n+        )\n+    );\n \n     public static class Names {\n-        public static final String EQ = OPERATOR_PREFIX + ComparisonExpression.Type.EQUAL.getValue();\n-        public static final String GTE = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN_OR_EQUAL.getValue();\n-        public static final String GT = OPERATOR_PREFIX + ComparisonExpression.Type.GREATER_THAN.getValue();\n-        public static final String LTE = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN_OR_EQUAL.getValue();\n-        public static final String LT = OPERATOR_PREFIX + ComparisonExpression.Type.LESS_THAN.getValue();\n-        public static final String NEQ = OPERATOR_PREFIX + ComparisonExpression.Type.NOT_EQUAL.getValue();\n+        public static final String EQ = Type.EQ.fullQualifiedName;\n+        public static final String GTE = Type.GTE.fullQualifiedName;\n+        public static final String GT = Type.GT.fullQualifiedName;\n+        public static final String LTE = Type.LTE.fullQualifiedName;\n+        public static final String LT = Type.LT.fullQualifiedName;\n+        public static final String NEQ = Type.NEQ.fullQualifiedName;\n+    }\n+\n+    public enum Type {\n+        EQ(ComparisonExpression.Type.EQUAL, result -> result == 0),\n+        NEQ(ComparisonExpression.Type.NOT_EQUAL, result -> result != 0),\n+        GTE(ComparisonExpression.Type.GREATER_THAN_OR_EQUAL, result -> result >= 0),\n+        GT(ComparisonExpression.Type.GREATER_THAN, result -> result > 0),\n+        LTE(ComparisonExpression.Type.LESS_THAN_OR_EQUAL, result -> result <= 0),\n+        LT(ComparisonExpression.Type.LESS_THAN, result -> result < 0);\n+\n+        final String fullQualifiedName;\n+        final String name;\n+        final IntPredicate cmp;\n+\n+        Type(ComparisonExpression.Type type, IntPredicate cmp) {\n+            this.fullQualifiedName = OPERATOR_PREFIX + type.getValue();\n+            this.name = type.getValue();\n+            this.cmp = cmp;\n+        }\n+\n+        public static List<String> fullQualifiedNames() {\n+            return Lists2.map(Arrays.asList(values()), t -> t.fullQualifiedName);\n+        }\n+\n+        public static List<String> operatorSymbols() {", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439078902", "bodyText": "Looks like in the call-sites of this we're now creating comparisons where the types don't match. Shouldn't they still be adjusted somehow?\nI'm afraid that this might bite us later if we don't do that.", "author": "mfussenegger", "createdAt": "2020-06-11T21:25:39Z", "path": "server/src/main/java/io/crate/expression/symbol/Symbols.java", "diffHunk": "@@ -170,6 +172,14 @@ public static String format(String messageTmpl, Symbol... symbols) {\n         return String.format(Locale.ENGLISH, messageTmpl, formattedSymbols);\n     }\n \n+    public static Symbol unwrapReferenceFromCast(Symbol symbol) {", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMwNzIyNw==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439307227", "bodyText": "It is only used to extract primary key columns or columns which generated column expressions are including/targeting to expand queries with the generated column. So the symbol tree will not be changed, the expanded generated column will still take the original comparison into account. Do I maybe miss something?", "author": "seut", "createdAt": "2020-06-12T09:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTE1Mw==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001153", "bodyText": "Do I maybe miss something?\n\nNo, thanks for the clarification - I misunderstood what's happening.", "author": "mfussenegger", "createdAt": "2020-06-15T08:10:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3ODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439079700", "bodyText": "Looks like this is not used yet. Should we remove this + isEnabled altogether for now?", "author": "mfussenegger", "createdAt": "2020-06-11T21:27:29Z", "path": "server/src/main/java/io/crate/planner/optimizer/collect/Rule.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.collect;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.planner.optimizer.matcher.Captures;\n+import io.crate.planner.optimizer.matcher.Pattern;\n+import org.elasticsearch.Version;\n+\n+public interface Rule<T> {\n+\n+    Pattern<T> pattern();\n+\n+    boolean isEnabled();\n+\n+    void setEnabled(boolean enabled);", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5MjcxOQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439292719", "bodyText": "Right. Maybe we should group all cast rules and expose one session setting to enable/disable all?", "author": "seut", "createdAt": "2020-06-12T08:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTQ4Mg==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001482", "bodyText": "Right. Maybe we should group all cast rules and expose one session setting to enable/disable all?\n\nNot sure. I'd leave it out and postpone the decision how to handle this for later.", "author": "mfussenegger", "createdAt": "2020-06-15T08:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA3OTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439080485", "bodyText": "Would date be casted to long without the explicit timestamp cast?\nHow would something like date >= '2019-01-01' behave?", "author": "mfussenegger", "createdAt": "2020-06-11T21:29:29Z", "path": "server/src/test/java/io/crate/analyze/DeleteAnalyzerTest.java", "diffHunk": "@@ -82,7 +82,7 @@ public void testDeleteWhereSysColumn() throws Exception {\n \n     @Test\n     public void testDeleteWherePartitionedByColumn() throws Exception {\n-        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000\");\n+        AnalyzedDeleteStatement delete = e.analyze(\"delete from parted where date = 1395874800000::timestamp\");", "originalCommit": "3efa9b457e875100a2dbf2534202086f68c29177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5NDA3OA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439294078", "bodyText": "Would date be casted to long without the explicit timestamp cast?\n\nYes. But the cast optimizer rules would change the cast to 1395874800000::timestamp eventually. I just wanted to avoid changing the assertions in that analyzer test.\n\nHow would something like date >= '2019-01-01' behave?\n\nThe same, cast on date will be replaced afterwards by the cast optimizer rules.", "author": "seut", "createdAt": "2020-06-12T08:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5ODQwNw==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439298407", "bodyText": "I think date::text >= '2019-01-01' has different semantics than date >= '2019-01-01'::timestamp has.\nIf we \"restore\" the later semantics only by the optimization, it's no longer only a performance optimization, but will be required for correct behavior - which I think is bad. We should be able to turn off all optimizations and every query should still return the same results as with the optimizations on.\nFor the numeric cases x::int = 1 or x = 1::long have the same behavior, so I think there it doesn't matter and is okay.\nMaybe we should add additional timestamp, text overloads for the comparison operators?", "author": "mfussenegger", "createdAt": "2020-06-12T09:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMxNDYzOA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r439314638", "bodyText": "I think date::text >= '2019-01-01' has different semantics than date >= '2019-01-01'::timestamp has.\n\nYeah right, good point.\n\nMaybe we should add additional timestamp, text overloads for the comparison operators?\n\nYes good idea. Could we then postpone this until the operators are refactored to use the new signature based function registry which easily allow overloads?\nI think adding this overload to the existing (old/deprecated) function resolver maybe tricky.", "author": "seut", "createdAt": "2020-06-12T09:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMTY0MQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440001641", "bodyText": "Could we then postpone this until the operators are refactored to use the new signature based function registry which easily allow overloads?\n\nyep", "author": "mfussenegger", "createdAt": "2020-06-15T08:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MDQ4NQ=="}], "type": "inlineReview"}, {"oid": "597ff9fa442dc639cffd76d3e6f88949086b371b", "url": "https://github.com/crate/crate/commit/597ff9fa442dc639cffd76d3e6f88949086b371b", "message": "fixup! Add query optimizer incl. rules for cast optimizations", "committedDate": "2020-06-15T11:23:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NTEyMA==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440145120", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Symbol apply(String bame, List<Symbol> arguments);\n          \n          \n            \n                Symbol apply(String name, List<Symbol> arguments);\n          \n      \n    \n    \n  \n\ntypo?", "author": "mfussenegger", "createdAt": "2020-06-15T12:38:27Z", "path": "server/src/main/java/io/crate/planner/optimizer/symbol/FunctionSymbolResolver.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.optimizer.symbol;\n+\n+import io.crate.expression.symbol.Symbol;\n+\n+import java.util.List;\n+\n+public interface FunctionSymbolResolver {\n+\n+    Symbol apply(String bame, List<Symbol> arguments);", "originalCommit": "597ff9fa442dc639cffd76d3e6f88949086b371b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE4MDMyMQ==", "url": "https://github.com/crate/crate/pull/10076#discussion_r440180321", "bodyText": "\ud83d\udc4d thx", "author": "seut", "createdAt": "2020-06-15T13:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE0NTEyMA=="}], "type": "inlineReview"}, {"oid": "5fc9a5de52f1036949d3283479d78321e5f3e44e", "url": "https://github.com/crate/crate/commit/5fc9a5de52f1036949d3283479d78321e5f3e44e", "message": "Add query optimizer incl. rules for cast optimizations\n\nThis replaces the special literal downcast logic inside the deprecated/old\nfunction matching which caused bugs on arithmetics.\n\nThe optimizer runs before creating any `RoutedCollectPhase` while building\nexecution plans and thus only runs once per query.", "committedDate": "2020-06-15T14:43:09Z", "type": "commit"}, {"oid": "5fc9a5de52f1036949d3283479d78321e5f3e44e", "url": "https://github.com/crate/crate/commit/5fc9a5de52f1036949d3283479d78321e5f3e44e", "message": "Add query optimizer incl. rules for cast optimizations\n\nThis replaces the special literal downcast logic inside the deprecated/old\nfunction matching which caused bugs on arithmetics.\n\nThe optimizer runs before creating any `RoutedCollectPhase` while building\nexecution plans and thus only runs once per query.", "committedDate": "2020-06-15T14:43:09Z", "type": "forcePushed"}, {"oid": "ee770ac8a5ecfced944413093bb07fe824715919", "url": "https://github.com/crate/crate/commit/ee770ac8a5ecfced944413093bb07fe824715919", "message": "Merge branch 'master' into s/cast-symbol-optimizer", "committedDate": "2020-06-15T15:17:45Z", "type": "commit"}]}