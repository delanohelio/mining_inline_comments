{"pr_number": 10826, "pr_title": "Add to_char scalar function", "pr_createdAt": "2020-11-26T16:26:05Z", "pr_url": "https://github.com/crate/crate/pull/10826", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531492552", "bodyText": "is it absolutely necessary to use joda time? I think we were actually moving away from it in favour of java time.", "author": "kovrus", "createdAt": "2020-11-27T09:51:05Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;", "originalCommit": "608b67d42fdffcabfe1e399338d69c86427c0e69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUyNTE5Ng==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531525196", "bodyText": "I wasn't sure - I was following what we've used in other scalar functions that involve intervals such as IntervalArithmeticScalar and IntervalTimestampArithmeticScalar. Totally happy to change it though", "author": "autophagy", "createdAt": "2020-11-27T10:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4OTg2Nw==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531589867", "bodyText": "Yes, it was used there because it seems that it was hard to go with java time in that case, but in I think the general rule we follow is going with java time if it is possible.", "author": "kovrus", "createdAt": "2020-11-27T13:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTY0MDg0NA==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531640844", "bodyText": "Just looking into it a bit further - would it be okay to use Joda for the time being here? IntervalType.sanitizeValue() itself returns a Joda period, and as far as I can tell converting between a Joda Period and a Java Period isn't super straightforward. Given we also use the Joda PeriodFormat here, maybe it makes sense to stick with Joda in this instance?", "author": "autophagy", "createdAt": "2020-11-27T14:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5MjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NDkzMQ==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531494931", "bodyText": "What do you think of using BinaryScalar and keeping the evaluate logic a bit more separated instead of having a generic function and then check for the type in the evaluate each time when it is executed? See CoordinateFunction or RoundFunction.", "author": "kovrus", "createdAt": "2020-11-27T09:55:19Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import io.crate.types.TimestampType;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        Stream.of(DataTypes.NUMERIC_PRIMITIVE_TYPES, List.of(DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP, DataTypes.INTERVAL))\n+            .flatMap(Collection::stream)\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ), ToCharFunction::new\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<Object>... args) {\n+        Literal expression = (Literal) args[0];\n+        int dataType = expression.valueType().id();\n+        if (TimestampType.ID_WITH_TZ == dataType) {\n+            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(String.valueOf(args[1].value()),\n+                                                                      Locale.ENGLISH);\n+            Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(args[0].value());", "originalCommit": "608b67d42fdffcabfe1e399338d69c86427c0e69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTUwNTU0OA==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531505548", "bodyText": "Aha! Yeah, I was just about to push a fixup where the evaluation logic was part of the registration step, rather than the evaluation step for every row. Thanks for the heads up \ud83d\ude42", "author": "autophagy", "createdAt": "2020-11-27T10:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NDkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQ5NTcxNw==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531495717", "bodyText": "it can result in NPE. You would have to do the null check yourself or if you use BinaryScalar, this case will be already taken care of.", "author": "kovrus", "createdAt": "2020-11-27T09:56:34Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataTypes;\n+import io.crate.types.IntervalType;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+import io.crate.types.TimestampType;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.stream.Stream;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        Stream.of(DataTypes.NUMERIC_PRIMITIVE_TYPES, List.of(DataTypes.TIMESTAMPZ, DataTypes.TIMESTAMP, DataTypes.INTERVAL))\n+            .flatMap(Collection::stream)\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ), ToCharFunction::new\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    @Override\n+    public String evaluate(TransactionContext txnCtx, NodeContext nodeCtx, Input<Object>... args) {\n+        Literal expression = (Literal) args[0];\n+        int dataType = expression.valueType().id();", "originalCommit": "608b67d42fdffcabfe1e399338d69c86427c0e69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTU4ODQ5MA==", "url": "https://github.com/crate/crate/pull/10826#discussion_r531588490", "bodyText": "maybe we can add some tests for the corner cases, like null handling, etc.", "author": "kovrus", "createdAt": "2020-11-27T13:00:15Z", "path": "server/src/test/java/io/crate/expression/scalar/ToCharFunctionTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import org.junit.Test;\n+\n+\n+public class ToCharFunctionTest extends AbstractScalarFunctionsTest {", "originalCommit": "82758a538ff1f330fc1f1a928b866ce761e8b164", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5b1e622cd5916a7b2f49497bcbcb517818f8762f", "url": "https://github.com/crate/crate/commit/5b1e622cd5916a7b2f49497bcbcb517818f8762f", "message": "Address nomi's comments", "committedDate": "2020-11-30T11:17:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MTk4NQ==", "url": "https://github.com/crate/crate/pull/10826#discussion_r532581985", "bodyText": "you do not really have to pass the argument type explicitly, you can already get it from the bound signature.\nassert boundSignature.getArgumentDataTypes().size() == 1\nboundSignature.getArgumentDataTypes().get(0)", "author": "kovrus", "createdAt": "2020-11-30T13:05:34Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;", "originalCommit": "5b1e622cd5916a7b2f49497bcbcb517818f8762f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ==", "url": "https://github.com/crate/crate/pull/10826#discussion_r532582711", "bodyText": "maybe we can reuse an instance of PeriodFormatter instead of initializing it on each function call.", "author": "kovrus", "createdAt": "2020-11-30T13:06:49Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    DataTypes.INTERVAL,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            type,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, DataType expressionType, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.expressionType = expressionType;\n+        this.evaluatorFunc = evaluatorFunc;\n+    }\n+\n+    private static String evaluateTimestamp(Object timestamp, String pattern) {\n+        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(pattern,\n+                                                                  Locale.ENGLISH);\n+        Long ts = DataTypes.TIMESTAMPZ.sanitizeValue(timestamp);\n+        LocalDateTime dateTime = LocalDateTime.ofInstant(Instant.ofEpochMilli(ts),\n+                                                         TimeZone.getTimeZone(\"UTC\").toZoneId());\n+        return formatter.format(dateTime);\n+    }\n+\n+    private static String evaluateInterval(Object interval, String pattern) {\n+        PeriodFormatter formatter = PeriodFormat.getDefault();", "originalCommit": "5b1e622cd5916a7b2f49497bcbcb517818f8762f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzIxMDQyOQ==", "url": "https://github.com/crate/crate/pull/10826#discussion_r533210429", "bodyText": "That would prevent the function from being static, right?", "author": "autophagy", "createdAt": "2020-12-01T09:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxNzA5Ng==", "url": "https://github.com/crate/crate/pull/10826#discussion_r533317096", "bodyText": "not really, you would have to do smth like:\nprivate static final PeriodFormatter PERIOD_FORMATTER = PeriodFormat.getDefault();", "author": "kovrus", "createdAt": "2020-12-01T10:52:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyMDExNQ==", "url": "https://github.com/crate/crate/pull/10826#discussion_r533320115", "bodyText": "Ah, of course \ud83e\udd26\u200d\u2640\ufe0f", "author": "autophagy", "createdAt": "2020-12-01T10:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjU4MjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyNzIzNw==", "url": "https://github.com/crate/crate/pull/10826#discussion_r533327237", "bodyText": "maybe add a message to the assertion, otherwise ack", "author": "kovrus", "createdAt": "2020-12-01T11:10:16Z", "path": "server/src/main/java/io/crate/expression/scalar/ToCharFunction.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.scalar;\n+\n+import io.crate.data.Input;\n+import io.crate.metadata.NodeContext;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.joda.time.Period;\n+import org.joda.time.format.PeriodFormat;\n+import org.joda.time.format.PeriodFormatter;\n+\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+import java.util.function.BiFunction;\n+\n+public class ToCharFunction extends Scalar<String, Object> {\n+\n+    public static final String NAME = \"to_char\";\n+\n+    public static void register(ScalarFunctionModule module) {\n+        List.of(DataTypes.TIMESTAMP, DataTypes.TIMESTAMPZ).stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            ToCharFunction::evaluateTimestamp\n+                        )\n+                );\n+            });\n+\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.INTERVAL.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature()\n+            ),\n+            (signature, boundSignature) ->\n+                new ToCharFunction(\n+                    signature,\n+                    boundSignature,\n+                    ToCharFunction::evaluateInterval\n+                )\n+        );\n+\n+        DataTypes.NUMERIC_PRIMITIVE_TYPES.stream()\n+            .forEach(type -> {\n+                module.register(\n+                    Signature.scalar(\n+                        NAME,\n+                        type.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature(),\n+                        DataTypes.STRING.getTypeSignature()\n+                    ),\n+                    (signature, boundSignature) ->\n+                        new ToCharFunction(\n+                            signature,\n+                            boundSignature,\n+                            ToCharFunction::evaluateNumber\n+                        )\n+                );\n+            });\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType expressionType;\n+    private final BiFunction<Object, String, String> evaluatorFunc;\n+\n+    private static final PeriodFormatter PERIOD_FORMATTER = PeriodFormat.getDefault();\n+\n+    public ToCharFunction(Signature signature, Signature boundSignature, BiFunction<Object, String, String> evaluatorFunc) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        assert boundSignature.getArgumentDataTypes().size() == 2;", "originalCommit": "30297ccccde26a4641aadf9675c472e1d37eaaa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f16e3ab2403f909184e002c1ee144d4c25d17f81", "url": "https://github.com/crate/crate/commit/f16e3ab2403f909184e002c1ee144d4c25d17f81", "message": "Add to_char scalar function", "committedDate": "2020-12-01T13:26:17Z", "type": "commit"}, {"oid": "f16e3ab2403f909184e002c1ee144d4c25d17f81", "url": "https://github.com/crate/crate/commit/f16e3ab2403f909184e002c1ee144d4c25d17f81", "message": "Add to_char scalar function", "committedDate": "2020-12-01T13:26:17Z", "type": "forcePushed"}]}