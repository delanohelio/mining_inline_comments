{"pr_number": 9833, "pr_title": "Unify lookup methods in PKLookupOperation", "pr_createdAt": "2020-03-31T12:04:51Z", "pr_url": "https://github.com/crate/crate/pull/9833", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NTkzOQ==", "url": "https://github.com/crate/crate/pull/9833#discussion_r400875939", "bodyText": "isn't projectors.wrap(...) missing here?", "author": "seut", "createdAt": "2020-03-31T12:33:40Z", "path": "sql/src/main/java/io/crate/execution/engine/collect/PKLookupOperation.java", "diffHunk": "@@ -177,60 +135,46 @@ public void runWithShardProjections(UUID jobId,\n                 }\n                 throw new ShardNotFoundException(shardId);\n             }\n-            try {\n-                shardAndIdsList.add(\n-                    new ShardAndIds(\n-                        shard,\n-                        shardCollectSource.getProjectorFactory(shardId),\n-                        idsByShardEntry.getValue()\n-                    ));\n-            } catch (ShardNotFoundException e) {\n-                if (ignoreMissing) {\n-                    continue;\n-                }\n-                throw e;\n-            }\n-        }\n-        ArrayList<BatchIterator<Row>> iterators = new ArrayList<>(shardAndIdsList.size());\n-        for (ShardAndIds shardAndIds : shardAndIdsList) {\n-            Stream<Row> rowStream = shardAndIds.value.stream()\n-                .map(pkAndVersion -> lookupDoc(shardAndIds.shard,\n-                                               pkAndVersion.id(),\n-                                               pkAndVersion.version(),\n-                                               pkAndVersion.seqNo(),\n-                                               pkAndVersion.primaryTerm()))\n+            Stream<Row> rowStream = idsByShardEntry.getValue().stream()\n+                .map(pkAndVersion -> lookupDoc(\n+                    shard,\n+                    pkAndVersion.id(),\n+                    pkAndVersion.version(),\n+                    VersionType.EXTERNAL,\n+                    pkAndVersion.seqNo(),\n+                    pkAndVersion.primaryTerm()))\n+                .filter(Objects::nonNull)\n                 .map(resultToRow);\n \n-            Projectors projectors = new Projectors(\n-                projections,\n-                jobId,\n-                txnCtx,\n-                ramAccountingSupplier.get(),\n-                memoryManagerSupplier.get(),\n-                shardAndIds.projectorFactory);\n-            final Iterable<Row> rowIterable;\n-            if (nodeConsumer.requiresScroll() && !projectors.providesIndependentScroll()) {\n-                rowIterable = rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList());\n+            if (projections.isEmpty()) {\n+                final Iterable<Row> rowIterable = requiresScroll\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));\n             } else {\n-                rowIterable = rowStream::iterator;\n+                ProjectorFactory projectorFactory;\n+                try {\n+                    projectorFactory = shardCollectSource.getProjectorFactory(shardId);\n+                } catch (ShardNotFoundException e) {\n+                    if (ignoreMissing) {\n+                        continue;\n+                    }\n+                    throw e;\n+                }\n+                Projectors projectors = new Projectors(\n+                    projections,\n+                    jobId,\n+                    txnCtx,\n+                    ramAccountingSupplier.get(),\n+                    memoryManagerSupplier.get(),\n+                    projectorFactory);\n+                final Iterable<Row> rowIterable = requiresScroll && !projectors.providesIndependentScroll()\n+                    ? rowStream.map(row -> new RowN(row.materialize())).collect(Collectors.toList())\n+                    : rowStream::iterator;\n+                iterators.add(InMemoryBatchIterator.of(rowIterable, SentinelRow.SENTINEL, true));", "originalCommit": "ae3cd47440ef75d363e53faf3405f8eb2ab449bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg4MDMyMg==", "url": "https://github.com/crate/crate/pull/9833#discussion_r400880322", "bodyText": "Right. Too much back & forth. I'll also append some changes that this code is actually used again.", "author": "mfussenegger", "createdAt": "2020-03-31T12:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NTkzOQ=="}], "type": "inlineReview"}, {"oid": "e6888f778adb54c1d75ad4a798b206cdedd96a5f", "url": "https://github.com/crate/crate/commit/e6888f778adb54c1d75ad4a798b206cdedd96a5f", "message": "Unify lookup methods in PKLookupOperation", "committedDate": "2020-03-31T13:19:12Z", "type": "commit"}, {"oid": "12e981d6ba25c66a1dd322da99d0d9e8cec9ed3b", "url": "https://github.com/crate/crate/commit/12e981d6ba25c66a1dd322da99d0d9e8cec9ed3b", "message": "Use shard projections on top of PKLookup", "committedDate": "2020-03-31T13:19:12Z", "type": "commit"}, {"oid": "19016189901bd23981f446f140f2bdaf6e9b0cce", "url": "https://github.com/crate/crate/commit/19016189901bd23981f446f140f2bdaf6e9b0cce", "message": "Use PKLookup for COPY TO if possible", "committedDate": "2020-03-31T13:19:12Z", "type": "commit"}, {"oid": "19016189901bd23981f446f140f2bdaf6e9b0cce", "url": "https://github.com/crate/crate/commit/19016189901bd23981f446f140f2bdaf6e9b0cce", "message": "Use PKLookup for COPY TO if possible", "committedDate": "2020-03-31T13:19:12Z", "type": "forcePushed"}]}