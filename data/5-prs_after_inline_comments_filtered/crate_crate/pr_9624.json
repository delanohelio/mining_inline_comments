{"pr_number": 9624, "pr_title": "Add returning for insert to storage engine", "pr_createdAt": "2020-02-05T11:43:38Z", "pr_url": "https://github.com/crate/crate/pull/9624", "timeline": [{"oid": "954ebedd1f94ae51d05695ba002472cd1963816b", "url": "https://github.com/crate/crate/commit/954ebedd1f94ae51d05695ba002472cd1963816b", "message": "Adapt InsertSourceGen to get all tests working (inefficient change)", "committedDate": "2020-02-06T14:18:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMxNjk0NA==", "url": "https://github.com/crate/crate/pull/9624#discussion_r376316944", "bodyText": "I am not sure if the ShardResponse.CompressedResult should have resultValues, it works, but seems to me semantically questionable.\nSo we could consider using the full ShardResponse when using return values instead or an own dedicated datastructure.", "author": "mkleen", "createdAt": "2020-02-07T10:22:22Z", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final List<Object[]> resultValues = new ArrayList<>();", "originalCommit": "d09063532acaa7dc407a01fdc8406b2f289e935f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "38591ccf274e4998028e771d0389bb9ab368d218", "url": "https://github.com/crate/crate/commit/38591ccf274e4998028e771d0389bb9ab368d218", "message": "Simplify TransportShardUpsertAction", "committedDate": "2020-02-07T17:21:26Z", "type": "forcePushed"}, {"oid": "cfb7667fb8a4bad1eb75b13d16d3401640bfb788", "url": "https://github.com/crate/crate/commit/cfb7667fb8a4bad1eb75b13d16d3401640bfb788", "message": "Simplify TransportShardUpsertAction", "committedDate": "2020-02-07T17:28:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r376889367", "bodyText": "According to @mfussenegger this case should never happen since the source would be only null if it is created from a FromRawInsertSource which only applies to the COPY statement, which does not have a returning clause. However, this make sure values are only converted back from BytesReference to Map<String, Object if result values are requested.", "author": "mkleen", "createdAt": "2020-02-10T06:46:46Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        final long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        final long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        final long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {", "originalCommit": "b5722a66711ce84783d1311fc496bc44aebaa012", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjA5Ng==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692096", "bodyText": "I think I was wrong. a INSERT INTO tbl (_raw) ... could probably also trigger this case.", "author": "mfussenegger", "createdAt": "2020-02-11T15:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg4OTM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MTQyNQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r376891425", "bodyText": "This change is needed to be able to retrieve the result as Map<String, Object>. In all cases except the one in FromRawInsertSource the data is already in the form of Map<String, Object> which is needed for the returnvalue evaluation. Otherwise the values would need to converted again from BytesReference, which is unnecessary and expensive.", "author": "mkleen", "createdAt": "2020-02-10T06:55:31Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -28,13 +28,17 @@\n import io.crate.metadata.doc.DocSysColumns;\n import io.crate.metadata.doc.DocTableInfo;\n import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n \n import java.io.IOException;\n import java.util.List;\n+import java.util.Map;\n \n public interface InsertSourceGen {\n \n-    BytesReference generateSourceAndCheckConstraints(Object[] values) throws IOException;\n+    BytesReference generateSourceAndCheckConstraintsAsBytesReference(Object[] values) throws IOException;\n+\n+    Map<String, Object> generateSourceAndCheckConstraints(Object[] values) throws IOException;", "originalCommit": "b5722a66711ce84783d1311fc496bc44aebaa012", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r376893241", "bodyText": "Minor: The type of outputs is defined in multiple ways over the codebase, sometimes it is List<Symbol> sometimes it is List<? extends Symbol> and sometimes it is List<Field>. Are there any cases where the output is not a Field  ?", "author": "mkleen", "createdAt": "2020-02-10T07:03:09Z", "path": "sql/src/main/java/io/crate/planner/operators/Insert.java", "diffHunk": "@@ -95,7 +95,7 @@ ColumnIndexWriterProjection columnIndexWriterProjection() {\n \n     @Override\n     public List<Symbol> outputs() {\n-        return MergeCountProjection.OUTPUTS;\n+        return (List<Symbol>) writeToTable.outputs();", "originalCommit": "555d0f64189e50104ceb5cab3ee4d4fa39d2ad32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NjUyMQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377696521", "bodyText": "Yes, there can be function symbols or Reference symbols as well.", "author": "mfussenegger", "createdAt": "2020-02-11T15:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg5MzI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r376998843", "bodyText": "This optimizes for the case where to insert value is already string-based.", "author": "mkleen", "createdAt": "2020-02-10T11:09:10Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +308,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        final BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {", "originalCommit": "e02cf964077f497226dcbdfc19642540f67a92a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MTQ3MQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377691471", "bodyText": "I think it would be worth adding the information that this is primarily a performance optimization as inline comment.", "author": "mfussenegger", "createdAt": "2020-02-11T15:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5ODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4Nzc0MA==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377687740", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private final ArrayList<Object[]> resultValues = new ArrayList<>();\n          \n          \n            \n                    private final ArrayList<Object[]> resultRows= new ArrayList<>();\n          \n      \n    \n    \n  \n\nI think rows would be less vague than values.", "author": "mfussenegger", "createdAt": "2020-02-11T14:58:50Z", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -257,6 +257,7 @@ public void writeTo(StreamOutput out) throws IOException {\n \n         private final BitSet successfulWrites = new BitSet();\n         private final BitSet failureLocations = new BitSet();\n+        private final ArrayList<Object[]> resultValues = new ArrayList<>();", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4ODQyNg==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377688426", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    public List<Object[]> resultValues() {\n          \n          \n            \n                    public List<Object[]> resultRows() {", "author": "mfussenegger", "createdAt": "2020-02-11T14:59:51Z", "path": "sql/src/main/java/io/crate/execution/dml/ShardResponse.java", "diffHunk": "@@ -280,6 +285,10 @@ public boolean failed(int location) {\n             return failureLocations.get(location);\n         }\n \n+        public List<Object[]> resultValues() {", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4OTk4Nw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377689987", "bodyText": "Would it be possible to add the default implementation to generateSourceAndCheckConstraintsAsBytesReference instead of adding an additional method?", "author": "mfussenegger", "createdAt": "2020-02-11T15:02:16Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/InsertSourceGen.java", "diffHunk": "@@ -51,4 +55,8 @@ static InsertSourceGen of(TransactionContext txnCtx,\n         }\n         return new InsertSourceFromCells(txnCtx, functions, table, indexName, validation, targets);\n     }\n+\n+    default BytesReference toBytesReference(Map<String, Object> source) throws IOException {", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377692688", "bodyText": "The other parameters have a different indentation than the last one. I'm surprised that checkstyle doesn't complain aobut this.", "author": "mfussenegger", "createdAt": "2020-02-11T15:06:33Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NTc3OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378095779", "bodyText": "I forgot to mention it, this formatting is on purpose. Ceckstyle complains if i format the lambda aligned to the other values, which seems wrong to me. [ant:checkstyle] [ERROR] /Users/mkleen/Code/crate/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java:357: 'lambda arguments' has incorrect indentation level 24, expected level should be 20. [Indentation]", "author": "mkleen", "createdAt": "2020-02-12T08:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExMTE5OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378111199", "bodyText": "I think the following passes:\ndiff --git a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\nindex 4001a79418..c9c1212316 100644\n--- a/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n+++ b/sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java\n@@ -347,13 +347,14 @@ public class TransportShardUpsertAction extends TransportShardAction<ShardUpsert\n             returnvalues = returnGen.generateReturnValues(\n                 // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n                 // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n-                new Doc(-1,\n-                        indexShard.shardId().getIndexName(),\n-                        item.id(),\n-                        indexResult.getVersion(),\n-                        indexResult.getSeqNo(),\n-                        primaryTerm,\n-                        source,\n+                new Doc(\n+                    -1,\n+                    indexShard.shardId().getIndexName(),\n+                    item.id(),\n+                    indexResult.getVersion(),\n+                    indexResult.getSeqNo(),\n+                    primaryTerm,\n+                    source,\n                     () -> \"\"\n                 )\n             );", "author": "mfussenegger", "createdAt": "2020-02-12T08:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MjY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MzE1Nw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693157", "bodyText": "I think it would also be worth adding a comment about why the -1 is okay.", "author": "mfussenegger", "createdAt": "2020-02-11T15:07:15Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,103 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = insertSourceGen.toBytesReference(source);\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(-1,", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377693949", "bodyText": "Nodes running 4.1 or earlier won't send this, so we need to add some BWC handling here.", "author": "mfussenegger", "createdAt": "2020-02-11T15:08:24Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA4OTYwOQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378089609", "bodyText": "Actually the whole block is already covered in a  if (in.getVersion().onOrAfter(Version.V_4_2_0)) statement.  Maybe this was not obvious from the change log. \n  \n    \n      crate/sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java\n    \n    \n         Line 121\n      in\n      720b84a\n    \n    \n    \n    \n\n        \n          \n           if (in.getVersion().onOrAfter(Version.V_4_2_0)) {", "author": "mkleen", "createdAt": "2020-02-12T08:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwODYyNw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378108627", "bodyText": "Ah right, didn't see this in the diff.", "author": "mfussenegger", "createdAt": "2020-02-12T08:47:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5Mzk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377694898", "bodyText": "What is the difference between returnValues and outputs? Isn't it redundant to have both?", "author": "mfussenegger", "createdAt": "2020-02-11T15:09:48Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/ColumnIndexWriterProjection.java", "diffHunk": "@@ -115,9 +124,41 @@ public ColumnIndexWriterProjection(RelationName relationName,\n             for (int i = 0; i < mapSize; i++) {\n                 allTargetColumns.add(Reference.fromStream(in));\n             }\n+\n+            int outputSize = in.readVInt();\n+            if (outputSize > 0) {\n+                var result = new ArrayList<Symbol>(outputSize);\n+                for (int i = 0; i < outputSize; i++) {\n+                    result.add(Symbols.fromStream(in));\n+                }\n+                outputs = result;\n+            } else {\n+                outputs = List.of();\n+            }\n+\n+            int returnValueSize = in.readVInt();\n+            if (returnValueSize > 0) {\n+                returnValues = new ArrayList<>(returnValueSize);\n+                for (int i = 0; i < returnValueSize; i++) {\n+                    returnValues.add(Symbols.fromStream(in));\n+                }\n+            } else {\n+                returnValues = List.of();\n+            }\n         } else {\n+            returnValues = List.of();\n+            outputs = List.of();\n             allTargetColumns = List.of();\n         }\n+\n+    }\n+\n+    public List<? extends Symbol> outputs() {\n+        return outputs;\n+    }\n+\n+    public List<Symbol> returnValues() {", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5MTA5OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378091099", "bodyText": "They are not the same. outputs are the types of result e.g. long for rowcount, while returnValues are the expression of the returning clause evaluated against the document.", "author": "mkleen", "createdAt": "2020-02-12T08:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODEwODM1Mg==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378108352", "bodyText": "But if returnValues are present, then the outputs must match. (Or at least have matching types).\nI think this needs at least some clarification via comments how they relate to each other. Or maybe utilize the outputs for both and have some flag that indicates if it is a result set or a single rowcount.", "author": "mfussenegger", "createdAt": "2020-02-12T08:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1NjU0OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378156549", "bodyText": "I just tried your suggestion to use the outputs and a flag indicating what is the purpose of the outputs and it clearly does not make the code simpler, because now i have to treat outputs in different ways depending on the purpose. For now I added a comment with the relationship between output and returnvalues and will give it a second thought also related to updates. If we do this change we should probably do it also for update related datastructures to be consistent.", "author": "mkleen", "createdAt": "2020-02-12T10:16:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5NDg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5ODc1NA==", "url": "https://github.com/crate/crate/pull/9624#discussion_r377698754", "bodyText": "Maybe limit this to only the one table that is used in the tests.\nWastes some CPU cycles and makes it more difficult to have an overview what schemas are in use in this file.", "author": "mfussenegger", "createdAt": "2020-02-11T15:15:33Z", "path": "sql/src/test/java/io/crate/planner/consumer/InsertFromSubQueryPlannerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.planner.consumer;\n+\n+import com.carrotsearch.randomizedtesting.RandomizedTest;\n+import io.crate.analyze.TableDefinitions;\n+import io.crate.exceptions.UnsupportedFeatureException;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.PartitionName;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.SQLExecutor;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static java.util.Collections.singletonList;\n+\n+public class InsertFromSubQueryPlannerTest extends CrateDummyClusterServiceUnitTest {\n+\n+    private SQLExecutor e;\n+    private TransactionContext txnCtx = CoordinatorTxnCtx.systemTransactionContext();\n+\n+    @Before\n+    public void prepare() throws IOException {\n+        e = buildExecutor(clusterService);\n+    }\n+\n+    private static SQLExecutor buildExecutor(ClusterService clusterService) throws IOException {\n+        return SQLExecutor.builder(clusterService, 2, RandomizedTest.getRandom())\n+            .enableDefaultTables()", "originalCommit": "720b84a7c13191c2fddac716de4e7e49ed70f603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5MTIwMw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378091203", "bodyText": "Good point, thank you!", "author": "mkleen", "createdAt": "2020-02-12T08:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5ODc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzI4OQ==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378097289", "bodyText": "Checkstyle lambda oddity again, see comment before.", "author": "mkleen", "createdAt": "2020-02-12T08:22:47Z", "path": "sql/src/main/java/io/crate/execution/dml/upsert/TransportShardUpsertAction.java", "diffHunk": "@@ -309,53 +306,108 @@ private IndexItemResponse indexItem(ShardUpsertRequest request,\n     }\n \n     @VisibleForTesting\n-    protected IndexItemResponse indexItem(ShardUpsertRequest request,\n-                                          ShardUpsertRequest.Item item,\n-                                          IndexShard indexShard,\n-                                          boolean tryInsertFirst,\n-                                          UpdateSourceGen updateSourceGen,\n-                                          InsertSourceGen insertSourceGen,\n-                                          @Nullable ReturnValueGen returnGen,\n-                                          boolean isRetry) throws Exception {\n-        final long seqNo;\n-        final long primaryTerm;\n-        final long version;\n-        Doc updatedDoc = null;\n-        if (tryInsertFirst) {\n-            version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE\n-                ? Versions.MATCH_ANY\n-                : Versions.MATCH_DELETED;\n-            seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n-            primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n-            try {\n-                item.source(insertSourceGen.generateSourceAndCheckConstraints(item.insertValues()));\n-            } catch (IOException e) {\n-                throw ExceptionsHelper.convertToElastic(e);\n+    protected IndexItemResponse insert(ShardUpsertRequest request,\n+                                       ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable InsertSourceGen insertSourceGen) throws Exception {\n+        assert insertSourceGen != null : \"InsertSourceGen must not be null\";\n+        BytesReference rawSource;\n+        Map<String, Object> source = null;\n+        try {\n+            // This optimizes for the case where the insert value is already string-based.\n+            if (insertSourceGen instanceof FromRawInsertSource) {\n+                rawSource = insertSourceGen.generateSourceAndCheckConstraintsAsBytesReference(item.insertValues());\n+            } else {\n+                source = insertSourceGen.generateSourceAndCheckConstraints(item.insertValues());\n+                rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n             }\n-        } else {\n-            Doc currentDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n-\n-            Map<String, Object> updatedSource = updateSourceGen.generateSource(\n-                currentDoc,\n-                item.updateAssignments(),\n-                item.insertValues()\n-            );\n-\n-            if (item.returnValues() != null) {\n-                updatedDoc = currentDoc.withUpdatedSource(updatedSource);\n+        } catch (IOException e) {\n+            throw ExceptionsHelper.convertToElastic(e);\n+        }\n+        item.source(rawSource);\n+\n+        long version = request.duplicateKeyAction() == DuplicateKeyAction.OVERWRITE ? Versions.MATCH_ANY : Versions.MATCH_DELETED;\n+        long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO;\n+        long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            // This optimizes for the case where the insert value is already string-based, so only parse the source\n+            // when return values are requested\n+            if (source == null) {\n+                source = JsonXContent.jsonXContent.createParser(\n+                    NamedXContentRegistry.EMPTY,\n+                    DeprecationHandler.THROW_UNSUPPORTED_OPERATION,\n+                    BytesReference.toBytes(rawSource)).map();\n             }\n+            returnvalues = returnGen.generateReturnValues(\n+                // return -1 as docId, the docId can only be retrieved by fetching the inserted document again, which\n+                // we want to avoid. The docId is anyway just valid with the lifetime of a searcher and can change afterwards.\n+                new Doc(-1,\n+                        indexShard.shardId().getIndexName(),\n+                        item.id(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        primaryTerm,\n+                        source,\n+                    () -> \"\"\n+                )\n+            );\n+        }\n+        return new IndexItemResponse(indexResult.getTranslogLocation(), returnvalues);\n+    }\n \n-            item.source(BytesReference.bytes(XContentFactory.jsonBuilder().map(updatedSource)));\n-            seqNo = item.seqNo();\n-            primaryTerm = item.primaryTerm();\n-            version = Versions.MATCH_ANY;\n+    protected IndexItemResponse update(ShardUpsertRequest.Item item,\n+                                       IndexShard indexShard,\n+                                       boolean isRetry,\n+                                       @Nullable ReturnValueGen returnGen,\n+                                       @Nullable UpdateSourceGen updateSourceGen) throws Exception {\n+        assert updateSourceGen != null : \"UpdateSourceGen must not be null\";\n+        Doc fetchedDoc = getDocument(indexShard, item.id(), item.version(), item.seqNo(), item.primaryTerm());\n+        Map<String, Object> source = updateSourceGen.generateSource(\n+            fetchedDoc,\n+            item.updateAssignments(),\n+            item.insertValues()\n+        );\n+        BytesReference rawSource = BytesReference.bytes(XContentFactory.jsonBuilder().map(source));\n+        item.source(rawSource);\n+        long seqNo = item.seqNo();\n+        long primaryTerm = item.primaryTerm();\n+        long version = Versions.MATCH_ANY;\n+\n+        Engine.IndexResult indexResult = index(item, indexShard, isRetry, seqNo, primaryTerm, version);\n+        Object[] returnvalues = null;\n+        if (returnGen != null) {\n+            returnvalues = returnGen.generateReturnValues(\n+                new Doc(fetchedDoc.docId(),\n+                        fetchedDoc.getIndex(),\n+                        fetchedDoc.getId(),\n+                        indexResult.getVersion(),\n+                        indexResult.getSeqNo(),\n+                        indexResult.getTerm(),\n+                        source,\n+                    () -> \"\")", "originalCommit": "a411e5152b95add7f9ea58590e5823e1fbf4f5d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODExMTg0Nw==", "url": "https://github.com/crate/crate/pull/9624#discussion_r378111847", "bodyText": "See my comment further above, if each arg is on a newline checkstyle passes.", "author": "mfussenegger", "createdAt": "2020-02-12T08:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NzI4OQ=="}], "type": "inlineReview"}, {"oid": "a61e6d581a99439b9e806c3993c064efcc1781ce", "url": "https://github.com/crate/crate/commit/a61e6d581a99439b9e806c3993c064efcc1781ce", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-12T11:02:03Z", "type": "commit"}, {"oid": "a61e6d581a99439b9e806c3993c064efcc1781ce", "url": "https://github.com/crate/crate/commit/a61e6d581a99439b9e806c3993c064efcc1781ce", "message": "Add returning clause for insert to storage engine", "committedDate": "2020-02-12T11:02:03Z", "type": "forcePushed"}]}