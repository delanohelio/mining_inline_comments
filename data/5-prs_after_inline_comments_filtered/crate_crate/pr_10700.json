{"pr_number": 10700, "pr_title": "Implement \"CREATE TABLE AS\"", "pr_createdAt": "2020-10-24T00:33:43Z", "pr_url": "https://github.com/crate/crate/pull/10700", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NTYzNw==", "url": "https://github.com/crate/crate/pull/10700#discussion_r512565637", "bodyText": "I think this logic here may break if the query isn't a simple select ... from tbl because it assumes there is a QuerySpecification and that the relations are Table instances.\nI think to support all kinds of query it would be possible to use the RelationAnalyzer to analyze the query, and then to create the required table elements from the outputs of the AnalyzedRelation.", "author": "mfussenegger", "createdAt": "2020-10-27T10:15:27Z", "path": "server/src/main/java/io/crate/analyze/CreateTableAsAnalyzer.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.RelationAnalyzer;\n+import io.crate.metadata.CoordinatorTxnCtx;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.metadata.table.Operation;\n+import io.crate.sql.tree.AllColumns;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.CreateTable;\n+import io.crate.sql.tree.CreateTableAs;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.GenericProperties;\n+import io.crate.sql.tree.Insert;\n+import io.crate.sql.tree.QualifiedName;\n+import io.crate.sql.tree.QualifiedNameReference;\n+import io.crate.sql.tree.Query;\n+import io.crate.sql.tree.QuerySpecification;\n+import io.crate.sql.tree.Relation;\n+import io.crate.sql.tree.SelectItem;\n+import io.crate.sql.tree.SingleColumn;\n+import io.crate.sql.tree.Table;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public final class CreateTableAsAnalyzer {\n+\n+    private final CreateTableStatementAnalyzer createTableStatementAnalyzer;\n+    private final InsertAnalyzer insertAnalyzer;\n+    private final RelationAnalyzer relationAnalyzer;\n+    private final Schemas schemas;\n+\n+    public CreateTableAsAnalyzer(CreateTableStatementAnalyzer createTableStatementAnalyzer,\n+                                 InsertAnalyzer insertAnalyzer,\n+                                 RelationAnalyzer relationAnalyzer,\n+                                 Schemas schemas) {\n+        this.createTableStatementAnalyzer = createTableStatementAnalyzer;\n+        this.insertAnalyzer = insertAnalyzer;\n+        this.relationAnalyzer = relationAnalyzer;\n+        this.schemas = schemas;\n+    }\n+\n+    public AnalyzedCreateTableAs analyze(CreateTableAs createTableAs,\n+                                         ParamTypeHints paramTypeHints,\n+                                         CoordinatorTxnCtx txnCtx) {\n+        RelationName relationName = RelationName.of(\n+            createTableAs.name().getName(), txnCtx.sessionContext().searchPath().currentSchema()\n+        );\n+        relationName.ensureValidForRelationCreation();\n+\n+        List<TableElement<Expression>> tableElements = getTableElementsFromSourceQuery(\n+            createTableAs.query(), txnCtx\n+        );\n+        CreateTable<Expression> createTable = new CreateTable<Expression>(\n+            createTableAs.name(),\n+            tableElements,\n+            Optional.empty(),\n+            Optional.empty(),\n+            GenericProperties.empty(),\n+            false\n+        );\n+\n+        //postponing the analysis of the insert statement, since the table has not been created yet.\n+        Supplier<AnalyzedInsertStatement> postponedInsertAnalysis = () -> {\n+                Insert<Expression> insert = new Insert<>(\n+                    createTableAs.name(),\n+                    createTableAs.query(),\n+                    Collections.emptyList(),\n+                    Collections.emptyList(),\n+                    Insert.DuplicateKeyContext.none()\n+                );\n+                return insertAnalyzer.analyze(insert, paramTypeHints, txnCtx);\n+            };\n+\n+        return new AnalyzedCreateTableAs(\n+            createTableStatementAnalyzer.analyze(createTable, paramTypeHints, txnCtx),\n+            postponedInsertAnalysis\n+        );\n+    }\n+\n+    private DocTableInfo resolveTableInfo(Table table,\n+                             CoordinatorTxnCtx txnCtx) {\n+        return (DocTableInfo) schemas.resolveTableInfo(\n+            table.getName(),\n+            Operation.INSERT,\n+            txnCtx.sessionContext().sessionUser(),\n+            txnCtx.sessionContext().searchPath()\n+        );\n+    }\n+\n+    private List<TableElement<Expression>> getTableElementsFromSourceQuery (Query sourceQuery,\n+                                                                            CoordinatorTxnCtx txnCtx) {\n+        var querySpec = (QuerySpecification) sourceQuery.getQueryBody();\n+        List<Relation> relations = querySpec.getFrom();\n+        List<SelectItem> selectItems = querySpec.getSelect().getSelectItems();\n+\n+        List<TableElement<Expression>> allTableElements = relations.stream()\n+            .map(relation -> (Table)relation)", "originalCommit": "a710cf7fc738b1693dd666a63e3de49a00e6d872", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc4ODgwNA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r512788804", "bodyText": "thanks for reviewing and suggestions! will move on", "author": "jeeminso", "createdAt": "2020-10-27T15:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjU2NTYzNw=="}], "type": "inlineReview"}, {"oid": "9c0637fa43357325e0d331ed224fdcbf49eae776", "url": "https://github.com/crate/crate/commit/9c0637fa43357325e0d331ed224fdcbf49eae776", "message": "create-table-as 2nd commit\n\nnow ColumnDefinitions are recovered by traversing analyzedRelations and converting its outputs.\ncreated an Extractor class for it and few sample test cases.", "committedDate": "2020-11-16T19:04:10Z", "type": "forcePushed"}, {"oid": "402c8af45fce5f9d5a335137567bee387e9928e1", "url": "https://github.com/crate/crate/commit/402c8af45fce5f9d5a335137567bee387e9928e1", "message": "create-table-as: code re-formatting", "committedDate": "2020-11-18T19:26:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529415040", "bodyText": "I think I don't really understand why the visiting of the relations is necessary.\nWouldn't it be sufficient to do something like this:\nreturn Lists2.map(analyzedRelation.outputs(), this::outputToColumnDefinition)\nAnd outputToColumnDefinition would look something like this:\npublic static ColumnDefinition<Expression> outputToColumnDefinition(Symbol symbol) {\n    ColumnIdent column = Symbols.pathFromSymbol(symbol);\n\n    var type = MetadataToASTNodeResolver.dataTypeToColumnType(...);\n    return new ColumnDefinition<>(\n      column.name(),\n      null,       // default expression is always null\n      null,       // generated expression is always null\n      type,\n      List.of()   // constraints are always empty\n    )\n}\nIt looks like constraints are never copied from the source, so the above should be sufficient to handle all source relations in a generic way.\nPostgreSQL:\npsql=# create table tbl (x int default 10);\nTime: 16.267 ms\npsql=# create table copy as (select * from tbl);\nTime: 3.355 ms\npsql=# \\d copy\n                Table \"public.copy\"\n Column |  Type   | Collation | Nullable | Default\n--------+---------+-----------+----------+---------\n x      | integer |           |          |", "author": "mfussenegger", "createdAt": "2020-11-24T10:24:59Z", "path": "server/src/main/java/io/crate/analyze/ColumnDefinitionExtractor.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.analyze.relations.AliasedAnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelation;\n+import io.crate.analyze.relations.AnalyzedRelationVisitor;\n+import io.crate.analyze.relations.AnalyzedView;\n+import io.crate.analyze.relations.DocTableRelation;\n+import io.crate.analyze.relations.TableFunctionRelation;\n+import io.crate.analyze.relations.UnionSelect;\n+import io.crate.expression.symbol.AliasSymbol;\n+import io.crate.expression.symbol.Function;\n+import io.crate.expression.symbol.ScopedSymbol;\n+import io.crate.expression.symbol.SymbolVisitor;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.Schemas;\n+import io.crate.metadata.doc.DocTableInfo;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.TableElement;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/*\n+ *  For the given Query(type: analyzedRelation), a list of tableElements will be returned according to its fields.\n+ */\n+public class ColumnDefinitionExtractor {\n+\n+    private final Schemas schemas;\n+    //along the traversal, TableIdents or Aliases and its TableElements are stored for re-use\n+    private final Map<RelationName, List<TableElement<Expression>>> TableIdentsToTableElementsMap = new HashMap<>();\n+    private final QueryAnalyzedRelationVisitor queryAnalyzedRelationVisitor = new QueryAnalyzedRelationVisitor();\n+    private final FieldsAstVisitor fieldsAstVisitor = new FieldsAstVisitor();\n+\n+\n+    public ColumnDefinitionExtractor(Schemas schemas) {\n+        this.schemas = schemas;\n+    }\n+\n+    public List<TableElement<Expression>> extractFrom(AnalyzedRelation analyzedRelation){\n+        return analyzedRelation.accept(queryAnalyzedRelationVisitor,null);\n+    }", "originalCommit": "fbb0ee1906f5e0b9de1e64defca7bf883064e814", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQzMjcxOA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529432718", "bodyText": "FWIW, the optional like_option clauses to the general CREATE TABLE statement [1] will allow users to specify which additional properties of the original table to copy.\nThe SO article at [2] outlines this a bit more and gives some examples.\n-- Apply all properties from the source table.\nCREATE TABLE IF NOT EXISTS <ClonedTableName> (LIKE <OriginalTableName> INCLUDING ALL);\n\n-- Apply specific properties from the source table.\nCREATE TABLE <ClonedTableName> (LIKE <OriginalTableName> INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES);\n[1] https://www.postgresql.org/docs/current/sql-createtable.html\n[2] https://stackoverflow.com/questions/11176383/create-table-as-with-primary-key-in-one-statement-postgresql\n\nSo, would the visiting of the relations as implemented by @jeeminso be suitable to reuse for implementing the CREATE TABLE LIKE feature instead?", "author": "amotl", "createdAt": "2020-11-24T10:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ0NTkxNw==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529445917", "bodyText": "So, would the visiting of the relations as implemented by @jeeminso be suitable to reuse for implementing the CREATE TABLE LIKE feature instead?\n\nI think it requires a different implementation. LIKE is restricted to a table name, not an arbitrary relation, so it won't be necessary to handle different concrete AnalyzedRelation implementations\nAlso: I think for a first version it's okay to not support the LIKE clause. We can extend that later in separate PRs. Otherwise this one will become rather big.", "author": "mfussenegger", "createdAt": "2020-11-24T10:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ1Mjg3MQ==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529452871", "bodyText": "It looks like constraints are never copied from the source, so the above should be sufficient to handle all source relations in a generic way.\n\nYes, if constraints are not required, outputToColumnDefinition() should be sufficient.\nOne question, I tried it on MySQL and observed the constraints copied, does CrateDB references Postgres documents only?\nmysql> create table tbl (x int default 10);\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql> show create table tbl;\n+-------+----------------------------------------------------------------------------------------+\n| Table | Create Table                                                                           |\n+-------+----------------------------------------------------------------------------------------+\n| tbl   | CREATE TABLE `tbl` (\n  `x` int(11) DEFAULT '10'\n) ENGINE=InnoDB DEFAULT CHARSET=latin1 |\n+-------+----------------------------------------------------------------------------------------+\n1 row in set (0.00 sec)\n\nmysql> create table copy as (select * from tbl);\nQuery OK, 0 rows affected (0.06 sec)\nRecords: 0  Duplicates: 0  Warnings: 0\n\nmysql> show create table copy;\n+-------+-----------------------------------------------------------------------------------------+\n| Table | Create Table                                                                            |\n+-------+-----------------------------------------------------------------------------------------+\n| copy  | CREATE TABLE `copy` (\n  `x` int(11) DEFAULT '10'\n) ENGINE=InnoDB DEFAULT CHARSET=latin1 |\n+-------+-----------------------------------------------------------------------------------------+\n1 row in set (0.00 sec)", "author": "jeeminso", "createdAt": "2020-11-24T10:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ1ODY0MA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529458640", "bodyText": "does CrateDB references Postgres documents only?\n\nyes, we try to follow the SQL Standard and if there are behaviour extensions we try to mimic PostgreSQL.", "author": "mfussenegger", "createdAt": "2020-11-24T11:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDQzNg==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529474436", "bodyText": "thanks for clarification, will drop the 'visiting relations' logic and proceed.", "author": "jeeminso", "createdAt": "2020-11-24T11:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3Nzk3NQ==", "url": "https://github.com/crate/crate/pull/10700#discussion_r529477975", "bodyText": "Also: I think for a first version it's okay to not support the LIKE clause. We can extend that later in separate PRs. Otherwise this one will become rather big.\n\nSure. I didn't want to argue otherwise and just wanted to support this conversation by giving a perspective into the other syntax which supports transferring table properties. Thanks for sorting this out, @jeeminso and @mfussenegger!", "author": "amotl", "createdAt": "2020-11-24T11:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEzMjU0NA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r530132544", "bodyText": "I have spent some time on this and encountered one issue. If one of the outputs (from the analyzedQuery) is a type of ScopedSymbol with its dataType being an ObjectType, its ColumnPolicy cannot be recovered without 'visiting relations'. Please help clarify whether recovering ColumnPolicy is required.\nI have tried to find Postgres equivalent of ObjectType and it seems that CompositeType is the closest but does not have ColumnPolicy feature.\nCurrently, I assigned ColumnPolicy.STRICT which should be default for ObjectTypes.\nAttached below the code snippet, in case you are interested. (almost all of the changes since the last changeset)\n    private List<TableElement<Expression>> getTableElementsFromSourceQuery(Query sourceQuery,\n                                                                           ParamTypeHints paramTypeHints,\n                                                                           CoordinatorTxnCtx txnCtx) {\n\n        AnalyzedRelation analyzedSourceQuery = relationAnalyzer.analyze(\n            sourceQuery,\n            new StatementAnalysisContext(paramTypeHints, Operation.READ, txnCtx));\n\n        return Lists2.map(analyzedSourceQuery.outputs(), CreateTableAsAnalyzer::outputToColumnDefinition);\n    }\n\n    private static ColumnDefinition<Expression> outputToColumnDefinition(Symbol symbol) {\n\n        final ColumnIdent column = Symbols.pathFromSymbol(symbol);\n        final ColumnPolicy columnPolicy = ColumnPolicy.STRICT;\n        final DataType<?> dataType = symbol.valueType();\n        var columnType = dataTypeToColumnType(dataType, columnPolicy);\n\n        return new ColumnDefinition<>(\n            column.name(),\n            null,\n            null,\n            columnType,\n            List.of()\n        );\n    }\n\n    //The original version from MetadataToASTNodeResolver depends on its private Extractor \n    // that makes use of extractColumnDefinitions() and DocTableInfo\n    private static ColumnType<Expression> dataTypeToColumnType(DataType<?> type,\n                                                               ColumnPolicy columnPolicy) {\n\n        if (type.id() == ObjectType.ID) {\n            List<ColumnDefinition<Expression>> childColumns = new ArrayList<>();\n            ((ObjectType) type).innerTypes().forEach(\n                (childName, childDataType) -> {\n                    childColumns.add(\n                        new ColumnDefinition<>(\n                            childName,\n                            null,\n                            null,\n                            dataTypeToColumnType(childDataType, columnPolicy),\n                            List.of())\n                    );\n                }\n            );\n            return new ObjectColumnType<>(columnPolicy.name(), childColumns);\n        } else if (type.id() == ArrayType.ID) {\n            DataType<?> innerType = ((ArrayType<?>) type).innerType();\n            return new CollectionColumnType<>(dataTypeToColumnType(\n                innerType,\n                columnPolicy\n            ));\n        } else if (type.id() == StringType.ID) {\n            StringType stringType = (StringType) type;\n            if (stringType.unbound()) {\n                return new ColumnType<>(type.getName());\n            } else {\n                return new ColumnType<>(\"VARCHAR\", List.of(stringType.lengthLimit()));\n            }\n        } else {\n            return new ColumnType<>(type.getName());\n        }\n    }", "author": "jeeminso", "createdAt": "2020-11-25T06:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDQ3NjQ2Mg==", "url": "https://github.com/crate/crate/pull/10700#discussion_r530476462", "bodyText": "I think for now it is okay to proceed with defaulting to ColumnPolicy.STRICT.\nWe may have to refactor the structures later to expose the column policy as part of the object-type, but we can follow up on that at a later point.", "author": "mfussenegger", "createdAt": "2020-11-25T15:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxNTA0MA=="}], "type": "inlineReview"}, {"oid": "3295e29dd3d3a2ffec114b8b7378371afa84c2e8", "url": "https://github.com/crate/crate/commit/3295e29dd3d3a2ffec114b8b7378371afa84c2e8", "message": "refactored createTableAsAnalyzer, added unittesting for symbolToColDefConverter", "committedDate": "2020-12-01T00:35:53Z", "type": "forcePushed"}, {"oid": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7", "url": "https://github.com/crate/crate/commit/660cf8a105c9a5e57406c7ddc881eeb4457c7df7", "message": "refactored createTableAsAnalyzer, added unittesting for symbolToColDefConverter", "committedDate": "2020-12-01T00:53:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxNzE1OQ==", "url": "https://github.com/crate/crate/pull/10700#discussion_r554917159", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static ColumnDefinition<Expression> convert(Symbol symbol) {\n          \n          \n            \n                    return symbolToColumnDefinition(symbol);\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nI think going with just symbolToColumnDefinition directly should be good enough?", "author": "mfussenegger", "createdAt": "2021-01-11T09:33:25Z", "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.ColumnIdent;\n+import io.crate.sql.tree.CollectionColumnType;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnPolicy;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.ObjectColumnType;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.ObjectType;\n+import io.crate.types.StringType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SymbolToColumnDefinitionConverter {\n+\n+    private static final ColumnPolicy OBJECT_TYPE_DEFAULT_COLUMN_POLICY = ColumnPolicy.STRICT;\n+\n+    public static ColumnDefinition<Expression> convert(Symbol symbol) {\n+        return symbolToColumnDefinition(symbol);\n+    }\n+", "originalCommit": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxOTg5OQ==", "url": "https://github.com/crate/crate/pull/10700#discussion_r554919899", "bodyText": "Would it be possible to adapt the code in MetadataToASTNodeResolver to use a shared version?", "author": "mfussenegger", "createdAt": "2021-01-11T09:38:15Z", "path": "server/src/main/java/io/crate/analyze/SymbolToColumnDefinitionConverter.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.analyze;\n+\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.metadata.ColumnIdent;\n+import io.crate.sql.tree.CollectionColumnType;\n+import io.crate.sql.tree.ColumnDefinition;\n+import io.crate.sql.tree.ColumnPolicy;\n+import io.crate.sql.tree.ColumnType;\n+import io.crate.sql.tree.Expression;\n+import io.crate.sql.tree.ObjectColumnType;\n+import io.crate.types.ArrayType;\n+import io.crate.types.DataType;\n+import io.crate.types.ObjectType;\n+import io.crate.types.StringType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class SymbolToColumnDefinitionConverter {\n+\n+    private static final ColumnPolicy OBJECT_TYPE_DEFAULT_COLUMN_POLICY = ColumnPolicy.STRICT;\n+\n+    public static ColumnDefinition<Expression> convert(Symbol symbol) {\n+        return symbolToColumnDefinition(symbol);\n+    }\n+\n+    private static ColumnDefinition<Expression> symbolToColumnDefinition(Symbol symbol) {\n+\n+        final ColumnIdent column = Symbols.pathFromSymbol(symbol);\n+        final DataType<?> dataType = symbol.valueType();\n+        var columnType = dataTypeToColumnType(dataType);\n+\n+        //handles the case when an ObjectType's field is to be re-constructed.\n+        String columnName = (column.path().isEmpty()) ? column.name() : column.path().get(column.path().size() - 1);\n+\n+        return new ColumnDefinition<>(\n+            columnName,\n+            null,\n+            null,\n+            columnType,\n+            List.of());\n+    }\n+\n+    //The original version from MetadataToASTNodeResolver depends on its private Extractor\n+    // that makes use of extractColumnDefinitions() and DocTableInfo", "originalCommit": "660cf8a105c9a5e57406c7ddc881eeb4457c7df7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE5NjMzMg==", "url": "https://github.com/crate/crate/pull/10700#discussion_r556196332", "bodyText": "ok thanks, will look into it.\nare you referring to the commented code in the testcase? it was just for me to use as a reference, will remove that, for non-draft PR. Thank you", "author": "jeeminso", "createdAt": "2021-01-13T01:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDkxOTg5OQ=="}], "type": "inlineReview"}, {"oid": "7056f7485ef4d2074be3a65c8a30031fc220b9f9", "url": "https://github.com/crate/crate/commit/7056f7485ef4d2074be3a65c8a30031fc220b9f9", "message": "shared ver. of dataTypeToColumnType, and addressed few other minor issues", "committedDate": "2021-01-21T13:19:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MDg2Mw==", "url": "https://github.com/crate/crate/pull/10700#discussion_r564690863", "bodyText": "Why did this change to lowercase?", "author": "mfussenegger", "createdAt": "2021-01-26T17:22:24Z", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -109,7 +124,7 @@ public static Expression expressionFromColumn(ColumnIdent ident) {\n             if (stringType.unbound()) {\n                 return new ColumnType<>(type.getName());\n             } else {\n-                return new ColumnType<>(\"VARCHAR\", List.of(stringType.lengthLimit()));\n+                return new ColumnType<>(\"varchar\", List.of(stringType.lengthLimit()));", "originalCommit": "0914192b5f46550ca2b26aba9745aebebfd9500b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MTM5NA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r564691394", "bodyText": "Could you revert the unrelated formatting changes here?", "author": "mfussenegger", "createdAt": "2021-01-26T17:23:04Z", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -283,9 +313,9 @@ public Extractor(DocTableInfo tableInfo) {\n             GenericProperties<Expression> properties = new GenericProperties<>();\n             Expression numReplicas = new StringLiteral(tableInfo.numberOfReplicas());\n             properties.add(new GenericProperty<>(\n-                TableParameters.NUMBER_OF_REPLICAS.getKey(),\n-                numReplicas\n-                )\n+                               TableParameters.NUMBER_OF_REPLICAS.getKey(),\n+                               numReplicas\n+                           )", "originalCommit": "0914192b5f46550ca2b26aba9745aebebfd9500b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDY5MTQ1OA==", "url": "https://github.com/crate/crate/pull/10700#discussion_r564691458", "bodyText": "Same here", "author": "mfussenegger", "createdAt": "2021-01-26T17:23:11Z", "path": "server/src/main/java/io/crate/analyze/MetadataToASTNodeResolver.java", "diffHunk": "@@ -294,9 +324,9 @@ public Extractor(DocTableInfo tableInfo) {\n             );\n             for (Map.Entry<String, Object> entry : tableParameters.entrySet()) {\n                 properties.add(new GenericProperty<>(\n-                        TableParameters.stripIndexPrefix(entry.getKey()),\n-                        Literal.fromObject(entry.getValue())\n-                    )\n+                                   TableParameters.stripIndexPrefix(entry.getKey()),\n+                                   Literal.fromObject(entry.getValue())\n+                               )", "originalCommit": "0914192b5f46550ca2b26aba9745aebebfd9500b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d3d37094f757de540fa7bf9091c24ba7b6a34745", "url": "https://github.com/crate/crate/commit/d3d37094f757de540fa7bf9091c24ba7b6a34745", "message": "integration tests and minor fixes", "committedDate": "2021-02-01T21:17:25Z", "type": "forcePushed"}, {"oid": "de3d68dc2f2b952e04fc0cb36549b56226244122", "url": "https://github.com/crate/crate/commit/de3d68dc2f2b952e04fc0cb36549b56226244122", "message": "integration tests and minor fixes", "committedDate": "2021-02-01T21:19:19Z", "type": "forcePushed"}, {"oid": "aa8407a3b4cafd4cc6d80dfb582b2ecb26588be8", "url": "https://github.com/crate/crate/commit/aa8407a3b4cafd4cc6d80dfb582b2ecb26588be8", "message": "create-table-as docs", "committedDate": "2021-02-02T03:31:35Z", "type": "forcePushed"}, {"oid": "afcbadb1455da60df029605d4ed6f75c37bfbbb0", "url": "https://github.com/crate/crate/commit/afcbadb1455da60df029605d4ed6f75c37bfbbb0", "message": "create-table-as docs", "committedDate": "2021-02-02T04:12:52Z", "type": "forcePushed"}, {"oid": "847c4e03bb3cb38e021fa3d9d8d2b8d79a4f0a43", "url": "https://github.com/crate/crate/commit/847c4e03bb3cb38e021fa3d9d8d2b8d79a4f0a43", "message": "create-table-as docs", "committedDate": "2021-02-02T05:05:58Z", "type": "forcePushed"}, {"oid": "192076579e8b9a83e76ccca1e1072624d4069831", "url": "https://github.com/crate/crate/commit/192076579e8b9a83e76ccca1e1072624d4069831", "message": "Add the CREATE TABLE AS statement", "committedDate": "2021-02-22T15:21:37Z", "type": "commit"}, {"oid": "192076579e8b9a83e76ccca1e1072624d4069831", "url": "https://github.com/crate/crate/commit/192076579e8b9a83e76ccca1e1072624d4069831", "message": "Add the CREATE TABLE AS statement", "committedDate": "2021-02-22T15:21:37Z", "type": "forcePushed"}, {"oid": "684bbd2ebe804488f5475b400c73ce55559ccd99", "url": "https://github.com/crate/crate/commit/684bbd2ebe804488f5475b400c73ce55559ccd99", "message": "Merge branch 'master' into create-table-as", "committedDate": "2021-02-22T15:58:15Z", "type": "commit"}]}