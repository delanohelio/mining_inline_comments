{"pr_number": 9928, "pr_title": "Use the new function registry for the subscript functions.", "pr_createdAt": "2020-05-06T12:30:40Z", "pr_url": "https://github.com/crate/crate/pull/9928", "timeline": [{"oid": "b6aef2ea90d219e6018879d096480aa944ee55a0", "url": "https://github.com/crate/crate/commit/b6aef2ea90d219e6018879d096480aa944ee55a0", "message": "WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-06T14:01:38Z", "type": "forcePushed"}, {"oid": "44f2a6f3e536594bc9420695bb1ae3daf063c760", "url": "https://github.com/crate/crate/commit/44f2a6f3e536594bc9420695bb1ae3daf063c760", "message": "fixup! WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-07T09:16:34Z", "type": "forcePushed"}, {"oid": "049c5ebd92d8582ac497d1cc351772d32a574ed7", "url": "https://github.com/crate/crate/commit/049c5ebd92d8582ac497d1cc351772d32a574ed7", "message": "fixup! WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-07T13:28:59Z", "type": "forcePushed"}, {"oid": "7d3f92525aa6c6fb69dd3866d322ce89c92b6e15", "url": "https://github.com/crate/crate/commit/7d3f92525aa6c6fb69dd3866d322ce89c92b6e15", "message": "fixup! WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-07T13:40:24Z", "type": "forcePushed"}, {"oid": "30248f04ebe3e0813145dfef21f2621480f31a6c", "url": "https://github.com/crate/crate/commit/30248f04ebe3e0813145dfef21f2621480f31a6c", "message": "WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-11T11:00:08Z", "type": "forcePushed"}, {"oid": "12947b5820c939a8276ddd04de32e7c0fee8d94d", "url": "https://github.com/crate/crate/commit/12947b5820c939a8276ddd04de32e7c0fee8d94d", "message": "WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-11T12:34:32Z", "type": "forcePushed"}, {"oid": "18c63ea99949243557568fcdc92877c088a9cfa0", "url": "https://github.com/crate/crate/commit/18c63ea99949243557568fcdc92877c088a9cfa0", "message": "fixup! fixup! WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-12T13:34:46Z", "type": "forcePushed"}, {"oid": "5893e641ae7aa580cc2a05d77ec092504f0412e4", "url": "https://github.com/crate/crate/commit/5893e641ae7aa580cc2a05d77ec092504f0412e4", "message": "fixup! fixup! fixup! WIP: Use the new func registry for the subscript functions.", "committedDate": "2020-05-12T14:35:03Z", "type": "forcePushed"}, {"oid": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "url": "https://github.com/crate/crate/commit/d6c62a0509e1c54ed81f2c312395c53a723d0b39", "message": "Use the new func registry for the subscript functions.", "committedDate": "2020-05-12T21:15:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI0OTQ2OA==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424249468", "bodyText": "nitpick: should be folded into the line above or indented.", "author": "seut", "createdAt": "2020-05-13T08:06:24Z", "path": "server/src/main/java/io/crate/expression/scalar/SubscriptFunction.java", "diffHunk": "@@ -57,14 +57,73 @@\n \n     public static final String NAME = \"subscript\";\n \n+    private final Signature signature;\n     private final FunctionInfo info;\n     private final BiFunction<Object, Object, Object> lookup;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        // subscript(array(object)), text) -> array(undefined)\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                parseTypeSignature(\"array(object)\"),\n+                DataTypes.STRING.getTypeSignature(),\n+                parseTypeSignature(\"array(undefined)\")),\n+            (signature, dataTypes) -> new SubscriptFunction(\n+                signature,\n+                FunctionInfo.of(NAME, dataTypes, new ArrayType<>(DataTypes.UNDEFINED)),\n+                SubscriptFunction::lookupIntoListObjectsByName)\n+        );\n+        // subscript(array(any)), text) -> any\n+        module.register(\n+            Signature\n+                .scalar(\n+                    NAME,\n+                    parseTypeSignature(\"array(E)\"),\n+                    DataTypes.INTEGER.getTypeSignature(),\n+                    parseTypeSignature(\"E\"))\n+                .withTypeVariableConstraints(\n+                typeVariable(\"E\")),", "originalCommit": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MDE3NQ==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424250175", "bodyText": "Could we document this a bit (why is this needed)?", "author": "seut", "createdAt": "2020-05-13T08:07:38Z", "path": "server/src/main/java/io/crate/expression/scalar/SubscriptFunction.java", "diffHunk": "@@ -57,14 +57,73 @@\n \n     public static final String NAME = \"subscript\";\n \n+    private final Signature signature;\n     private final FunctionInfo info;\n     private final BiFunction<Object, Object, Object> lookup;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        // subscript(array(object)), text) -> array(undefined)\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                parseTypeSignature(\"array(object)\"),\n+                DataTypes.STRING.getTypeSignature(),\n+                parseTypeSignature(\"array(undefined)\")),\n+            (signature, dataTypes) -> new SubscriptFunction(\n+                signature,\n+                FunctionInfo.of(NAME, dataTypes, new ArrayType<>(DataTypes.UNDEFINED)),\n+                SubscriptFunction::lookupIntoListObjectsByName)\n+        );\n+        // subscript(array(any)), text) -> any\n+        module.register(\n+            Signature\n+                .scalar(\n+                    NAME,\n+                    parseTypeSignature(\"array(E)\"),\n+                    DataTypes.INTEGER.getTypeSignature(),\n+                    parseTypeSignature(\"E\"))\n+                .withTypeVariableConstraints(\n+                typeVariable(\"E\")),\n+            (signature, dataTypes) -> {\n+                var returnType = ((ArrayType<?>) dataTypes.get(0)).innerType();\n+                return new SubscriptFunction(\n+                    signature,\n+                    FunctionInfo.of(NAME, dataTypes, returnType),\n+                    SubscriptFunction::lookupByNumericIndex);\n+            });\n+        // subscript(object(text, element), text) -> element\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                DataTypes.UNTYPED_OBJECT.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.UNDEFINED.getTypeSignature()),\n+            (signature, dataTypes) ->\n+                new SubscriptFunction(\n+                    signature,\n+                    new FunctionInfo(new FunctionIdent(NAME, dataTypes), DataTypes.UNDEFINED),\n+                    SubscriptFunction::lookupByName\n+                )\n+        );\n+        module.register(", "originalCommit": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MTM2Mw==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424251363", "bodyText": "I think this error message is not really understandable for users. Is it possible to improve here?", "author": "seut", "createdAt": "2020-05-13T08:09:33Z", "path": "server/src/test/java/io/crate/expression/scalar/SubscriptFunctionTest.java", "diffHunk": "@@ -69,9 +69,7 @@ public void testIndexOutOfRange() throws Exception {\n \n     @Test\n     public void testIndexExpressionIsNotInteger() throws Exception {\n-        expectedException.expectMessage(\n-            \"`index` in subscript expression (`base[index]`) \" +\n-            \"must be a numeric type if the base expression is text_array\");\n+        expectedException.expectMessage(\"No cast function found for return type undefined\");", "originalCommit": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ1NzE2Mg==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424457162", "bodyText": "probably cannot do it better than this https://github.com/crate/crate/pull/9928/files#diff-fb3a57a840597e5dc05aa82f387d13e6R406, otherwise, we will get the casting exception message.", "author": "kovrus", "createdAt": "2020-05-13T13:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MTM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ2OTI0Mg==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424469242", "bodyText": "\ud83d\udc4d Think this is much better now.", "author": "seut", "createdAt": "2020-05-13T14:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MTM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzU1Mw==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424253553", "bodyText": "Why are arrays of objects skipped here? Shouldn't the array-type/object-type be adapted instead?", "author": "mfussenegger", "createdAt": "2020-05-13T08:13:23Z", "path": "server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java", "diffHunk": "@@ -401,7 +402,11 @@ private FrameBoundDefinition convertToAnalyzedFrameBound(ExpressionAnalysisConte\n         int size = symbolsToCast.size();\n         List<Symbol> castList = new ArrayList<>(size);\n         for (int i = 0; i < size; i++) {\n-            castList.add(symbolsToCast.get(i).cast(targetTypes.get(i), false));\n+            var symbolToCast = symbolsToCast.get(i);\n+            if (ArrayType.unnest(symbolToCast.valueType()).id() != ObjectType.ID) {\n+                symbolToCast = symbolToCast.cast(targetTypes.get(i), false);\n+            }", "originalCommit": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDM2MzA5OA==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424363098", "bodyText": "The description of this point from the chat communication\nThe second issue is related to subscript on object or arrays of objects. There we try to infer the return type of the function at the normalization step based on arguments, see https://github.com/crate/crate/blob/master/server/src/main/java/io/crate/expression/scalar/SubscriptObjectFunction.java#L98, but with the new function signature, the object arguments were cast to objects coz of different inner types (empty vs actual inner types) and the return type inference logic was not working any longer.\nso basically I did that to skip cast for object and array(object) i am not sure how to handle in another way. hmm maybe actually checking whether the source and target are either array(object) and object and then don't cast source type if the source and target types have different inner types?", "author": "kovrus", "createdAt": "2020-05-13T11:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1MzU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1Mzk4NA==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424253984", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // subscript(array(any)), text) -> any\n          \n          \n            \n                    // subscript(array(any)), integer) -> any\n          \n      \n    \n    \n  \n\n?", "author": "mfussenegger", "createdAt": "2020-05-13T08:14:08Z", "path": "server/src/main/java/io/crate/expression/scalar/SubscriptFunction.java", "diffHunk": "@@ -57,14 +57,73 @@\n \n     public static final String NAME = \"subscript\";\n \n+    private final Signature signature;\n     private final FunctionInfo info;\n     private final BiFunction<Object, Object, Object> lookup;\n \n     public static void register(ScalarFunctionModule module) {\n-        module.register(NAME, new Resolver());\n+        // subscript(array(object)), text) -> array(undefined)\n+        module.register(\n+            Signature.scalar(\n+                NAME,\n+                parseTypeSignature(\"array(object)\"),\n+                DataTypes.STRING.getTypeSignature(),\n+                parseTypeSignature(\"array(undefined)\")),\n+            (signature, dataTypes) -> new SubscriptFunction(\n+                signature,\n+                FunctionInfo.of(NAME, dataTypes, new ArrayType<>(DataTypes.UNDEFINED)),\n+                SubscriptFunction::lookupIntoListObjectsByName)\n+        );\n+        // subscript(array(any)), text) -> any", "originalCommit": "d6c62a0509e1c54ed81f2c312395c53a723d0b39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "014b49e422656643b5a449b398e3a4cf0f2af430", "url": "https://github.com/crate/crate/commit/014b49e422656643b5a449b398e3a4cf0f2af430", "message": "fixup! Use the new func registry for the subscript functions.", "committedDate": "2020-05-13T09:35:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NjIyNg==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424446226", "bodyText": "so basically the cast for the object and array(object) was added coz the target type, the one that comes from the signature, has the empty inner types while the source data type has some inner types. There is no point to cast an object to an object type with empty inner types, so probably these semantic is not correct. I've added this condition in the Symbol#cast. @mfussenegger (such as we talked a little bit about it during the daily coffee) wdyt?", "author": "kovrus", "createdAt": "2020-05-13T13:40:54Z", "path": "server/src/main/java/io/crate/expression/symbol/Symbol.java", "diffHunk": "@@ -59,6 +61,9 @@ public final Symbol cast(DataType<?> targetType) {\n     public Symbol cast(DataType<?> targetType, boolean tryCast) {\n         if (targetType.equals(valueType())) {\n             return this;\n+        } else if (ArrayType.unnest(targetType).equals(DataTypes.UNTYPED_OBJECT)", "originalCommit": "d8a19c3254cd1e56c7c6734c803a1984e8b88c7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ1NDc3Nw==", "url": "https://github.com/crate/crate/pull/9928#discussion_r424454777", "bodyText": "Looks better to me to have it here \ud83d\udc4d", "author": "mfussenegger", "createdAt": "2020-05-13T13:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0NjIyNg=="}], "type": "inlineReview"}, {"oid": "871be74243c8661594f2bf4ce7933b3c1ac44a5d", "url": "https://github.com/crate/crate/commit/871be74243c8661594f2bf4ce7933b3c1ac44a5d", "message": "fixup! Use the new func registry for the subscript functions.", "committedDate": "2020-05-13T13:53:57Z", "type": "forcePushed"}, {"oid": "1c05c116dbfc17350ade38f536c642b151ae8131", "url": "https://github.com/crate/crate/commit/1c05c116dbfc17350ade38f536c642b151ae8131", "message": "fixup! Use the new func registry for the subscript functions.", "committedDate": "2020-05-13T14:12:58Z", "type": "forcePushed"}, {"oid": "31ad836ac588d9cc0d13c5c2b3e4c1d8fbeee934", "url": "https://github.com/crate/crate/commit/31ad836ac588d9cc0d13c5c2b3e4c1d8fbeee934", "message": "Use the new func registry for the subscript functions.", "committedDate": "2020-05-13T19:46:15Z", "type": "commit"}, {"oid": "31ad836ac588d9cc0d13c5c2b3e4c1d8fbeee934", "url": "https://github.com/crate/crate/commit/31ad836ac588d9cc0d13c5c2b3e4c1d8fbeee934", "message": "Use the new func registry for the subscript functions.", "committedDate": "2020-05-13T19:46:15Z", "type": "forcePushed"}, {"oid": "efad7699460b87416a62b59da47a0a15270d9be3", "url": "https://github.com/crate/crate/commit/efad7699460b87416a62b59da47a0a15270d9be3", "message": "Merge branch 'master' into r/subscript-functions", "committedDate": "2020-05-14T12:42:26Z", "type": "commit"}]}