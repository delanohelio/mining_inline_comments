{"pr_number": 9985, "pr_title": "Always generate `cast` function for implicit casts", "pr_createdAt": "2020-05-22T14:45:58Z", "pr_url": "https://github.com/crate/crate/pull/9985", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4MzA4Ng==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429783086", "bodyText": "Would it be possible to remove the isEagerNormalizationAllowed flag now altogether?\nWe've afaik only 2 places where it is disabled (for using literals as table function and in the values case), in those cases we could call expression.accept.. directly instead of going through convert.", "author": "mfussenegger", "createdAt": "2020-05-25T07:47:15Z", "path": "server/src/main/java/io/crate/analyze/expressions/ExpressionAnalyzer.java", "diffHunk": "@@ -215,7 +216,12 @@ public ExpressionAnalyzer(Functions functions,\n      * Functions with constants will be normalized.\n      */\n     public Symbol convert(Expression expression, ExpressionAnalysisContext expressionAnalysisContext) {\n-        return expression.accept(innerAnalyzer, expressionAnalysisContext);\n+        var symbol = expression.accept(innerAnalyzer, expressionAnalysisContext);\n+        var normalizer = EvaluatingNormalizer.functionOnlyNormalizer(\n+            functions,\n+            f -> expressionAnalysisContext.isEagerNormalizationAllowed() && f.info().isDeterministic()", "originalCommit": "68141748f43ab2d419bc7e1fad69061d65c63464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4NzE3NQ==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429787175", "bodyText": "Nevermind. I think then it wouldn't apply for inner convert calls. Guess we have to keep it.", "author": "mfussenegger", "createdAt": "2020-05-25T07:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc4MzA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MTQ3Ng==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429791476", "bodyText": "explicitCast is not used at all in isConvertableTo", "author": "kovrus", "createdAt": "2020-05-25T08:04:18Z", "path": "server/src/main/java/io/crate/types/DataType.java", "diffHunk": "@@ -107,7 +107,7 @@ public boolean precedes(DataType other) {\n      * @param other the DataType to check conversion to\n      * @return true or false\n      */\n-    public boolean isConvertableTo(DataType<?> other) {\n+    public boolean isConvertableTo(DataType<?> other, boolean explicitCast) {", "originalCommit": "68141748f43ab2d419bc7e1fad69061d65c63464", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MjQ1OA==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429792458", "bodyText": "It is: https://github.com/crate/crate/pull/9985/files#diff-932a1ef471972a95b5dfde013523b515R186", "author": "seut", "createdAt": "2020-05-25T08:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MjcwNA==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429792704", "bodyText": "Or here: https://github.com/crate/crate/pull/9985/files#diff-d9273c5d03d846ae406a74ae5af32ad5R109", "author": "seut", "createdAt": "2020-05-25T08:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5Mjg2NA==", "url": "https://github.com/crate/crate/pull/9985#discussion_r429792864", "bodyText": "ah i see, tnx", "author": "kovrus", "createdAt": "2020-05-25T08:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTc5MTQ3Ng=="}], "type": "inlineReview"}, {"oid": "719ac1c86ff93495f4197bf8687842c28f2a4587", "url": "https://github.com/crate/crate/commit/719ac1c86ff93495f4197bf8687842c28f2a4587", "message": "Always generate `cast` function for implicit casts\n\nCasting literals used a special logic and resulted in immediately\nconverted literals. Some plans relied on this logic and break if\nnon-literals are used.\nEarly normalization of literal casts, over the special logic or by\nnormalizing the `cast` function, removes relevant information maybe\nrequired by outer symbols (functions). E.g. normalizing of array\nliterals converts them into an array object and thus looses\nthe ability of using concrete type cast functionality of each literal\narray element.\n\nAll these issues can be solved by removing early \u201con-function-resolving\u201d\nnormalization and early literal conversion.\nInstead the complete symbol tree will be normalized after it has been build.\n\nAdditionally we differentiate between explicit and implicit casts.\nThis was already the case from a user perspective but internally hidden\ndue to the special early literal cast (conversion) logic.\nAn example where explicit casts are possible but implicit casts not\nis the supported `ObjectType<->StringType` conversion to allow object\nliterals of type JSON string.\nThis is still allowed on explicit casts but not on implicit ones.", "committedDate": "2020-05-25T08:12:08Z", "type": "commit"}, {"oid": "719ac1c86ff93495f4197bf8687842c28f2a4587", "url": "https://github.com/crate/crate/commit/719ac1c86ff93495f4197bf8687842c28f2a4587", "message": "Always generate `cast` function for implicit casts\n\nCasting literals used a special logic and resulted in immediately\nconverted literals. Some plans relied on this logic and break if\nnon-literals are used.\nEarly normalization of literal casts, over the special logic or by\nnormalizing the `cast` function, removes relevant information maybe\nrequired by outer symbols (functions). E.g. normalizing of array\nliterals converts them into an array object and thus looses\nthe ability of using concrete type cast functionality of each literal\narray element.\n\nAll these issues can be solved by removing early \u201con-function-resolving\u201d\nnormalization and early literal conversion.\nInstead the complete symbol tree will be normalized after it has been build.\n\nAdditionally we differentiate between explicit and implicit casts.\nThis was already the case from a user perspective but internally hidden\ndue to the special early literal cast (conversion) logic.\nAn example where explicit casts are possible but implicit casts not\nis the supported `ObjectType<->StringType` conversion to allow object\nliterals of type JSON string.\nThis is still allowed on explicit casts but not on implicit ones.", "committedDate": "2020-05-25T08:12:08Z", "type": "forcePushed"}]}