{"pr_number": 10104, "pr_title": "Add support for global flag 'g' to now tabular function regexp_matches", "pr_createdAt": "2020-06-18T20:50:27Z", "pr_url": "https://github.com/crate/crate/pull/10104", "timeline": [{"oid": "f5878fd6b29912b94f6aef0d362cc94d004e5c92", "url": "https://github.com/crate/crate/commit/f5878fd6b29912b94f6aef0d362cc94d004e5c92", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-06-18T21:25:01Z", "type": "forcePushed"}, {"oid": "dc2da01950be6f90cb8963926b4bcacf75a7d329", "url": "https://github.com/crate/crate/commit/dc2da01950be6f90cb8963926b4bcacf75a7d329", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-22T18:51:16Z", "type": "forcePushed"}, {"oid": "c805f023c3ff4ce5a5307f5375cc572aed08e30e", "url": "https://github.com/crate/crate/commit/c805f023c3ff4ce5a5307f5375cc572aed08e30e", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-22T18:56:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444773118", "bodyText": "cells is a varargs argument, this will cause you to have a Row with multiple cells.\n List.of(\"foo\", \"bar\").toArray()\n$2 ==> Object[2] { \"foo\", \"bar\" }\n\n\nvar row = new RowN(List.of(\"foo\", \"bar\").toArray())\nrow.numColumns(); -> this will be 2, instead of 1\n\nWhat you want is something like this:\nvar row = new RowN(new Object[] { List.of(\"foo\", \"bar\").toArray() });\nrow.numColumns(); -> this will be 1", "author": "mfussenegger", "createdAt": "2020-06-24T09:42:00Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/FoobarFunction.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class FoobarFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"foobar\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"planetzs\")); // single column, array(text)\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(NAME, ROW_TYPE.getTypeSignature()),\n+            (signature, args) -> new FoobarFunction(\n+                signature,\n+                new FunctionInfo(\n+                    new FunctionIdent(NAME, args),\n+                    ROW_TYPE,\n+                    FunctionInfo.Type.TABLE))\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final FunctionInfo info;\n+\n+    private FoobarFunction(Signature signature, FunctionInfo info) {\n+        this.signature = signature;\n+        this.info = info;\n+    }\n+\n+    @Override\n+    public FunctionInfo info() {\n+        return info;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        return iterableOf(List.of(\n+            \"Mercury\", \"Venus\", \"Earth\", \"Jupiter\", \"Saturn\", \"Your-anus\", \"Ne pais fume\"));\n+    }\n+    private static Iterable<Row> iterableOf(List<String> data) {\n+        if (data == null || data.size() == 0) {\n+            return null;\n+        }\n+        return () -> new Iterator<>() {\n+            final RowN row = new RowN(1);\n+            int idx = 0;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return idx < 1;\n+            }\n+\n+            @Override\n+            public Row next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException(\"no more rows\");\n+                }\n+                row.cells(data.toArray());", "originalCommit": "f2bb0da87f153e5310018548ea711648daac07e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NTYwNw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444775607", "bodyText": "and then the problem is:\nSQLActionException[ClassCastException: class [Ljava.lang.Object; cannot be cast to class java.util.List ([Ljava.lang.Object; and java.util.List are in module java.base of loader 'bootstrap')]", "author": "marregui", "createdAt": "2020-06-24T09:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NTc0NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444775744", "bodyText": "cool", "author": "marregui", "createdAt": "2020-06-24T09:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NjgxMA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444776810", "bodyText": "YES!!!!!!! thank you very much!!!! I could not see the freaking varargs issue!!! and went mental, hitting my antlers against the wall, xxx", "author": "marregui", "createdAt": "2020-06-24T09:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3ODEwNA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444778104", "bodyText": "and then the problem is:\n\nRight, the toArray() call is bogus.  STRING_ARRAY value must be a List<String>, not an array.", "author": "mfussenegger", "createdAt": "2020-06-24T09:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}], "type": "inlineReview"}, {"oid": "3f005ebc303de2d839b194db664bb7167d9a6fcc", "url": "https://github.com/crate/crate/commit/3f005ebc303de2d839b194db664bb7167d9a6fcc", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-25T13:47:01Z", "type": "forcePushed"}, {"oid": "79d57ca0ac4354298172c0ea1cc4cc77a5979b97", "url": "https://github.com/crate/crate/commit/79d57ca0ac4354298172c0ea1cc4cc77a5979b97", "message": "No need for checking pgtype and act accordingly (mistake)", "committedDate": "2020-06-26T14:00:20Z", "type": "forcePushed"}, {"oid": "3213e0dc57621fb9020ca7b75b1b523cc7f9d6ee", "url": "https://github.com/crate/crate/commit/3213e0dc57621fb9020ca7b75b1b523cc7f9d6ee", "message": "Adapt to new signature only function definition", "committedDate": "2020-06-29T11:42:13Z", "type": "forcePushed"}, {"oid": "749835d8833d00fe5c1bc61197846c65586d362f", "url": "https://github.com/crate/crate/commit/749835d8833d00fe5c1bc61197846c65586d362f", "message": "Refactor documentation, still needs work", "committedDate": "2020-06-29T13:22:34Z", "type": "forcePushed"}, {"oid": "0816fe05a0f722ceeeaa7e46ecd38c70a6a5a87d", "url": "https://github.com/crate/crate/commit/0816fe05a0f722ceeeaa7e46ecd38c70a6a5a87d", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-06-30T14:21:42Z", "type": "forcePushed"}, {"oid": "7b2834e21ed2896260ffc27ccb73b38517770a0a", "url": "https://github.com/crate/crate/commit/7b2834e21ed2896260ffc27ccb73b38517770a0a", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-07-01T10:25:20Z", "type": "forcePushed"}, {"oid": "b1b8839a154af89ee56272430965fa12c140c612", "url": "https://github.com/crate/crate/commit/b1b8839a154af89ee56272430965fa12c140c612", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-07-01T17:19:30Z", "type": "forcePushed"}, {"oid": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "url": "https://github.com/crate/crate/commit/972b05d2661ecf1c330442f18c99cd31ee58dba2", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-01T19:07:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxODIzMA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454618230", "bodyText": "I don't this this should be changed here. Rather the functions shouldn't return null elements.", "author": "mfussenegger", "createdAt": "2020-07-14T20:17:11Z", "path": "server/src/main/java/io/crate/execution/engine/pipeline/TableFunctionApplier.java", "diffHunk": "@@ -57,7 +58,11 @@ public TableFunctionApplier(List<Input<Iterable<Row>>> tableFunctions,\n             expressions.get(i).setNextRow(row);\n         }\n         mapIncomingValuesToOutgoingCells();\n-        List<Iterator<Row>> iterators = Lists2.map(tableFunctions, x -> x.value().iterator());\n+        List<Iterator<Row>> iterators = tableFunctions.stream()\n+            .map(Input::value)\n+            .filter(Objects::nonNull)\n+            .map(Iterable::iterator)\n+            .collect(Collectors.toList());", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyMTY5Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454621696", "bodyText": "Part of this function is now used by the regexp_replace function, the other by the regexp_matches functions. Would it make sense to separate this into two classes, or inline the relevant code as inner static class to the relevant functions?\nOr another option would be to have two implementations and the implementation would be retrieved via a static constructor that takes the flag as argument, to avoid the if (global cases", "author": "mfussenegger", "createdAt": "2020-07-14T20:23:45Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,37 +22,54 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n \n public class RegexMatcher {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDU3Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454624576", "bodyText": "Does the type signature definition still fit? Shouldn't that be a row-type now?", "author": "mfussenegger", "createdAt": "2020-07-14T20:28:35Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -19,29 +19,37 @@\n  * software solely pursuant to the terms of the relevant commercial agreement.\n  */\n \n-package io.crate.expression.scalar.regex;\n+package io.crate.expression.tablefunctions;\n \n+import io.crate.common.annotations.VisibleForTesting;\n import io.crate.data.Input;\n-import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.symbol.Function;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.expression.symbol.SymbolType;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n \n import javax.annotation.Nullable;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.NoSuchElementException;\n \n-public class MatchesFunction extends Scalar<List<String>, Object> {\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n \n     public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n \n-    public static void register(ScalarFunctionModule module) {\n+    public static void register(TableFunctionModule module) {\n         module.register(\n-            Signature.scalar(\n+            Signature.table(", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5ODQwMg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r456398402", "bodyText": "It is a row_type, new RowType(List.of(DataTypes.STRING_ARRAY), List.of(\"groups\")), I followed a similar approach to GenerateSeries.", "author": "marregui", "createdAt": "2020-07-17T12:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjMxOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testCompile() throws Exception {\n          \n          \n            \n                public void test_compile_creates_regex_matcher_instance_on_table_function() throws Exception {", "author": "mfussenegger", "createdAt": "2020-07-14T20:31:39Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/MatchesFunctionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.metadata.Scalar;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class MatchesFunctionTest extends AbstractTableFunctionsTest {\n+\n+    @Test\n+    public void testCompile() throws Exception {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjcxNQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626715", "bodyText": "why not pass the argument into the function directly?", "author": "mfussenegger", "createdAt": "2020-07-14T20:32:23Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/MatchesFunctionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.metadata.Scalar;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class MatchesFunctionTest extends AbstractTableFunctionsTest {\n+\n+    @Test\n+    public void testCompile() throws Exception {\n+        Matcher<Scalar> matcher = new BaseMatcher<>() {\n+            @Override\n+            public boolean matches(Object item) {\n+                MatchesFunction regexpImpl = (MatchesFunction) item;\n+                // ensure that the RegexMatcher was created due to compilation\n+                return regexpImpl.regexMatcher() != null;\n+            }\n+\n+            @Override\n+            public void describeTo(Description description) {\n+            }\n+        };\n+        assertCompile(\"regexp_matches(name, '.*(ba).*')\", (s) -> matcher);\n+    }\n+\n+    private static String regexp_matches(String value, String pattern, String flags) {\n+        return String.format(Locale.ENGLISH, \"regexp_matches('%s', '%s', '%s')\", value, pattern, flags);\n+    }\n+\n+    private static String regexp_matches(String value, String pattern) {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjk5NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Seed(\"C328C6C2B806C0E9\")", "author": "mfussenegger", "createdAt": "2020-07-14T20:32:55Z", "path": "server/src/test/java/io/crate/integrationtests/RegexpMatchesTableFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.integrationtests;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Seed;\n+import io.crate.testing.TestingHelpers;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static io.crate.testing.TestingHelpers.printedTable;\n+import static org.hamcrest.core.Is.is;\n+\n+public class RegexpMatchesTableFunctionIntegrationTest extends SQLTransportIntegrationTest {\n+\n+    @Before\n+    public void setup() {\n+        execute(\"create table tregex (i integer, s string) with (number_of_replicas=0)\");\n+        execute(\"insert into tregex(i, s) values (?, ?)\", new Object[][]{\n+            new Object[]{1, \"foo is first\"},\n+            new Object[]{2, \"bar is second\"},\n+            new Object[]{3, \"foobar is great\"},\n+            new Object[]{4, \"boobar is greater\"},\n+            new Object[]{5, \"awam bam baluma\"},\n+            new Object[]{6, null}\n+        });\n+        refresh();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        execute(\"drop table tregex\");\n+    }\n+\n+    @Seed(\"C328C6C2B806C0E9\")", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNzMwMQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454627301", "bodyText": "I don't really see how these are testing anything that is not covered by the unit tests?", "author": "mfussenegger", "createdAt": "2020-07-14T20:33:30Z", "path": "server/src/test/java/io/crate/integrationtests/RegexpMatchesTableFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.integrationtests;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Seed;\n+import io.crate.testing.TestingHelpers;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static io.crate.testing.TestingHelpers.printedTable;\n+import static org.hamcrest.core.Is.is;\n+\n+public class RegexpMatchesTableFunctionIntegrationTest extends SQLTransportIntegrationTest {\n+\n+    @Before\n+    public void setup() {\n+        execute(\"create table tregex (i integer, s string) with (number_of_replicas=0)\");\n+        execute(\"insert into tregex(i, s) values (?, ?)\", new Object[][]{\n+            new Object[]{1, \"foo is first\"},\n+            new Object[]{2, \"bar is second\"},\n+            new Object[]{3, \"foobar is great\"},\n+            new Object[]{4, \"boobar is greater\"},\n+            new Object[]{5, \"awam bam baluma\"},\n+            new Object[]{6, null}\n+        });\n+        refresh();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        execute(\"drop table tregex\");\n+    }\n+\n+    @Seed(\"C328C6C2B806C0E9\")\n+    @Test\n+    public void test_regexp_matches_is_used_in_select_filtering_from_a_table() {\n+        execute(\"select regexp_matches(s, '(\\\\w+) is (great).*', 'g') from tregex\");\n+        Arrays.sort(response.rows(), Comparator.comparing(o -> ((List<String>) o[0]).get(0)));\n+        assertThat(TestingHelpers.printedTable(response.rows()), is(\"[boobar, great]\\n\" +\n+                                                                    \"[foobar, great]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches_is_used_in_from_generating_a_table() {\n+        execute(\"select * from regexp_matches('foobar is greater', '(\\\\w+) is (great|greater)', 'g')\");\n+        assertThat(TestingHelpers.printedTable(response.rows()), is(\"[foobar, great]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches_g() {\n+        execute(\"select regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\" +\n+                                                     \"[bazil, barf]\\n\"));\n+\n+        execute(\"select groups from regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\" +\n+                                                     \"[bazil, barf]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches() {\n+        execute(\"select regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\"));\n+\n+        execute(\"select groups from regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\"));\n+    }", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1362e7fcd3d0e84abf5cb01bd25bd765fa8fdc0", "url": "https://github.com/crate/crate/commit/b1362e7fcd3d0e84abf5cb01bd25bd765fa8fdc0", "message": "Remove integration tests as their logic is covered in unit tests already", "committedDate": "2020-07-17T14:32:09Z", "type": "forcePushed"}, {"oid": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "url": "https://github.com/crate/crate/commit/4d98613ddd524d8fccd4b634bd3513cce8b578a6", "message": "Refactor RegexMatcher to split functionality match/replace", "committedDate": "2020-07-18T17:36:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MjU2Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457942566", "bodyText": "I think this could be final, right ?", "author": "mkleen", "createdAt": "2020-07-21T08:55:21Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -33,6 +33,7 @@\n \n import javax.annotation.Nullable;\n import java.util.List;\n+import java.util.regex.Matcher;\n \n public class RegexpReplaceFunction extends Scalar<String, Object> {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MzA5OQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457943099", "bodyText": "This could be final as well i think.", "author": "mkleen", "createdAt": "2020-07-21T08:56:13Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NjU0Nw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457956547", "bodyText": "Minor: I think you could just return List.of() and () -> new Iterator<>() {.. and avoid the allocation here, but this is more like a personal preference.", "author": "mkleen", "createdAt": "2020-07-21T09:18:57Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NTI5MQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457975291", "bodyText": "emptyIterator in any case returns a singleton and can be used directly. Assigning it to a different constant field wastes some memory for no reason.", "author": "mfussenegger", "createdAt": "2020-07-21T09:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NjU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2NjA4OQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457966089", "bodyText": "Minor: RegexpMatcher would be more consistent with the rest of the crate naming.", "author": "mkleen", "createdAt": "2020-07-21T09:34:45Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0ODY1Mg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457948652", "bodyText": "is this variable really necessary patternVal, you can probably just use pattern.", "author": "kovrus", "createdAt": "2020-07-21T09:05:25Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1ODUyNQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457958525", "bodyText": "i am wondering why this exception is swallowed and the null is returned, shouldn't we propagate this failure?", "author": "kovrus", "createdAt": "2020-07-21T09:22:09Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {\n+                Matcher matcher = initMatcher(term);\n+                return collector.apply(() -> {\n+                    if (!matcher.find()) {\n+                        return null;\n+                    }\n+                    int groupCount = matcher.groupCount();\n+                    if (groupCount == 0) {\n+                        try {\n+                            return List.of(matcher.group());\n+                        } catch (IllegalStateException e) {\n+                            return null;", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzMDQ0Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458630446", "bodyText": "matcher.group() throws IllegalStateException:\n     *  If no match has yet been attempted,\n     *  or if the previous match operation failed\n\nRemoving try/catch block to propagate the exception :)", "author": "marregui", "createdAt": "2020-07-22T08:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1ODUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1OTg0MQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457959841", "bodyText": "maybe we can make this function nonnullable, then we probably won't have to handle special null cases here https://github.com/crate/crate/pull/10104/files#diff-4f4a1a2d0baa1a4764044bf3363dcba8R168 and use the same logic to handle both empty and non-empty cases?", "author": "kovrus", "createdAt": "2020-07-21T09:24:27Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2ODk3OA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457968978", "bodyText": "imho a simple for-loop would be more readable and it would avoid to/from object operations (not sure whether it is the case though)", "author": "kovrus", "createdAt": "2020-07-21T09:39:52Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {\n+                Matcher matcher = initMatcher(term);\n+                return collector.apply(() -> {\n+                    if (!matcher.find()) {\n+                        return null;\n+                    }\n+                    int groupCount = matcher.groupCount();\n+                    if (groupCount == 0) {\n+                        try {\n+                            return List.of(matcher.group());\n+                        } catch (IllegalStateException e) {\n+                            return null;\n+                        }\n+                    }\n+                    return IntStream", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3MjIyMQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457972221", "bodyText": "kind of similar what jordi commented already. The abstract RegexMatcher class is implemented partially by match and replace functions, which raises the question about using this abstraction. I'd better move related to functions logic closer to the implementation and maybe add some static factory methods that would hide things like https://github.com/crate/crate/pull/10104/files#diff-bffb730cd7513f358bd585218cd15286R172 and https://github.com/crate/crate/pull/10104/files#diff-4f4a1a2d0baa1a4764044bf3363dcba8R198", "author": "kovrus", "createdAt": "2020-07-21T09:45:22Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3Mjg4OA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457972888", "bodyText": "is there a reason why Supplier is used here?", "author": "kovrus", "createdAt": "2020-07-21T09:46:36Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NjMxMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457976313", "bodyText": "I'm not sure I like the design of the new abstraction here.\nIs the availability of these two methods depending on the g flag? Or why we do need to have these two methods in a base class when they can be unavailable?", "author": "mfussenegger", "createdAt": "2020-07-21T09:52:43Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {\n \n-    private final boolean globalFlag;\n     private final Pattern pattern;\n     private Matcher matcher;\n \n-    public RegexMatcher(String regex, int flags, boolean globalFlag) {\n-        pattern = Pattern.compile(regex, flags);\n-        this.globalFlag = globalFlag;\n-    }\n-\n     public RegexMatcher(String regex, @Nullable String flags) {\n-        this(regex, parseFlags(flags), isGlobal(flags));\n-    }\n-\n-    public RegexMatcher(String regex) {\n-        this(regex, 0, false);\n-    }\n-\n-    public boolean match(String term) {\n-        initMatcher(term);\n-        return matcher.find();\n-    }\n-\n-    @Nullable\n-    public List<String> groups() {\n-        int groupCount = matcher.groupCount();\n-        if (groupCount == 0) {\n-            try {\n-                return List.of(matcher.group());\n-            } catch (IllegalStateException e) {\n-                return null;\n-            }\n-        }\n-        ArrayList<String> groups = new ArrayList<>(groupCount);\n-        for (int i = 0; i < groupCount; i++) {\n-            groups.add(matcher.group(i + 1));\n-        }\n-        return groups;\n+        pattern = Pattern.compile(regex, parseFlags(flags));\n     }\n \n-    public String replace(String term, String replacement) {\n-        initMatcher(term);\n-        if (globalFlag) {\n-            return matcher.replaceAll(replacement);\n-        } else {\n-            return matcher.replaceFirst(replacement);\n-        }\n-    }\n-\n-    private void initMatcher(String term) {\n+    protected Matcher initMatcher(String term) {\n         if (matcher == null) {\n             matcher = pattern.matcher(term);\n         } else {\n             matcher.reset(term);\n         }\n+        return matcher;\n     }\n \n-    public static int parseFlags(@Nullable String flagsString) {\n+    public List<List<String>> match(String term) {\n+        throw new UnsupportedOperationException(\"method not available\");\n+    }\n+\n+    public String replace(String term, String replacement) {\n+        throw new UnsupportedOperationException(\"method not available\");\n+    }\n+", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzODk0NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458638944", "bodyText": "Well, Pattern/Matcher provide functionality to replace and match, each exposed by a different function (regexp_replace and regexp_matches). Before both functions shared the same package, but now the later function is a table function, so it has been refactored to a different package.\nBoth functions accept flags, including g, however this flag results in a behaviour not included by Matcher and thus needs to be provided by a subclass. I modelled it in this way because I evolved the code from what existed and because the g spot is common to both functions.\nI will give it another round, to see if I can impress this time.", "author": "marregui", "createdAt": "2020-07-22T08:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NjMxMw=="}], "type": "inlineReview"}, {"oid": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "url": "https://github.com/crate/crate/commit/5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "message": "Cosmetic changes pass 1, the least meaty changes", "committedDate": "2020-07-22T08:43:51Z", "type": "forcePushed"}, {"oid": "92cf07cb1e112d519fa44dfc2ab7b2ed4f17f5d3", "url": "https://github.com/crate/crate/commit/92cf07cb1e112d519fa44dfc2ab7b2ed4f17f5d3", "message": "Daisy's feedback, thank you!", "committedDate": "2020-07-22T11:47:44Z", "type": "forcePushed"}, {"oid": "56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "url": "https://github.com/crate/crate/commit/56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "message": "Catch null pointer exception", "committedDate": "2020-07-24T11:15:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MDE3NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460790174", "bodyText": "is it possible to replace this stream with something like:\nvar group = groups(matcher);\nwhile (group != null) {\n    rowGroups.add(...)\n    group = groups(matcher)\n}", "author": "kovrus", "createdAt": "2020-07-27T10:17:14Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.crate.expression.RegexpFlagsHelper.parseFlags;\n+import static io.crate.expression.RegexpFlagsHelper.isGlobal;\n+\n+public final class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private Pattern pattern;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable Pattern pattern) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.pattern = pattern;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    Pattern pattern() {\n+        return pattern;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            pattern = literal.value();\n+            if (pattern == null) {\n+                return this;\n+            }\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, Pattern.compile(pattern, parseFlags(flags)));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        String flags = null;\n+        if (args.length == 3) {\n+            flags = (String) args[2].value();\n+        }\n+\n+        if (this.pattern == null) {\n+            this.pattern = Pattern.compile(pattern, parseFlags(flags));\n+        }\n+        Matcher matcher = this.pattern.matcher(value);\n+        List<List<String>> rowGroups;\n+        if (isGlobal(flags)) {\n+            rowGroups = Stream", "originalCommit": "56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5NzQwMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460797403", "bodyText": "yes, I was proud of that snippet!", "author": "marregui", "createdAt": "2020-07-27T10:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MDE3NA=="}], "type": "inlineReview"}, {"oid": "06af923fd9bedbea8473e02499b70ca337bfef5f", "url": "https://github.com/crate/crate/commit/06af923fd9bedbea8473e02499b70ca337bfef5f", "message": "Remove streams, I prefer them though", "committedDate": "2020-07-27T10:29:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460824846", "bodyText": "maybe final or do we really have to mutate it in the evaluate?", "author": "kovrus", "createdAt": "2020-07-27T11:29:10Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -65,16 +70,16 @@ public static void register(ScalarFunctionModule module) {\n     private final Signature signature;\n     private final Signature boundSignature;\n     @Nullable\n-    private final RegexMatcher regexMatcher;\n+    private Pattern pattern;", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg1NjI5Mg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460856292", "bodyText": "compile creates the Pattern.", "author": "marregui", "createdAt": "2020-07-27T12:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg1NzAyNg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460857026", "bodyText": "i was talking about the mutation here https://github.com/crate/crate/pull/10104/files#diff-bffb730cd7513f358bd585218cd15286R155", "author": "kovrus", "createdAt": "2020-07-27T12:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg3NTA1NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460875054", "bodyText": "evaluate does not mutate pattern, it checks whether it was initialised (compile would do this), and if not, then it initialises it. I kind of preserved this logic from the previous scalar implementation.", "author": "marregui", "createdAt": "2020-07-27T13:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNDgzOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460834838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class RegexpFlagsHelper {\n          \n          \n            \n            public final class RegexpFlags {\n          \n      \n    \n    \n  \n\nNot sure if Helper adds anything useful to readers.", "author": "mfussenegger", "createdAt": "2020-07-27T11:50:18Z", "path": "server/src/main/java/io/crate/expression/RegexpFlagsHelper.java", "diffHunk": "@@ -1,89 +1,31 @@\n /*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n  * obtain a copy of the License at\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n  *\n  * However, if you have executed another commercial license agreement\n  * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n  */\n \n-package io.crate.expression.scalar.regex;\n+package io.crate.expression;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n-\n-    private final boolean globalFlag;\n-    private final Pattern pattern;\n-    private Matcher matcher;\n-\n-    public RegexMatcher(String regex, int flags, boolean globalFlag) {\n-        pattern = Pattern.compile(regex, flags);\n-        this.globalFlag = globalFlag;\n-    }\n-\n-    public RegexMatcher(String regex, @Nullable String flags) {\n-        this(regex, parseFlags(flags), isGlobal(flags));\n-    }\n-\n-    public RegexMatcher(String regex) {\n-        this(regex, 0, false);\n-    }\n-\n-    public boolean match(String term) {\n-        initMatcher(term);\n-        return matcher.find();\n-    }\n-\n-    @Nullable\n-    public List<String> groups() {\n-        int groupCount = matcher.groupCount();\n-        if (groupCount == 0) {\n-            try {\n-                return List.of(matcher.group());\n-            } catch (IllegalStateException e) {\n-                return null;\n-            }\n-        }\n-        ArrayList<String> groups = new ArrayList<>(groupCount);\n-        for (int i = 0; i < groupCount; i++) {\n-            groups.add(matcher.group(i + 1));\n-        }\n-        return groups;\n-    }\n-\n-    public String replace(String term, String replacement) {\n-        initMatcher(term);\n-        if (globalFlag) {\n-            return matcher.replaceAll(replacement);\n-        } else {\n-            return matcher.replaceFirst(replacement);\n-        }\n-    }\n-\n-    private void initMatcher(String term) {\n-        if (matcher == null) {\n-            matcher = pattern.matcher(term);\n-        } else {\n-            matcher.reset(term);\n-        }\n-    }\n+public final class RegexpFlagsHelper {", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNTUxNg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460835516", "bodyText": "Are all arguments String? If so the generic definition could be changed, eliminating the casts here.", "author": "mfussenegger", "createdAt": "2020-07-27T11:51:48Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -89,35 +94,32 @@ public Signature boundSignature() {\n \n     @Override\n     public Symbol normalizeSymbol(Function function, TransactionContext txnCtx) {\n-        List<Symbol> arguments = function.arguments();\n-        final int size = arguments.size();\n+        List<Symbol> args = function.arguments();\n+        final int size = args.size();\n         assert size == 3 || size == 4 : \"function's number of arguments must be 3 or 4\";\n-\n-        if (anyNonLiterals(arguments)) {\n+        if (anyNonLiterals(args)) {\n             return function;\n         }\n-\n-        final Input input = (Input) arguments.get(0);\n-        final Input pattern = (Input) arguments.get(1);\n-        final Input replacement = (Input) arguments.get(2);\n-        final String inputValue = (String) input.value();\n-        final String patternValue = (String) pattern.value();\n-        final String replacementValue = (String) replacement.value();\n-        if (inputValue == null || patternValue == null || replacementValue == null) {\n+        final String value = ((Input<String>) args.get(0)).value();\n+        final String pattern = ((Input<String>) args.get(1)).value();\n+        final String replacement = ((Input<String>) args.get(2)).value();", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1256fb015e12ee9c1d36990b558450bfd04ee723", "url": "https://github.com/crate/crate/commit/1256fb015e12ee9c1d36990b558450bfd04ee723", "message": "Make pattern final as requested by Ruslan", "committedDate": "2020-07-27T13:59:46Z", "type": "forcePushed"}, {"oid": "c25c7441730c9b85f221644f487189ef303106cd", "url": "https://github.com/crate/crate/commit/c25c7441730c9b85f221644f487189ef303106cd", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-27T14:44:40Z", "type": "commit"}, {"oid": "c25c7441730c9b85f221644f487189ef303106cd", "url": "https://github.com/crate/crate/commit/c25c7441730c9b85f221644f487189ef303106cd", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-27T14:44:40Z", "type": "forcePushed"}]}