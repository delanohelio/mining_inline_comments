{"pr_number": 10825, "pr_title": "Backport missing cluster health fixes from ES", "pr_createdAt": "2020-11-26T16:18:36Z", "pr_url": "https://github.com/crate/crate/pull/10825", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEzNDkwNQ==", "url": "https://github.com/crate/crate/pull/10825#discussion_r531134905", "bodyText": "Could we use the slow annotation here instead, or does it currently fail?", "author": "mfussenegger", "createdAt": "2020-11-26T16:28:21Z", "path": "server/src/test/java/org/elasticsearch/gateway/GatewayIndexStateIT.java", "diffHunk": "@@ -0,0 +1,585 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.gateway;\n+\n+import io.crate.action.sql.SQLOperations;\n+import io.crate.common.unit.TimeValue;\n+import io.crate.integrationtests.SQLTransportIntegrationTest;\n+import io.crate.protocols.postgres.PostgresNetty;\n+import io.crate.testing.SQLTransportExecutor;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.Requests;\n+import org.elasticsearch.cluster.ClusterState;\n+import org.elasticsearch.cluster.metadata.IndexGraveyard;\n+import org.elasticsearch.cluster.metadata.IndexMetadata;\n+import org.elasticsearch.cluster.metadata.Metadata;\n+import org.elasticsearch.cluster.routing.IndexRoutingTable;\n+import org.elasticsearch.cluster.routing.IndexShardRoutingTable;\n+import org.elasticsearch.cluster.routing.RoutingTable;\n+import org.elasticsearch.cluster.routing.ShardRoutingState;\n+import org.elasticsearch.cluster.routing.UnassignedInfo;\n+import org.elasticsearch.common.CheckedConsumer;\n+import org.elasticsearch.common.Priority;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.transport.BoundTransportAddress;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.NodeEnvironment;\n+import org.elasticsearch.node.Node;\n+import org.elasticsearch.test.ESIntegTestCase;\n+import org.elasticsearch.test.ESIntegTestCase.ClusterScope;\n+import org.elasticsearch.test.ESIntegTestCase.Scope;\n+import org.elasticsearch.test.InternalTestCluster.RestartCallback;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.crate.protocols.postgres.PGErrorStatus.INTERNAL_ERROR;\n+import static io.crate.testing.Asserts.assertThrows;\n+import static io.crate.testing.SQLErrorMatcher.isSQLError;\n+import static io.crate.testing.SQLTransportExecutor.REQUEST_TIMEOUT;\n+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;\n+import static org.elasticsearch.indices.ShardLimitValidator.SETTING_CLUSTER_MAX_SHARDS_PER_NODE;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+@ClusterScope(scope = Scope.TEST, numDataNodes = 0)\n+public class GatewayIndexStateIT extends SQLTransportIntegrationTest {\n+\n+    private final Logger logger = LogManager.getLogger(GatewayIndexStateIT.class);\n+\n+    @Override\n+    protected boolean addMockInternalEngine() {\n+        // testRecoverBrokenIndexMetadata replies on the flushing on shutdown behavior which can be randomly disabled in MockInternalEngine.\n+        return false;\n+    }\n+\n+    public void testSimpleOpenClose() throws Exception {\n+        logger.info(\"--> starting 2 nodes\");\n+        internalCluster().startNodes(2);\n+\n+        logger.info(\"--> creating test index\");\n+\n+        int numPrimaries = 2;\n+        int numReplicas = 1;\n+        int totalNumShards = numPrimaries + (numPrimaries * numReplicas);\n+        var tableName = getFqn(\"test\");\n+\n+        execute(\"create table test (id int primary key) clustered into ? shards with (number_of_replicas = ?)\",\n+                new Object[]{numPrimaries, numReplicas});\n+\n+        logger.info(\"--> waiting for green status\");\n+        ensureGreen();\n+\n+        ClusterStateResponse stateResponse = client().admin().cluster().prepareState().execute().actionGet();\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.OPEN));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shards().size(), equalTo(numPrimaries));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shardsWithState(ShardRoutingState.STARTED).size(),\n+            equalTo(totalNumShards));\n+\n+        logger.info(\"--> insert a simple document\");\n+        execute(\"insert into test (id) values (1)\");\n+\n+        logger.info(\"--> closing test index...\");\n+        execute(\"alter table test close\");\n+\n+        stateResponse = client().admin().cluster().prepareState().execute().actionGet();\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.CLOSE));\n+        assertThat(stateResponse.getState().routingTable().index(tableName), notNullValue());\n+\n+        logger.info(\"--> verifying that the state is green\");\n+        ensureGreen();\n+\n+        logger.info(\"--> trying to index into a closed index ...\");\n+        try {\n+            execute(\"insert into test (id) values (2)\");\n+            fail();\n+        } catch (Exception e) {\n+            // all is well\n+        }\n+\n+        logger.info(\"--> creating another index (test2) and indexing into it\");\n+        execute(\"create table test2 (id int primary key) with (number_of_replicas = 0)\");\n+        execute(\"insert into test2 (id) values (1)\");\n+\n+        logger.info(\"--> verifying that the state is green\");\n+        ensureGreen();\n+\n+        logger.info(\"--> opening the first index again...\");\n+        execute(\"alter table test open\");\n+\n+        logger.info(\"--> verifying that the state is green\");\n+        ensureGreen();\n+\n+        stateResponse = client().admin().cluster().prepareState().execute().actionGet(REQUEST_TIMEOUT);\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.OPEN));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shards().size(), equalTo(numPrimaries));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shardsWithState(ShardRoutingState.STARTED).size(),\n+            equalTo(totalNumShards));\n+\n+        logger.info(\"--> trying to get the indexed document on the first index\");\n+        execute(\"select id from test where id = 1\");\n+        assertThat(response.rowCount(), is(1L));\n+\n+\n+        logger.info(\"--> closing test index...\");\n+        execute(\"alter table test close\");\n+\n+        stateResponse = client().admin().cluster().prepareState().execute().actionGet(REQUEST_TIMEOUT);\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.CLOSE));\n+        assertThat(stateResponse.getState().routingTable().index(tableName), notNullValue());\n+\n+        logger.info(\"--> restarting nodes...\");\n+        internalCluster().fullRestart();\n+        logger.info(\"--> waiting for two nodes and green status\");\n+        ensureGreen();\n+\n+        stateResponse = client().admin().cluster().prepareState().execute().actionGet(REQUEST_TIMEOUT);\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.CLOSE));\n+        assertThat(stateResponse.getState().routingTable().index(tableName), notNullValue());\n+\n+        logger.info(\"--> trying to index into a closed index ...\");\n+        try {\n+            execute(\"insert into test (id) values (2)\");\n+            fail();\n+        } catch (Exception e) {\n+            // all is well\n+        }\n+\n+        logger.info(\"--> opening index...\");\n+        execute(\"alter table test open\");\n+\n+        logger.info(\"--> waiting for green status\");\n+        ensureGreen();\n+\n+        stateResponse = client().admin().cluster().prepareState().execute().actionGet();\n+        assertThat(stateResponse.getState().metadata().index(tableName).getState(), equalTo(IndexMetadata.State.OPEN));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shards().size(), equalTo(numPrimaries));\n+        assertThat(stateResponse.getState().routingTable().index(tableName).shardsWithState(ShardRoutingState.STARTED).size(),\n+            equalTo(totalNumShards));\n+\n+        logger.info(\"--> trying to get the indexed document on the first round (before close and shutdown)\");\n+        execute(\"select id from test where id = 1\");\n+        assertThat(response.rowCount(), is(1L));\n+\n+        logger.info(\"--> indexing a simple document\");\n+        execute(\"insert into test (id) values (2)\");\n+    }\n+\n+    @Test\n+    @Ignore(\"Creating a table without any data node will take very long as internally at CrateDB, a table creation\" +", "originalCommit": "1a34fadd97d4c8536f1b1801c2a6abd1378f6c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE0OTg1Ng==", "url": "https://github.com/crate/crate/pull/10825#discussion_r531149856", "bodyText": "Was not sure if it's worth and maybe adds another flakiness. I've added a fixup.", "author": "seut", "createdAt": "2020-11-26T17:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEzNDkwNQ=="}], "type": "inlineReview"}, {"oid": "3b5079f78b215d3247abffbc1d89f7a09898663f", "url": "https://github.com/crate/crate/commit/3b5079f78b215d3247abffbc1d89f7a09898663f", "message": "Remove obsolet assertBusy calls on FilteringAllocationIT\n\nThe root cause for flaky test, which was tried to workaround\nby the assertBusy calls, is solve by backporting fixes of the\ncluster health action which is used by `ensureGreen`.", "committedDate": "2020-11-26T16:52:52Z", "type": "forcePushed"}, {"oid": "4b69eacef6cf6c03f4fb2d2e6e0bb50dab278e62", "url": "https://github.com/crate/crate/commit/4b69eacef6cf6c03f4fb2d2e6e0bb50dab278e62", "message": "bp: Do not use MockInternalEngine in GatewayIndexStateIT (#43716)\n\nhttps://github.com/elastic/elasticsearch/commit/6f5b3a6c71f498263b98b93614c98c2e6a73817f\n\nAdditionally this backports the complete GatewayIndexStateIT.", "committedDate": "2020-11-27T08:49:44Z", "type": "commit"}, {"oid": "40d26a1b5f2c9fb8d7da3317be344b8e3a83b783", "url": "https://github.com/crate/crate/commit/40d26a1b5f2c9fb8d7da3317be344b8e3a83b783", "message": "bp: Cluster health should await events plus other things (#44348)\n\nhttps://github.com/elastic/elasticsearch/commit/41ef1e64e64de78e3a9a6b3aeea1f8fb58f514c8", "committedDate": "2020-11-27T08:49:45Z", "type": "commit"}, {"oid": "a027659ac0b66d4b9988ee2fb060c5e0ca92bb42", "url": "https://github.com/crate/crate/commit/a027659ac0b66d4b9988ee2fb060c5e0ca92bb42", "message": "bp: Use applied cluster state in cluster health (#44426)\n\nhttps://github.com/elastic/elasticsearch/commit/0e958b6650b6b2c477219bf8617936bc6ed731c2", "committedDate": "2020-11-27T08:49:45Z", "type": "commit"}, {"oid": "a91e2c6f21b029b52f3738eecd4867da35b789d9", "url": "https://github.com/crate/crate/commit/a91e2c6f21b029b52f3738eecd4867da35b789d9", "message": "Update es-backports.rst, add cluster health package commits\n\nThe cluster health action is used internally inside java test\nand such we need to backport this package commits as well to\nfix maybe exiting bugs there.\nWe had already some causes `ensureGreen()` to not work as expected\nresulting in flaky test.", "committedDate": "2020-11-27T08:49:45Z", "type": "commit"}, {"oid": "504888137b9bc37eddb32d1888239ee2a4f01a0d", "url": "https://github.com/crate/crate/commit/504888137b9bc37eddb32d1888239ee2a4f01a0d", "message": "Remove obsolet assertBusy calls on FilteringAllocationIT\n\nThe root cause for flaky test, which was tried to workaround\nby the assertBusy calls, is solve by backporting fixes of the\ncluster health action which is used by `ensureGreen`.", "committedDate": "2020-11-27T08:49:45Z", "type": "commit"}, {"oid": "504888137b9bc37eddb32d1888239ee2a4f01a0d", "url": "https://github.com/crate/crate/commit/504888137b9bc37eddb32d1888239ee2a4f01a0d", "message": "Remove obsolet assertBusy calls on FilteringAllocationIT\n\nThe root cause for flaky test, which was tried to workaround\nby the assertBusy calls, is solve by backporting fixes of the\ncluster health action which is used by `ensureGreen`.", "committedDate": "2020-11-27T08:49:45Z", "type": "forcePushed"}]}