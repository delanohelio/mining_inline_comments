{"pr_number": 10780, "pr_title": "Ensure pg_proc.oid and pg_type.typreceive can be joined", "pr_createdAt": "2020-11-18T14:40:04Z", "pr_url": "https://github.com/crate/crate/pull/10780", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE1MDY0Ng==", "url": "https://github.com/crate/crate/pull/10780#discussion_r526150646", "bodyText": "the signatures return types are now all undefined, is it because they are not used?", "author": "kovrus", "createdAt": "2020-11-18T14:55:37Z", "path": "server/src/main/java/io/crate/execution/engine/collect/sources/InformationSchemaIterables.java", "diffHunk": "@@ -167,34 +166,16 @@ public InformationSchemaIterables(final Schemas schemas,\n             Stream.concat(\n                 sequentialStream(PGTypes.pgTypes())\n                     .filter(t -> t.typArray() != 0)\n-                    .map(InformationSchemaIterables::typeToSignature)\n+                    .map(x -> x.typReceive().asDummySignature())\n                     .map(PgProcTable.Entry::of),\n \n                 // Don't generate array_recv entry from pgTypes to avoid duplicate entries\n                 // (We want 1 array_recv entry, not one per array type)\n-                Stream.of(\n-                    PgProcTable.Entry.of(\n-                        Signature.scalar(\n-                            \"array_recv\",\n-                            DataTypes.INTEGER.getTypeSignature(),\n-                            new ArrayType<>(DataTypes.UNDEFINED).getTypeSignature()\n-                        )\n-                    )\n-                )\n+                Stream.of(PgProcTable.Entry.of(Regproc.of(\"array_recv\").asDummySignature()))", "originalCommit": "edc5bf6f4071659a5adfc539311c1c21be101baf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE1NTM5Mw==", "url": "https://github.com/crate/crate/pull/10780#discussion_r526155393", "bodyText": "The signature is used in columns of the pg_proc table, but given that we don't have a real array_recv, or  <type>_in / <type>_out functions I think it should be alright to use a dummy value.\nIf it turns out that it causes problems we'll probably have to introduce some kind of registry for the dummy pg streaming functions.", "author": "mfussenegger", "createdAt": "2020-11-18T15:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjE1MDY0Ng=="}], "type": "inlineReview"}, {"oid": "05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "url": "https://github.com/crate/crate/commit/05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "message": "Ensure pg_proc.oid and pg_type.typreceive can be joined\n\nFixes a regression which led in npgsql to an error like this:\n\n    The CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\n    PostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\n\n    SELECT ns.nspname, typ_and_elem_type.*,\n      CASE\n          WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n          WHEN typtype = 'r' THEN 1                        -- Ranges after\n          WHEN typtype = 'c' THEN 2                        -- Composites after\n          WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n          WHEN typtype = 'a' THEN 4                        -- Arrays before\n          WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n        END AS ord\n    FROM (\n        -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n        -- We first do this for the type (innerest-most subquery), and then for its element type\n        -- This also returns the array element, range subtype and domain base type as elemtypoid\n        SELECT\n            typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n            elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n            CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n        FROM (\n            SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n                CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n                CASE\n                    WHEN proc.proname='array_recv' THEN typ.typelem\n                    WHEN typ.typtype='r' THEN rngsubtype\n                    WHEN typ.typtype='d' THEN typ.typbasetype\n                END AS elemtypoid\n            FROM pg_type AS typ\n            LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n            LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n            LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n        ) AS typ\n        LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n        LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n        LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n    ) AS typ_and_elem_type\n    JOIN pg_namespace AS ns ON (ns.oid = typnamespace)\n    WHERE\n        typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n        (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n        (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n        (typtype = 'a' AND (  -- Array of...\n            elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n            (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n            (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n        ))\n    ORDER BY ord;\n\nThe join `LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive` didn't\nmatch anymore after ae507cc46432064a019e3dc56b5a44d402d1d3b8 because the\nfunction to generate the oid for `pg_proc` was changed without changing\nthe corresponding `pg_type` related entries.", "committedDate": "2020-11-19T08:41:43Z", "type": "commit"}, {"oid": "05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "url": "https://github.com/crate/crate/commit/05f2dda1026ce3c0b48bb20ef600fc76c46b4d4f", "message": "Ensure pg_proc.oid and pg_type.typreceive can be joined\n\nFixes a regression which led in npgsql to an error like this:\n\n    The CLR array type System.Int32[] isn't supported by Npgsql or your PostgreSQL. If you wish to map it to an\n    PostgreSQL composite type array you need to register it before usage, please refer to the documentation.\n\nThe reason for that error is that npgsql looks up type information via\nthe following query:\n\n    SELECT ns.nspname, typ_and_elem_type.*,\n      CASE\n          WHEN typtype IN ('b', 'e', 'p') THEN 0           -- First base types, enums, pseudo-types\n          WHEN typtype = 'r' THEN 1                        -- Ranges after\n          WHEN typtype = 'c' THEN 2                        -- Composites after\n          WHEN typtype = 'd' AND elemtyptype <> 'a' THEN 3 -- Domains over non-arrays after\n          WHEN typtype = 'a' THEN 4                        -- Arrays before\n          WHEN typtype = 'd' AND elemtyptype = 'a' THEN 5  -- Domains over arrays last\n        END AS ord\n    FROM (\n        -- Arrays have typtype=b - this subquery identifies them by their typreceive and converts their typtype to a\n        -- We first do this for the type (innerest-most subquery), and then for its element type\n        -- This also returns the array element, range subtype and domain base type as elemtypoid\n        SELECT\n            typ.oid, typ.typnamespace, typ.typname, typ.typtype, typ.typrelid, typ.typnotnull, typ.relkind,\n            elemtyp.oid AS elemtypoid, elemtyp.typname AS elemtypname, elemcls.relkind AS elemrelkind,\n            CASE WHEN elemproc.proname='array_recv' THEN 'a' ELSE elemtyp.typtype END AS elemtyptype\n        FROM (\n            SELECT typ.oid, typnamespace, typname, typrelid, typnotnull, relkind, typelem AS elemoid,\n                CASE WHEN proc.proname='array_recv' THEN 'a' ELSE typ.typtype END AS typtype,\n                CASE\n                    WHEN proc.proname='array_recv' THEN typ.typelem\n                    WHEN typ.typtype='r' THEN rngsubtype\n                    WHEN typ.typtype='d' THEN typ.typbasetype\n                END AS elemtypoid\n            FROM pg_type AS typ\n            LEFT JOIN pg_class AS cls ON (cls.oid = typ.typrelid)\n            LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive\n            LEFT JOIN pg_range ON (pg_range.rngtypid = typ.oid)\n        ) AS typ\n        LEFT JOIN pg_type AS elemtyp ON elemtyp.oid = elemtypoid\n        LEFT JOIN pg_class AS elemcls ON (elemcls.oid = elemtyp.typrelid)\n        LEFT JOIN pg_proc AS elemproc ON elemproc.oid = elemtyp.typreceive\n    ) AS typ_and_elem_type\n    JOIN pg_namespace AS ns ON (ns.oid = typnamespace)\n    WHERE\n        typtype IN ('b', 'r', 'e', 'd') OR -- Base, range, enum, domain\n        (typtype = 'c' AND relkind='c') OR -- User-defined free-standing composites (not table composites) by default\n        (typtype = 'p' AND typname IN ('record', 'void')) OR -- Some special supported pseudo-types\n        (typtype = 'a' AND (  -- Array of...\n            elemtyptype IN ('b', 'r', 'e', 'd') OR -- Array of base, range, enum, domain\n            (elemtyptype = 'p' AND elemtypname IN ('record', 'void')) OR -- Arrays of special supported pseudo-types\n            (elemtyptype = 'c' AND elemrelkind='c') -- Array of user-defined free-standing composites (not table composites) by default\n        ))\n    ORDER BY ord;\n\nThe join `LEFT JOIN pg_proc AS proc ON proc.oid = typ.typreceive` didn't\nmatch anymore after ae507cc46432064a019e3dc56b5a44d402d1d3b8 because the\nfunction to generate the oid for `pg_proc` was changed without changing\nthe corresponding `pg_type` related entries.", "committedDate": "2020-11-19T08:41:43Z", "type": "forcePushed"}]}