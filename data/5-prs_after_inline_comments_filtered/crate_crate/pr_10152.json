{"pr_number": 10152, "pr_title": "Resolve unnest and _values signature return type correctly.", "pr_createdAt": "2020-06-30T13:42:33Z", "pr_url": "https://github.com/crate/crate/pull/10152", "timeline": [{"oid": "6530bde9c08d75852bd1f687a7517e8ee48ece7f", "url": "https://github.com/crate/crate/commit/6530bde9c08d75852bd1f687a7517e8ee48ece7f", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-06-30T14:18:52Z", "type": "forcePushed"}, {"oid": "478003e222405b7e45b0cf7f4a76a00fb8ec4956", "url": "https://github.com/crate/crate/commit/478003e222405b7e45b0cf7f4a76a00fb8ec4956", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-06-30T14:28:09Z", "type": "forcePushed"}, {"oid": "8452b778357bde5575dadaab0983d0071705e7b1", "url": "https://github.com/crate/crate/commit/8452b778357bde5575dadaab0983d0071705e7b1", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-06-30T14:51:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTMxNw==", "url": "https://github.com/crate/crate/pull/10152#discussion_r447759317", "bodyText": "previously, we had kind of similar approach with overriding the function info 468e81c#diff-ac060c995181f48a5efb0b2e51fc576dL63-L70\nIt seems a bit complicated to do it in the type signature parsing itself :/ and such as we had the approach with overwriting before, i've decided to go this way. Also, it is only the unnest and _values that have this issue.", "author": "kovrus", "createdAt": "2020-06-30T15:08:43Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/UnnestFunction.java", "diffHunk": "@@ -68,15 +71,39 @@ public static void register(TableFunctionModule module) {\n                 )\n                 .withTypeVariableConstraints(typeVariable(\"E\"), typeVariableOfAnyType(\"N\"))\n                 .withVariableArity(),\n-            UnnestTableFunctionImplementation::new\n+            (signature, boundSignature) -> {", "originalCommit": "8452b778357bde5575dadaab0983d0071705e7b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMDE5OQ==", "url": "https://github.com/crate/crate/pull/10152#discussion_r447910199", "bodyText": "Would it be possible to somehow adapt the Signature.table constructor to enforce the building of a correct RowType?\nAs it is it's rather difficult to register a table function that is actually working correctly", "author": "mfussenegger", "createdAt": "2020-06-30T18:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Mjc3Ng==", "url": "https://github.com/crate/crate/pull/10152#discussion_r447962776", "bodyText": "but we are not always registering table functions that have the row type as the return type, for instance, https://github.com/crate/crate/blob/master/server/src/main/java/io/crate/expression/tablefunctions/GenerateSeries.java#L72 we register the function with a return type that corresponds to the type of the input arguments so we can use it as scalar and we use properly constructed row type for TableFunctionImplementation#returnType in the case when table function used normally. Therefore, I am not sure that we should enforce Signature.table, maybe we can add some shortcut for such cases, e.g. Signature.tableForArgumetsOnly or smth, but it will be used only for this specific case. (and _values)\nhttps://github.com/crate/crate/pull/10152/files#diff-3b1c265f133d1b9627ea392b630649c2R65-R70\nI think we initially split the unnest signature to emphasise case when there is more than one array of any type\nso then we have to return the row type. I think we can merge this and previous signatures and add similar logic that we had before which I mentioned in the previous comment to build all the required function info, but we would still have to rewrite the return type of the bound signature and construct the value for TableFunctionImplementation#returnType. If we keep the signatures as they are now then another approach would be to implement some kind of signature binding based on the number of arguments or smth like that, that will be used for this particular case, but it doesn't seem to be that straightforward and I am not sure whether it worth it.", "author": "kovrus", "createdAt": "2020-06-30T20:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE2OTI4Mw==", "url": "https://github.com/crate/crate/pull/10152#discussion_r448169283", "bodyText": "Could we then maybe extend the table-function base test class to assert that if the aggregation has a RowType with multiple fields, that the signature result-type must also be a row-type and must match?", "author": "mfussenegger", "createdAt": "2020-07-01T07:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTMxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTg5OQ==", "url": "https://github.com/crate/crate/pull/10152#discussion_r448205899", "bodyText": "@mfussenegger pushed the fixup", "author": "kovrus", "createdAt": "2020-07-01T08:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc1OTMxNw=="}], "type": "inlineReview"}, {"oid": "57a8fff7d6799633f59480769e0750e958a00961", "url": "https://github.com/crate/crate/commit/57a8fff7d6799633f59480769e0750e958a00961", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-06-30T15:10:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxNDI2Nw==", "url": "https://github.com/crate/crate/pull/10152#discussion_r448214267", "bodyText": "\"If the the function has multiple fields, then the bound type must be RowType\"", "author": "marregui", "createdAt": "2020-07-01T08:48:30Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/AbstractTableFunctionsTest.java", "diffHunk": "@@ -58,16 +61,31 @@ public void prepareFunctions() throws Exception {\n         Symbol functionSymbol = sqlExpressions.normalize(sqlExpressions.asSymbol(expr));\n \n         var function = (Function) functionSymbol;\n-        TableFunctionImplementation<?> functionImplementation = (TableFunctionImplementation<?>) functions.getQualified(\n+        var functionImplementation = (TableFunctionImplementation<?>) functions.getQualified(\n             function,\n             txnCtx.sessionSettings().searchPath()\n         );\n+\n+        var boundArguments = functionImplementation.boundSignature().getArgumentTypes();\n+        if (boundArguments.size() > 1 && boundArguments.stream()\n+            .allMatch(arg -> arg.getBaseTypeName().equalsIgnoreCase(ArrayType.NAME))) {\n+\n+            var boundReturnType = functionImplementation.boundSignature().getReturnType();\n+            assertThat(\n+                \"If the the function has multiple fields, than the bound type must be RowType\",", "originalCommit": "d8bc6d2b0e35e11edd5ef17783fc263c52179d75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c9d4bc99d8f0c669631248c7cfee58a6aa68ab8e", "url": "https://github.com/crate/crate/commit/c9d4bc99d8f0c669631248c7cfee58a6aa68ab8e", "message": "fixup! Resolve unnest and _values signature return type correctly.", "committedDate": "2020-07-01T08:51:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxODI1Nw==", "url": "https://github.com/crate/crate/pull/10152#discussion_r448218257", "bodyText": "I was thinking of something like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    var boundArguments = functionImplementation.boundSignature().getArgumentTypes();\n          \n          \n            \n                    if (boundArguments.size() > 1 && boundArguments.stream()\n          \n          \n            \n                        .allMatch(arg -> arg.getBaseTypeName().equalsIgnoreCase(ArrayType.NAME))) {\n          \n          \n            \n            \n          \n          \n            \n                        var boundReturnType = functionImplementation.boundSignature().getReturnType();\n          \n          \n            \n                        assertThat(\n          \n          \n            \n                            \"If the function has multiple fields, than the bound type must be RowType\",\n          \n          \n            \n                            boundReturnType.getBaseTypeName(),\n          \n          \n            \n                            is(RowType.NAME)\n          \n          \n            \n                        );\n          \n          \n            \n                        assertThat(boundReturnType.getParameters().size(), greaterThan(1));\n          \n          \n            \n                    }\n          \n          \n            \n                    if (functionImplementation.returnType().numElements() > 1) {\n          \n          \n            \n                        // See classdocs of TableFunctionImplementation for an explanation\n          \n          \n            \n                        assertThat(\n          \n          \n            \n                            \"If the rowType has multiple elements, the returnType of the boundSignature must be an exact match of the returnType\",\n          \n          \n            \n                            functionImplementation.boundSignature().getReturnType().createType(),\n          \n          \n            \n                            is(functionImplementation.returnType())\n          \n          \n            \n                        );\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\nWhat do you think?", "author": "mfussenegger", "createdAt": "2020-07-01T08:55:14Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/AbstractTableFunctionsTest.java", "diffHunk": "@@ -58,16 +61,31 @@ public void prepareFunctions() throws Exception {\n         Symbol functionSymbol = sqlExpressions.normalize(sqlExpressions.asSymbol(expr));\n \n         var function = (Function) functionSymbol;\n-        TableFunctionImplementation<?> functionImplementation = (TableFunctionImplementation<?>) functions.getQualified(\n+        var functionImplementation = (TableFunctionImplementation<?>) functions.getQualified(\n             function,\n             txnCtx.sessionSettings().searchPath()\n         );\n+\n+        var boundArguments = functionImplementation.boundSignature().getArgumentTypes();\n+        if (boundArguments.size() > 1 && boundArguments.stream()\n+            .allMatch(arg -> arg.getBaseTypeName().equalsIgnoreCase(ArrayType.NAME))) {\n+\n+            var boundReturnType = functionImplementation.boundSignature().getReturnType();\n+            assertThat(\n+                \"If the function has multiple fields, than the bound type must be RowType\",\n+                boundReturnType.getBaseTypeName(),\n+                is(RowType.NAME)\n+            );\n+            assertThat(boundReturnType.getParameters().size(), greaterThan(1));\n+        }", "originalCommit": "c9d4bc99d8f0c669631248c7cfee58a6aa68ab8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIyMjk1MQ==", "url": "https://github.com/crate/crate/pull/10152#discussion_r448222951", "bodyText": "ah sure, we can assert against the TableFunctionImplementation#returnType :( it is defientely better like that!", "author": "kovrus", "createdAt": "2020-07-01T09:03:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIxODI1Nw=="}], "type": "inlineReview"}, {"oid": "a623e5e29ee6055b1800d7dcad63ef9c7df73762", "url": "https://github.com/crate/crate/commit/a623e5e29ee6055b1800d7dcad63ef9c7df73762", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-07-01T09:11:03Z", "type": "forcePushed"}, {"oid": "222313970bb1beeff792aac4a2380786498431ab", "url": "https://github.com/crate/crate/commit/222313970bb1beeff792aac4a2380786498431ab", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-07-01T09:27:26Z", "type": "commit"}, {"oid": "222313970bb1beeff792aac4a2380786498431ab", "url": "https://github.com/crate/crate/commit/222313970bb1beeff792aac4a2380786498431ab", "message": "Resolve unnest and _values signature return type correctly.\n\nThe inner type of the `unnest` and `_values` function resolved\ncorrectly and accounts the inner types of the record type, while\nthe return type of the bound signature return always the empty\nrecord type. It happens due the type signature binding limitation\nof functions that have an argument represented by the array type\nthat has a variable of any type and variably arity.", "committedDate": "2020-07-01T09:27:26Z", "type": "forcePushed"}]}