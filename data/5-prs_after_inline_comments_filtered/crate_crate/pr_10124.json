{"pr_number": 10124, "pr_title": "Delay writes on channel until execute is finished", "pr_createdAt": "2020-06-23T14:12:44Z", "pr_url": "https://github.com/crate/crate/pull/10124", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NDMwOA==", "url": "https://github.com/crate/crate/pull/10124#discussion_r444264308", "bodyText": "shouldn't this be at least volatile?", "author": "seut", "createdAt": "2020-06-23T14:23:56Z", "path": "server/src/main/java/io/crate/protocols/postgres/DelayableWriteChannel.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres;\n+\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.concurrent.CompletableFuture;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelId;\n+import io.netty.channel.ChannelMetadata;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelProgressivePromise;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoop;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Channel implementation that allows to delay writes with `blockWritesUntil`\n+ **/\n+public class DelayableWriteChannel implements Channel {\n+\n+    private final Channel delegate;\n+    private DelayedWrites delay;", "originalCommit": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI4OTQyOA==", "url": "https://github.com/crate/crate/pull/10124#discussion_r444289428", "bodyText": "I wasn't entirely sure either, but after thinking about it some more I think you're right.", "author": "mfussenegger", "createdAt": "2020-06-23T14:55:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NDMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NjQ2Nw==", "url": "https://github.com/crate/crate/pull/10124#discussion_r444266467", "bodyText": "As ArrayDeque isn't thread-safe, don't we have to ensure thread-safety here or on the caller side?\n(same on the below delayed.poll())", "author": "seut", "createdAt": "2020-06-23T14:26:45Z", "path": "server/src/main/java/io/crate/protocols/postgres/DelayableWriteChannel.java", "diffHunk": "@@ -0,0 +1,326 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres;\n+\n+import java.net.SocketAddress;\n+import java.util.ArrayDeque;\n+import java.util.concurrent.CompletableFuture;\n+\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelConfig;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelId;\n+import io.netty.channel.ChannelMetadata;\n+import io.netty.channel.ChannelPipeline;\n+import io.netty.channel.ChannelProgressivePromise;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.EventLoop;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n+\n+/**\n+ * Channel implementation that allows to delay writes with `blockWritesUntil`\n+ **/\n+public class DelayableWriteChannel implements Channel {\n+\n+    private final Channel delegate;\n+    private DelayedWrites delay;\n+\n+    public DelayableWriteChannel(Channel channel) {\n+        this.delegate = channel;\n+    }\n+\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        return delegate.attr(key);\n+    }\n+\n+    @Override\n+    public <T> boolean hasAttr(AttributeKey<T> key) {\n+        return delegate.hasAttr(key);\n+    }\n+\n+    @Override\n+    public ChannelFuture bind(SocketAddress localAddress) {\n+        return delegate.bind(localAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress) {\n+        return delegate.connect(remoteAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) {\n+        return delegate.connect(remoteAddress, localAddress);\n+    }\n+\n+    @Override\n+    public ChannelFuture disconnect() {\n+        return delegate.disconnect();\n+    }\n+\n+    @Override\n+    public ChannelFuture close() {\n+        return delegate.close();\n+    }\n+\n+    @Override\n+    public ChannelFuture deregister() {\n+        return delegate.deregister();\n+    }\n+\n+    @Override\n+    public ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) {\n+        return delegate.bind(localAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) {\n+        return delegate.connect(remoteAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) {\n+        return delegate.connect(remoteAddress, localAddress, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture disconnect(ChannelPromise promise) {\n+        return delegate.disconnect(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture close(ChannelPromise promise) {\n+        return delegate.close(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture deregister(ChannelPromise promise) {\n+        return delegate.deregister(promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture write(Object msg) {\n+        if (delay != null) {\n+            ChannelPromise newPromise = newPromise();\n+            delay.add(() -> delegate.write(msg, newPromise));\n+            return newPromise;\n+        }\n+        return delegate.write(msg);\n+    }\n+\n+    @Override\n+    public ChannelFuture write(Object msg, ChannelPromise promise) {\n+        if (delay != null) {\n+            delay.add(() -> delegate.write(msg, promise));\n+            return promise;\n+        }\n+        return delegate.write(msg, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeAndFlush(Object msg, ChannelPromise promise) {\n+        if (delay != null) {\n+            delay.add(() -> delegate.writeAndFlush(msg, promise));\n+        }\n+        return delegate.writeAndFlush(msg, promise);\n+    }\n+\n+    @Override\n+    public ChannelFuture writeAndFlush(Object msg) {\n+        if (delay != null) {\n+            ChannelPromise promise = newPromise();\n+            delay.add(() -> delegate.writeAndFlush(msg, promise));\n+            return promise;\n+        }\n+        return delegate.writeAndFlush(msg);\n+    }\n+\n+    @Override\n+    public ChannelPromise newPromise() {\n+        return delegate.newPromise();\n+    }\n+\n+    @Override\n+    public ChannelProgressivePromise newProgressivePromise() {\n+        return delegate.newProgressivePromise();\n+    }\n+\n+    @Override\n+    public ChannelFuture newSucceededFuture() {\n+        return delegate.newSucceededFuture();\n+    }\n+\n+    @Override\n+    public ChannelFuture newFailedFuture(Throwable cause) {\n+        return delegate.newFailedFuture(cause);\n+    }\n+\n+    @Override\n+    public ChannelPromise voidPromise() {\n+        return delegate.voidPromise();\n+    }\n+\n+    @Override\n+    public int compareTo(Channel o) {\n+        return delegate.compareTo(o);\n+    }\n+\n+    @Override\n+    public ChannelId id() {\n+        return delegate.id();\n+    }\n+\n+    @Override\n+    public EventLoop eventLoop() {\n+        return delegate.eventLoop();\n+    }\n+\n+    @Override\n+    public Channel parent() {\n+        return delegate.parent();\n+    }\n+\n+    @Override\n+    public ChannelConfig config() {\n+        return delegate.config();\n+    }\n+\n+    @Override\n+    public boolean isOpen() {\n+        return delegate.isOpen();\n+    }\n+\n+    @Override\n+    public boolean isRegistered() {\n+        return delegate.isRegistered();\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return delegate.isActive();\n+    }\n+\n+    @Override\n+    public ChannelMetadata metadata() {\n+        return delegate.metadata();\n+    }\n+\n+    @Override\n+    public SocketAddress localAddress() {\n+        return delegate.localAddress();\n+    }\n+\n+    @Override\n+    public SocketAddress remoteAddress() {\n+        return delegate.remoteAddress();\n+    }\n+\n+    @Override\n+    public ChannelFuture closeFuture() {\n+        return delegate.closeFuture();\n+    }\n+\n+    @Override\n+    public boolean isWritable() {\n+        return delegate.isWritable();\n+    }\n+\n+    @Override\n+    public long bytesBeforeUnwritable() {\n+        return delegate.bytesBeforeUnwritable();\n+    }\n+\n+    @Override\n+    public long bytesBeforeWritable() {\n+        return delegate.bytesBeforeWritable();\n+    }\n+\n+    @Override\n+    public Unsafe unsafe() {\n+        return delegate.unsafe();\n+    }\n+\n+    @Override\n+    public ChannelPipeline pipeline() {\n+        return delegate.pipeline();\n+    }\n+\n+    @Override\n+    public ByteBufAllocator alloc() {\n+        return delegate.alloc();\n+    }\n+\n+    @Override\n+    public Channel read() {\n+        return delegate.read();\n+    }\n+\n+    @Override\n+    public Channel flush() {\n+        return delegate.flush();\n+    }\n+\n+    public Channel bypassDelay() {\n+        return delegate;\n+    }\n+\n+    public void delayWritesUntil(CompletableFuture<?> future) {\n+        DelayedWrites delayedWrites;\n+        if (delay == null) {\n+            delayedWrites = new DelayedWrites(future);\n+        } else {\n+            delayedWrites = new DelayedWrites(delay.future.thenCompose(ignored -> future));\n+        }\n+        this.delay = delayedWrites;\n+        future.whenComplete((res, err) -> {\n+            delayedWrites.runDelayed();\n+            if (delay == delayedWrites) {\n+                delay = null;\n+            }\n+        });\n+    }\n+\n+    static class DelayedWrites {\n+\n+        private final ArrayDeque<Runnable> delayed = new ArrayDeque<>();\n+        private final CompletableFuture<?> future;\n+\n+        public DelayedWrites(CompletableFuture<?> future) {\n+            this.future = future;\n+        }\n+\n+        public void add(Runnable runnable) {\n+            delayed.add(runnable);", "originalCommit": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDI2NzcwNQ==", "url": "https://github.com/crate/crate/pull/10124#discussion_r444267705", "bodyText": "could be annotated with @Nullable", "author": "seut", "createdAt": "2020-06-23T14:28:09Z", "path": "server/src/main/java/io/crate/action/sql/Session.java", "diffHunk": "@@ -353,7 +353,7 @@ public DescribeResult describe(char type, String portalOrStatement) {\n         }\n     }\n \n-    public void execute(String portalName, int maxRows, ResultReceiver<?> resultReceiver) {\n+    public CompletableFuture<?> execute(String portalName, int maxRows, ResultReceiver<?> resultReceiver) {", "originalCommit": "f1bf4f65c94f2b10bd4b1bd041e011b7d3cee584", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "95cdb268a49b434e38151b247f2ba447cbf9c136", "url": "https://github.com/crate/crate/commit/95cdb268a49b434e38151b247f2ba447cbf9c136", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068", "committedDate": "2020-06-23T15:15:16Z", "type": "forcePushed"}, {"oid": "c3a458eeca39f2733b002538e9c0f656d9505c10", "url": "https://github.com/crate/crate/commit/c3a458eeca39f2733b002538e9c0f656d9505c10", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068", "committedDate": "2020-06-23T15:59:25Z", "type": "commit"}, {"oid": "c3a458eeca39f2733b002538e9c0f656d9505c10", "url": "https://github.com/crate/crate/commit/c3a458eeca39f2733b002538e9c0f656d9505c10", "message": "Delay writes on channel until execute is finished\n\nWe must make sure that the client receives the rows and the\n`commandComplete` message before it receives a `parseComplete` for a\nsecond query that the client may have sent as well.\n\nWe send the query results and the `commandComplete` from the `SEARCH`\nthreadpool instead of from the netty worker thread, which causes netty\nto schedule them for later execution. (When the worker thread can pick\nit up)\n\nMeanwhile it was the case that the netty-loop continued processing more\nmessages.\n\nThis fixes https://github.com/crate/crate/issues/10068", "committedDate": "2020-06-23T15:59:25Z", "type": "forcePushed"}]}