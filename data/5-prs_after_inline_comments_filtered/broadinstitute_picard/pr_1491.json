{"pr_number": 1491, "pr_title": "Improvements to CompareMetrics", "pr_createdAt": "2020-03-30T17:07:12Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1491", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NzA0NA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400397044", "bodyText": "It's usually not a good idea to have a non-final static field, especially one that's not thread safe (like HashMap). It doesn't look like this needs to be static, was is done this way to make it testable?", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:16:18Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MjM0MA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400482340", "bodyText": "Yeah, that was for testing.  I've made it final and instantiated it there.", "author": "gbggrant", "createdAt": "2020-03-30T20:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NzA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5Nzk0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400397942", "bodyText": "I think lang3 is preferred over lang\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import org.apache.commons.lang.StringUtils;\n          \n          \n            \n            import org.apache.commons.lang3.StringUtils;", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:17:48Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -24,19 +24,39 @@\n \n package picard.analysis;\n \n+import htsjdk.samtools.metrics.MetricBase;\n import htsjdk.samtools.metrics.MetricsFile;\n import htsjdk.samtools.util.IOUtil;\n import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.StringUtil;\n+import org.apache.commons.lang.StringUtils;", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MjY5MA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400482690", "bodyText": "\ud83d\udc4d", "author": "gbggrant", "createdAt": "2020-03-30T20:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5Nzk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5ODkxMg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400398912", "bodyText": "metricsA and metricsB are initialized but never used. It looks like they can be deleted.", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:19:29Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MzE5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400483195", "bodyText": "Thanks - some old testing code there I think", "author": "gbggrant", "createdAt": "2020-03-30T20:46:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5ODkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMDc0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400400742", "bodyText": "Unnecessary else after return.", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:22:41Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MzU5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400483593", "bodyText": "\ud83d\udc4d", "author": "gbggrant", "createdAt": "2020-03-30T20:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwMDc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjM3Nw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400406377", "bodyText": "Inner classes should be static if possible to avoid capturing the outer class. Also I think in this case static is unnecessary, with default scope the test class should be able to see it, as it's in the same package.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public class SimpleResult {\n          \n          \n            \n                static class SimpleResult {", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:31:36Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(\n+                new FileOutputStream(output), StandardCharsets.UTF_8))) {\n+            writer.write(header + \"\\n\\n\");\n+            writer.write(StringUtils.join(textLines, \"\\n\"));\n+        }\n+    }\n+\n+    private void validateMetricNames(final MetricsFile<?, ?> metrics, final File metricsFile, final Collection<String> metricNames) {\n+        Set<String> metricsToIgnore = new HashSet<>(metricNames);\n+        metricsToIgnore.removeAll(metrics.getMetricsColumnLabels());\n+        if (!metricsToIgnore.isEmpty()) {\n+            throw new PicardException(\"Metric(s) of the name: \" + StringUtil.join(\", \", metricsToIgnore) + \" were not found in \" + metricsFile.getAbsolutePath());\n+        }\n+    }\n+\n+    public class SimpleResult {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NDA3OA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400484078", "bodyText": "\ud83d\udc4d", "author": "gbggrant", "createdAt": "2020-03-30T20:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQwNjM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMzI3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400413275", "bodyText": "I think using static imports makes code harder to read and should be avoided in general. It looks like this is only used once in this file, and Math is pretty short anyway so removing the static import shouldn't be a big change.", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:43:40Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -24,19 +24,39 @@\n \n package picard.analysis;\n \n+import htsjdk.samtools.metrics.MetricBase;\n import htsjdk.samtools.metrics.MetricsFile;\n import htsjdk.samtools.util.IOUtil;\n import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.StringUtil;\n+import org.apache.commons.lang.StringUtils;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n import org.broadinstitute.barclay.help.DocumentedFeature;\n import picard.PicardException;\n import picard.cmdline.CommandLineProgram;\n-import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n-import org.broadinstitute.barclay.argparser.PositionalArguments;\n+import picard.cmdline.StandardOptionDefinitions;\n import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n \n+import java.io.BufferedWriter;\n import java.io.File;\n+import java.io.FileOutputStream;\n import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.lang.reflect.Field;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.lang.Math.abs;", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMDc1NQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402520755", "bodyText": "done.", "author": "gbggrant", "createdAt": "2020-04-02T18:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMzI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMzk4OQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400413989", "bodyText": "should be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n          \n          \n            \n                private static final DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:44:49Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMTAwNg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402521006", "bodyText": "I ended up getting rid of the DecimalFormat usage", "author": "gbggrant", "createdAt": "2020-04-02T18:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxMzk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNDYwOA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400414608", "bodyText": "These elses are unnecessary and make the code a little more confusing to me, but maybe they make it clearer to you? Either way is OK.", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:45:50Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTM4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400415387", "bodyText": "This could be returned at the end of the try block and then you don't need to declare retVal outside the try.", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:47:15Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyMTU0OA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402521548", "bodyText": "So true.", "author": "gbggrant", "createdAt": "2020-04-02T18:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMDc0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400420741", "bodyText": "This use of StringUtil.join() can be replaced using a JDK builtin, String.join()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new PicardException(\"Metric(s) of the name: \" + StringUtil.join(\", \", metricsToIgnore) + \" were not found in \" + metricsFile.getAbsolutePath());\n          \n          \n            \n                        throw new PicardException(\"Metric(s) of the name: \" + String.join(\", \", metricsToIgnore) + \" were not found in \" + metricsFile.getAbsolutePath());", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:55:52Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(\n+                new FileOutputStream(output), StandardCharsets.UTF_8))) {\n+            writer.write(header + \"\\n\\n\");\n+            writer.write(StringUtils.join(textLines, \"\\n\"));\n+        }\n+    }\n+\n+    private void validateMetricNames(final MetricsFile<?, ?> metrics, final File metricsFile, final Collection<String> metricNames) {\n+        Set<String> metricsToIgnore = new HashSet<>(metricNames);\n+        metricsToIgnore.removeAll(metrics.getMetricsColumnLabels());\n+        if (!metricsToIgnore.isEmpty()) {\n+            throw new PicardException(\"Metric(s) of the name: \" + StringUtil.join(\", \", metricsToIgnore) + \" were not found in \" + metricsFile.getAbsolutePath());", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNzAzMw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402527033", "bodyText": "yup", "author": "gbggrant", "createdAt": "2020-04-02T18:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMDc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMDk5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400420995", "bodyText": "This can be static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void validateMetricNames(final MetricsFile<?, ?> metrics, final File metricsFile, final Collection<String> metricNames) {\n          \n          \n            \n                private static void validateMetricNames(final MetricsFile<?, ?> metrics, final File metricsFile, final Collection<String> metricNames) {", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:56:20Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(\n+                new FileOutputStream(output), StandardCharsets.UTF_8))) {\n+            writer.write(header + \"\\n\\n\");\n+            writer.write(StringUtils.join(textLines, \"\\n\"));\n+        }\n+    }\n+\n+    private void validateMetricNames(final MetricsFile<?, ?> metrics, final File metricsFile, final Collection<String> metricNames) {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNzMyNA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402527324", "bodyText": "Thanks.", "author": "gbggrant", "createdAt": "2020-04-02T18:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMDk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTcxMA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400421710", "bodyText": "This can be static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n          \n          \n            \n                private static void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:57:34Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUyNzk0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r402527947", "bodyText": "thanks.", "author": "gbggrant", "createdAt": "2020-04-02T18:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMTcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMjAwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400422009", "bodyText": "This can be replaced with String.join()\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        writer.write(StringUtils.join(textLines, \"\\n\"));\n          \n          \n            \n                        writer.write(String.join(\"\\n\", textLines));", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:58:04Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(\n+                new FileOutputStream(output), StandardCharsets.UTF_8))) {\n+            writer.write(header + \"\\n\\n\");\n+            writer.write(StringUtils.join(textLines, \"\\n\"));", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NDQyMg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400484422", "bodyText": "\ud83d\udc4d", "author": "gbggrant", "createdAt": "2020-03-30T20:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzAzMA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400423030", "bodyText": "Using Files makes this a little shorter\n        try (Writer writer = Files.newBufferedWriter(output.toPath())) {", "author": "pshapiro4broad", "createdAt": "2020-03-30T18:59:40Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);\n+                    }\n+                }\n+            } else {\n+                if (!value1.equals(value2)) {\n+                    equal = false;\n+                    description = \"Different Values\";\n+                }\n+            }\n+        }\n+        return new SimpleResult(equal, description);\n+    }\n+\n+    private void writeTextToFile(final File output, final String header, final List<String> textLines) throws IOException {\n+        try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTA0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400485041", "bodyText": "\ud83d\udc4d", "author": "gbggrant", "createdAt": "2020-03-30T20:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyMzAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDQ5Mg==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400424492", "bodyText": "It doesn't hurt to check both, but since the code already asserts that the sizes are equal, they should only ever both be true. So the code only needs to check one here.", "author": "pshapiro4broad", "createdAt": "2020-03-30T19:02:17Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NTMxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400485319", "bodyText": "True that.", "author": "gbggrant", "createdAt": "2020-03-30T20:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQyNDQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODY4MA==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400438680", "bodyText": "It's probably fine, but do you think it's OK that using a fixed format in this way will prevent some differences from showing up? E.g. from the test run output I see:\nERROR\t2020-03-30 14:51:21\tCompareMetrics\tRow: 0 Metric: GENOME_TERRITORY values differ. Value1: 2745186694 Value2: 2745186691 Changed by 0.0000000\nERROR\t2020-03-30 14:51:21\tCompareMetrics\tRow: 0 Metric: PCT_EXC_BASEQ values differ. Value1: 0.122134 Value2: 0.122133 Changed by 0.0000082\nERROR\t2020-03-30 14:51:21\tCompareMetrics\tRow: 1 Metric: GENOME_TERRITORY values differ. Value1: 2745186694 Value2: 2745186691 Changed by 0.0000000\nERROR\t2020-03-30 14:51:21\tCompareMetrics\tRow: 1 Metric: PCT_EXC_BASEQ values differ. Value1: 0.122134 Value2: 0.122133 Changed by 0.0000082", "author": "pshapiro4broad", "createdAt": "2020-03-30T19:25:05Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!IGNORE_HISTOGRAM_DIFFERENCES) {\n+            final boolean histogramsEqual = mf1.areHistogramsEqual(mf2);\n+            if (!histogramsEqual) {\n+                final String diffString = \"Metric Histograms differ\";\n+                differences.add(diffString);\n+                log.error(diffString);\n+            }\n+            if (retVal == 0 && !histogramsEqual) {\n+                retVal = 1;\n+            }\n+        }\n+        if (OUTPUT != null) {\n+            final String header = \"Comparison of \" + mf1.getMetrics().get(0).getClass().getName() + \" metrics between \"\n+                    + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath() + \"\\nResult = \" +\n+                    ((retVal == 0) ? \"Pass\" : \"Fail\");\n+            writeTextToFile(OUTPUT, header, differences);\n+        }\n+\n+        return retVal;\n+    }\n+\n+    protected SimpleResult compareMetricValues(final Object value1, final Object value2, final String metricName) {\n+        boolean equal = true;\n+        String description = \"\";\n+        if (value1 == null || value2 == null) {\n+            if (value1 != null || value2 != null) {\n+                equal = false;\n+                description = \"One of the values is null\";\n+            }\n+        } else {\n+            if (value1 instanceof Number) {\n+                double numValue1 = ((Number) value1).doubleValue();\n+                double numValue2 = ((Number) value2).doubleValue();\n+                double relativeChange = (numValue1 == 0 && numValue2 == 0) ? 0 : (numValue1 == 0) ? Double.MAX_VALUE : (numValue1 - numValue2) / numValue2;\n+                if (relativeChange != 0) {\n+                    if (MetricToAllowableRelativeChange.containsKey(metricName)) {\n+                        double allowableRelativeChange = MetricToAllowableRelativeChange.get(metricName);\n+                        if (abs(relativeChange) >= allowableRelativeChange) {\n+                            equal = false;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is outside of the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        } else {\n+                            equal = true;\n+                            description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange) +\n+                                    \" which is within the allowable tolerance of \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(allowableRelativeChange);\n+                        }\n+                    } else {\n+                        equal = false;\n+                        description = \"Changed by \" + RELATIVE_CHANGE_DECIMAL_FORMAT.format(relativeChange);", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NjEyOQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400486129", "bodyText": "I went back and forth on that.  I agree that it's losing information, so I'll put it back.", "author": "gbggrant", "createdAt": "2020-03-30T20:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ0OTQ3MQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400449471", "bodyText": "Is it important to log when adding, vs logging at the end when all differences have been generated? If you log at the end, then you don't need to log both here and below with the histogram check.", "author": "pshapiro4broad", "createdAt": "2020-03-30T19:44:44Z", "path": "src/main/java/picard/analysis/CompareMetrics.java", "diffHunk": "@@ -50,35 +70,244 @@\n public class CompareMetrics extends CommandLineProgram {\n     static final String USAGE_SUMMARY = \"Compare two metrics files.\";\n     static final String USAGE_DETAIL = \"This tool compares the metrics and histograms generated from metric tools to determine \" +\n-            \"if the generated results are identical.  This tool is useful to test and compare outputs when code changes are implemented. It is not meant for use by end-users of this toolkit.<br /><br />  \" +\n-            \"The tool's output simply indicates whether two metrics files are equal or not equal. <br /> \"  +\n+            \"if the generated results are identical.  Note that if there are differences in metric values, this tool describes those differences \" +\n+            \"as the change of the first input metric relative to the second. \" +\n+            \"<br /><br />  \" +\n             \"<h4>Usage example:</h4>\" +\n             \"<pre>\" +\n             \"java -jar picard.jar CompareMetrics \\\\<br />\" +\n-            \"      metricfile1.txt \\\\<br />\" +\n-            \"      metricfile2.txt\" +\n+            \"      INPUT=metricfile1.txt \\\\<br />\" +\n+            \"      INPUT=metricfile2.txt \\\\<br />\" +\n+            \"      METRICS_TO_IGNORE=INSERT_LENGTH \\\\<br />\" +\n+            \"      METRIC_ALLOWABLE_RELATIVE_CHANGE=HET_HOM_RATIO:0.0005 \\\\<br />\" +\n+            \"      IGNORE_HISTOGRAM_DIFFERENCES=false\" +\n             \"</pre>\" +\n             \"<hr />\";\n \n-    @PositionalArguments(minElements = 2, maxElements = 2)\n-    public List<File> metricsFiles;\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"Metric files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME,\n+            doc = \"Output file to write comparison results to.\", optional = true)\n+    public File OUTPUT;\n+\n+    @Argument(shortName = \"MI\",\n+            doc = \"Metrics to ignore. Any metrics specified here will be excluded from comparison by the tool.\",\n+            optional = true)\n+    public List<String> METRICS_TO_IGNORE;\n+\n+    @Argument(shortName = \"MARC\",\n+            doc = \"Metric Allowable Relative Change. A colon separate pair of metric name and an absolute relative change.  For any metric specified here, \" +\n+                    \" when the values are compared between the two files, the program will allow that much relative change between the \" +\n+                    \" two values.\",\n+            optional = true)\n+    public List<String> METRIC_ALLOWABLE_RELATIVE_CHANGE;\n+\n+    @Argument(shortName = \"IHD\",\n+            doc = \"Ignore any differences between the two metric file's histograms (useful if using the 'METRIC_ALLOWABLE_RELATIVE_CHANGE')\",\n+            optional = true)\n+    public boolean IGNORE_HISTOGRAM_DIFFERENCES = false;\n+\n+    private final List<String> differences = new ArrayList<>();\n \n     private static final Log log = Log.getInstance(CompareMetrics.class);\n \n+    protected static Map<String, Double> MetricToAllowableRelativeChange;\n+\n+    private static DecimalFormat RELATIVE_CHANGE_DECIMAL_FORMAT = new DecimalFormat(\"#0.0000000\");\n+\n     @Override\n     protected int doWork() {\n-        IOUtil.assertFilesAreReadable(metricsFiles);\n+        IOUtil.assertFilesAreReadable(INPUT);\n         final MetricsFile<?, ?> metricsA = new MetricsFile();\n         final MetricsFile<?, ?> metricsB = new MetricsFile();\n+        int retVal = 1;\n         try {\n-            metricsA.read(new FileReader(metricsFiles.get(0)));\n-            metricsB.read(new FileReader(metricsFiles.get(1)));\n-            final boolean areEqual = metricsA.areMetricsEqual(metricsB) && metricsA.areHistogramsEqual(metricsB);\n-            final String status = areEqual ? \"EQUAL\" : \"NOT EQUAL\";\n-            log.info(\"Files \" + metricsFiles.get(0) + \" and \" + metricsFiles.get(1) + \"are \" + status);\n+            metricsA.read(new FileReader(INPUT.get(0)));\n+            metricsB.read(new FileReader(INPUT.get(1)));\n+            retVal = compareMetricsFiles(INPUT.get(0), INPUT.get(1));\n+            final String status = retVal == 0 ? \"EQUAL\" : \"NOT EQUAL\";\n+            log.info(\"Files \" + INPUT.get(0) + \" and \" + INPUT.get(1) + \" are \" + status);\n         } catch (final Exception e) {\n             throw new PicardException(e.getMessage());\n         }\n-        return 0;\n+        return retVal;\n     }\n+\n+    @Override\n+    protected String[] customCommandLineValidation() {\n+        final List<String> errs = new ArrayList<>();\n+\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        MetricToAllowableRelativeChange = new HashMap<>();\n+        if (METRIC_ALLOWABLE_RELATIVE_CHANGE != null) {\n+            for (String diffs : METRIC_ALLOWABLE_RELATIVE_CHANGE) {\n+                String[] pair = diffs.split(\":\");\n+                if (pair.length == 2) {\n+                    String name = pair[0];\n+                    try {\n+                        double value = Double.parseDouble(pair[1]);\n+                        if (value > 0) {\n+                            MetricToAllowableRelativeChange.put(name, value);\n+                        } else {\n+                            errs.add(\"Value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE' must be > 0.0\");\n+                        }\n+                    } catch (NumberFormatException ne) {\n+                        errs.add(\"Invalid value for numeric component of Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                    }\n+                } else {\n+                    errs.add(\"Invalid value for Argument 'METRIC_ALLOWABLE_RELATIVE_CHANGE'\");\n+                }\n+            }\n+        }\n+\n+        if (errs.isEmpty()) {\n+            return null;\n+        } else {\n+            return errs.toArray(new String[0]);\n+        }\n+    }\n+\n+    private int compareMetricsFiles(final File metricFile1, final File metricFile2) throws IOException, IllegalAccessException {\n+        final MetricsFile<?, ?> mf1 = new MetricsFile<>();\n+        final MetricsFile<?, ?> mf2 = new MetricsFile<>();\n+        mf1.read(new FileReader(metricFile1));\n+        mf2.read(new FileReader(metricFile2));\n+        if (mf1.areMetricsEqual(mf2)) {\n+            return 0;\n+        } else if (!mf1.getMetrics().get(0).getClass().equals(mf2.getMetrics().get(0).getClass())) {\n+            throw new PicardException(\"Metrics are of differing class between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+        } else if (!mf1.getMetricsColumnLabels().equals(mf2.getMetricsColumnLabels())) {\n+            log.error(\"Metric columns differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        } else if (mf1.getMetrics().size() != mf2.getMetrics().size()) {\n+            log.error(\"Number of metric rows differ between \" + metricFile1.getAbsolutePath() + \" and \" + metricFile2.getAbsolutePath());\n+            return 1;\n+        }\n+\n+        validateMetricNames(mf1, metricFile1, METRICS_TO_IGNORE);\n+        validateMetricNames(mf1, metricFile1, MetricToAllowableRelativeChange.keySet());\n+\n+        Set<String> metricsToIgnore = new HashSet<>(METRICS_TO_IGNORE);\n+\n+        final Class<? extends MetricBase> metricClass = mf1.getMetrics().get(0).getClass();\n+\n+        int retVal = 0;\n+        int rowNumber = -1;\n+        final Field[] fields = metricClass.getFields();\n+        Iterator<?> mf1Iterator = mf1.getMetrics().iterator();\n+        Iterator<?> mf2Iterator = mf2.getMetrics().iterator();\n+        while (mf1Iterator.hasNext() && mf2Iterator.hasNext()) {\n+            rowNumber++;\n+            MetricBase metric1 = (MetricBase) mf1Iterator.next();\n+            MetricBase metric2 = (MetricBase) mf2Iterator.next();\n+            for (Field field : fields) {\n+                if (!metricsToIgnore.contains(field.getName())) {\n+                    final Object value1 = field.get(metric1);\n+                    final Object value2 = field.get(metric2);\n+                    SimpleResult result = compareMetricValues(value1, value2, field.getName());\n+                    if (!result.equal) {\n+                        retVal = 1;\n+                        final String diffString = \"Row: \" + rowNumber + \" Metric: \" + field.getName() +\n+                                \" values differ. Value1: \" + value1 + \" Value2: \" + value2 + \" \" + result.description;\n+                        differences.add(diffString);\n+                        log.error(diffString);", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzcyOQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400487729", "bodyText": "that's true.", "author": "gbggrant", "createdAt": "2020-03-30T20:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ0OTQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MDg4OQ==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400450889", "bodyText": "If you did make MetricToAllowableRelativeChange static for testing, you should be able to do this instead\n        compareMetrics.METRIC_ALLOWABLE_RELATIVE_CHANGE = Collections.singletonList(\"M:\" + marcValue);\n        compareMetrics.customCommandLineValidation();", "author": "pshapiro4broad", "createdAt": "2020-03-30T19:47:26Z", "path": "src/test/java/picard/analysis/CompareMetricsTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package picard.analysis;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+\n+public class CompareMetricsTest {\n+    private static final File TEST_DATA_DIR = new File(\"testdata/picard/analysis/metrics\");\n+\n+    @DataProvider(name = \"testCompareMetricsDataProvider\")\n+    public Object[][] testCompareMetricsDataProvider() {\n+        return new Object[][]{\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", null, null, null, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", \"GENOME_TERRITORY\", Collections.singletonList(\"SD_COVERAGE:0.00002\"), true, 0 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", \"GENOME_TERRITORY\", Collections.singletonList(\"SD_COVERAGE:0.00002\"), false, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", \"GENOME_TERRITORY\", Collections.singletonList(\"SD_COVERAGE:0.00002\"), null, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", \"GENOME_TERRITORY\", Collections.singletonList(\"SD_COVERAGE:0.00001\"), null, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", null, asList(\"GENOME_TERRITORY:0.0001\", \"SD_COVERAGE:0.00002\"), true, 0 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", null, asList(\"GENOME_TERRITORY:0.0001\", \"SD_COVERAGE:0.00002\"), false, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", null, asList(\"GENOME_TERRITORY:0.0001\", \"SD_COVERAGE:0.00002\"), null, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test2.wgs_metrics\", null, asList(\"GENOME_TERRITORY:0.0001\", \"SD_COVERAGE:0.00001\"), null, 1 },\n+                { \"wgs_test1.wgs_metrics\", \"wgs_test1.wgs_metrics\", null, null, null, 0 },\n+                { \"wgs_test1.raw_wgs_metrics\", \"wgs_test2.raw_wgs_metrics\", null, null, null, 1 },\n+                { \"wgs_test1.2rows.raw_wgs_metrics\", \"wgs_test1.2rows.raw_wgs_metrics\", null, null, null, 0 },\n+                { \"wgs_test1.2rows.raw_wgs_metrics\", \"wgs_test2.2rows.raw_wgs_metrics\", null, null, null, 1 },\n+                { \"wgs_test1.raw_wgs_metrics\", \"wgs_test2.2rows.raw_wgs_metrics\", null, null, null, 1 },\n+                { \"wgs_test1.fingerprinting_summary_metrics\", \"wgs_test2.fingerprinting_summary_metrics\", null, null, null, 1 },\n+                { \"test1.arrays_variant_calling_detail_metrics\", \"test2.arrays_variant_calling_detail_metrics\", null, null, null, 1 },\n+                { \"test1.arrays_variant_calling_detail_metrics\", \"test2.arrays_variant_calling_detail_metrics\", \"AUTOCALL_DATE\", null, null, 0 },\n+                { \"test1.arrays_variant_calling_summary_metrics\", \"test2.arrays_variant_calling_summary_metrics\", null, null, null, 0 },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testCompareMetricsDataProvider\")\n+    public void testCompareMetrics(final String file1, final String file2,\n+                                   final String metricsToIgnore, final List<String> metricsToAllowableRelativeChange,\n+                                   final Boolean ignoreHistogramDifferences, final int expectedReturnValue) {\n+        final File input1 = new File(TEST_DATA_DIR, file1);\n+        final File input2 = new File(TEST_DATA_DIR, file2);\n+        final CompareMetrics compareMetrics = new CompareMetrics();\n+        compareMetrics.INPUT = asList(input1, input2);\n+        if (metricsToIgnore != null) {\n+            compareMetrics.METRICS_TO_IGNORE = Collections.singletonList(metricsToIgnore);\n+        }\n+        if (metricsToAllowableRelativeChange != null) {\n+            compareMetrics.METRIC_ALLOWABLE_RELATIVE_CHANGE = metricsToAllowableRelativeChange;\n+        }\n+        if (ignoreHistogramDifferences != null) {\n+            compareMetrics.IGNORE_HISTOGRAM_DIFFERENCES = ignoreHistogramDifferences;\n+        }\n+        Assert.assertEquals(compareMetrics.instanceMain(new String[0]), expectedReturnValue);\n+    }\n+\n+    @Test(expectedExceptions = PicardException.class)\n+    public void testFailCompareMetricsOnDifferentClasses() {\n+        final File input1 = new File(TEST_DATA_DIR, \"wgs_test1.wgs_metrics\");\n+        final File input2 = new File(TEST_DATA_DIR, \"wgs_test1.raw_wgs_metrics\");\n+        final CompareMetrics compareMetrics = new CompareMetrics();\n+        compareMetrics.INPUT = asList(input1, input2);\n+        Assert.assertEquals(compareMetrics.instanceMain(new String[0]), 1);\n+    }\n+\n+    @Test(expectedExceptions = PicardException.class)\n+    public void testFailCompareMetricsInvalidMetricToIgnore() {\n+        final File input1 = new File(TEST_DATA_DIR, \"test1.arrays_variant_calling_detail_metrics\");\n+        final File input2 = new File(TEST_DATA_DIR, \"test2.arrays_variant_calling_detail_metrics\");\n+        final CompareMetrics compareMetrics = new CompareMetrics();\n+        compareMetrics.INPUT = asList(input1, input2);\n+        compareMetrics.METRICS_TO_IGNORE = Collections.singletonList(\"NONEXISTENT_METRIC\");\n+        Assert.assertEquals(compareMetrics.instanceMain(new String[0]), 1);\n+    }\n+\n+    @Test(expectedExceptions = PicardException.class)\n+    public void testFailCompareMetricsInvalidMetricToAllowableRelativeChange() {\n+        final File input1 = new File(TEST_DATA_DIR, \"test1.arrays_variant_calling_detail_metrics\");\n+        final File input2 = new File(TEST_DATA_DIR, \"test2.arrays_variant_calling_detail_metrics\");\n+        final CompareMetrics compareMetrics = new CompareMetrics();\n+        compareMetrics.INPUT = asList(input1, input2);\n+        compareMetrics.METRIC_ALLOWABLE_RELATIVE_CHANGE = Collections.singletonList(\"NONEXISTENT_METRIC:0.3\");\n+        Assert.assertEquals(compareMetrics.instanceMain(new String[0]), 1);\n+    }\n+\n+    @DataProvider(name = \"testCompareMetricValuesDataProvider\")\n+    public Object[][] testCompareMetricValuesDataProvider() {\n+        return new Object[][]{\n+                { 1.0, 1.0, true, \"\", null },\n+                { 1.1, 1.0, false, \"Changed by 0.1000000 which is outside of the allowable tolerance of 0.0500000\", 0.05 },\n+                { 1.1, 1.0, false, \"Changed by 0.1000000 which is outside of the allowable tolerance of 0.1000000\", 0.1 },\n+                { 1.1, 1.0, true, \"Changed by 0.1000000 which is within the allowable tolerance of 0.1001000\", 0.1001 },\n+                { 1.1, 1.0, true, \"Changed by 0.1000000 which is within the allowable tolerance of 0.2000000\", 0.2 },\n+                { 1.0f, 1.0f, true, \"\", null },\n+                { 1.1f, 1.0f, false, \"Changed by 0.1000000 which is outside of the allowable tolerance of 0.0500000\", 0.05 },\n+                { 1.1f, 1.0f, false, \"Changed by 0.1000000 which is outside of the allowable tolerance of 0.1000000\", 0.1 },\n+                { 1.1f, 1.0f, true, \"Changed by 0.1000000 which is within the allowable tolerance of 0.1001000\", 0.1001 },\n+                { 1.1f, 1.0f, true, \"Changed by 0.1000000 which is within the allowable tolerance of 0.2000000\", 0.2 },\n+                { 1, 1, true, \"\", null },\n+                { 1f, 1f, true, \"\", null }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testCompareMetricValuesDataProvider\")\n+    public void testCompareMetrics(final Object value1, final Object value2,\n+                                   final boolean expectedEqual, final String expectedDescription, final Double marcValue) {\n+        final CompareMetrics compareMetrics = new CompareMetrics();\n+        CompareMetrics.MetricToAllowableRelativeChange = new HashMap<>();", "originalCommit": "85f8aa4a302380abd9cd7ee2778951ce904b59f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwMzk3Nw==", "url": "https://github.com/broadinstitute/picard/pull/1491#discussion_r400503977", "bodyText": "yup.  Yay - more test coverage.", "author": "gbggrant", "createdAt": "2020-03-30T21:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ1MDg4OQ=="}], "type": "inlineReview"}, {"oid": "214260ff762b83f3f0056402dd37581550cd2770", "url": "https://github.com/broadinstitute/picard/commit/214260ff762b83f3f0056402dd37581550cd2770", "message": "Improvements to CompareMetrics\n- Now gives fuller description of differences in metrics.\n- Added feature to ignore differences in certain metrics.\n- Added 'fuzzy' metric comparison.\n- Added ability to output a differences file.", "committedDate": "2020-03-31T22:11:48Z", "type": "forcePushed"}, {"oid": "405018e688b44ba1f017dc43c4cf5c2d44e1c928", "url": "https://github.com/broadinstitute/picard/commit/405018e688b44ba1f017dc43c4cf5c2d44e1c928", "message": "Improvements to CompareMetrics\n- Now gives fuller description of differences in metrics.\n- Added feature to ignore differences in certain metrics.\n- Added 'fuzzy' metric comparison.\n- Added ability to output a differences file.", "committedDate": "2020-04-03T12:26:58Z", "type": "commit"}, {"oid": "405018e688b44ba1f017dc43c4cf5c2d44e1c928", "url": "https://github.com/broadinstitute/picard/commit/405018e688b44ba1f017dc43c4cf5c2d44e1c928", "message": "Improvements to CompareMetrics\n- Now gives fuller description of differences in metrics.\n- Added feature to ignore differences in certain metrics.\n- Added 'fuzzy' metric comparison.\n- Added ability to output a differences file.", "committedDate": "2020-04-03T12:26:58Z", "type": "forcePushed"}]}