{"pr_number": 1458, "pr_title": "Fixed a bug where the merging of fingerprints changes", "pr_createdAt": "2020-01-28T13:51:04Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1458", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r371985308", "bodyText": "Is there a reason why you don't use System.arrayCopy() here too? Or call setLogLikelihoods()? it would be nice to keep the field final if possible.", "author": "pshapiro4broad", "createdAt": "2020-01-28T18:40:14Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesUsingLogLikelihoods.java", "diffHunk": "@@ -26,33 +26,46 @@\n \n import picard.util.MathUtil;\n \n-import static java.lang.Math.log10;\n-\n /**\n  * Represents the probability of the underlying haplotype using log likelihoods as the basic datum for each of the SNPs. By convention the\n  * alleles stored for each SNP are in phase.\n  *\n  * @author Tim Fennell\n  * @author Yossi Farjoun\n  */\n-abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities {\n+abstract class HaplotypeProbabilitiesUsingLogLikelihoods extends HaplotypeProbabilities implements Cloneable {\n \n     // some derived classes might need to incorporate accumulated data before logLikelihood is usable.\n     // use the getter to allow these classes to calculate the likelihood from the data.\n-    private final double[] loglikelihoods = new double[Genotype.values().length];\n+    // not final so that clone works\n+    private double[] loglikelihoods = new double[Genotype.values().length];\n+\n     private boolean likelihoodsNeedUpdating = true;\n \n     // stored in order to reduce computation we store these partial results.\n     // they need to be recalculated if loglikelihoodNeedsUpdating\n+\n     private double[] likelihoods = new double[Genotype.values().length];\n     private double[] posteriorProbabilities = new double[Genotype.values().length];\n-    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n+    //normalized (likeihood * prior / normalization_factor)\n+    private double[] shiftedLogPosteriors = new double[Genotype.values().length];\n \n     public HaplotypeProbabilitiesUsingLogLikelihoods(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        final HaplotypeProbabilitiesUsingLogLikelihoods c = (HaplotypeProbabilitiesUsingLogLikelihoods)super.clone();\n+        c.likelihoods = this.likelihoods.clone();", "originalCommit": "685c7ced92998c718b381a551e6edf8bfe8eddd9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyNjM1OA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372026358", "bodyText": "super.clone does a shallow copy...in order to have these arrays be actually different, I need to clone them. I could make new arrays and arrayCopy, but I'm not sure why that is better. I don't think it's possible to keep the field final...not the clone, anyway...but I'm happy to learn something new.", "author": "yfarjoun", "createdAt": "2020-01-28T20:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyODAxMg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372028012", "bodyText": "It's actually, the other way around...I need to get rid of the other arrayCopy and convert that to a clone..but I'll write a test the proves it first.", "author": "yfarjoun", "createdAt": "2020-01-28T20:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk4NjMxOA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r371986318", "bodyText": "more whitespace, please\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    System.arraycopy(likelihoods,0,c.likelihoods,0,likelihoods.length);\n          \n          \n            \n                    System.arraycopy(likelihoods, 0, c.likelihoods, 0, likelihoods.length);", "author": "pshapiro4broad", "createdAt": "2020-01-28T18:42:15Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -28,10 +28,17 @@\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n-public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n+public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities implements Cloneable{\n     private final Snp snp;\n     private final double[] likelihoods;\n \n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        HaplotypeProbabilitiesFromGenotype c = (HaplotypeProbabilitiesFromGenotype) super.clone();\n+        System.arraycopy(likelihoods,0,c.likelihoods,0,likelihoods.length);", "originalCommit": "685c7ced92998c718b381a551e6edf8bfe8eddd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2efa86d81400e34535414c2cc3cebea167b08ae5", "url": "https://github.com/broadinstitute/picard/commit/2efa86d81400e34535414c2cc3cebea167b08ae5", "message": "- moved from clone to \"deepCopy\" using a copy constructor.\n- cleanup\n- test, test, test.", "committedDate": "2020-01-29T14:30:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODU4OQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372498589", "bodyText": "I don't think assert is what you want here, since they have no effect unless the code is run with the -ea flag. E.g. if you had a unit test that tried to trigger this assert, it would fail.", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:41:50Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +188,19 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        assert (genotypeFrequencies.length == nGeno);", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODc5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372498795", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Genotype g: Genotype.values()){\n          \n          \n            \n                    for (Genotype g : Genotype.values()) {", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:42:11Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +188,19 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        assert (genotypeFrequencies.length == nGeno);\n+        assert (likelihoods.length == nGeno);\n+\n \n         double result = 0;\n-        for (int i = 0; i < likelihoods.length; ++i) {\n-            result += likelihoods[i] * genotypeFrequencies[i];\n+        for (Genotype g: Genotype.values()){", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDE5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372500195", "bodyText": "Is this done because performance was measured and you found that using values().length each time was too slow? It seems like in most cases this wouldn't have a measurable benefit.\nIf you keep it, it should be all caps as it's a static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final int nGeno = Genotype.values().length;\n          \n          \n            \n                static final int NUM_GENOTYPE = Genotype.values().length;", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:44:34Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -272,4 +274,5 @@ public double getLodMostProbableGenotype() {\n             this.v = v;\n         }\n     }\n+    static final int nGeno = Genotype.values().length;", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyNzgwNg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372927806", "bodyText": "not performance, just readability and writability", "author": "yfarjoun", "createdAt": "2020-01-30T12:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMDgwNQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372500805", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other){\n          \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other) {", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:45:35Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -53,10 +59,18 @@ public HaplotypeProbabilitiesFromContaminatorSequence(final HaplotypeBlock haplo\n         this.contamination = contamination;\n     }\n \n-    /**\n-     * Adds a base observation with the observed quality to the evidence for this haplotype\n-     * based on the fact that the SNP is part of the haplotype.\n-     */\n+    public HaplotypeProbabilitiesFromContaminatorSequence(HaplotypeProbabilitiesFromContaminatorSequence other){", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTE2OA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372501168", "bodyText": "I would use covariant return types here so you can write\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HaplotypeProbabilities deepCopy() {\n          \n          \n            \n                public HaplotypeProbabilitiesFromContaminatorSequence deepCopy() {", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:46:11Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyODc2NA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372928764", "bodyText": "I didn't know you can do that when @Overrideing...thanks!", "author": "yfarjoun", "createdAt": "2020-01-30T12:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTUwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372501509", "bodyText": "This can also use covariant return types", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:46:47Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -90,16 +104,21 @@ public void addToProbs(final Snp snp, final byte base, final byte qual) {\n \n     //a function needed to update the logLikelihoods from the likelihoodMap.\n     private void updateLikelihoods() {\n-        final double[] ll = new double[Genotype.values().length];\n+        final double[] ll = new double[nGeno];\n         for (final Genotype contGeno : Genotype.values()) {\n             // p(a | g_c) = \\sum_g_m { P(g_m) \\prod_i P(a_i| g_m, g_c)}\n-            ll[contGeno.v] = log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n+            ll[contGeno.v] = Math.log10(MathUtil.sum(MathUtil.multiply(this.getPriorProbablities(), likelihoodMap[contGeno.v])));\n         }\n         setLogLikelihoods(ll);\n     }\n \n     @Override\n-    public void merge(final HaplotypeProbabilities other) {\n+    public HaplotypeProbabilities deepCopy() {\n+        return new HaplotypeProbabilitiesFromContaminatorSequence(this);\n+    }\n+\n+    @Override\n+    public HaplotypeProbabilities merge(final HaplotypeProbabilities other) {", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzMDYzOQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372930639", "bodyText": "\ud83d\udc4d", "author": "yfarjoun", "createdAt": "2020-01-30T12:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzExMQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503111", "bodyText": "why not\nwhy not\n\n    this(snp, getHaplotype(), likelihoods[0], likelihoods[1], likelihoods[2]);", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:49:36Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -24,13 +24,26 @@\n \n package picard.fingerprint;\n \n+import java.util.Arrays;\n+\n /**\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n     private final Snp snp;\n-    private final double[] likelihoods;\n+    private double[] likelihoods;\n+\n+    @Override\n+    public HaplotypeProbabilities deepCopy()  {\n+        return new HaplotypeProbabilitiesFromGenotype(this);\n+    }\n+\n+    public HaplotypeProbabilitiesFromGenotype(final HaplotypeProbabilitiesFromGenotype other){\n+        super(other.getHaplotype());", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzMwMg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503302", "bodyText": "It looks like this can be final", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:49:56Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotype.java", "diffHunk": "@@ -24,13 +24,26 @@\n \n package picard.fingerprint;\n \n+import java.util.Arrays;\n+\n /**\n  * Represents a set of HaplotypeProbabilities that were derived from a single SNP\n  * genotype at a point in time.\n  */\n public class HaplotypeProbabilitiesFromGenotype extends HaplotypeProbabilities {\n     private final Snp snp;\n-    private final double[] likelihoods;\n+    private double[] likelihoods;", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzgyMg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503822", "bodyText": "why not\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < alleles.size(); i++) {\n          \n          \n            \n                    for (allele : alleles) {", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:50:52Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "diffHunk": "@@ -54,11 +58,11 @@ public void addToLogLikelihoods(final Snp snp, final List<Allele> alleles, final\n         assertSnpPartOfHaplotype(snp);\n \n         // only allow biallelic snps\n-        assert (logGenotypeLikelihoods.length == Genotype.values().length);\n+        assert (logGenotypeLikelihoods.length == nGeno);\n         assert (alleles.size() == 2);\n \n         //make sure that alleles are comparable to SNPs\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < alleles.size(); i++) {", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwMzk5OQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372503999", "bodyText": "As I said above I don't think this has any effect in practice.", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:51:12Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromGenotypeLikelihoods.java", "diffHunk": "@@ -54,11 +58,11 @@ public void addToLogLikelihoods(final Snp snp, final List<Allele> alleles, final\n         assertSnpPartOfHaplotype(snp);\n \n         // only allow biallelic snps\n-        assert (logGenotypeLikelihoods.length == Genotype.values().length);\n+        assert (logGenotypeLikelihoods.length == nGeno);\n         assert (alleles.size() == 2);\n \n         //make sure that alleles are comparable to SNPs\n-        for (int i = 0; i < 2; i++) {\n+        for (int i = 0; i < alleles.size(); i++) {\n             assert (alleles.get(i).getBases().length == 1);", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNDM2OA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372504368", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this(other.getHaplotype() , other.obsAllele1,other.obsAllele2,other.obsAlleleOther);\n          \n          \n            \n                    this(other.getHaplotype(), other.obsAllele1, other.obsAllele2, other.obsAlleleOther);", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:51:49Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromSequence.java", "diffHunk": "@@ -36,10 +35,21 @@\n public class HaplotypeProbabilitiesFromSequence extends HaplotypeProbabilitiesUsingLogLikelihoods {\n     protected int obsAllele1, obsAllele2, obsAlleleOther;\n \n+    HaplotypeProbabilitiesFromSequence(final HaplotypeBlock haplotypeBlock, int ob1, int ob2, int obOther) {\n+        this(haplotypeBlock);\n+        obsAllele1 = ob1;\n+        obsAllele2 = ob2;\n+        obsAlleleOther = obOther;\n+    }\n+\n     public HaplotypeProbabilitiesFromSequence(final HaplotypeBlock haplotypeBlock) {\n         super(haplotypeBlock);\n     }\n \n+    public HaplotypeProbabilitiesFromSequence(final HaplotypeProbabilitiesFromSequence other) {\n+        this(other.getHaplotype() , other.obsAllele1,other.obsAllele2,other.obsAlleleOther);", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjQwMg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372506402", "bodyText": "This seems dangerous to me. For one, it's not thread safe. It also introduces state which is never cleared, e.g. a memory leak, if the code is ever used in a non-CLP situation.", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:55:18Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilityOfNormalGivenTumor.java", "diffHunk": "@@ -51,12 +58,13 @@ public TransitionMatrix(double pLoH) {\n                     {0, 0, 1}}; //normal is hom_var => tumor must be the same\n         }\n \n-        public double[][] getTransitionMatrix() {\n+        double[][] getTransitionMatrix() {\n             return transitionMatrix;\n         }\n     }\n \n     private final HaplotypeProbabilities hpOfTumor;\n+    @SuppressWarnings(\"MismatchedQueryAndUpdateOfCollection\")\n     static private Map<Double, TransitionMatrix> transitionMatrixMap = new CollectionUtil.DefaultingMap<>(TransitionMatrix::new, true);", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372507302", "bodyText": "What is this testing? It doesn't cover any code that we've written. It can't assert anything about the behavior of a system picard will be run on, only the behavior of the system where the test is run.", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:56:47Z", "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzI5Ng==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937296", "bodyText": "This was at the bottom of the Fingerprinting test for some reason...so I moved it out....I think that at some point in the past there were questions about the ability to write to /dev/null and so a test was added (possibly by me) in the wrong place...", "author": "yfarjoun", "createdAt": "2020-01-30T13:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzY0NQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937645", "bodyText": "Ah, I see the problem..I forgot to remove it from where I found it..so it looks like I just added it out of the blue...", "author": "yfarjoun", "createdAt": "2020-01-30T13:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNzMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwODEwNA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372508104", "bodyText": "If you really want to do this, it would be simpler to write\nFiles.write(Paths.get(\"/dev/null\"), \"Just a test\".getBytes());", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:58:09Z", "path": "src/test/java/picard/util/MiscTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package picard.util;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+\n+public class MiscTest {\n+\n+    @Test\n+    public void canWriteToDevNull() throws IOException {\n+        File f = new File(\"/dev/null\");", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNzcxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372937715", "bodyText": "not new code.", "author": "yfarjoun", "createdAt": "2020-01-30T13:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwODEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372509153", "bodyText": "I think a more idiomatic way to write this is\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n          \n          \n            \n                    final Path na12891_r1 = Paths.get(TEST_DATA_DIR).resolve(\"NA12891.over.fingerprints.r1.sam\");", "author": "pshapiro4broad", "createdAt": "2020-01-29T16:59:59Z", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzOTA0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372939047", "bodyText": "since TEST_DATA_DIR is a File, it's actually more lengthy as I need to stick a getAbsoluteFileName() in there as well....I'll do it if you prefer though.", "author": "yfarjoun", "createdAt": "2020-01-30T13:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcwNzM5NA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374707394", "bodyText": "Oh, I thought it was String. If it's File then you can write:\n        final Path na12891_r1 = TEST_DATA_DIR.toPath().resolve(\"NA12891.over.fingerprints.r1.sam\");\n\nI don't know why you'd need to use getAbsoluteFileName() in this code.", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwOTE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUxMDAyMw==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r372510023", "bodyText": "In general, if you have an assert in a for, you need to assert that the thing you're looping over has at least one item, otherwise the test will pass when the for never executes.", "author": "pshapiro4broad", "createdAt": "2020-01-29T17:01:32Z", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +229,145 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+\n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{new HaplotypeProbabilitiesFromSequence(hb, 5, 0, 1), new HaplotypeProbabilitiesFromSequence(hb, 3, 2, 1)},\n+                new Object[]{new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 0, 1), new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1, 5, 1, 0)},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n+        final Path na12891_r2 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r2.sam\").toPath();\n+        final Path na12892_r1 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r1.sam\").toPath();\n+        final Path na12892_r2 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r2.sam\").toPath();\n+\n+        final List<Path> listOfFiles = Arrays.asList(na12891_r1, na12891_r2, na12892_r1, na12892_r2);\n+\n+        final FingerprintChecker checker = new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = checker.fingerprintFiles(listOfFiles, 1, 0, TimeUnit.DAYS);\n+\n+        final Fingerprint combinedFp = new Fingerprint(\"test\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp::merge);\n+\n+        final Fingerprint combinedFp2 = new Fingerprint(\"test2\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp2::merge);\n+\n+        for (final HaplotypeBlock block : combinedFp.keySet()) {", "originalCommit": "2efa86d81400e34535414c2cc3cebea167b08ae5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcwOTM0Ng==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374709346", "bodyText": "Using Objects.equals(haplotypeBlock, that.haplotypeBlock) would help here.", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:41:29Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374712823", "bodyText": "This seems like a bug, that equals() uses getLikelihoods() but hashCode() does not.", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:46:54Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final HaplotypeProbabilities that = (HaplotypeProbabilities) o;\n+\n+        if (haplotypeBlock != null ? !haplotypeBlock.equals(that.haplotypeBlock) : that.haplotypeBlock != null) {\n+            return false;\n+        }\n+        return Arrays.equals(getLikelihoods(), that.getLikelihoods());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return haplotypeBlock != null ? haplotypeBlock.hashCode() : 0;", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2NzY5Mg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374767692", "bodyText": "yeah...this is on purpose since likelihood is mutable...I figured it's better to not use it in the hash, but I need it in the equals...", "author": "yfarjoun", "createdAt": "2020-02-04T16:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyODczOQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375528739", "bodyText": "OK, that's fine, it's true that you can hash two non-equal objects to the same value.", "author": "pshapiro4broad", "createdAt": "2020-02-05T21:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjg5Mg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374712892", "bodyText": "Is it required that HaplotypeProbabilities is hash-able and comparable? This means that all subclasses must properly implement these too.", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:47:02Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -63,7 +64,29 @@ public HaplotypeBlock getHaplotype() {\n      * Returns the posterior probabilities using the population frequency as a prior.\n      */\n     public double[] getPosteriorProbabilities() {\n-        return pNormalizeVector(multiply(getLikelihoods(), getPriorProbablities()));\n+        return MathUtil.pNormalizeVector(MathUtil.multiply(getLikelihoods(), getPriorProbablities()));\n+    }\n+\n+    @Override\n+    public boolean equals(final Object o) {", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3MzI5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374773295", "bodyText": "hmmm.\nI use it for testing....I guess I could make a utility function that compares? would that be preferable since I only need it for testing?", "author": "yfarjoun", "createdAt": "2020-02-04T16:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMjg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMzUwOA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374713508", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES,\"provided genotype frequencies must be length 3\");\n          \n          \n            \n                    ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES, \"provided genotype frequencies must be length 3\");", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:47:55Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilities.java", "diffHunk": "@@ -190,17 +213,18 @@ void assertSnpPartOfHaplotype(final Snp snp) {\n \n     public double scaledEvidenceProbabilityUsingGenotypeFrequencies(final double[] genotypeFrequencies) {\n         final double[] likelihoods = getLikelihoods();\n-        assert (genotypeFrequencies.length == likelihoods.length);\n+        ValidationUtils.validateArg(genotypeFrequencies.length == NUM_GENOTYPES,\"provided genotype frequencies must be length 3\");", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcxMzcyOA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374713728", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ValidationUtils.validateArg(contamination <= 1.0, ()->\"contamination must be <=1, found \" + contamination);\n          \n          \n            \n                    ValidationUtils.validateArg(contamination <= 1.0, () -> \"contamination must be <=1, found \" + contamination);", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:48:16Z", "path": "src/main/java/picard/fingerprint/HaplotypeProbabilitiesFromContaminatorSequence.java", "diffHunk": "@@ -42,21 +41,31 @@\n \n     // for each model (contGenotype, mainGenotype) there's a likelihood of the data. These need to be collected separately\n     // and only collated once all the data is in.\n-    double[][] likelihoodMap = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n+    private final double[][] likelihoodMap = {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}};\n \n     public HaplotypeProbabilitiesFromContaminatorSequence(final HaplotypeBlock haplotypeBlock, final double contamination) {\n         super(haplotypeBlock);\n \n-        assert (contamination <= 1.0);\n-        assert (contamination >= 0.0);\n+        ValidationUtils.validateArg(contamination <= 1.0, ()->\"contamination must be <=1, found \" + contamination);", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374720769", "bodyText": "Does this annotation do anything? If it's a no-op it can be removed.", "author": "pshapiro4broad", "createdAt": "2020-02-04T14:59:12Z", "path": "src/test/java/picard/fingerprint/CrosscheckReadGroupFingerprintsTest.java", "diffHunk": "@@ -102,7 +102,8 @@ public void testCrossCheckRGs(final File file1, final File file2, final boolean\n         doTest(args, metrics, expectedRetVal, expectedNMetrics * expectedNMetrics , CrosscheckMetric.DataType.READGROUP, expectAllMatch);\n     }\n \n-    @DataProvider(name = \"bamFilesLBs\")\n+\n+    @DataProvider()", "originalCommit": "873979705895a8fabfbcd0c281add5e2b3224d6e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2OTgxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374769819", "bodyText": "without the \"name\" the default is the name of the function itself....so, yes it is providing data...", "author": "yfarjoun", "createdAt": "2020-02-04T16:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc3MDEwNw==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r374770107", "bodyText": "I guess I can remove the parens though", "author": "yfarjoun", "createdAt": "2020-02-04T16:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyMDc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUyOTc1OQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375529759", "bodyText": "I think this is cleaner given that it's only used by a test. Also, can you reformat this file in the IDE? It's missing a few whitespaces.", "author": "pshapiro4broad", "createdAt": "2020-02-05T21:54:22Z", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package picard.fingerprint;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs){", "originalCommit": "0985e669414fd759812284a7c6c0d76e834b29a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMDM4OQ==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375530389", "bodyText": "Given that this is only used as an argument to assertTrue() you could add another static method  assertHaplotypeProbabilitiesEqual() which calls this one.\nOr assertFPHaplotypeProbabilitiesEqual(fp1, fp2) since that's how it's used.", "author": "pshapiro4broad", "createdAt": "2020-02-05T21:55:43Z", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package picard.fingerprint;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs){", "originalCommit": "0985e669414fd759812284a7c6c0d76e834b29a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTg0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r375531842", "bodyText": "Does it make more sense to assert that its' the same as combinedFp2?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertNotEquals(combinedFp.keySet().size(), 0);\n          \n          \n            \n                    Assert.assertEquals(combinedFp.keySet().size(), combinedFp2.size());\n          \n      \n    \n    \n  \n\nIn either case if you had an assert that compared Fingerprints then you can assert this there instead and avoid the duplication for each of the test cases here.", "author": "pshapiro4broad", "createdAt": "2020-02-05T21:58:48Z", "path": "src/test/java/picard/fingerprint/FingerprintCheckerTest.java", "diffHunk": "@@ -223,6 +230,173 @@ public void testQueryable(final File vcf, boolean expectedQueryable) {\n         }\n     }\n \n+    @DataProvider()\n+    Object[][] mergeIsDafeProvider() {\n+        final HaplotypeProbabilitiesFromSequence hp1 = new HaplotypeProbabilitiesFromSequence(hb);\n+        final HaplotypeProbabilitiesFromSequence hp2 = new HaplotypeProbabilitiesFromSequence(hb);\n+\n+        addObservation(hp1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hp1, hb, 1, (byte) (hb.getFirstSnp().getAllele1() + 1));\n+        addObservation(hp2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hp2, hb, 2, hb.getFirstSnp().getAllele2());\n+\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs1 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+        final HaplotypeProbabilitiesFromContaminatorSequence hpcs2 = new HaplotypeProbabilitiesFromContaminatorSequence(hb, .1);\n+\n+        addObservation(hpcs1, hb, 5, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs1, hb, 1, (byte)(hb.getFirstSnp().getAllele1()+1));\n+        addObservation(hpcs2, hb, 3, hb.getFirstSnp().getAllele1());\n+        addObservation(hpcs2, hb, 1, hb.getFirstSnp().getAllele1());\n+\n+\n+        return new Object[][]{\n+                new Object[]{new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D)},\n+                new Object[]{\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 5D, 0D, 10D), .05),\n+                        new HaplotypeProbabilityOfNormalGivenTumor(\n+                                new HaplotypeProbabilitiesFromGenotype(snp, hb, 0D, 10D, 100D), 0.05)},\n+                new Object[]{hp1,hp2},\n+                new Object[]{hpcs1,hpcs2},\n+        };\n+    }\n+\n+    private static void addObservation(final HaplotypeProbabilitiesFromSequence haplotypeProb, final HaplotypeBlock haplotypeBlock, final int count, final byte allele) {\n+        for (int i = 0; i < count; i++) {\n+            haplotypeProb.addToProbs(haplotypeBlock.getFirstSnp(), allele, (byte) 30);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeHaplotypeProbabilitiesIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final HaplotypeProbabilities merged1 = hp1.deepCopy().merge(hp2);\n+        final HaplotypeProbabilities merged2 = hp1.deepCopy().merge(hp2);\n+\n+        Assert.assertEquals(merged1.getLikelihoods(),merged2.getLikelihoods());\n+    }\n+\n+\n+    @Test(dataProvider = \"mergeIsDafeProvider\")\n+    public void testMergeFingerprintIsSafe(final HaplotypeProbabilities hp1, final HaplotypeProbabilities hp2){\n+\n+        final Fingerprint fpA = new Fingerprint(\"test2\",null,\"none\");\n+        final Fingerprint fpB = new Fingerprint(\"test2\",null,\"none\");\n+\n+        final Fingerprint fp1 = new Fingerprint(\"test1\",null,\"none\");\n+        fp1.add(hp1);\n+\n+        final Fingerprint fp2 = new Fingerprint(\"test1\",null,\"none\");\n+        fp2.add(hp2);\n+\n+        fpA.merge(fp1);\n+        fpB.merge(fp1);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+\n+        fpA.merge(fp2);\n+        fpB.merge(fp2);\n+        fpB.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertNotEquals(fpA.get(hb), fpB.get(hb));\n+        }\n+\n+        fpA.merge(fp2);\n+\n+        Assert.assertNotEquals(fpA.keySet().size(), 0);\n+        for(HaplotypeBlock hb:fpA.keySet()){\n+            Assert.assertEquals(fpA.get(hb).getLikelihoods(),fpB.get(hb).getLikelihoods());\n+        }\n+    }\n+\n+    @Test\n+    public void testMergeIsSafeFromSequence() {\n+        final Path na12891_r1 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r1.sam\").toPath();\n+        final Path na12891_r2 = new File(TEST_DATA_DIR, \"NA12891.over.fingerprints.r2.sam\").toPath();\n+        final Path na12892_r1 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r1.sam\").toPath();\n+        final Path na12892_r2 = new File(TEST_DATA_DIR, \"NA12892.over.fingerprints.r2.sam\").toPath();\n+\n+        final List<Path> listOfFiles = Arrays.asList(na12891_r1, na12891_r2, na12892_r1, na12892_r2);\n+        final FingerprintChecker checker = new FingerprintChecker(SUBSETTED_HAPLOTYPE_DATABASE_FOR_TESTING);\n+        final Map<FingerprintIdDetails, Fingerprint> fingerprintIdDetailsFingerprintMap = checker.fingerprintFiles(listOfFiles, 1, 0, TimeUnit.DAYS);\n+\n+        final Fingerprint combinedFp = new Fingerprint(\"test\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp::merge);\n+\n+        final Fingerprint combinedFp2 = new Fingerprint(\"test2\", null, null);\n+        fingerprintIdDetailsFingerprintMap.values().forEach(combinedFp2::merge);\n+\n+        Assert.assertNotEquals(combinedFp.keySet().size(), 0);", "originalCommit": "0985e669414fd759812284a7c6c0d76e834b29a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1OTg3OA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r378959878", "bodyText": "Now that you've refactored into assertFingerPrintHPsAreEqual() this assert is no longer necessary, as the refactored code has the assert:\n        Assert.assertEquals(lhs.keySet().size(), rhs.keySet().size());\n\nOr, if you believe it is still necessary, you can move it into the refactored code, instead of repeating it before every call to assertFingerPrintHPsAreEqual().", "author": "pshapiro4broad", "createdAt": "2020-02-13T16:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTUzMTg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2MDUwNA==", "url": "https://github.com/broadinstitute/picard/pull/1458#discussion_r378960504", "bodyText": "code should be indented, also missing whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertTrue(lhs.containsKey(block),\"HaplotypeBlock was missing from lhs\" + block);\n          \n          \n            \n                        Assert.assertTrue(lhs.containsKey(block), \"HaplotypeBlock was missing from lhs\" + block);", "author": "pshapiro4broad", "createdAt": "2020-02-13T16:09:49Z", "path": "src/test/java/picard/fingerprint/FingerprintingTestUtils.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package picard.fingerprint;\n+\n+import org.testng.Assert;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class FingerprintingTestUtils {\n+\n+    public static boolean areHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs) {\n+        if (lhs == rhs) {\n+            return true;\n+        }\n+        if (lhs == null || rhs == null || lhs.getClass() != rhs.getClass()) {\n+            return false;\n+        }\n+\n+        if (!Objects.equals(lhs.getHaplotype(), rhs.getHaplotype())) {\n+            return false;\n+        }\n+\n+        return Arrays.equals(lhs.getLikelihoods(), rhs.getLikelihoods());\n+    }\n+\n+    public static void assertHaplotypeProbabilitiesEqual(final HaplotypeProbabilities lhs, final HaplotypeProbabilities rhs) {\n+        Assert.assertTrue(areHaplotypeProbabilitiesEqual(lhs, rhs),\n+                \"Expected HaplotypeProbabilities to be equal, but they differ: \" +\n+                lhs + \", \" + rhs);\n+    }\n+\n+    public static void assertFingerPrintHPsAreEqual(final Fingerprint lhs, final Fingerprint rhs) {\n+        Assert.assertEquals(lhs.keySet().size(), rhs.keySet().size());\n+\n+        for (final HaplotypeBlock block : lhs.keySet()) {\n+        Assert.assertTrue(lhs.containsKey(block),\"HaplotypeBlock was missing from lhs\" + block);", "originalCommit": "f5649583033c47cb4e92a469c5622f5ecd73e65b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bb31f7439ae4364ec43d288865f765ab4f377f53", "url": "https://github.com/broadinstitute/picard/commit/bb31f7439ae4364ec43d288865f765ab4f377f53", "message": "- Fixed a bug where the merging of fingerprints changes the original list of fingerprints leading to incorrect results in the self-lod case when using Crosscheck without SECOND_INPUT.\n\n- major cleanup and response to review comments.", "committedDate": "2020-02-19T16:26:19Z", "type": "commit"}, {"oid": "bb31f7439ae4364ec43d288865f765ab4f377f53", "url": "https://github.com/broadinstitute/picard/commit/bb31f7439ae4364ec43d288865f765ab4f377f53", "message": "- Fixed a bug where the merging of fingerprints changes the original list of fingerprints leading to incorrect results in the self-lod case when using Crosscheck without SECOND_INPUT.\n\n- major cleanup and response to review comments.", "committedDate": "2020-02-19T16:26:19Z", "type": "forcePushed"}]}