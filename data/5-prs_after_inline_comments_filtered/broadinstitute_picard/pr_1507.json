{"pr_number": 1507, "pr_title": "New CheckDuplicateMarking CLP", "pr_createdAt": "2020-05-11T23:13:55Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1507", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY2OTM2Nw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424669367", "bodyText": "can be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static private int NUM_WARNINGS = 100;\n          \n          \n            \n                private static final int NUM_WARNINGS = 100;", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:09:32Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjUxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672515", "bodyText": "Might be clearer to have this if block in a method, ensureSortedBam()", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:15:13Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MjcwMA==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424672700", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return numBadRecords > 0 ? 1:0;\n          \n          \n            \n                        return numBadRecords > 0 ? 1 : 0;", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:15:35Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzI0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673241", "bodyText": "Use error not info if there are bad records, and/or only log if there's an error.", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:16:29Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3MzQ1Nw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424673457", "bodyText": "can be static\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n          \n          \n            \n                private static final Log log = Log.getInstance(CheckDuplicateMarking.class);", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:16:53Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674015", "bodyText": "For methods that return boolean, is is usually preferred\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean duplicateMarkingGood(final SAMRecord rec) {\n          \n          \n            \n                private boolean isDuplicateMarkingValid(final SAMRecord rec) {", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:17:56Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEyNjE3Nw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441126177", "bodyText": "but this method is not only a predicate...it also changes a global tally....how about checkAndTallyRecordDuplicateMarking?", "author": "yfarjoun", "createdAt": "2020-06-16T20:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NDY5Mg==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445164692", "bodyText": "Yes, that sounds good to me.", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NDg5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424674893", "bodyText": "unnecessary return since this will fall through to the return at line 136", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:19:35Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY3NzAzMg==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424677032", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try (PrintWriter writer =  OUTPUT==null?\n          \n          \n            \n                    try (PrintWriter writer =  OUTPUT == null ?\n          \n          \n            \n                                    new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM) :", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:23:33Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDI1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680251", "bodyText": "No case in code to handle PRIMARY_ONLY, is that supported as it's the inverse of the rest?", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:29:30Z", "path": "src/main/java/picard/sam/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,165 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistenct of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    static private int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            //sort by queryname if not already\n+            final Iterable<SAMRecord> samRecordIterable;\n+            if (reader.getFileHeader().getSortOrder() != SAMFileHeader.SortOrder.queryname) {\n+                log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+                final Path[] tmpPaths = TMP_DIR.stream()\n+                        .map(File::toPath)\n+                        .toArray(Path[]::new);\n+\n+                final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+                final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                        new BAMRecordCodec(reader.getFileHeader()),\n+                        new SAMRecordQueryNameComparator(),\n+                        MAX_RECORDS_IN_RAM,\n+                        tmpPaths);\n+\n+                for (final SAMRecord rec : reader) {\n+                    alignmentSorter.add(rec);\n+                    sortProgress.record(rec);\n+                }\n+                samRecordIterable = alignmentSorter;\n+            } else {\n+                samRecordIterable = reader;\n+            }\n+\n+            checkDuplicateMarkingsInIterable(samRecordIterable);\n+            log.info(\"Found \" + numBadRecords + \" bad records.\");\n+            return numBadRecords > 0 ? 1:0;\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+    }\n+\n+    private boolean duplicateMarkingGood(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+            return true;\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            numBadRecords++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer =  OUTPUT==null?\n+                new PrintWriter(NullOutputStream.NULL_OUTPUT_STREAM):\n+                new PrintWriter(new FileWriter(OUTPUT))) {\n+\n+            for (final SAMRecord rec : iterable) {\n+                if (MODE != Mode.ALL && rec.isSecondaryOrSupplementary()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_MAPPED_ONLY && rec.getReadUnmappedFlag()) {\n+                    continue;\n+                }\n+\n+                if (MODE == Mode.PRIMARY_PROPER_PAIR_ONLY && !rec.getProperPairFlag()) {\n+                    continue;\n+                }\n+", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzMDQ1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441130453", "bodyText": "it's a bit confusing, but notice that the first if is if NOT EQUALS Mode.ALL", "author": "yfarjoun", "createdAt": "2020-06-16T20:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MDk5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424680991", "bodyText": "Reformat new code to follow conventions\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";\n          \n          \n            \n                private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:30:49Z", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.sam.CheckDuplicateMarking;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR=\"testdata/picard/sam/CheckDuplicateMarking\";", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r424681815", "bodyText": "Is there a reason to move the test but not the class? Normally the test for a class is in the same package as the class being tested.", "author": "pshapiro4broad", "createdAt": "2020-05-13T19:32:30Z", "path": "src/test/java/picard/sam/markduplicates/DuplicationMetricsTest.java", "diffHunk": "@@ -22,11 +22,12 @@\n  * THE SOFTWARE.\n  */\n \n-package picard.sam;\n+package picard.sam.markduplicates;\n \n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.sam.DuplicationMetrics;", "originalCommit": "90160ba81d12d2e288cb3315197973258b0a3a8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEzNDU4NQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r441134585", "bodyText": "oops", "author": "yfarjoun", "createdAt": "2020-06-16T20:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzOTY2Mw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445139663", "bodyText": "Does that mean you will move it back? It looks like this wasn't addressed.", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMDM2OA==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451110368", "bodyText": "yeah. not sure what happened there...sorry.", "author": "yfarjoun", "createdAt": "2020-07-07T20:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY4MTgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExOTc5OQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445119799", "bodyText": "toString() unnecessary\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = {\"I=\" + input.toString()};\n          \n          \n            \n                    final String[] args = {\"I=\" + input};", "author": "pshapiro4broad", "createdAt": "2020-06-24T19:24:57Z", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"pass_coordinate.sam\"), 0},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_mate_coordinate.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_1.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_queryname_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_supplementary_coordinate_2.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_queryname.sam\"), 1},\n+                {Paths.get(TEST_FILES_DIR, \"fail_secondary_coordinate.sam\"), 1},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"checkDuplicateMarkingDataProvider\")\n+    public void testCheckDuplicateMarking(final Path input, int expectedReturn) {\n+        final CheckDuplicateMarking cmdLine = new CheckDuplicateMarking();\n+        final String[] args = {\"I=\" + input.toString()};", "originalCommit": "01b6be605398de1ce68034bd312e068bfb9111e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEzODMwNw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445138307", "bodyText": "it's a minor thing but you can avoid the duplication here by changing this to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},\n          \n          \n            \n                            {\"pass_queryname.sam\", 0},\n          \n      \n    \n    \n  \n\nAnd use Paths.get(TEST_FILES_DIR, input) below.", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:00:40Z", "path": "src/test/java/picard/sam/markduplicates/CheckDuplicateMarkingTest.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package picard.sam.markduplicates;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class CheckDuplicateMarkingTest {\n+    private static final String TEST_FILES_DIR = \"testdata/picard/sam/CheckDuplicateMarking\";\n+\n+    @DataProvider(name = \"checkDuplicateMarkingDataProvider\")\n+    public Object[][] checkDuplicateMarkingDataProvider() {\n+        return new Object[][]{\n+                {Paths.get(TEST_FILES_DIR, \"pass_queryname.sam\"), 0},", "originalCommit": "01b6be605398de1ce68034bd312e068bfb9111e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445159472", "bodyText": "If this is done in more than one CLP, it would make sense to move it to CommandLineProgram.\n(Also, it is odd that File is deprecated in SortingCollection but not in SortingLongCollection)", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:42:03Z", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()", "originalCommit": "01b6be605398de1ce68034bd312e068bfb9111e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMTI0Mw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451111243", "bodyText": "it's done in only two other CLPs....somehow.", "author": "yfarjoun", "createdAt": "2020-07-07T20:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMzEzOA==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451113138", "bodyText": "hmmm. most CLPs use system property \"java.io.tmpdir\" but I chose to use input variable TMP_DIR...not sure which is right.", "author": "yfarjoun", "createdAt": "2020-07-07T20:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExMzY5OQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451113699", "bodyText": "oh...it's the same. I'll use the other.", "author": "yfarjoun", "createdAt": "2020-07-07T20:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1OTQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDY2Nw==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445160667", "bodyText": "Is it common to create a sorting collection and not call cleanup() on it?", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:44:16Z", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,", "originalCommit": "01b6be605398de1ce68034bd312e068bfb9111e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNTA4MA==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451115080", "bodyText": "done.", "author": "yfarjoun", "createdAt": "2020-07-07T20:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r445163360", "bodyText": "could put ternary op inside constructor\n        try (PrintWriter writer = new PrintWriter(OUTPUT != null ? new FileWriter(OUTPUT) : NullOutputStream.NULL_OUTPUT_STREAM)) {", "author": "pshapiro4broad", "createdAt": "2020-06-24T20:49:29Z", "path": "src/main/java/picard/sam/markduplicates/CheckDuplicateMarking.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package picard.sam.markduplicates;\n+\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.ProgressLogger;\n+import htsjdk.samtools.util.SortingCollection;\n+import org.apache.commons.io.output.NullOutputStream;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineParser;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import org.broadinstitute.barclay.help.DocumentedFeature;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+import picard.cmdline.programgroups.DiagnosticsAndQCProgramGroup;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Path;\n+\n+@CommandLineProgramProperties(\n+        summary = CheckDuplicateMarking.USAGE_DETAILS,\n+        oneLineSummary = CheckDuplicateMarking.USAGE_SUMMARY,\n+        programGroup = DiagnosticsAndQCProgramGroup.class)\n+\n+@DocumentedFeature(enable = false)\n+public class CheckDuplicateMarking extends CommandLineProgram {\n+    static final String USAGE_SUMMARY = \"Checks the consistency of duplicate markings.\";\n+    static final String USAGE_DETAILS = \"This tool checks that all reads with the same queryname have their duplicate marking flags set the same way. \" +\n+            \"NOTE: This tool does NOT check that the duplicate marking is correct. The ONLY thing that it checks is that the 0x400 bit-flags of records \" +\n+            \"with the same queryname are equal.\";\n+\n+    @Argument(doc = \"Input BAM or SAM file to check.\", shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)\n+    public File INPUT;\n+\n+    @Argument(doc = \"Output file into which bad querynames will be placed (if not null).\", shortName = StandardOptionDefinitions.OUTPUT_SHORT_NAME, optional = true)\n+    public File OUTPUT = null;\n+\n+    @Argument(doc = \"Which reads of the same name should be checked to have same duplicate marking.\")\n+    public Mode MODE = Mode.ALL;\n+\n+    private String currentReadName = \"\";\n+    private boolean currentReadDuplicateMarked = false;\n+\n+    private static final Log log = Log.getInstance(CheckDuplicateMarking.class);\n+    private final ProgressLogger progress = new ProgressLogger(log, (int) 1e6, \"Checked.\");\n+\n+    private static final int NUM_WARNINGS = 100;\n+    private int numBadRecords = 0;\n+\n+    public enum Mode implements CommandLineParser.ClpEnum {\n+        ALL(\"Check all reads.\"),\n+        PRIMARY_ONLY(\"Check primary alignments.\"),\n+        PRIMARY_MAPPED_ONLY(\"Check mapped alignments.\"),\n+        PRIMARY_PROPER_PAIR_ONLY(\"Check mapped alignments.\");\n+\n+        private final String message;\n+\n+        Mode(final String message) {\n+            this.message = message;\n+        }\n+\n+        public String getHelpDoc() {\n+            return message;\n+        }\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFileIsReadable(INPUT);\n+        if (OUTPUT != null) {\n+            IOUtil.assertFileIsWritable(OUTPUT);\n+        }\n+\n+        try (SamReader reader = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(INPUT)) {\n+\n+            checkDuplicateMarkingsInIterable(getSortedRecordsFromReader(reader));\n+            if (numBadRecords > 0) {\n+                log.error(\"Found \" + numBadRecords + \" records that do not agree on their duplicate flag.\");\n+            } else {\n+                log.info(\"All records' duplicate markings agree.\");\n+            }\n+\n+        } catch (IOException e) {\n+            throw new PicardException(\"Error while reading input file \" + INPUT, e);\n+        }\n+\n+        return numBadRecords > 0 ? 1 : 0;\n+    }\n+\n+    private Iterable<SAMRecord> getSortedRecordsFromReader(final SamReader reader) {\n+        if (reader.getFileHeader().getSortOrder() == SAMFileHeader.SortOrder.queryname) {\n+            return reader;\n+        }\n+\n+        log.info(\"Input file isn't queryname sorted. Sorting into temp space.\");\n+\n+        final Path[] tmpPaths = TMP_DIR.stream()\n+                .map(File::toPath)\n+                .toArray(Path[]::new);\n+\n+        final ProgressLogger sortProgress = new ProgressLogger(log, (int) 1e6, \"Read into sorter\");\n+        final SortingCollection<SAMRecord> alignmentSorter = SortingCollection.newInstance(SAMRecord.class,\n+                new BAMRecordCodec(reader.getFileHeader()),\n+                new SAMRecordQueryNameComparator(),\n+                MAX_RECORDS_IN_RAM,\n+                tmpPaths);\n+\n+        for (final SAMRecord rec : reader) {\n+            alignmentSorter.add(rec);\n+            sortProgress.record(rec);\n+        }\n+        return alignmentSorter;\n+    }\n+\n+    private boolean checkAndTallyRecordDuplicateMarking(final SAMRecord rec) {\n+        if (!rec.getReadName().equals(currentReadName)) {\n+            // this case the queryname changed, and thus there's no comparison to make\n+            currentReadName = rec.getReadName();\n+            currentReadDuplicateMarked = rec.getDuplicateReadFlag();\n+        } else if (rec.getDuplicateReadFlag() != currentReadDuplicateMarked) {\n+            // Here the current queryname is the same, but the duplicate flag doesn't match the first record with that queryname\n+            numBadRecords++;\n+\n+            if (numBadRecords <= NUM_WARNINGS) {\n+                log.warn(() -> \"Reads with queryname \" + currentReadName + \" have different duplicate flags (at \" +\n+                        rec.getContig() + \":\" + rec.getStart() + \")\");\n+            }\n+\n+            if (numBadRecords == NUM_WARNINGS) {\n+                log.warn(\"Further warnings will be suppressed.\");\n+            }\n+\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void checkDuplicateMarkingsInIterable(final Iterable<SAMRecord> iterable) throws IOException {\n+        try (PrintWriter writer = OUTPUT == null ?", "originalCommit": "01b6be605398de1ce68034bd312e068bfb9111e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNTkxMg==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451115912", "bodyText": "no...it's a different constructor..", "author": "yfarjoun", "createdAt": "2020-07-07T20:12:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTExNjQ3OQ==", "url": "https://github.com/broadinstitute/picard/pull/1507#discussion_r451116479", "bodyText": "PrintWriter(Writer) vs.  PrintWriter(OutputStream)", "author": "yfarjoun", "createdAt": "2020-07-07T20:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MzM2MA=="}], "type": "inlineReview"}, {"oid": "84b0d1d7504a3a43cd698a56be6abd6a648e5c07", "url": "https://github.com/broadinstitute/picard/commit/84b0d1d7504a3a43cd698a56be6abd6a648e5c07", "message": "- added a new (undocumented) CLP that will check that all the records with the same queryname have the same duplicate marking.\n- added tests\n- moved another test into a markduplicates test directory", "committedDate": "2020-07-08T14:56:57Z", "type": "commit"}, {"oid": "82a334593c16f0dc5d804b5631da6ba66bf8d2c1", "url": "https://github.com/broadinstitute/picard/commit/82a334593c16f0dc5d804b5631da6ba66bf8d2c1", "message": "-responding to review comments", "committedDate": "2020-07-08T14:56:57Z", "type": "commit"}, {"oid": "0cf05de2e9608772423c5fa3940c313fc6d56357", "url": "https://github.com/broadinstitute/picard/commit/0cf05de2e9608772423c5fa3940c313fc6d56357", "message": "- respond to nits", "committedDate": "2020-07-08T14:58:41Z", "type": "commit"}, {"oid": "4c295d4b128265fcdbbc848945a2738c566a990d", "url": "https://github.com/broadinstitute/picard/commit/4c295d4b128265fcdbbc848945a2738c566a990d", "message": "oops. wrong operator.", "committedDate": "2020-07-08T14:59:00Z", "type": "commit"}, {"oid": "4c295d4b128265fcdbbc848945a2738c566a990d", "url": "https://github.com/broadinstitute/picard/commit/4c295d4b128265fcdbbc848945a2738c566a990d", "message": "oops. wrong operator.", "committedDate": "2020-07-08T14:59:00Z", "type": "forcePushed"}, {"oid": "e8afa73b63910bebe169c4f682302b4c6fa27724", "url": "https://github.com/broadinstitute/picard/commit/e8afa73b63910bebe169c4f682302b4c6fa27724", "message": "Merge branch 'master' into yf_Add_Check_DuplicateMarking", "committedDate": "2020-07-10T04:17:58Z", "type": "commit"}]}