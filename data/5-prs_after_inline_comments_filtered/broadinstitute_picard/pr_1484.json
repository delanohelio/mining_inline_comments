{"pr_number": 1484, "pr_title": "Hardclip adapter option in MergeBamAlignments", "pr_createdAt": "2020-03-10T21:54:11Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1484", "timeline": [{"oid": "1ad177b03ef0543cdb0b4874f97cb082280407bc", "url": "https://github.com/broadinstitute/picard/commit/1ad177b03ef0543cdb0b4874f97cb082280407bc", "message": "hardclipping", "committedDate": "2020-03-10T21:47:20Z", "type": "commit"}, {"oid": "bf6f43280e9d6cc9f3fe8d110d73b15609e40d9f", "url": "https://github.com/broadinstitute/picard/commit/bf6f43280e9d6cc9f3fe8d110d73b15609e40d9f", "message": "strand flipping", "committedDate": "2020-03-10T21:47:20Z", "type": "commit"}, {"oid": "cd6bd15b2a8fb4d3b0585e88f969a0f9080859a5", "url": "https://github.com/broadinstitute/picard/commit/cd6bd15b2a8fb4d3b0585e88f969a0f9080859a5", "message": "tests", "committedDate": "2020-03-10T21:47:40Z", "type": "commit"}, {"oid": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "url": "https://github.com/broadinstitute/picard/commit/519b1616d9e9a0a8096e761c85acf297eb19f3d7", "message": "tests", "committedDate": "2020-03-10T21:47:40Z", "type": "commit"}, {"oid": "7715fd4fbbdaf34d5e7c7daf54d44706916054ef", "url": "https://github.com/broadinstitute/picard/commit/7715fd4fbbdaf34d5e7c7daf54d44706916054ef", "message": "fixing tests", "committedDate": "2020-03-11T13:48:17Z", "type": "commit"}, {"oid": "7028bccafb6bbb7442396cbe8459e7072083582b", "url": "https://github.com/broadinstitute/picard/commit/7028bccafb6bbb7442396cbe8459e7072083582b", "message": "more tests", "committedDate": "2020-03-11T21:06:36Z", "type": "commit"}, {"oid": "b76d9b6edcf2a46be58d832f1900635918927a47", "url": "https://github.com/broadinstitute/picard/commit/b76d9b6edcf2a46be58d832f1900635918927a47", "message": "mba test on sam file", "committedDate": "2020-03-13T13:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMjE2OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394522169", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right\n          \n          \n            \n                                //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early soft-clipping isn't quite right", "author": "yfarjoun", "createdAt": "2020-03-18T17:31:54Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n+                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                            final int clipFrom = posClipFrom;\n+\n+                            for (final AdapterPair adapterPair : adaptersPairs) {\n+                                if (basesToClipMatchAdapterPair(read1, clipFrom - 1, adapterPair, read2Structure) && basesToClipMatchAdapterPair(read2, clipFrom - 1, adapterPair, read1Structure)) {\n+                                    CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, CigarOperator.HARD_CLIP);\n+                                    CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, CigarOperator.HARD_CLIP);\n+                                    return;\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+\n+                    //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMjcxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394522715", "bodyText": "the \"readthrough bases\"? not clear what is meant by that....", "author": "yfarjoun", "createdAt": "2020-03-18T17:32:46Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODgzMA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394568830", "bodyText": "unclear what you are trying to do here....could you put a comment in the code?", "author": "yfarjoun", "createdAt": "2020-03-18T18:50:40Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n+                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                            final int clipFrom = posClipFrom;\n+", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3NDM1NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394574354", "bodyText": "hmmm. this feels like code that already exists in htsjdk....basically you want to go from a reference position to a readoffset, right? how about htsjdk.samtools.SAMRecord#getReadPositionAtReferencePosition(htsjdk.samtools.SAMRecord, int, boolean) does that help?", "author": "yfarjoun", "createdAt": "2020-03-18T19:00:29Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -780,9 +821,154 @@ protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRe\n                         final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n                         CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n                     }\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTIxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400489219", "bodyText": "comment still stands", "author": "yfarjoun", "createdAt": "2020-03-30T20:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3NDM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNTE5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394615191", "bodyText": "the generalizability of having the clipping operator given as such seems like premature optimization...why not just a boolean hardClip ?", "author": "yfarjoun", "createdAt": "2020-03-18T20:19:27Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNzQ4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394617486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operatore.\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operator.\");", "author": "yfarjoun", "createdAt": "2020-03-18T20:23:59Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -964,8 +1150,18 @@ public boolean isClipOverlappingReads() {\n         return clipOverlappingReads;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n+    public void setClipOverlappingReads(final boolean clipOverlappingReads, final CigarOperator clipOverlappingReadsOperator,\n+                                        final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                        final List<AdapterPair> adapters) {\n         this.clipOverlappingReads = clipOverlappingReads;\n+        if (clipOverlappingReads && !clipOverlappingReadsOperator.isClipping()) {\n+            throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operatore.\");", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MTg2NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394671864", "bodyText": "Why do we need two read structures? the read structure is something that breaks up the entire stream of cycles into various things: UMIs,  Sample BCs, Template reads, skips...it is not clear (to me!) how a single readStructure should be broken up into to.", "author": "yfarjoun", "createdAt": "2020-03-18T22:19:32Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -280,6 +301,16 @@\n             \"the result will be an invalid record. To force no change use the DO_NOT_CHANGE_INVALID strategy.\", optional = true)\n     public AbstractAlignmentMerger.UnmappingReadStrategy UNMAPPED_READ_STRATEGY = AbstractAlignmentMerger.UnmappingReadStrategy.DO_NOT_CHANGE;\n \n+    @Argument(doc = \"Structure of read 1.  If this and READ_STRUCTURE both are unspecified, will be assumed that all bases in read 1 are template. Cannot be used with READ_STRUCTURE.\", optional = true, mutex = {\"READ_STRUCTURE\"})\n+    public ReadStructure READ_1_STRUCTURE;", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MjcxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394672719", "bodyText": "This function is awfully complex....but it seems to be doing a combination of things for which other functions already exist...can you explain what it does? perhaps it needs to be broken up into a few smaller methods.", "author": "yfarjoun", "createdAt": "2020-03-18T22:21:45Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -780,9 +821,154 @@ protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRe\n                         final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n                         CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n                     }\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {\n+\n+        if (refPosToClipFrom > rec.getUnclippedEnd() || refPosToClipFrom < rec.getUnclippedStart()) {\n+            //read doesn't cover position\n+            return -1;\n+        }\n+        final Cigar cigar = rec.getCigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(cigar.getCigarElements()); //need to be modifiable\n+        if (rec.getReadNegativeStrandFlag()) {\n+            Collections.reverse(cigarElements);\n+        }\n+\n+        int currentRefPosition = rec.getReadNegativeStrandFlag()? -rec.getUnclippedEnd() : rec.getUnclippedStart();\n+        final int refPosObjective = rec.getReadNegativeStrandFlag()? -refPosToClipFrom : refPosToClipFrom;\n+\n+        int currentReadPosition = 1;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if ((op.consumesReferenceBases() || op.isClipping()) && currentRefPosition + cigarElement.getLength() >= refPosObjective) {\n+                if (op.consumesReadBases() || op == CigarOperator.SOFT_CLIP) {\n+                    return currentReadPosition + refPosObjective - currentRefPosition;\n+                } else if (op == CigarOperator.HARD_CLIP) {\n+                    //for hardclip, position is not on read\n+                    return -1;\n+                } else {\n+                    //if doesn't consume read bases and isn't clipping, return current base\n+                    return currentReadPosition;\n                 }\n             }\n+\n+            if (op.consumesReferenceBases() || op.isClipping()) {\n+                currentRefPosition += cigarElement.getLength();\n+            }\n+\n+            if (op.consumesReadBases() || op.isClipping()) {\n+                currentReadPosition += cigarElement.getLength();\n+            }\n         }\n+\n+        //if we haven't found the correct position, there is a bug\n+        throw new PicardException(\"Could not find read position for reference position \" + refPosToClipFrom + \" which should be covered by read \" + rec);\n+    }\n+\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+        clipForOverlappingReads(read1, read2, CigarOperator.SOFT_CLIP, null, null, Collections.emptyList());\n+    }\n+\n+    protected static boolean basesToClipMatchAdapterPair(final SAMRecord read, final int posToClip, final AdapterPair adapterPair,", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1MTY4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r391151687", "bodyText": "import picard.util.IlluminaUtil;\ncan be removed", "author": "fleharty", "createdAt": "2020-03-11T17:44:16Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -29,7 +29,13 @@\n import htsjdk.samtools.reference.ReferenceSequenceFileWalker;\n import htsjdk.samtools.SAMFileHeader.SortOrder;\n import htsjdk.samtools.util.*;\n+import htsjdk.tribble.util.ParsingUtils;\n import picard.PicardException;\n+import picard.illumina.parser.ReadDescriptor;\n+import picard.illumina.parser.ReadStructure;\n+import picard.illumina.parser.ReadType;\n+import picard.util.AdapterPair;\n+import picard.util.IlluminaUtil;", "originalCommit": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1Mjg1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r391152851", "bodyText": "Are you suggesting 45 since that is what we believe PCR error to be?\nIf so, it might be useful to have a comment here explaining the justification for 45.", "author": "fleharty", "createdAt": "2020-03-11T17:46:09Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -59,6 +65,10 @@\n \n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n+    public static final int MAX_ERROR_PHRED = 45;", "originalCommit": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4Mzk3Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r393783977", "bodyText": "If this is going to be public, then I think it should have javadoc", "author": "fleharty", "createdAt": "2020-03-17T15:53:52Z", "path": "src/main/java/picard/illumina/CustomAdapterPair.java", "diffHunk": "@@ -28,12 +28,12 @@\n import htsjdk.samtools.util.StringUtil;\n import picard.util.AdapterPair;\n \n-class CustomAdapterPair implements AdapterPair {\n+public class CustomAdapterPair implements AdapterPair {\n \n     private final String fivePrime, threePrime, fivePrimeReadOrder;\n     private final byte[] fivePrimeBytes, threePrimeBytes, fivePrimeReadOrderBytes;\n \n-    CustomAdapterPair(final String fivePrime, final String threePrime) {\n+    public CustomAdapterPair(final String fivePrime, final String threePrime) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyODQxMw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394728413", "bodyText": "Maybe say, \"adapter kit\", or something similar just to be more specific", "author": "fleharty", "createdAt": "2020-03-19T00:57:13Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -256,9 +261,25 @@\n             \"alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily.\")\n     public PrimaryAlignmentStrategy PRIMARY_ALIGNMENT_STRATEGY = PrimaryAlignmentStrategy.BestMapq;\n \n-    @Argument(doc = \"For paired reads, soft clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.\")\n+    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting.\")\n     public boolean CLIP_OVERLAPPING_READS = true;\n \n+    @Argument(doc = \"Type of clipping to used for overlapping reads.  If set to hard clip, hard clipping will only be performed if bases to be clipped match expected adapter sequences, otherwise bases will be soft clipped.\")\n+    public CigarOperator CLIP_OVERLAPPING_READS_OPERATOR = CigarOperator.SOFT_CLIP;\n+\n+    @Argument(doc = \"Which adapters to look for in the read.\")", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczNzkxNA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394737914", "bodyText": "Should there be a check on if FIVE_PRIME_ADAPTER == null and THREE_PRIME_ADAPTER != null and\nvice versa?  Maybe throw an exception.", "author": "fleharty", "createdAt": "2020-03-19T01:26:36Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -348,7 +379,16 @@ protected int doWork() {\n                 READ1_ALIGNED_BAM, READ2_ALIGNED_BAM, EXPECTED_ORIENTATIONS, SORT_ORDER,\n                 PRIMARY_ALIGNMENT_STRATEGY.newInstance(), ADD_MATE_CIGAR, UNMAP_CONTAMINANT_READS,\n                 MIN_UNCLIPPED_BASES, UNMAPPED_READ_STRATEGY, MATCHING_DICTIONARY_TAGS);\n-        merger.setClipOverlappingReads(CLIP_OVERLAPPING_READS);\n+\n+        final List<AdapterPair> adapters = new ArrayList<>(ADAPTERS_TO_CHECK);\n+\n+        if (FIVE_PRIME_ADAPTER != null && THREE_PRIME_ADAPTER != null) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczOTAxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394739011", "bodyText": "A lot of code duplication here\ntesOverlappedReadClippingWithNonOverlappedReads (has misspelling in name)\ntestOverlappedReadHardClippingWithNonOverlappedReads\ntestBasicOverlappedReadClipping\nare all basically the same thing, they could be consolidated into a single test that uses a data provider.", "author": "fleharty", "createdAt": "2020-03-19T01:31:20Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -36,6 +48,22 @@\n         Assert.assertEquals(r2.getCigarString(), \"110M\");\n     }\n \n+    @Test", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDc1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394754751", "bodyText": "expectedReadPosToCLipFrom - funny capitalization in CLip", "author": "fleharty", "createdAt": "2020-03-19T02:22:44Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -49,6 +77,272 @@\n         Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n     }\n \n+    @DataProvider(name = \"hardClippingDataProvider\")\n+    public Object [][] getHardClippingData() {\n+\n+\n+        final List<Object[]> ret = new ArrayList<>();\n+        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n+        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n+        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n+        SequenceUtil.reverseComplement(templateBasesRC);\n+        //All Illumina barcode combinations should work\n+        \n+        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n+            final int readLength = templateBases.length + nAdapterBases;\n+            final String cigarF = readLength + \"M\";\n+            final String cigarR = readLength + \"M\";\n+            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n+            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n+\n+            for (final AdapterPair adapterPair : illuminaAdapters) {\n+                SequenceUtil.reverseComplement(templateBasesRC);\n+                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n+                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n+            }\n+\n+            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n+            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+\n+            //3' of one barcode, 5' of another, should only softclip\n+            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n+            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+\n+        }\n+\n+        //already soft-clipped\n+        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+        //already soft-clipped more than adapters\n+        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //already hard-clipped\n+        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //soft-clipped beginning\n+        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n+\n+\n+        //hard-clipped beginning\n+        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n+\n+        //insertion in reads\n+        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n+\n+        //insertion in adapter portion of read\n+        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //deletion in reads\n+        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n+\n+        //deletion in adapter portion of read\n+        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //Ns in adapter\n+        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n+        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n+                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n+                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //read structures and UMIs\n+        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n+            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n+                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n+                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n+                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n+                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n+\n+\n+                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n+                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n+\n+                    final String umi1String = StringUtil.bytesToString(umi1);\n+                    final String umi2String = StringUtil.bytesToString(umi2);\n+\n+                    SequenceUtil.reverseComplement(umi1);\n+                    SequenceUtil.reverseComplement(umi2);\n+\n+                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);\n+                    final byte[] templateBasesRCWithUMI = ArrayUtils.addAll(templateBasesRCClipped, umi2);\n+\n+                    final List<ReadDescriptor> readDescriptors = new ArrayList<>();\n+                    if (gapBeforeUMI > 0) {\n+                        readDescriptors.add(new ReadDescriptor(gapBeforeUMI, ReadType.Skip));\n+                    }\n+                    if (umiLength > 0) {\n+                        readDescriptors.add(new ReadDescriptor(umiLength, ReadType.MolecularIndex));\n+                    }\n+                    if (gapAfterUMI > 0) {\n+                        readDescriptors.add(new ReadDescriptor(gapAfterUMI, ReadType.Skip));\n+                    }\n+                    readDescriptors.add(new ReadDescriptor(110 - totalBasesToRemove, ReadType.Template));\n+\n+                    final ReadStructure readStructure = new ReadStructure(readDescriptors);\n+\n+                    ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                            buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                            false, true, 100, 90 - totalBasesToRemove, illuminaAdapters, (110 - totalBasesToRemove) + \"M\" + (10 + totalBasesToRemove) + \"H\", (10 + totalBasesToRemove) + \"H\" + (110 - totalBasesToRemove) + \"M\", 100, 100,\n+                            umi1String + \"-\" + umi2String, readStructure});\n+\n+                }\n+            }\n+        }\n+\n+        return ret.toArray(new Object[][]{});\n+    }\n+\n+    private byte[] buildReadBases(final byte[] templateBasesReadOrder, final byte[] adapterBasesReadOrder, final int readLength, final boolean negativeStrand) {\n+        final byte[] bases = ArrayUtils.addAll(templateBasesReadOrder, adapterBasesReadOrder);\n+        final byte[] readBases = Arrays.copyOf(bases, readLength);\n+        if (negativeStrand) {\n+            SequenceUtil.reverseComplement(readBases);\n+        }\n+        return readBases;\n+    }\n+\n+    @Test (dataProvider = \"hardClippingDataProvider\")\n+    public void testOverlappedReadHardClipping(final String originalCigar1, final String originalCigar2, final byte[] read1Bases, final byte[] read2Bases, final boolean strand1, final boolean strand2,\n+                                               final int start1, final int start2, final List<AdapterPair> adapters, final String expectedCigar1, final String expectedCigar2, final int expectedStart1, final int expectedStart2,\n+                                               final String umiTag, final ReadStructure readStructure) {\n+        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n+        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, originalCigar1, originalCigar2, strand1, strand2, 30);\n+        final SAMRecord r1 = recs.get(0);\n+        final SAMRecord r2 = recs.get(1);\n+\n+        r1.setReadBases(read1Bases);\n+        r2.setReadBases(read2Bases);\n+\n+        if (umiTag != null) {\n+            r1.setAttribute(SAMTag.RX.toString(), umiTag);\n+            r2.setAttribute(SAMTag.RX.toString(), umiTag);\n+        }\n+\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, readStructure, readStructure, adapters);\n+        Assert.assertEquals(r1.getAlignmentStart(), expectedStart1);\n+        Assert.assertEquals(r1.getCigarString(), expectedCigar1);\n+\n+        Assert.assertEquals(r2.getAlignmentStart(), expectedStart2);\n+        Assert.assertEquals(r2.getCigarString(), expectedCigar2);\n+    }\n+\n+    @DataProvider(name = \"getReadPosToClipFromDataProvider\")\n+    public Object[][] getReadPosToClipFromData() {\n+        return new Object[][] {\n+                {\"120M\", false, 450, 502, 53},\n+                {\"120M\", true, 450, 502, 68},\n+                {\"120M\", false, 450, 580, -1},\n+                {\"120M\", false, 450, 440, -1},\n+                {\"120M\", true, 450, 580, -1},\n+                {\"120M\", true, 450, 440, -1},\n+\n+                {\"100M3I100M\", false, 300, 425, 129},\n+                {\"100M3I100M\", true, 300, 425, 75},\n+\n+                {\"100M3D100M\", false, 300, 425, 123},\n+                {\"100M3D100M\", true, 300, 425, 78},\n+\n+                {\"100M16S\", false, 300, 410, 111},\n+                {\"100M16S\", true, 300, 400, 16},\n+                {\"16S100M\", false, 316, 410, 111},\n+                {\"16S100M\", true, 316, 310, 106},\n+\n+                {\"100M16H\", false, 300, 410, -1},\n+                {\"100M16H\", true, 300, 410, -1},\n+                {\"100M16H\", true, 300, 390, 26},\n+                {\"16H100M\", false, 316, 310, -1},\n+                {\"16H100M\", true, 316, 310, -1},\n+                {\"16H100M\", true, 316, 350, 66}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getReadPosToClipFromDataProvider\")\n+    public void testGetReadPositionToClipFrom(final String cigarString, final boolean negativeStrand, final int start, final int refPosToClipFrom, final int expectedReadPosToCLipFrom) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NjA3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394756073", "bodyText": "I don't think templateBasesWithUMI or templateBasesRCWithUMI are used.", "author": "fleharty", "createdAt": "2020-03-19T02:27:04Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -49,6 +77,272 @@\n         Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n     }\n \n+    @DataProvider(name = \"hardClippingDataProvider\")\n+    public Object [][] getHardClippingData() {\n+\n+\n+        final List<Object[]> ret = new ArrayList<>();\n+        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n+        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n+        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n+        SequenceUtil.reverseComplement(templateBasesRC);\n+        //All Illumina barcode combinations should work\n+        \n+        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n+            final int readLength = templateBases.length + nAdapterBases;\n+            final String cigarF = readLength + \"M\";\n+            final String cigarR = readLength + \"M\";\n+            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n+            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n+\n+            for (final AdapterPair adapterPair : illuminaAdapters) {\n+                SequenceUtil.reverseComplement(templateBasesRC);\n+                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n+                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n+            }\n+\n+            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n+            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+\n+            //3' of one barcode, 5' of another, should only softclip\n+            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n+            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+\n+        }\n+\n+        //already soft-clipped\n+        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+        //already soft-clipped more than adapters\n+        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //already hard-clipped\n+        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //soft-clipped beginning\n+        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n+\n+\n+        //hard-clipped beginning\n+        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n+\n+        //insertion in reads\n+        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n+\n+        //insertion in adapter portion of read\n+        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //deletion in reads\n+        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n+\n+        //deletion in adapter portion of read\n+        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //Ns in adapter\n+        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n+        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n+                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n+                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //read structures and UMIs\n+        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n+            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n+                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n+                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n+                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n+                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n+\n+\n+                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n+                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n+\n+                    final String umi1String = StringUtil.bytesToString(umi1);\n+                    final String umi2String = StringUtil.bytesToString(umi2);\n+\n+                    SequenceUtil.reverseComplement(umi1);\n+                    SequenceUtil.reverseComplement(umi2);\n+\n+                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f7d94668099e260e0feee530cd477a0af09c3319", "url": "https://github.com/broadinstitute/picard/commit/f7d94668099e260e0feee530cd477a0af09c3319", "message": "Doing simplified hard-clipping and refactoring tests.", "committedDate": "2020-03-26T18:48:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzA0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487042", "bodyText": "perhaps let's use non-X (but lowercase) tag, so that we can try to make it a real (upper-cased) tag in hts-specs later. look for a reasonable two-caracter tag name...perhaps cb and cq is not taken? also, need to think what to do if it's clipped from both ends....or perhaps we assert that these bases are only from the end of the read.", "author": "yfarjoun", "createdAt": "2020-03-30T20:53:41Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -60,6 +60,9 @@\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n+    static final String HARD_CLIPPED_BASES_TAG = \"XB\";", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzgzNg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487836", "bodyText": "I think it's better to use a boolean as there are only 2 resaonable operators here....SOFT and HARD.", "author": "yfarjoun", "createdAt": "2020-03-30T20:55:00Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,105 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Nzk4NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487985", "bodyText": "(and then the sanity checks below will not be needed)", "author": "yfarjoun", "createdAt": "2020-03-30T20:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4ODk4Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400488982", "bodyText": "I think that the bases should be stored in original read order, so that in order to revert, you just need to stick these on the ends of the reverted records.", "author": "yfarjoun", "createdAt": "2020-03-30T20:57:10Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,105 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    //need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                        final int clipFrom = posClipFrom;\n+\n+                        if (clippingOperator == CigarOperator.HARD_CLIP) {\n+                            moveClippedBasesToTag(read1, clipFrom);\n+                            moveClippedBasesToTag(read2, clipFrom);\n+                        }\n+\n+                        CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, clippingOperator);\n+                        CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, clippingOperator);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if(rec.getReadNegativeStrandFlag()) {", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "482c78d70ac057856f7e97fabe75ae6d19b0744a", "url": "https://github.com/broadinstitute/picard/commit/482c78d70ac057856f7e97fabe75ae6d19b0744a", "message": "Broke tests somehow", "committedDate": "2020-04-08T17:55:53Z", "type": "commit"}, {"oid": "e21a98c77debb37bbc64d5c65601ebb2233f473d", "url": "https://github.com/broadinstitute/picard/commit/e21a98c77debb37bbc64d5c65601ebb2233f473d", "message": "Responding to Yossi's comments, getDistanceFrom3PromeEndToClipFrom needs fixing before his rereview.", "committedDate": "2020-04-10T18:45:21Z", "type": "commit"}, {"oid": "c7659b7f5c1556bb5db0e3b3b0428169289ec4e0", "url": "https://github.com/broadinstitute/picard/commit/c7659b7f5c1556bb5db0e3b3b0428169289ec4e0", "message": "Fixes two broken tests", "committedDate": "2020-04-14T22:38:51Z", "type": "commit"}, {"oid": "2af405160b031288b96ea2bf78d26015c4df694c", "url": "https://github.com/broadinstitute/picard/commit/2af405160b031288b96ea2bf78d26015c4df694c", "message": "This commit is a test", "committedDate": "2020-04-22T23:08:56Z", "type": "commit"}, {"oid": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "url": "https://github.com/broadinstitute/picard/commit/c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "message": "Small refactoring to get rid of duplicated code.", "committedDate": "2020-04-23T02:20:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5ODU0OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414698549", "bodyText": "since soft-clipped bases are not removed, I think that the \"h\" is superfluous. how about EB and EQ (for End Bases, and End Quality) since in theory, bases could also be (hard-)clipped off of the start of a read..", "author": "yfarjoun", "createdAt": "2020-04-24T16:17:15Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -60,6 +60,9 @@\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n+    static final String HARD_CLIPPED_BASES_TAG = \"hB\";", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5OTAzNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414699037", "bodyText": "also, as a //Todo item here to switch to using the htsjdk version if it gets into hts-spec and implemented", "author": "yfarjoun", "createdAt": "2020-04-24T16:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5ODU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMDM0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414700341", "bodyText": "is clippingOperator used elsewhere?", "author": "yfarjoun", "createdAt": "2020-04-24T16:20:17Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMzA4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414703087", "bodyText": "add a sanity check that the tags are not already in use. at this point I think it's OK to break if they are in use, but losing data due to overwriting old tags would not be good.", "author": "yfarjoun", "createdAt": "2020-04-24T16:24:37Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDMxNg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414704316", "bodyText": "could you split this into three parts:\n\nextract the required bases/qualities\noptionally reverse/rev-comp the arrays\nset the attributes\n\nwhile it takes up more lines of code, there's less code duplication.", "author": "yfarjoun", "createdAt": "2020-04-24T16:26:33Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+\n+            if (rec.getReadNegativeStrandFlag()) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNTM0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414705342", "bodyText": "also, you defined a method to \"move bases to tag\" so perhaps you should be using it... :-)", "author": "yfarjoun", "createdAt": "2020-04-24T16:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwODE1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414708153", "bodyText": "please add a test that has an expected sam file with the tags", "author": "yfarjoun", "createdAt": "2020-04-24T16:32:39Z", "path": "src/test/java/picard/sam/MergeBamAlignmentTest.java", "diffHunk": "@@ -1206,6 +1206,50 @@ public void testShortFragmentClipping() throws Exception {\n         result.close();\n     }\n \n+    @Test\n+    public void testShortFragmentHardClipping() throws IOException {\n+        final File output = File.createTempFile(\"testShortFragmentClipping\", \".sam\");", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMDk5MA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414710990", "bodyText": "This method seems overly complicated and doesn't make enough use of existing coordinate switching code like htsjdk.samtools.SAMRecord#getReadPositionAtReferencePosition(htsjdk.samtools.SAMRecord, int, boolean)\nif you really need it, it needs to be heavily documented and tested.", "author": "yfarjoun", "createdAt": "2020-04-24T16:36:56Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+\n+            if (rec.getReadNegativeStrandFlag()) {\n+                // Ensures that bases are reverse complemented and base qualities are reversed\n+                rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n+                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n+            } else {\n+                rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipFrom - 1, readLength)));\n+            }\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if (rec.getReadNegativeStrandFlag()) {\n+            // Ensures that bases are reverse complemented and base qualities are reversed\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n+        } else {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities,clipFrom - 1, readLength)));\n+        }\n+    }\n+\n+    protected static int getDistanceFrom3PrimeEndToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjUzMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414726531", "bodyText": "as a change in public API, this is annoying. perhaps you should leave the previous method with a default of false?", "author": "yfarjoun", "createdAt": "2020-04-24T17:02:00Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -964,8 +1035,9 @@ public boolean isClipOverlappingReads() {\n         return clipOverlappingReads;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n+    public void setClipOverlappingReads(final boolean clipOverlappingReads, final boolean hardClipOverlappingReads) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzA3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414727075", "bodyText": "docuement where the clipped bases/qualities go to", "author": "yfarjoun", "createdAt": "2020-04-24T17:02:58Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -256,9 +257,12 @@\n             \"alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily.\")\n     public PrimaryAlignmentStrategy PRIMARY_ALIGNMENT_STRATEGY = PrimaryAlignmentStrategy.BestMapq;\n \n-    @Argument(doc = \"For paired reads, soft clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.\")\n+    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting.\")\n     public boolean CLIP_OVERLAPPING_READS = true;\n \n+    @Argument(doc = \"If true, hard clipping will be applied to overlapping reads.  By default, soft clipping is used.\")", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzY4MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414727681", "bodyText": "there seems to be a preference for explicit imports rather than wildcard. you can change your intelliJ settings for that.", "author": "yfarjoun", "createdAt": "2020-04-24T17:03:55Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -1,15 +1,10 @@\n package picard.sam;\n \n-import htsjdk.samtools.SAMFileHeader;\n-import htsjdk.samtools.SAMFileWriter;\n-import htsjdk.samtools.SAMFileWriterFactory;\n-import htsjdk.samtools.SAMRecord;\n-import htsjdk.samtools.SAMRecordIterator;\n-import htsjdk.samtools.SAMRecordSetBuilder;\n-import htsjdk.samtools.SamReader;\n-import htsjdk.samtools.SamReaderFactory;\n-import htsjdk.samtools.ValidationStringency;\n+import htsjdk.samtools.*;", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0MDI3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423940273", "bodyText": "this.", "author": "yfarjoun", "createdAt": "2020-05-12T18:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzY4MQ=="}], "type": "inlineReview"}, {"oid": "c36152e97fc74246396b725a4df10776f29002c1", "url": "https://github.com/broadinstitute/picard/commit/c36152e97fc74246396b725a4df10776f29002c1", "message": "Responding to all but one of Yossi's comments", "committedDate": "2020-05-01T15:35:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYwMTE4MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r418601181", "bodyText": "single line } else {", "author": "yfarjoun", "createdAt": "2020-05-01T15:47:54Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -788,38 +797,42 @@ private static void clipRead(final SAMRecord rec, final int clipFrom, final bool\n \n         // If we are using hard clips, add bases and qualities to SAM tag.\n         if (useHardClipping) {\n-            final byte[] bases = rec.getReadBases();\n-            final byte[] baseQualities = rec.getBaseQualities();\n-            final int readLength = rec.getReadLength();\n-\n-            if (rec.getReadNegativeStrandFlag()) {\n-                // Ensures that bases are reverse complemented and base qualities are reversed\n-                rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n-                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n-            } else {\n-                rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n-                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipFrom - 1, readLength)));\n-            }\n+            moveClippedBasesToTag(rec, clipFrom);\n         }\n \n         // Actually clip the read\n         CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n     }\n \n     private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n \n         final byte[] bases = rec.getReadBases();\n         final byte[] baseQualities = rec.getBaseQualities();\n         final int readLength = rec.getReadLength();\n \n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;\n+        }", "originalCommit": "c36152e97fc74246396b725a4df10776f29002c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6713891198a795f619079d84bf0f8be5dd30eae5", "url": "https://github.com/broadinstitute/picard/commit/6713891198a795f619079d84bf0f8be5dd30eae5", "message": "Experimenting with different methods of getting read position at reference position including soft clips", "committedDate": "2020-05-03T03:38:40Z", "type": "commit"}, {"oid": "20f92b0ec2be41663c6d57a80350a7116ea1c1b1", "url": "https://github.com/broadinstitute/picard/commit/20f92b0ec2be41663c6d57a80350a7116ea1c1b1", "message": "Running this through the test suite, do not review or merge.  Testing alternative usage of getReadPositionAtReferencePosition", "committedDate": "2020-05-03T15:12:30Z", "type": "commit"}, {"oid": "361e25c47a629dcf554ad7dba7fa5a96ac05ad70", "url": "https://github.com/broadinstitute/picard/commit/361e25c47a629dcf554ad7dba7fa5a96ac05ad70", "message": "Reverting htsjdk version to released version", "committedDate": "2020-05-03T15:20:37Z", "type": "commit"}, {"oid": "7f5c73403f1f0d32325c777cbf7c4f52e7b2ff97", "url": "https://github.com/broadinstitute/picard/commit/7f5c73403f1f0d32325c777cbf7c4f52e7b2ff97", "message": "Adding tests, and ability to revert hard-clipped reads", "committedDate": "2020-05-07T00:53:51Z", "type": "commit"}, {"oid": "dc2d098e741fb32e0726814f8e2154cde3210964", "url": "https://github.com/broadinstitute/picard/commit/dc2d098e741fb32e0726814f8e2154cde3210964", "message": "Fixing issue with import", "committedDate": "2020-05-07T01:29:05Z", "type": "commit"}, {"oid": "bf4ce44e4353f80863cca180bc4a421ee99fcce5", "url": "https://github.com/broadinstitute/picard/commit/bf4ce44e4353f80863cca180bc4a421ee99fcce5", "message": "Using XB and XQ instead of eB and eQ and a few minor clean ups", "committedDate": "2020-05-07T02:54:22Z", "type": "commit"}, {"oid": "2a8822c1991fa3d7c28350115d139460cbe35d5a", "url": "https://github.com/broadinstitute/picard/commit/2a8822c1991fa3d7c28350115d139460cbe35d5a", "message": "Updated hard-cliped test sam file to use correct tags in test", "committedDate": "2020-05-07T14:37:50Z", "type": "commit"}, {"oid": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "url": "https://github.com/broadinstitute/picard/commit/bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "message": "Fixed some sam tags in a test", "committedDate": "2020-05-07T15:09:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMTkwMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421731902", "bodyText": "cigarElements can still be final, right?", "author": "yfarjoun", "createdAt": "2020-05-07T19:10:37Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNTYzMA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421735630", "bodyText": "I think some comments about what's happening here would be appreciated by a future developer...", "author": "yfarjoun", "createdAt": "2020-05-07T19:17:30Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNTk3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421735975", "bodyText": "what if this is negative?", "author": "yfarjoun", "createdAt": "2020-05-07T19:18:04Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNzA3NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421737074", "bodyText": "I would include 3primeEnd in the names of the methods here..", "author": "yfarjoun", "createdAt": "2020-05-07T19:20:04Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNzc2MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421737761", "bodyText": "make sure you include the name of the offending record, and the names of the tags that you need...otherwise, debugging this might be tough.", "author": "yfarjoun", "createdAt": "2020-05-07T19:21:28Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTA5OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421739098", "bodyText": "\"ensures that the qualities and bases in the tags are stored in their original order, as produced by the sequencer\"", "author": "yfarjoun", "createdAt": "2020-05-07T19:23:55Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;\n+        } else {\n+            clipPositionFrom = clipFrom - 1;\n+            clipPositionTo = readLength;\n+        }\n+\n+        String basesToKeepInTag = StringUtil.bytesToString(Arrays.copyOfRange(bases, clipPositionFrom, clipPositionTo));\n+        String qualitiesToKeepInTag = SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipPositionFrom, clipPositionTo));\n+\n+        if (rec.getReadNegativeStrandFlag()) {\n+            // Ensures that bases are reverse complemented and base qualities are reversed", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MTE5OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421741198", "bodyText": "I know I said this is better than changing a public API...but it's still not good. set* methods should only change the variable they are named for. why not add a setClipWithHardClips method and avoid changing two things in one method?", "author": "yfarjoun", "createdAt": "2020-05-07T19:27:44Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -966,6 +1029,12 @@ public boolean isClipOverlappingReads() {\n \n     public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n         this.clipOverlappingReads = clipOverlappingReads;\n+        this.hardClipOverlappingReads = false;", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MTU4OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421741588", "bodyText": "hi mark", "author": "yfarjoun", "createdAt": "2020-05-07T19:28:26Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -373,6 +366,10 @@ public void revertSamRecord(final SAMRecord rec) {\n             rec.setDuplicateReadFlag(false);\n         }\n \n+        if (RESTORE_HARDCLIPS && !REMOVE_ALIGNMENT_INFORMATION) {\n+            throw new PicardException(\"hi mom\");", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MjI0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421742247", "bodyText": "please verify your assumption (and throw otherwise)", "author": "yfarjoun", "createdAt": "2020-05-07T19:29:35Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -396,6 +393,20 @@ public void revertSamRecord(final SAMRecord rec) {\n             rec.setMateReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX);\n             rec.setMateUnmappedFlag(rec.getReadPairedFlag());\n \n+            if (RESTORE_HARDCLIPS) {\n+                String hardClippedBases = rec.getStringAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG);\n+                String hardClippedQualities = rec.getStringAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG);\n+                if (hardClippedBases != null && hardClippedQualities != null) {\n+                    // Record has already been reverse complemented if this was on the negative strand\n+                    rec.setReadString(rec.getReadString() + hardClippedBases);", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNDM1NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423834355", "bodyText": "nm.", "author": "yfarjoun", "createdAt": "2020-05-12T15:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MjI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421743721", "bodyText": "update comment with actual tag name", "author": "yfarjoun", "createdAt": "2020-05-07T19:32:26Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClippedRecovery() throws Exception {\n+        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNTExNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423835117", "bodyText": "tB and tQ tags?", "author": "yfarjoun", "createdAt": "2020-05-12T15:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzNzUxNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423937517", "bodyText": "why does the comment keep saying tB and tQ?", "author": "yfarjoun", "createdAt": "2020-05-12T18:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzgxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421743811", "bodyText": "comment", "author": "yfarjoun", "createdAt": "2020-05-07T19:32:35Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClippedRecovery() throws Exception {\n+        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] args = new String[]{\n+                \"I=\" + hardClippedSamToRevert,\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputFile.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        // Ensure that the reverted reads and qualities match the tB and tQ tags", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0NDcxMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421744712", "bodyText": "Could you add around-tripping test, that merges and then restores?", "author": "yfarjoun", "createdAt": "2020-05-07T19:34:13Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "url": "https://github.com/broadinstitute/picard/commit/2d2ccf1d274316b3e89a3d49f3ad416943a55896", "message": "Responding to Yossi's comments again", "committedDate": "2020-05-12T13:21:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NDg0OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423754849", "bodyText": "// instead of setting back the position of the read by posShift, which could create a negative start position, we add posShift the final position in the read.", "author": "yfarjoun", "createdAt": "2020-05-12T13:57:33Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,104 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        final List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements());\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            // Replace SOFT_CLIPs in the oldCigar with MATCH_OR_MISMATCH in newCigar\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        // Temporarily use the newCigar that has SOFT_CLIPs replaced with MATCH_OR_MISMATCH to get read position at reference, but ignore existence of soft-clips\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        return readPosition + posShift;", "originalCommit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1b9796be81b5adf7800685e5f19526ba496ae256", "url": "https://github.com/broadinstitute/picard/commit/1b9796be81b5adf7800685e5f19526ba496ae256", "message": "Adding comment about posShiftt so we don't accidently create a negative start position", "committedDate": "2020-05-12T15:30:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NTg3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423755873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        clipPositionTo = bases.length - clipFrom + 1;\n          \n          \n            \n                        clipPositionTo = readLength - clipFrom + 1;", "author": "yfarjoun", "createdAt": "2020-05-12T13:58:50Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,104 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        final List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements());\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            // Replace SOFT_CLIPs in the oldCigar with MATCH_OR_MISMATCH in newCigar\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        // Temporarily use the newCigar that has SOFT_CLIPs replaced with MATCH_OR_MISMATCH to get read position at reference, but ignore existence of soft-clips\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        return readPosition + posShift;\n+    }\n+\n+    private static void clip3PrimeEndOfRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record \" + rec.getReadName() + \" already contains tags for restoring hard-clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;", "originalCommit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzMDc3NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423830774", "bodyText": "do explicit imports please.", "author": "yfarjoun", "createdAt": "2020-05-12T15:34:08Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -24,18 +24,8 @@\n \n package picard.sam;\n \n-import htsjdk.samtools.BAMRecordCodec;\n-import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.*;", "originalCommit": "1b9796be81b5adf7800685e5f19526ba496ae256", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNTQ4Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423835482", "bodyText": "why split this line?", "author": "yfarjoun", "createdAt": "2020-05-12T15:40:19Z", "path": "src/test/java/picard/sam/MergeSamFilesTest.java", "diffHunk": "@@ -37,7 +37,8 @@\n \n import java.io.File;\n \n-public class MergeSamFilesTest extends CommandLineProgramTest {\n+public class", "originalCommit": "1b9796be81b5adf7800685e5f19526ba496ae256", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "url": "https://github.com/broadinstitute/picard/commit/9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "message": "Fixing a few nits", "committedDate": "2020-05-12T16:06:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzODgxMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423938812", "bodyText": "final", "author": "yfarjoun", "createdAt": "2020-05-12T18:17:08Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzODg2Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423938867", "bodyText": "final", "author": "yfarjoun", "createdAt": "2020-05-12T18:17:14Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();\n+            SAMRecord unmapped = unmappedIterator.next();", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzOTcxOA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423939718", "bodyText": "convert to try-with-resources to assure closing the readers", "author": "yfarjoun", "createdAt": "2020-05-12T18:18:33Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0MDMyMw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423940323", "bodyText": "remove extra NLs", "author": "yfarjoun", "createdAt": "2020-05-12T18:19:39Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -54,7 +59,13 @@ public int runPicardCommandLine(final String[] args) {\n         return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(args));\n     }\n \n+    public int runPicardCommandLine(final String programName, final String[] args) {\n+        return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(programName, Arrays.asList(args)));\n+    }\n+\n     public int runPicardCommandLine(final Map<String, String> kwargs) {\n         return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(kwargs));\n     }\n+", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "url": "https://github.com/broadinstitute/picard/commit/f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "message": "Try with resources, removing vestigal comment, and whitespace fix", "committedDate": "2020-05-12T18:57:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzg0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r424023847", "bodyText": "delete on exit", "author": "yfarjoun", "createdAt": "2020-05-12T20:48:03Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,45 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");", "originalCommit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNDAxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r424024015", "bodyText": "delete on exit", "author": "yfarjoun", "createdAt": "2020-05-12T20:48:18Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,45 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");", "originalCommit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f2ff19940c20862ff653094c9e76877f5408f541", "url": "https://github.com/broadinstitute/picard/commit/f2ff19940c20862ff653094c9e76877f5408f541", "message": "Merge branch 'master' into ck_hardclip_merge_bam_alignments", "committedDate": "2020-05-12T20:50:03Z", "type": "commit"}, {"oid": "f39e69e289632591a0fb9656158679ee71e7aea0", "url": "https://github.com/broadinstitute/picard/commit/f39e69e289632591a0fb9656158679ee71e7aea0", "message": "Added deleteOnExit to files generated during tests", "committedDate": "2020-05-12T21:20:00Z", "type": "commit"}]}