{"pr_number": 1468, "pr_title": "GL-859.  Ported CompareGtcFiles from Picard private repo", "pr_createdAt": "2020-02-14T19:04:27Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1468", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNDI4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379604286", "bodyText": "can be final\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<String> errors = new ArrayList<>();\n          \n          \n            \n                private final List<String> errors = new ArrayList<>();", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:25:29Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxOTg0Ng==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379619846", "bodyText": "yup", "author": "gbggrant", "createdAt": "2020-02-14T20:02:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNDI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTAwNw==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379605007", "bodyText": "Is there a reason to not use Arrays.of() here? I think that would be cleaner than having a static block", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:27:09Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyNjY4NA==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379626684", "bodyText": "Actually, I\"m pretty comfortable using static blocks.", "author": "gbggrant", "createdAt": "2020-02-14T20:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkzODAxMA==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r387938010", "bodyText": "Done", "author": "gbggrant", "createdAt": "2020-03-04T21:14:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNTAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNjY5Ng==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379606696", "bodyText": "These are opened and never closed, using try-with-resources would fix that, although it's a bit awkward since InfiniumGTCFile itself is not AutoCloseable.", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:30:53Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyODY4Mw==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379628683", "bodyText": "I'm trying to address that in another PR.  At least the NormalizationManifest.  Not going to make InfiniumGTCFile Autocloseable in this PR.  In the interest of making small PRs.", "author": "gbggrant", "createdAt": "2020-02-14T20:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNjY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNzcwNg==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379607706", "bodyText": "The java convention is to put a space after //, it would be nice to update the comments in this file to follow that standard. Also in cases like this, where the comment is a punctuated sentence, it should start with a capital letter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        //report errors and exit 1 if any are detected.\n          \n          \n            \n                        // Report errors and exit 1 if any are detected.", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:33:17Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyNjgxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379626811", "bodyText": "yup.  I blame Jay.", "author": "gbggrant", "createdAt": "2020-02-14T20:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwNzcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwODg3MQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379608871", "bodyText": "It's little confusing that type is used here when this is actually the method name.", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:35:58Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyODcyMg==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379628722", "bodyText": "renamed it.", "author": "gbggrant", "createdAt": "2020-02-14T20:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwODg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwOTc3Mg==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379609772", "bodyText": "These parameters are not necessarily arrays. Maybe Object objectOne, Object objectTwo would be better\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n          \n          \n            \n                private boolean checkNulls(Object objectOne, Object objectTwo, String type) {", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:38:15Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyNjg5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379626895", "bodyText": "renamed.", "author": "gbggrant", "createdAt": "2020-02-14T20:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYwOTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMDgzMQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379610831", "bodyText": "This logic is incorrect. If both are null, a warning will be reported. Unless  you want this to fail if both are null, in that case the error message is ingorrect.", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:40:40Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n+        //if one is null we assume a version mismatch\n+        if (arrayOne == null || arrayTwo == null) {", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyNzM0NQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379627345", "bodyText": "I don't believe that both are null can ever occur, since the methodName list is derived from both input Gtcs.", "author": "gbggrant", "createdAt": "2020-02-14T20:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMDgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMTMxMA==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379611310", "bodyText": "Is the error here a version mismatch or some other kind of error?", "author": "pshapiro4broad", "createdAt": "2020-02-14T19:41:47Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,236 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private List<String> errors = new ArrayList<>();\n+\n+    //ignored methods\n+    private static final List<String> IGNORED_METHODS = new ArrayList<>();\n+\n+    static {\n+        IGNORED_METHODS.add(\"getClass\");\n+        IGNORED_METHODS.add(\"getAutoCallDate\");\n+        IGNORED_METHODS.add(\"getImagingDate\");\n+        //This is the number of TOC entries. It will be different with different versions.\n+        IGNORED_METHODS.add(\"getNumberOfEntries\");\n+        //We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        IGNORED_METHODS.add(\"getSampleName\");\n+        IGNORED_METHODS.add(\"getSamplePlate\");\n+        IGNORED_METHODS.add(\"getSampleWell\");\n+    }\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        try {\n+            InfiniumNormalizationManifest infiniumNormalizationManifest\n+                    = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+            InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+            InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest);\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            //report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (IOException | IllegalAccessException | InvocationTargetException e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        //compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            //skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            //compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                //if we have a version and they don't match we just want a warning\n+                //if getter returns an array compare all array values otherwise do an Object compare.\n+                //if getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String type) {\n+        if (checkNulls(objectOne, objectTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    type, objectOne, objectTwo));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String type) {\n+        if (checkNulls(arrayOne, arrayTwo, type)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, type, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String type, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                //for floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;\n+                    } else {\n+                        BigDecimal decimal1 = BigDecimal.valueOf(float1).setScale(3, BigDecimal.ROUND_DOWN);\n+                        BigDecimal decimal2 = BigDecimal.valueOf(float2).setScale(3, BigDecimal.ROUND_DOWN);\n+                        if (!decimal1.equals(decimal2)) {\n+                            diffCount++;\n+                        }\n+                    }\n+                } else if (!Array.get(arrayOne, i).equals(Array.get(arrayTwo, i))) {\n+                    diffCount++;\n+                }\n+            }\n+        }\n+        return diffCount;\n+    }\n+\n+\n+    private void compareArrayOfArrays(Object arrayOfArraysOne, Object arrayOfArraysTwo, String type) {\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (checkNulls(arrayOfArraysOne, arrayOfArraysTwo, type)) return;\n+\n+        int differences = 0;\n+        int length1 = Array.getLength(arrayOfArraysOne);\n+        int length2 = Array.getLength(arrayOfArraysTwo);\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    type, length1, length2));\n+        } else {\n+            //iterate over the first array\n+            for (int i = 0; i < length1; i++) {\n+                //iterate over the second array\n+                Object innerArrayOne = Array.get(arrayOfArraysOne, i);\n+                Object innerArrayTwo = Array.get(arrayOfArraysTwo, i);\n+                differences += arrayDifferences(innerArrayOne, innerArrayTwo, type, compareErrors);\n+            }\n+            if (differences > 0) {\n+                compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", type, differences));\n+            }\n+        }\n+        checkErrors(type, compareErrors);\n+    }\n+\n+    private void checkErrors(String type, List<String> compareErrors) {\n+        if (compareErrors.size() > 0) {\n+            errors.addAll(compareErrors);\n+        } else {\n+            log.info(type + \" IDENTICAL\");\n+        }\n+    }\n+\n+    private boolean checkNulls(Object arrayOne, Object arrayTwo, String type) {\n+        //if one is null we assume a version mismatch\n+        if (arrayOne == null || arrayTwo == null) {\n+            log.warn(String.format(\"Field %s is not in both files. Version mismatch likely\", type));", "originalCommit": "f0fb17c4ad1f0c23164518ccfb34f49e67039e7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYyNzU1NA==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r379627554", "bodyText": "It's most likely a version mismatch.  They've added a getN in one version that wasn't in the other", "author": "gbggrant", "createdAt": "2020-02-14T20:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYxMTMxMA=="}], "type": "inlineReview"}, {"oid": "1bb9eec9852bbe98cd39680cc35f933b7216ff61", "url": "https://github.com/broadinstitute/picard/commit/1bb9eec9852bbe98cd39680cc35f933b7216ff61", "message": "Code review responses.", "committedDate": "2020-03-04T21:01:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NDIyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1468#discussion_r389794221", "bodyText": "I thought that NaN didn't equal itself but apparently in Java it does?", "author": "pshapiro4broad", "createdAt": "2020-03-09T16:08:46Z", "path": "src/main/java/picard/arrays/illumina/CompareGtcFiles.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package picard.arrays.illumina;\n+\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import org.broadinstitute.barclay.argparser.Argument;\n+import org.broadinstitute.barclay.argparser.CommandLineProgramProperties;\n+import picard.PicardException;\n+import picard.cmdline.CommandLineProgram;\n+import picard.cmdline.StandardOptionDefinitions;\n+\n+import java.io.DataInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * A simple tool to compare two Illumina GTC files.\n+ */\n+\n+@CommandLineProgramProperties(\n+        summary = CompareGtcFiles.USAGE_DETAILS,\n+        oneLineSummary = \"Compares two GTC files.\",\n+        programGroup = picard.cmdline.programgroups.GenotypingArraysProgramGroup.class\n+)\n+public class CompareGtcFiles extends CommandLineProgram {\n+\n+    static final String USAGE_DETAILS =\n+            \"CompareGtcFiles takes two Illumina GTC file and compares their contents to ensure that fields expected to be the same \" +\n+                    \"are in fact the same.  This will exclude any variable field, such as a date. \" +\n+                    \"The GTC files must be generated on the same chip type. \" +\n+                    \"<h4>Usage example:</h4>\" +\n+                    \"<pre>\" +\n+                    \"java -jar picard.jar CompareGtcFiles \\\\<br />\" +\n+                    \"      INPUT=input1.gtc \\\\<br />\" +\n+                    \"      INPUT=input2.gtc \\\\<br />\" +\n+                    \"      ILLUMINA_NORMALIZATION_MANIFEST=chip_name.bpm.csv \\\\<br />\" +\n+                    \"</pre>\";\n+\n+    private static final Log log = Log.getInstance(CompareGtcFiles.class);\n+\n+    @Argument(shortName = StandardOptionDefinitions.INPUT_SHORT_NAME,\n+            doc = \"GTC input files to compare.\",\n+            minElements = 2,\n+            maxElements = 2)\n+    public List<File> INPUT;\n+\n+    @Argument(shortName = \"NORM_MANIFEST\", doc = \"An Illumina bead pool manifest (a manifest containing the Illumina normalization ids) (bpm.csv)\")\n+    public File ILLUMINA_NORMALIZATION_MANIFEST;\n+\n+    private final List<String> errors = new ArrayList<>();\n+\n+    // Ignored methods\n+    private static final List<String> IGNORED_METHODS = Arrays.asList(\n+        \"getClass\",\n+        \"getAutocallDate\",\n+        \"getImagingDate\",\n+        // This is the number of TOC entries. It will be different with different versions.\n+        \"getNumberOfEntries\",\n+        // We don't inject these in our gtcs so they will always be blank and so we don't bother comparing.\n+        \"getSampleName\",\n+        \"getSamplePlate\",\n+        \"getSampleWell\");\n+\n+    @Override\n+    protected int doWork() {\n+        IOUtil.assertFilesAreReadable(INPUT);\n+\n+        InfiniumNormalizationManifest infiniumNormalizationManifest = new InfiniumNormalizationManifest(ILLUMINA_NORMALIZATION_MANIFEST);\n+        try (InfiniumGTCFile gtcFileOne = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(0))), infiniumNormalizationManifest);\n+             InfiniumGTCFile gtcFileTwo = new InfiniumGTCFile(new DataInputStream(new FileInputStream(INPUT.get(1))), infiniumNormalizationManifest)) {\n+            compareGTCFiles(gtcFileOne, gtcFileTwo);\n+\n+            // Report errors and exit 1 if any are detected.\n+            if (!errors.isEmpty()) {\n+                for (String error : errors) {\n+                    log.error(error);\n+                }\n+                return 1;\n+            }\n+        } catch (Exception e) {\n+            throw new PicardException(\"File error: \", e);\n+        }\n+        return 0;\n+    }\n+\n+    private void compareGTCFiles(InfiniumGTCFile gtcFileOne, InfiniumGTCFile gtcFileTwo) throws InvocationTargetException, IllegalAccessException {\n+        // Compare all fields we expect won't change.\n+        Method[] methods = gtcFileOne.getClass().getMethods();\n+        for (Method method : methods) {\n+            // Skip ignored methods.\n+            if (IGNORED_METHODS.contains(method.getName())) {\n+                continue;\n+            }\n+            // Compare all getters\n+            if (method.getName().startsWith(\"get\") && method.getGenericParameterTypes().length == 0) {\n+                // If we have a version and they don't match we just want a warning\n+                // If getter returns an array compare all array values otherwise do an Object compare.\n+                // If getter returns an array of arrays do deep compare\n+                if (method.getName().equals(\"getFileVersion\")) {\n+                    compareVersions(method.invoke(gtcFileOne), method.invoke(gtcFileTwo));\n+                } else if (method.getReturnType().isArray() && method.getReturnType().getComponentType().isArray()) {\n+                    compareArrayOfArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else if (method.getReturnType().isArray()) {\n+                    compareArrays(method.invoke(gtcFileOne), method.invoke(gtcFileTwo),\n+                            method.getName());\n+                } else {\n+                    compare(method.invoke(gtcFileOne),\n+                            method.invoke(gtcFileTwo), method.getName());\n+                }\n+            }\n+        }\n+    }\n+\n+    private void compareVersions(Object versionOne, Object versionTwo) {\n+        if (!versionOne.equals(versionTwo)) {\n+            log.warn(String.format(\"File versions do not match ( %s vs %s )\",\n+                    versionOne, versionTwo));\n+        }\n+    }\n+\n+    private void compare(Object objectOne, Object objectTwo, String methodName) {\n+        if (checkNulls(objectOne, objectTwo, methodName)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+\n+        if (!objectOne.equals(objectTwo)) {\n+            compareErrors.add(String.format(\"%s does not match ( %s vs %s )\",\n+                    methodName, objectOne, objectTwo));\n+        }\n+        checkErrors(methodName, compareErrors);\n+    }\n+\n+    private void compareArrays(Object arrayOne, Object arrayTwo, String methodName) {\n+        if (checkNulls(arrayOne, arrayTwo, methodName)) return;\n+\n+        List<String> compareErrors = new ArrayList<>();\n+        int differences = arrayDifferences(arrayOne, arrayTwo, methodName, compareErrors);\n+        if (differences > 0) {\n+            compareErrors.add(String.format(\"%s do not match. %d elements of the array differ.\", methodName, differences));\n+        }\n+        checkErrors(methodName, compareErrors);\n+    }\n+\n+    private int arrayDifferences(Object arrayOne, Object arrayTwo, String methodName, List<String> compareErrors) {\n+        int length1 = Array.getLength(arrayOne);\n+        int length2 = Array.getLength(arrayTwo);\n+\n+        int diffCount = 0;\n+        if (length1 != length2) {\n+            compareErrors.add(String.format(\"%s do not match. Arrays of different lengths. ( %d vs %d )\",\n+                    methodName, length1, length2));\n+        } else {\n+            for (int i = 0; i < length1; i++) {\n+                // For floats only compare 3 decimal places\n+                if (arrayOne.getClass().getComponentType() == float.class) {\n+                    Float float1 = (float) Array.get(arrayOne, i);\n+                    Float float2 = (float) Array.get(arrayTwo, i);\n+                    if (float1.equals(Float.NaN) || float2.equals(Float.NaN)) {\n+                        if (!float1.equals(float2)) diffCount++;", "originalCommit": "9ab43c2f7118f8adb05fabb1a662457dcc5f73ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "url": "https://github.com/broadinstitute/picard/commit/c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "message": "Ported CompareGtcFiles from Picard private repo\nMade some classes implement AutoCloseable", "committedDate": "2020-03-16T18:21:59Z", "type": "commit"}, {"oid": "c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "url": "https://github.com/broadinstitute/picard/commit/c30afc8b8a40323bcb71fe0d989bfc033bd6b9a5", "message": "Ported CompareGtcFiles from Picard private repo\nMade some classes implement AutoCloseable", "committedDate": "2020-03-16T18:21:59Z", "type": "forcePushed"}]}