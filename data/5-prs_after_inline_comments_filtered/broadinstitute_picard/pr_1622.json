{"pr_number": 1622, "pr_title": "Yf make cram valid input", "pr_createdAt": "2020-12-23T20:07:19Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1622", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE3ODY4Mg==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r561178682", "bodyText": "What's so special about 2016 here?  Why not through 2021?", "author": "gbggrant", "createdAt": "2021-01-20T18:22:04Z", "path": "src/main/java/picard/sam/CleanSam.java", "diffHunk": "@@ -1,7 +1,7 @@\n /*\n  * The MIT License\n  *\n- * Copyright (c) 2010 The Broad Institute\n+ * Copyright (c) 2010 - 2016 The Broad Institute", "originalCommit": "d75a90ccdf0fc03ebe967d890c6eced2cf5018ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjI5NjE5Nw==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r596296197", "bodyText": "goes to show when the code was written...I guess.", "author": "yfarjoun", "createdAt": "2021-03-17T18:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE3ODY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MDY0MA==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605850640", "bodyText": "Should this be File samFile? (and elsewhere)", "author": "gbggrant", "createdAt": "2021-04-01T18:07:15Z", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,", "originalCommit": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY0MDk5MTM4Mw==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r640991383", "bodyText": "sure. elsewhere, in this file? or elsewhere in other files?", "author": "yfarjoun", "createdAt": "2021-05-27T21:46:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MjU4OA==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605852588", "bodyText": "??\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Closes any the open bfq file(s), if any, and opens the new one(s)\n          \n          \n            \n                 * Closes any open bfq file(s), and opens the new one(s)", "author": "gbggrant", "createdAt": "2021-04-01T18:10:45Z", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        this.referenceSequence = referenceSequence;\n+        if (total != null) {\n+            final double writeable = countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public SamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, null, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)", "originalCommit": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1MzAzNw==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605853037", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {\n          \n          \n            \n                    if (!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {", "author": "gbggrant", "createdAt": "2021-04-01T18:11:30Z", "path": "src/main/java/picard/fastq/SamToBfqWriter.java", "diffHunk": "@@ -0,0 +1,447 @@\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in SAM/BAM/CRAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * file having all paired reads together in order.\n+ */\n+public class SamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private final File referenceSequence;\n+    private final boolean pairedReads;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(SamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public SamToBfqWriter(final File bamFile, final File referenceSequence, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        this.referenceSequence = referenceSequence;\n+        if (total != null) {\n+            final double writeable = countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public SamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, null, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)\n+     *\n+     * @param fileIndex the index (counter) of the files to write\n+     */\n+    private void initializeNextBfqFiles(final int fileIndex) {\n+        // Close the codecs if they were writing before\n+        if (codec1 != null) {\n+            codec1.close();\n+            if (pairedReads) {\n+                codec2.close();\n+            }\n+        }\n+\n+        // Open new file, using the fileIndex.\n+        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\n+        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\n+        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\n+        if (pairedReads) {\n+            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\n+            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\n+            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\n+        }\n+    }\n+\n+    /**\n+     * Writes out a SAMRecord in Maq fastq format\n+     *\n+     * @param codec the code to write to\n+     * @param rec   the SAMRecord to write\n+     */\n+    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\n+\n+        // Trim the run barcode off the read name\n+        String readName = rec.getReadName();\n+        if (namePrefix != null && readName.startsWith(namePrefix)) {\n+            readName = readName.substring(nameTrim);\n+        }\n+        // Writes the length of the read name and then the name (null-terminated)\n+        codec.writeString(readName, true, true);\n+\n+        final char[] seqs = rec.getReadString().toCharArray();\n+        final char[] quals = rec.getBaseQualityString().toCharArray();\n+\n+        int retainedLength = seqs.length;\n+        if (clipAdapters){\n+            // adjust to a shorter length iff clipping tag exists\n+            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\n+            if (trimPoint != null) {\n+                ValidationUtils.validateArg(rec.getReadLength() == seqs.length, () -> \"length of read and seqs differ. Found \" + rec.getReadLength() + \" and '\" + seqs.length + \".\");\n+\n+                retainedLength = Math.min(seqs.length, Math.max(SEED_REGION_LENGTH, trimPoint -1));\n+            }\n+        }\n+\n+        // Write the length of the sequence\n+        codec.writeInt(basesToWrite != null ? basesToWrite : seqs.length);\n+\n+        // Calculate and write the sequence and qualities\n+        final byte[] seqsAndQuals = encodeSeqsAndQuals(seqs, quals, retainedLength);\n+        codec.writeBytes(seqsAndQuals);\n+    }\n+\n+    private byte[] encodeSeqsAndQuals(char[] seqs, char[] quals, int retainedLength) {\n+        final byte[] seqsAndQuals = new byte[basesToWrite == null ? seqs.length : basesToWrite];\n+\n+        int seedRegionNoCallFixes = 0;\n+        for (int i = 0; i < retainedLength && i < seqsAndQuals.length; i++) {\n+            int quality = Math.min(quals[i]-33, 63);\n+            final int base;\n+            switch(seqs[i]) {\n+                case 'A':\n+                case 'a':\n+                    base = 0;\n+                    break;\n+                case 'C':\n+                case 'c':\n+                    base = 1;\n+                    break;\n+                case 'G':\n+                case 'g':\n+                    base = 2;\n+                    break;\n+                case 'T':\n+                case 't':\n+                    base = 3;\n+                    break;\n+                case 'N':\n+                case 'n':\n+                case '.':\n+                    base = 0;\n+                    if (i < SEED_REGION_LENGTH ) {\n+                        if (seedRegionNoCallFixes < MAX_SEED_REGION_NOCALL_FIXES) {\n+                            quality = 1;\n+                            seedRegionNoCallFixes++;\n+                        }\n+                        else {\n+                            quality = 0;\n+                        }\n+                    }\n+                    else {\n+                        quality = 1;\n+                    }\n+                    break;\n+                default:\n+                    throw new PicardException(\"Unknown base when writing bfq file: \" + seqs[i]);\n+            }\n+            seqsAndQuals[i] = encodeBaseAndQuality(base, quality);\n+        }\n+        // rewrite clipped adapter with all A's of quality 1\n+        for (int i = retainedLength; i < seqsAndQuals.length; i++) {\n+            seqsAndQuals[i] = encodeBaseAndQuality(0, 1);\n+        }\n+\n+        return seqsAndQuals;\n+    }\n+\n+    private byte encodeBaseAndQuality(int base, int quality) {\n+        return (byte) ((base << 6) | quality);\n+    }\n+\n+    /**\n+     * Count the number of records in the bamFile that could potentially be written\n+     *\n+     * @return  the number of records in the Bam file\n+     */\n+    private int countWritableRecords() {\n+        int count = 0;\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceSequence).open(bamFile);\n+        if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {", "originalCommit": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1NDU1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605854556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static final String USAGE_DETAILS = \"This tool initially compares the headers input files. \" +\n          \n          \n            \n                static final String USAGE_DETAILS = \"This tool initially compares the headers of the input files. \" +\n          \n      \n    \n    \n  \n\n??", "author": "gbggrant", "createdAt": "2021-04-01T18:14:14Z", "path": "src/main/java/picard/sam/CompareSAMs.java", "diffHunk": "@@ -53,8 +53,8 @@\n         programGroup = DiagnosticsAndQCProgramGroup.class)\n @DocumentedFeature\n public class CompareSAMs extends CommandLineProgram {\n-    static final String USAGE_SUMMARY = \"Compare two input \\\".sam\\\" or \\\".bam\\\" files.  \";\n-    static final String USAGE_DETAILS = \"This tool initially compares the headers of SAM or BAM files. \" +\n+    static final String USAGE_SUMMARY = \"Compare two input SAM/BAM/CRAM files.  \";\n+    static final String USAGE_DETAILS = \"This tool initially compares the headers input files. \" +", "originalCommit": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTg1ODkzOA==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r605858938", "bodyText": "spacing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX,index,extension)));\n          \n          \n            \n                                    new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX, index, extension)));", "author": "gbggrant", "createdAt": "2021-04-01T18:21:41Z", "path": "src/main/java/picard/sam/SplitSamByNumberOfReads.java", "diffHunk": "@@ -131,14 +134,16 @@ protected int doWork() {\n         int fileIndex = 1;\n \n         Function<Integer, SAMFileWriter> createWriter = (index) ->\n-                writerFactory.makeSAMOrBAMWriter(header, true, new File(OUTPUT, OUT_PREFIX + \"_\" + String.format(\"%04d\", index) + BamFileIoUtils.BAM_FILE_EXTENSION));\n+                writerFactory.makeSAMOrBAMWriter(header, true,\n+                        new File(OUTPUT, String.format(\"%s_%04d.%s\", OUT_PREFIX,index,extension)));", "originalCommit": "69ea6cd5130a0607bfe3248a4d77ce8587bc43d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2988913f6f59681f26cea997f574a47da4b608e3", "url": "https://github.com/broadinstitute/picard/commit/2988913f6f59681f26cea997f574a47da4b608e3", "message": "- CRAM\n- 2021", "committedDate": "2021-05-28T03:03:35Z", "type": "forcePushed"}, {"oid": "3b1b8feda2b86b6a4766b44481ea59a0b400f347", "url": "https://github.com/broadinstitute/picard/commit/3b1b8feda2b86b6a4766b44481ea59a0b400f347", "message": "Enable cram in more CLPs\n\nfix: #433, #431, #361", "committedDate": "2021-06-29T02:03:04Z", "type": "forcePushed"}, {"oid": "8acd7bfa364ab7a82434ab71dad9f9f71d87afb5", "url": "https://github.com/broadinstitute/picard/commit/8acd7bfa364ab7a82434ab71dad9f9f71d87afb5", "message": "- fixed almost all tests...still one straggler left behind...", "committedDate": "2021-07-27T03:39:11Z", "type": "forcePushed"}, {"oid": "1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39", "url": "https://github.com/broadinstitute/picard/commit/1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39", "message": "- replaced .bai index file with .crai as the cram was a samtools-generated file and according to @cmnbroad this is currently incompatible....", "committedDate": "2021-08-02T17:02:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r682827709", "bodyText": "Should this have a deleteOnExit()?", "author": "gbggrant", "createdAt": "2021-08-04T17:41:22Z", "path": "src/test/java/picard/sam/CramCompatibilityTest.java", "diffHunk": "@@ -0,0 +1,275 @@\n+package picard.sam;\n+\n+import htsjdk.samtools.SamStreams;\n+import htsjdk.samtools.cram.CRAMException;\n+import htsjdk.samtools.util.IOUtil;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import picard.cmdline.CommandLineProgram;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+public class CramCompatibilityTest {\n+\n+    public static final String CRAM_FILE = \"testdata/picard/sam/test_cram_file_coordinate_sorted.cram\";\n+    public static final String CRAM_FILE_2 = \"testdata/picard/sam/test_cram_file_header_only.cram\";\n+    public static final String CRAM_FILE_ONE_PAIR_MC = \"testdata/picard/sam/MarkDuplicates/one_pair_mc.cram\";\n+\n+    public static final String CRAM_FILE_QUERY_SORTED_UNMAPPED = \"testdata/picard/sam/unmapped_queryname_sorted.cram\";\n+    public static final String CRAM_FILE_QUERY_SORTED = \"testdata/picard/sam/test_cram_file_query_sorted.cram\";\n+\n+    public static final String REFERENCE_FILE = \"testdata/picard/sam/test_cram_file.ref.fa\";\n+    public static final String FASTQ_FILE = \"testdata/picard/sam/fastq2bam/fastq-sanger/5k-v1-Rhodobacter_LW1.sam.fastq\";\n+\n+    public static final String CRAM_UNMAPPED = \"testdata/picard/sam/SamFormatConverterTest/unmapped.cram\";\n+    public static final String CRAM_UNMAPPED_WITH_OQ_TAG = \"testdata/picard/sam/unmapped_with_oq_tag.cram\";\n+\n+    public static final String CRAM_UNMAPPED_PART_1 = \"testdata/picard/sam/unmapped_part_1.cram\";\n+    public static final String CRAM_UNMAPPED_PART_2 = \"testdata/picard/sam/unmapped_part_2.cram\";\n+\n+    public static final String CRAM_SPLIT_UNMAPPED = \"testdata/picard/sam/split_test_unmapped.cram\";\n+\n+    public static final String MBA_ALIGNED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.aligned.cram\";\n+    public static final String MBA_UNMAPPED_CRAM = \"testdata/picard/sam/MergeBamAlignment/cliptest.unmapped.cram\";\n+    public static final String MBA_REFERENCE = \"testdata/picard/sam/MergeBamAlignment/cliptest.fasta\";\n+\n+    private static final File outputDir = IOUtil.createTempDir(\"testdata/picard/sam/CramCompatibilityTest\", \".tmp\");\n+\n+    @AfterTest\n+    public void tearDown() {\n+        IOUtil.recursiveDelete(outputDir.toPath());\n+    }\n+\n+    @DataProvider(name = \"programArgsForCRAMWithReference\")\n+    public Object[][] getArgsForCRAMWithReference() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_FILE_QUERY_SORTED, REFERENCE_FILE},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.ReorderSam\",\n+                        \"SEQUENCE_DICTIONARY=\" + REFERENCE_FILE,\n+                        CRAM_FILE,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SetNmMdAndUqTags\", null, CRAM_FILE, REFERENCE_FILE},\n+                {\"picard.sam.MergeBamAlignment\",\n+                        \"UNMAPPED=\" + new File(MBA_UNMAPPED_CRAM).getAbsolutePath() +\n+                        \" ALIGNED=\" + new File(MBA_ALIGNED_CRAM).getAbsolutePath(),\n+                        null,\n+                        MBA_REFERENCE\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                        REFERENCE_FILE\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE, REFERENCE_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithReference\")\n+    public void testShouldWriteCRAMWhenCRAMWithReference(String program,\n+                                                         String parameters,\n+                                                         String cramFile,\n+                                                         String reference) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, reference);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, reference);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    @DataProvider(name  = \"programArgsForCRAMWithoutReferenceToFail\")\n+    public Object[][] getArgsForCRAMWithoutReferenceToFail() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\",\n+                        \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\",\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.CleanSam\", null, CRAM_FILE},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_FILE},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_FILE},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_FILE\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_FILE},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_FILE},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_FILE},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + CRAM_FILE_2, CRAM_FILE},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", null, CRAM_FILE_QUERY_SORTED},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED).getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED\n+                },\n+                {\"picard.sam.markduplicates.MarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"MarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE},\n+                {\"picard.sam.markduplicates.SimpleMarkDuplicatesWithMateCigar\",\n+                        \"M=\" + createTempFile(\"SimpleMarkDuplicatesWithMateCigar\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_ONE_PAIR_MC},\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED,\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_FILE}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsForCRAMWithoutReferenceToFail\", expectedExceptions = {CRAMException.class, IllegalArgumentException.class})\n+    public void testShouldFailWhenCRAMWithoutReference(String program,\n+                                                       String parameters,\n+                                                       String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    // test with CRAMs that don't need reference (unmapped CRAMs for input or output)\n+    @DataProvider(name = \"programArgsWithUnmappedCRAM\")\n+    public Object[][] getArgsWithUnmappedCRAM() {\n+        return new Object[][] {\n+                {\"picard.sam.AddOrReplaceReadGroups\", \"RGID=4 RGLB=lib1 RGPL=illumina RGPU=unit1 RGSM=20\", CRAM_UNMAPPED},\n+                {\"picard.sam.CleanSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.DownsampleSam\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.FixMateInformation\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.markduplicates.MarkDuplicates\",\n+                        \"M=\" + createTempFile(\"MarkDuplicates\", \".dir\").getAbsolutePath(),\n+                        CRAM_UNMAPPED\n+                },\n+                {\"picard.sam.MergeSamFiles\", null, CRAM_UNMAPPED},\n+                {\"picard.sam.PositionBasedDownsampleSam\", \"FRACTION=0.5\", CRAM_UNMAPPED},\n+                {\"picard.sam.SortSam\", \"SORT_ORDER=queryname\", CRAM_UNMAPPED},\n+                {\"picard.sam.ReplaceSamHeader\", \"HEADER=\" + MBA_UNMAPPED_CRAM, CRAM_UNMAPPED},\n+                {\"picard.sam.RevertOriginalBaseQualitiesAndAddMateCigar\", \"CREATE_INDEX=false\", CRAM_UNMAPPED_WITH_OQ_TAG},\n+                {\"picard.sam.GatherBamFiles\",\n+                        \"I=\" + new File(CRAM_UNMAPPED_PART_2).getAbsolutePath(),\n+                        CRAM_UNMAPPED_PART_1\n+                },\n+                {\"picard.sam.FastqToSam\", \"F1=\" + FASTQ_FILE + \" SAMPLE_NAME=s1\", null},\n+                {\"picard.illumina.IlluminaBasecallsToSam\",\n+                        \"BASECALLS_DIR=\" + new File(\"testdata/picard/illumina/25T8B25T/Data/Intensities/BaseCalls\") +\n+                        \" LANE=1 READ_STRUCTURE=25S8S25T RUN_BARCODE=HiMom SAMPLE_ALIAS=HiDad LIBRARY_NAME=HelloWorld SEQUENCING_CENTER=BI\" ,\n+                        null\n+                },\n+                {\"picard.illumina.MarkIlluminaAdapters\",\n+                        \"METRICS=\" + createTempFile(\"picard.illumina.MarkIlluminaAdapters\", \".txt\").getAbsolutePath(),\n+                        CRAM_FILE_QUERY_SORTED_UNMAPPED\n+                },\n+                {\"picard.sam.SplitSamByLibrary\", null, CRAM_SPLIT_UNMAPPED}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"programArgsWithUnmappedCRAM\")\n+    public void testShouldWriteCRAMWhenUnmappedCRAMWithoutReference(String program,\n+                                                                    String parameters,\n+                                                                    String cramFile) throws IOException, IllegalAccessException, InstantiationException, ClassNotFoundException {\n+        if (!program.equals(\"picard.sam.SplitSamByLibrary\")) {\n+            final File outputFile = createTempCram(program);\n+            launchProgram(program, cramFile, outputFile.getAbsolutePath(), parameters, null);\n+            assertCRAM(outputFile);\n+        } else {\n+            final File tmpDir = IOUtil.createTempDir(outputDir.getAbsolutePath(), program);\n+            launchProgram(program, cramFile, tmpDir.getAbsolutePath(), parameters, null);\n+            assertCRAMs(tmpDir);\n+        }\n+    }\n+\n+    private File createTempCram(String name) throws IOException {\n+        return createTempFile(name, \".cram\");", "originalCommit": "1a472ba6e47bb5ef4af461b1fa3ebd00eebb7a39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4Mjk5NTU4MA==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r682995580", "bodyText": "isn't it 2 7 lines below?", "author": "yfarjoun", "createdAt": "2021-08-04T22:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MzA3NTIzOQ==", "url": "https://github.com/broadinstitute/picard/pull/1622#discussion_r683075239", "bodyText": "Yes.", "author": "gbggrant", "createdAt": "2021-08-05T02:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4MjgyNzcwOQ=="}], "type": "inlineReview"}, {"oid": "1ec0fc2f37b5a310ee8f304ba5f2a4170ff282d4", "url": "https://github.com/broadinstitute/picard/commit/1ec0fc2f37b5a310ee8f304ba5f2a4170ff282d4", "message": "Enable cram in more CLPs\n\nfix: #433, #431, #361", "committedDate": "2021-08-04T22:21:15Z", "type": "commit"}, {"oid": "322ab41e46e7a3b1ba0d456a462a7cd631b3c9fa", "url": "https://github.com/broadinstitute/picard/commit/322ab41e46e7a3b1ba0d456a462a7cd631b3c9fa", "message": "- fixed almost all tests...still one straggler left behind...", "committedDate": "2021-08-04T22:21:15Z", "type": "commit"}, {"oid": "653ce90d9bf87ed4bad3e1538d7c6e2870dde700", "url": "https://github.com/broadinstitute/picard/commit/653ce90d9bf87ed4bad3e1538d7c6e2870dde700", "message": "- fixed almost all tests...still one straggler left behind...", "committedDate": "2021-08-04T22:21:15Z", "type": "commit"}, {"oid": "ac4160439b3703bb307607303233570de67e937b", "url": "https://github.com/broadinstitute/picard/commit/ac4160439b3703bb307607303233570de67e937b", "message": "- replaced .bai index file with .crai as the cram was a samtools-generated file and according to @cmnbroad this is currently incompatible....", "committedDate": "2021-08-04T22:21:15Z", "type": "commit"}, {"oid": "ac4160439b3703bb307607303233570de67e937b", "url": "https://github.com/broadinstitute/picard/commit/ac4160439b3703bb307607303233570de67e937b", "message": "- replaced .bai index file with .crai as the cram was a samtools-generated file and according to @cmnbroad this is currently incompatible....", "committedDate": "2021-08-04T22:21:15Z", "type": "forcePushed"}]}