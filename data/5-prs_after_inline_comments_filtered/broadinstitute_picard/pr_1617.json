{"pr_number": 1617, "pr_title": "Add optional mapping quality concordance feature to CompareSAMs", "pr_createdAt": "2020-12-02T14:02:20Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1617", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE4ODQ0Mw==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r561188443", "bodyText": "Might want to add a:\nIOUtil.assertFileIsWritable(samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE);\nbefore the call to generate the concordance report (in order to fail fast if there's a problem writing the file).", "author": "gbggrant", "createdAt": "2021-01-20T18:37:34Z", "path": "src/main/java/picard/sam/CompareSAMs.java", "diffHunk": "@@ -118,6 +118,9 @@ protected int doWork() {\n             if (OUTPUT != null) {\n                 comparison.writeReport(OUTPUT, getDefaultHeaders());\n             }\n+            if (samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE != null) {\n+                comparison.writeMQConcordanceReport(samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE, getDefaultHeaders());", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTE5MTYxMA==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r561191610", "bodyText": "Please deleteOnExit() any temp files created by the test.", "author": "gbggrant", "createdAt": "2021-01-20T18:42:50Z", "path": "src/test/java/picard/sam/CompareSAMsTest.java", "diffHunk": "@@ -120,4 +125,77 @@ public void testComparisons(final String f1, final String f2, final ArrayList<St\n         Assert.assertEquals(metricsOutput.getMetrics().get(1).LEFT_FILE, in2);\n         Assert.assertEquals(metricsOutput.getMetrics().get(1).RIGHT_FILE, in1);\n     }\n+\n+    @DataProvider(name=\"compareSamsMQConcordance\")\n+    public Object[][] compareSamsMQConcordanceTestData() {\n+        return new Object[][] {\n+                {\"genomic_sorted.sam\", \"unsorted.sam\", null},\n+                {\"genomic_sorted.sam\", \"chr21.sam\", null},\n+                {\"genomic_sorted.sam\", \"bigger_seq_dict.sam\", null},\n+                {\"genomic_sorted.sam\", \"genomic_sorted.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"has_non_primary.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted_5.sam\", \"genomic_sorted_5_plus.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 4}}},\n+                {\"group_same_coord.sam\", \"group_same_coord_diff_order.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 2}}},\n+                {\"genomic_sorted_same_position.sam\", \"genomic_sorted_same_position.sam\", new Object[][] { {\"0,0\", 2}}},\n+                {\"group_same_coord.sam\", \"diff_coords.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 4}}},\n+                {\"genomic_sorted.sam\", \"unmapped_first.sam\", new Object[][] { {\"20,0\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"unmapped_second.sam\", new Object[][] { {\"30,0\", 1}, {\"20,20\", 1}}},\n+                {\"unmapped_first.sam\", \"unmapped_second.sam\", new Object[][] { {\"0,20\", 1}, {\"30,0\", 1}}},\n+                {\"unmapped_first.sam\", \"unmapped_first.sam\", new Object[][] { {\"0,0\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"genomic_sorted_sam_v1.6.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"unsorted.sam\", \"unsorted.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"unsorted.sam\", \"unsorted2.sam\", new Object[][] { {\"20,20\", 1}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_strict.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_lenient_one_align_differ.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_two_mismatch_lenient.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_lenient.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_strict.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_strict_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_lenient_one_align_differ_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_two_mismatch_lenient_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_lenient_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_strict_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"genomic_sorted.sam\", \"mq0_2.sam\", new Object[][] { {\"20,0\", 1}, {\"30,30\", 1}}},\n+                {\"mq0_1.sam\", \"mq0_2.sam\", new Object[][] { {\"0,0\", 1}, {\"30,30\", 1}}}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"compareSamsMQConcordance\")\n+    public void testMQConcordance(final String f1, final String f2, final Object[][] expectedMQConcordance) throws IOException {\n+        final Path tmpOutput = Files.createTempFile(\"compareSam\", \".tsv\");\n+        final Path tmpMQConcordanceOutput = Files.createTempFile(\"compareSam.mqconcordance\", \".tsv\");", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0MzgxNA==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562143814", "bodyText": "does this histogram really need to be written out to a separate file?  Can't it just be added to the main metrics output?", "author": "kachulis", "createdAt": "2021-01-21T19:30:33Z", "path": "src/main/java/picard/sam/util/SamComparison.java", "diffHunk": "@@ -72,6 +75,16 @@ public void writeReport(final File output, final List<Header> headers) {\n         comparisonMetricFile.write(output);\n     }\n \n+    public void writeMQConcordanceReport(final File output, final List<Header> headers) {", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0NzM1NQ==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562147355", "bodyText": "this doesn't need a separate message.  Stating that the alignments cannot be compared (above) covers that the mapping qualities of the alignments aren't being compared.", "author": "kachulis", "createdAt": "2021-01-21T19:37:04Z", "path": "src/main/java/picard/sam/util/SamComparison.java", "diffHunk": "@@ -155,12 +168,18 @@ private boolean compareAlignmentsAndCatalogDuplicateMarkingDifferences() {\n         if (!compareValues(leftReader.getFileHeader().getSortOrder(), rightReader.getFileHeader().getSortOrder(),\n                 \"Sort Order\")) {\n             System.out.println(\"Cannot compare alignments if sort orders differ.\");\n+            if (samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE != null) {", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE0OTkxNw==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562149917", "bodyText": "I don't think creating a pair object and using its toString method is the best way to  generate this string.  Just build the string yourself instead.  You can write a one line method for it for clarity.", "author": "kachulis", "createdAt": "2021-01-21T19:41:45Z", "path": "src/main/java/picard/sam/util/SamComparison.java", "diffHunk": "@@ -397,6 +416,10 @@ private boolean alignmentsMatch(final SAMRecord s1, final SAMRecord s2) {\n                 (samComparisonArgumentCollection.LENIENT_UNKNOWN_MQ_ALIGNMENT && s1.getMappingQuality() == SAMRecord.UNKNOWN_MAPPING_QUALITY && s2.getMappingQuality() == SAMRecord.UNKNOWN_MAPPING_QUALITY));\n     }\n \n+    private void compareAndUpdateMappingQualityConcordance(final SAMRecord s1, final SAMRecord s2) {\n+        mappingQualityHistogram.increment(new Pair<>(s1.getMappingQuality(), s2.getMappingQuality()).toString());", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MDExMw==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562150113", "bodyText": "don't need separate output.", "author": "kachulis", "createdAt": "2021-01-21T19:42:09Z", "path": "src/main/java/picard/sam/util/SamComparison.java", "diffHunk": "@@ -407,6 +430,10 @@ private void tallyAlignmentRecords(final SAMRecord s1, final SAMRecord s2) {\n         catalogDuplicateDifferences(s1, s2);\n         final AlignmentComparison comp = compareAlignmentRecords(s1, s2);\n         comparisonMetric.updateMetric(comp);\n+\n+        if (samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE != null) {", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1MjQwMg==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562152402", "bodyText": "the tool shouldn't throw exception in this case, but in future you can replace this pattern with Assert.assertThrows", "author": "kachulis", "createdAt": "2021-01-21T19:46:18Z", "path": "src/test/java/picard/sam/CompareSAMsTest.java", "diffHunk": "@@ -120,4 +125,77 @@ public void testComparisons(final String f1, final String f2, final ArrayList<St\n         Assert.assertEquals(metricsOutput.getMetrics().get(1).LEFT_FILE, in2);\n         Assert.assertEquals(metricsOutput.getMetrics().get(1).RIGHT_FILE, in1);\n     }\n+\n+    @DataProvider(name=\"compareSamsMQConcordance\")\n+    public Object[][] compareSamsMQConcordanceTestData() {\n+        return new Object[][] {\n+                {\"genomic_sorted.sam\", \"unsorted.sam\", null},\n+                {\"genomic_sorted.sam\", \"chr21.sam\", null},\n+                {\"genomic_sorted.sam\", \"bigger_seq_dict.sam\", null},\n+                {\"genomic_sorted.sam\", \"genomic_sorted.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"has_non_primary.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted_5.sam\", \"genomic_sorted_5_plus.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 4}}},\n+                {\"group_same_coord.sam\", \"group_same_coord_diff_order.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 2}}},\n+                {\"genomic_sorted_same_position.sam\", \"genomic_sorted_same_position.sam\", new Object[][] { {\"0,0\", 2}}},\n+                {\"group_same_coord.sam\", \"diff_coords.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 4}}},\n+                {\"genomic_sorted.sam\", \"unmapped_first.sam\", new Object[][] { {\"20,0\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"unmapped_second.sam\", new Object[][] { {\"30,0\", 1}, {\"20,20\", 1}}},\n+                {\"unmapped_first.sam\", \"unmapped_second.sam\", new Object[][] { {\"0,20\", 1}, {\"30,0\", 1}}},\n+                {\"unmapped_first.sam\", \"unmapped_first.sam\", new Object[][] { {\"0,0\", 1}, {\"30,30\", 1}}},\n+                {\"genomic_sorted.sam\", \"genomic_sorted_sam_v1.6.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"unsorted.sam\", \"unsorted.sam\", new Object[][] { {\"20,20\", 1}, {\"30,30\", 1}}},\n+                {\"unsorted.sam\", \"unsorted2.sam\", new Object[][] { {\"20,20\", 1}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_strict.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_lenient_one_align_differ.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_two_mismatch_lenient.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_lenient.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base.sam\", \"duplicate_four_mismatch_strict.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_strict_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_lenient_one_align_differ_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_two_mismatch_lenient_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_lenient_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"duplicate_base_queryname.sam\", \"duplicate_four_mismatch_strict_queryname.sam\", new Object[][] { {\"20,20\", 2}, {\"30,30\", 12}}},\n+                {\"genomic_sorted.sam\", \"mq0_2.sam\", new Object[][] { {\"20,0\", 1}, {\"30,30\", 1}}},\n+                {\"mq0_1.sam\", \"mq0_2.sam\", new Object[][] { {\"0,0\", 1}, {\"30,30\", 1}}}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"compareSamsMQConcordance\")\n+    public void testMQConcordance(final String f1, final String f2, final Object[][] expectedMQConcordance) throws IOException {\n+        final Path tmpOutput = Files.createTempFile(\"compareSam\", \".tsv\");\n+        final Path tmpMQConcordanceOutput = Files.createTempFile(\"compareSam.mqconcordance\", \".tsv\");\n+        final String in1 = new File(TEST_FILES_DIR, f1).getAbsolutePath();\n+        final String in2 = new File(TEST_FILES_DIR, f2).getAbsolutePath();\n+        final ArrayList<String> commandArgs = new ArrayList<>(\n+                Arrays.asList(\n+                        in1,\n+                        in2,\n+                        \"O=\" + tmpOutput,\n+                        \"OUTPUT_MQ_CONCORDANCE=\" + tmpMQConcordanceOutput\n+                )\n+        );\n+        // If the files cannot be compared (e.g. if their sort order differs) we expect an exception to be thrown.\n+        if (expectedMQConcordance == null) {", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjE1NDU0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562154541", "bodyText": "don't throw an exception.  we want the tool to run successfully and return that the SAM files are different in this case.", "author": "kachulis", "createdAt": "2021-01-21T19:49:46Z", "path": "src/main/java/picard/sam/util/SamComparison.java", "diffHunk": "@@ -155,12 +168,18 @@ private boolean compareAlignmentsAndCatalogDuplicateMarkingDifferences() {\n         if (!compareValues(leftReader.getFileHeader().getSortOrder(), rightReader.getFileHeader().getSortOrder(),\n                 \"Sort Order\")) {\n             System.out.println(\"Cannot compare alignments if sort orders differ.\");\n+            if (samComparisonArgumentCollection.OUTPUT_MQ_CONCORDANCE != null) {\n+                throw new PicardException(\"Cannot generate mapping quality concordance histogram because the two files cannot be compared (see reason above).\");", "originalCommit": "00c2851668345663e39ab393ca2fde3eb0c83a3e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "89460cd441f5f8e6bfb8a15d01a4b16b5b4647dd", "url": "https://github.com/broadinstitute/picard/commit/89460cd441f5f8e6bfb8a15d01a4b16b5b4647dd", "message": "Added mapping quality concordance functionality to CompareSAMs\n\n- If the argument COMPARE_MQ is set to true, CompareSAMs will produce a histogram that reflects concordance of mapping qualities between two alignment files.\n- Added saparate tests for all CompareSAM test cases to check the mapping quality concordance.", "committedDate": "2021-01-22T13:23:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0NTMyOQ==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562845329", "bodyText": "unused", "author": "kachulis", "createdAt": "2021-01-22T19:02:15Z", "path": "src/test/java/picard/sam/CompareSAMsTest.java", "diffHunk": "@@ -24,18 +24,21 @@\n package picard.sam;\n \n import htsjdk.samtools.metrics.MetricsFile;\n+import htsjdk.samtools.util.Histogram;\n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Test;\n+import picard.PicardException;", "originalCommit": "89460cd441f5f8e6bfb8a15d01a4b16b5b4647dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjg0NTc5Ng==", "url": "https://github.com/broadinstitute/picard/pull/1617#discussion_r562845796", "bodyText": "unused", "author": "kachulis", "createdAt": "2021-01-22T19:03:15Z", "path": "src/main/java/picard/sam/util/SAMComparisonArgumentCollection.java", "diffHunk": "@@ -3,6 +3,8 @@\n import org.broadinstitute.barclay.argparser.Argument;\n import org.broadinstitute.barclay.argparser.ArgumentCollection;\n \n+import java.io.File;", "originalCommit": "89460cd441f5f8e6bfb8a15d01a4b16b5b4647dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eddd97210c197fd4fc411c67f809a48244e446ab", "url": "https://github.com/broadinstitute/picard/commit/eddd97210c197fd4fc411c67f809a48244e446ab", "message": "Added mapping quality concordance functionality to CompareSAMs\n\n- If the argument COMPARE_MQ is set to true, CompareSAMs will produce a histogram that reflects concordance of mapping qualities between two alignment files.\n- Added saparate tests for all CompareSAM test cases to check the mapping quality concordance.", "committedDate": "2021-01-25T10:28:54Z", "type": "forcePushed"}, {"oid": "5db820becde2a042b1c4c52e67d5e3816eced211", "url": "https://github.com/broadinstitute/picard/commit/5db820becde2a042b1c4c52e67d5e3816eced211", "message": "Added mapping quality concordance functionality to CompareSAMs\n\n- If the argument COMPARE_MQ is set to true, CompareSAMs will produce a histogram that reflects concordance of mapping qualities between two alignment files.\n- Added saparate tests for all CompareSAM test cases to check the mapping quality concordance.", "committedDate": "2021-01-25T11:18:01Z", "type": "forcePushed"}, {"oid": "367195c3da5ce24f5373e15cc8e990675e575257", "url": "https://github.com/broadinstitute/picard/commit/367195c3da5ce24f5373e15cc8e990675e575257", "message": "Added mapping quality concordance functionality to CompareSAMs\n\n- If the argument COMPARE_MQ is set to true, CompareSAMs will produce a histogram that reflects concordance of mapping qualities between two alignment files.\n- Added saparate tests for all CompareSAM test cases to check the mapping quality concordance.", "committedDate": "2021-01-25T11:54:02Z", "type": "commit"}, {"oid": "367195c3da5ce24f5373e15cc8e990675e575257", "url": "https://github.com/broadinstitute/picard/commit/367195c3da5ce24f5373e15cc8e990675e575257", "message": "Added mapping quality concordance functionality to CompareSAMs\n\n- If the argument COMPARE_MQ is set to true, CompareSAMs will produce a histogram that reflects concordance of mapping qualities between two alignment files.\n- Added saparate tests for all CompareSAM test cases to check the mapping quality concordance.", "committedDate": "2021-01-25T11:54:02Z", "type": "forcePushed"}]}