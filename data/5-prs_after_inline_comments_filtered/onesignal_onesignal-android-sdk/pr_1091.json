{"pr_number": 1091, "pr_title": "Single Worker for notification processing and foreground handlers", "pr_createdAt": "2020-07-13T20:27:57Z", "pr_url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458155451", "bodyText": "can we use Log.i  instead of sysout", "author": "Jeasmine", "createdAt": "2020-07-21T14:47:06Z", "path": "Examples/OneSignalDemo/app/src/main/java/com/onesignal/sdktest/notification/AppNotificationExtensionService.java", "diffHunk": "@@ -1,43 +1,50 @@\n package com.onesignal.sdktest.notification;\n \n+import android.content.Context;\n+\n import androidx.core.app.NotificationCompat;\n \n-import com.onesignal.NotificationExtenderService;\n+import com.onesignal.OSNotificationDisplayedResult;\n+import com.onesignal.OSNotificationExtender;\n import com.onesignal.OSNotificationGenerationJob.ExtNotificationGenerationJob;\n import com.onesignal.OSNotificationOpenResult;\n import com.onesignal.OSNotificationPayload;\n-import com.onesignal.OSNotificationReceivedResult;\n+import com.onesignal.OSNotificationReceived;\n import com.onesignal.OneSignal;\n import com.onesignal.sdktest.R;\n \n-public class AppNotificationExtenderService extends NotificationExtenderService implements\n+public class AppNotificationExtensionService implements\n+        OneSignal.NotificationProcessingHandler,\n         OneSignal.ExtNotificationWillShowInForegroundHandler,\n         OneSignal.NotificationOpenedHandler {\n \n    @Override\n-   protected boolean onNotificationProcessing(OSNotificationReceivedResult notification) {\n+   public void notificationProcessing(Context context, OSNotificationReceived notification) {\n       if (notification.payload.actionButtons != null) {\n          for (OSNotificationPayload.ActionButton button : notification.payload.actionButtons) {\n             System.out.println(\"button:\" + button.toString());\n          }\n       }\n \n-      OverrideSettings overrideSettings = new NotificationExtenderService.OverrideSettings();\n+      OSNotificationExtender.OverrideSettings overrideSettings = new OSNotificationExtender.OverrideSettings();\n       overrideSettings.extender = new NotificationCompat.Extender() {\n          @Override\n          public NotificationCompat.Builder extend(NotificationCompat.Builder builder) {\n-            return builder.setColor(getResources().getColor(R.color.colorPrimary));\n+            return builder.setColor(context.getResources().getColor(R.color.colorPrimary));\n          }\n       };\n \n-      displayNotification(overrideSettings);\n+      notification.setModifiedContent(overrideSettings);\n+\n+      OSNotificationDisplayedResult notificationDisplayedResult = notification.display();\n+      System.out.println(\"Android notification id: \" + notificationDisplayedResult.androidNotificationId);", "originalCommit": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2MzAzMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467163033", "bodyText": "This is just demo app but yes we can replace sysout with Log.i", "author": "mikechoch", "createdAt": "2020-08-07T17:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NTMyMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467165323", "bodyText": "Fixed!", "author": "mikechoch", "createdAt": "2020-08-07T17:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE1NTQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MDgwMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458160803", "bodyText": "remove extra enters", "author": "Jeasmine", "createdAt": "2020-07-21T14:53:58Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java", "diffHunk": "@@ -59,534 +58,530 @@\n  * */\n class NotificationBundleProcessor {\n \n-   public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n+    public static final String PUSH_ADDITIONAL_DATA_KEY = \"a\";\n \n-   public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n-   public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n-   public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n-   public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n+    public static final String PUSH_MINIFIED_BUTTONS_LIST = \"o\";\n+    public static final String PUSH_MINIFIED_BUTTON_ID = \"i\";\n+    public static final String PUSH_MINIFIED_BUTTON_TEXT = \"n\";\n+    public static final String PUSH_MINIFIED_BUTTON_ICON = \"p\";\n \n-   private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n-   static final String DEFAULT_ACTION = \"__DEFAULT__\";\n+    private static final String IAM_PREVIEW_KEY = \"os_in_app_message_preview_id\";\n+    static final String DEFAULT_ACTION = \"__DEFAULT__\";\n \n-   static void ProcessFromFCMIntentService(Context context, BundleCompat bundle, NotificationExtenderService.OverrideSettings overrideSettings) {\n-      OneSignal.setAppContext(context);\n-      try {\n-         String jsonStrPayload = bundle.getString(\"json_payload\");\n-         if (jsonStrPayload == null) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n-            return;\n-         }\n+    static void processFromFCMIntentService(Context context, BundleCompat bundle, OSNotificationExtender.OverrideSettings overrideSettings) {\n+        OneSignal.setAppContext(context);\n+        try {\n+            String jsonStrPayload = bundle.getString(\"json_payload\");\n+            if (jsonStrPayload == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"json_payload key is nonexistent from mBundle passed to ProcessFromFCMIntentService: \" + bundle);\n+                return;\n+            }\n \n-         OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-         notifJob.isRestoring = bundle.getBoolean(\"restoring\", false);\n-         notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n-         notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n-         notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+            OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n+            notifJob.jsonPayload = new JSONObject(jsonStrPayload);\n+            notifJob.isRestoring = bundle.getBoolean(\"is_restoring\", false);\n+            notifJob.shownTimeStamp = bundle.getLong(\"timestamp\");\n+            notifJob.isIamPreview = inAppPreviewPushUUID(notifJob.jsonPayload) != null;\n+\n+            if (!notifJob.isRestoring &&\n+                    !notifJob.isIamPreview &&\n+                    OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n+                return;\n+\n+            if (bundle.containsKey(\"android_notif_id\")) {\n+                if (overrideSettings == null)\n+                    overrideSettings = new OSNotificationExtender.OverrideSettings();\n+                overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n+            }\n \n-         if (!notifJob.isRestoring &&\n-             !notifJob.isIamPreview &&\n-             OneSignal.notValidOrDuplicated(context, notifJob.jsonPayload))\n-            return;\n+            notifJob.overrideSettings = overrideSettings;\n+            processJobForDisplay(notifJob);\n \n-         if (bundle.containsKey(\"android_notif_id\")) {\n-            if (overrideSettings == null)\n-               overrideSettings = new NotificationExtenderService.OverrideSettings();\n-            overrideSettings.androidNotificationId = bundle.getInt(\"android_notif_id\");\n-         }\n-         \n-         notifJob.overrideSettings = overrideSettings;\n-         ProcessJobForDisplay(notifJob);\n-\n-         // Delay to prevent CPU spikes.\n-         //    Normally more than one notification is restored at a time.\n-         if (notifJob.isRestoring)\n-            OSUtils.sleep(100);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+            // Delay to prevent CPU spikes.\n+            //    Normally more than one notification is restored at a time.\n+            if (notifJob.isRestoring)\n+                OSUtils.sleep(100);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n     /**\n      * Recommended method to process notification before displaying\n-     * Only use the {@link NotificationBundleProcessor#ProcessJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n+     * Only use the {@link NotificationBundleProcessor#processJobForDisplay(OSNotificationGenerationJob, boolean, boolean)}\n      *     in the event where you want to mark a notification as opened or displayed different than the defaults\n      */\n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob) {\n-        return ProcessJobForDisplay(notifJob, false, true);\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob) {\n+        return processJobForDisplay(notifJob, false, true);\n     }\n \n-    static int ProcessJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n+    static int processJobForDisplay(OSNotificationGenerationJob notifJob, boolean opened, boolean displayed) {\n         processCollapseKey(notifJob);\n \n+        int androidNotifId = notifJob.getAndroidIdWithoutCreate();\n         boolean doDisplay = shouldDisplayNotif(notifJob);\n-        if (doDisplay)\n+        if (doDisplay) {\n+            androidNotifId = notifJob.getAndroidId();\n             OneSignal.fireNotificationWillShowInForegroundHandlers(notifJob);\n+        }\n \n         if (!notifJob.isRestoring && !notifJob.isIamPreview) {\n             processNotification(notifJob, opened);\n             OneSignal.handleNotificationReceived(notifJob, displayed);\n         }\n \n-        return notifJob.getAndroidIdWithoutCreate();\n+        return androidNotifId;\n+    }\n+\n+    private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n+        // Validate that the current Android device is Android 4.4 or higher and the current job is a\n+        //    preview push\n+        if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n+            return false;\n+\n+        // Otherwise, this is a normal notification and should be shown\n+        return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n+    }\n+\n+    /**\n+     * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n+     */\n+    static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n+        saveNotification(notifJob, opened);\n+\n+        if (!notifJob.isNotificationToDisplay())\n+            return;\n+\n+        String notificationId = notifJob.getApiNotificationId();\n+        OneSignal.getSessionManager().onNotificationReceived(notificationId);\n+        OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n+    }\n+\n+    // Saving the notification provides the following:\n+    //   * Prevent duplicates\n+    //   * Build summary notifications\n+    //   * Collapse key / id support - Used to lookup the android notification id later\n+    //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n+    //   * Future - Public API to get a list of notifications\n+    private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n+        Context context = notifiJob.context;\n+        JSONObject jsonPayload = notifiJob.jsonPayload;\n+\n+        try {\n+            JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n+\n+            OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+            SQLiteDatabase writableDb = null;\n+\n+            try {\n+                writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n+\n+                writableDb.beginTransaction();\n+\n+                // Count any notifications with duplicated android notification ids as dismissed.\n+                // -1 is used to note never displayed\n+                if (notifiJob.isNotificationToDisplay()) {\n+                    String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+                    ContentValues values = new ContentValues();\n+                    values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+                    writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+                    BadgeCountUpdater.update(writableDb, context);\n+                }\n+\n+                // Save just received notification to DB\n+                ContentValues values = new ContentValues();\n+                values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n+                if (jsonPayload.has(\"grp\"))\n+                    values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n+                if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n+                    values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n+\n+                values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n+                if (!opened)\n+                    values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n+\n+                if (notifiJob.getTitle() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n+                if (notifiJob.getBody() != null)\n+                    values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n+\n+                // Set expire_time\n+                long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n+                int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n+                long expireTime = sentTime + ttl;\n+                values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n+\n+                values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n+\n+                writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n+\n+                if (!opened)\n+                    BadgeCountUpdater.update(writableDb, context);\n+                writableDb.setTransactionSuccessful();\n+            } catch (Exception e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n+            } finally {\n+                if (writableDb != null) {\n+                    try {\n+                        writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                    } catch (Throwable t) {\n+                        OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                    }\n+                }\n+            }\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n     }\n \n-   private static boolean shouldDisplayNotif(OSNotificationGenerationJob notifJob) {\n-      // Validate that the current Android device is Android 4.4 or higher and the current job is a\n-      //    preview push\n-      if (notifJob.isIamPreview && Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR2)\n-         return false;\n-\n-      // Otherwise, this is a normal notification and should be shown\n-      return notifJob.hasExtender() || shouldDisplay(notifJob.jsonPayload.optString(\"alert\"));\n-   }\n-\n-   private static JSONArray bundleAsJsonArray(Bundle bundle) {\n-      JSONArray jsonArray = new JSONArray();\n-      jsonArray.put(bundleAsJSONObject(bundle));\n-      return jsonArray;\n-   }\n-\n-   private static OSNotificationGenerationJob saveAndProcessNotification(Context context, Bundle bundle, boolean opened, int notificationId) {\n-      OSNotificationGenerationJob notifJob = new OSNotificationGenerationJob(context);\n-      notifJob.jsonPayload = bundleAsJSONObject(bundle);\n-      notifJob.overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      notifJob.overrideSettings.androidNotificationId = notificationId;\n-\n-      processNotification(notifJob, opened);\n-\n-      return notifJob;\n-   }\n-\n-   /**\n-    * Save notification, updates Outcomes, and sends Received Receipt if they are enabled.\n-    */\n-   static void processNotification(OSNotificationGenerationJob notifJob, boolean opened) {\n-      saveNotification(notifJob, opened);\n-\n-      if (!notifJob.isNotificationToDisplay())\n-         return;\n-\n-      String notificationId = notifJob.getApiNotificationId();\n-      OneSignal.getSessionManager().onNotificationReceived(notificationId);\n-      OSReceiveReceiptController.getInstance().sendReceiveReceipt(notificationId);\n-   }\n-\n-   // Saving the notification provides the following:\n-   //   * Prevent duplicates\n-   //   * Build summary notifications\n-   //   * Collapse key / id support - Used to lookup the android notification id later\n-   //   * Redisplay notifications after reboot, upgrade of app, or cold boot after a force kill.\n-   //   * Future - Public API to get a list of notifications\n-   private static void saveNotification(OSNotificationGenerationJob notifiJob, boolean opened) {\n-      Context context = notifiJob.context;\n-      JSONObject jsonPayload = notifiJob.jsonPayload;\n-      \n-      try {\n-         JSONObject customJSON = getCustomJSONObject(notifiJob.jsonPayload);\n-   \n-         OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-         SQLiteDatabase writableDb = null;\n-\n-         try {\n+    static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n+        if (notifiJob.getAndroidIdWithoutCreate() == -1)\n+            return;\n+\n+        String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+\n+        OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n+        SQLiteDatabase writableDb = null;\n+\n+        try {\n             writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-   \n             writableDb.beginTransaction();\n-            \n-            // Count any notifications with duplicated android notification ids as dismissed.\n-            // -1 is used to note never displayed\n-            if (notifiJob.isNotificationToDisplay()) {\n-               String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n-   \n-               ContentValues values = new ContentValues();\n-               values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n-   \n-               writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-               BadgeCountUpdater.update(writableDb, context);\n-            }\n \n-            // Save just received notification to DB\n             ContentValues values = new ContentValues();\n-            values.put(NotificationTable.COLUMN_NAME_NOTIFICATION_ID, customJSON.optString(\"i\"));\n-            if (jsonPayload.has(\"grp\"))\n-               values.put(NotificationTable.COLUMN_NAME_GROUP_ID, jsonPayload.optString(\"grp\"));\n-            if (jsonPayload.has(\"collapse_key\") && !\"do_not_collapse\".equals(jsonPayload.optString(\"collapse_key\")))\n-               values.put(NotificationTable.COLUMN_NAME_COLLAPSE_ID, jsonPayload.optString(\"collapse_key\"));\n-\n-            values.put(NotificationTable.COLUMN_NAME_OPENED, opened ? 1 : 0);\n-            if (!opened)\n-               values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, notifiJob.getAndroidIdWithoutCreate());\n-            \n-            if (notifiJob.getTitle() != null)\n-               values.put(NotificationTable.COLUMN_NAME_TITLE, notifiJob.getTitle().toString());\n-            if (notifiJob.getBody() != null)\n-               values.put(NotificationTable.COLUMN_NAME_MESSAGE, notifiJob.getBody().toString());\n-\n-            // Set expire_time\n-            long sentTime = jsonPayload.optLong(\"google.sent_time\", SystemClock.currentThreadTimeMillis()) / 1_000L;\n-            int ttl = jsonPayload.optInt(\"google.ttl\", NotificationRestorer.DEFAULT_TTL_IF_NOT_IN_PAYLOAD);\n-            long expireTime = sentTime + ttl;\n-            values.put(NotificationTable.COLUMN_NAME_EXPIRE_TIME, expireTime);\n-\n-            values.put(NotificationTable.COLUMN_NAME_FULL_DATA, jsonPayload.toString());\n-\n-            writableDb.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n-\n-            if (!opened)\n-               BadgeCountUpdater.update(writableDb, context);\n+            values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+\n+            writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n+            BadgeCountUpdater.update(writableDb, notifiJob.context);\n+\n             writableDb.setTransactionSuccessful();\n-         } catch (Exception e) {\n+\n+        } catch (Exception e) {\n             OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-         } finally {\n+        } finally {\n             if (writableDb != null) {\n-               try {\n-                  writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n-               } catch (Throwable t) {\n-                  OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n-               }\n+                try {\n+                    writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                } catch (Throwable t) {\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                }\n+            }\n+        }\n+    }\n+\n+    static @NonNull\n+    JSONObject bundleAsJSONObject(Bundle bundle) {\n+        JSONObject json = new JSONObject();\n+        Set<String> keys = bundle.keySet();\n+\n+        for (String key : keys) {\n+            try {\n+                json.put(key, bundle.get(key));\n+            } catch (JSONException e) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n             }\n-         }\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-   }\n+        }\n \n-   static void markRestoredNotificationAsDismissed(OSNotificationGenerationJob notifiJob) {\n-      if (notifiJob.getAndroidIdWithoutCreate() == -1)\n-         return;\n+        return json;\n+    }\n \n-      String whereStr = NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID + \" = \" + notifiJob.getAndroidIdWithoutCreate();\n+    // Format our short keys into more readable ones.\n+    private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n+        if (!fcmBundle.containsKey(\"o\"))\n+            return;\n \n-      OneSignalDbHelper dbHelper = OneSignalDbHelper.getInstance(notifiJob.context);\n-      SQLiteDatabase writableDb = null;\n+        try {\n+            JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n+            JSONObject additionalDataJSON;\n+\n+            if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            else\n+                additionalDataJSON = new JSONObject();\n+\n+            JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n+            fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n+            for (int i = 0; i < buttons.length(); i++) {\n+                JSONObject button = buttons.getJSONObject(i);\n+\n+                String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n+                button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n+\n+                String buttonId;\n+                if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n+                    buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n+                    button.remove(PUSH_MINIFIED_BUTTON_ID);\n+                } else\n+                    buttonId = buttonText;\n+\n+                button.put(\"id\", buttonId);\n+                button.put(\"text\", buttonText);\n+\n+                if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n+                    button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n+                    button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+                }\n+            }\n \n-      try {\n-         writableDb = dbHelper.getSQLiteDatabaseWithRetries();\n-         writableDb.beginTransaction();\n+            additionalDataJSON.put(\"actionButtons\", buttons);\n+            additionalDataJSON.put(BUNDLE_KEY_ACTION_ID, DEFAULT_ACTION);\n+            if (!customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n+                customJSON.put(PUSH_ADDITIONAL_DATA_KEY, additionalDataJSON);\n \n-         ContentValues values = new ContentValues();\n-         values.put(NotificationTable.COLUMN_NAME_DISMISSED, 1);\n+            fcmBundle.putString(\"custom\", customJSON.toString());\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+    }\n \n-         writableDb.update(NotificationTable.TABLE_NAME, values, whereStr, null);\n-         BadgeCountUpdater.update(writableDb, notifiJob.context);\n+    static OSNotificationPayload OSNotificationPayloadFrom(JSONObject currentJsonPayload) {\n+        OSNotificationPayload notification = new OSNotificationPayload();\n+        try {\n+            JSONObject customJson = getCustomJSONObject(currentJsonPayload);\n+            notification.notificationID = customJson.optString(\"i\");\n+            notification.templateId = customJson.optString(\"ti\");\n+            notification.templateName = customJson.optString(\"tn\");\n+            notification.rawPayload = currentJsonPayload.toString();\n+            notification.additionalData = customJson.optJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n+            notification.launchURL = customJson.optString(\"u\", null);\n+\n+            notification.body = currentJsonPayload.optString(\"alert\", null);\n+            notification.title = currentJsonPayload.optString(\"title\", null);\n+            notification.smallIcon = currentJsonPayload.optString(\"sicon\", null);\n+            notification.bigPicture = currentJsonPayload.optString(\"bicon\", null);\n+            notification.largeIcon = currentJsonPayload.optString(\"licon\", null);\n+            notification.sound = currentJsonPayload.optString(\"sound\", null);\n+            notification.groupKey = currentJsonPayload.optString(\"grp\", null);\n+            notification.groupMessage = currentJsonPayload.optString(\"grp_msg\", null);\n+            notification.smallIconAccentColor = currentJsonPayload.optString(\"bgac\", null);\n+            notification.ledColor = currentJsonPayload.optString(\"ledc\", null);\n+            String visibility = currentJsonPayload.optString(\"vis\", null);\n+            if (visibility != null)\n+                notification.lockScreenVisibility = Integer.parseInt(visibility);\n+            notification.fromProjectNumber = currentJsonPayload.optString(\"from\", null);\n+            notification.priority = currentJsonPayload.optInt(\"pri\", 0);\n+            String collapseKey = currentJsonPayload.optString(\"collapse_key\", null);\n+            if (!\"do_not_collapse\".equals(collapseKey))\n+                notification.collapseId = collapseKey;\n \n-         writableDb.setTransactionSuccessful();\n+            try {\n+                setActionButtons(notification);\n+            } catch (Throwable t) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.actionButtons values!\", t);\n+            }\n \n-      } catch (Exception e) {\n-         OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error saving notification record! \", e);\n-      } finally {\n-         if (writableDb != null) {\n             try {\n-               writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                setBackgroundImageLayout(notification, currentJsonPayload);\n             } catch (Throwable t) {\n-               OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", t);\n+                OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload.backgroundImageLayout values!\", t);\n             }\n-         }\n-      }\n-   }\n-\n-   static @NonNull JSONObject bundleAsJSONObject(Bundle bundle) {\n-      JSONObject json = new JSONObject();\n-      Set<String> keys = bundle.keySet();\n-\n-      for (String key : keys) {\n-         try {\n-            json.put(key, bundle.get(key));\n-         } catch (JSONException e) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"bundleAsJSONObject error for key: \" + key, e);\n-         }\n-      }\n-\n-      return json;\n-   }\n-\n-   // Format our short keys into more readable ones.\n-   private static void maximizeButtonsFromBundle(Bundle fcmBundle) {\n-      if (!fcmBundle.containsKey(\"o\"))\n-         return;\n-      \n-      try {\n-         JSONObject customJSON = new JSONObject(fcmBundle.getString(\"custom\"));\n-         JSONObject additionalDataJSON;\n-\n-         if (customJSON.has(PUSH_ADDITIONAL_DATA_KEY))\n-            additionalDataJSON = customJSON.getJSONObject(PUSH_ADDITIONAL_DATA_KEY);\n-         else\n-            additionalDataJSON = new JSONObject();\n-\n-         JSONArray buttons = new JSONArray(fcmBundle.getString(PUSH_MINIFIED_BUTTONS_LIST));\n-         fcmBundle.remove(PUSH_MINIFIED_BUTTONS_LIST);\n-         for (int i = 0; i < buttons.length(); i++) {\n-            JSONObject button = buttons.getJSONObject(i);\n-\n-            String buttonText = button.getString(PUSH_MINIFIED_BUTTON_TEXT);\n-            button.remove(PUSH_MINIFIED_BUTTON_TEXT);\n-\n-            String buttonId;\n-            if (button.has(PUSH_MINIFIED_BUTTON_ID)) {\n-               buttonId = button.getString(PUSH_MINIFIED_BUTTON_ID);\n-               button.remove(PUSH_MINIFIED_BUTTON_ID);\n-            } else\n-               buttonId = buttonText;\n-\n-            button.put(\"id\", buttonId);\n-            button.put(\"text\", buttonText);\n-\n-            if (button.has(PUSH_MINIFIED_BUTTON_ICON)) {\n-               button.put(\"icon\", button.getString(PUSH_MINIFIED_BUTTON_ICON));\n-               button.remove(PUSH_MINIFIED_BUTTON_ICON);\n+        } catch (Throwable t) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Error assigning OSNotificationPayload values!\", t);\n+        }\n+\n+        return notification;\n+    }\n+", "originalCommit": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDI4Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164286", "bodyText": "Fixed!", "author": "mikechoch", "createdAt": "2020-08-07T17:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2MDgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r458166852", "bodyText": "Can it happend that for the same notification we call more than once this method?", "author": "Jeasmine", "createdAt": "2020-07-21T15:01:36Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationWorkManager.java", "diffHunk": "@@ -0,0 +1,91 @@\n+package com.onesignal;\n+\n+import android.content.Context;\n+\n+import androidx.annotation.NonNull;\n+import androidx.work.Data;\n+import androidx.work.OneTimeWorkRequest;\n+import androidx.work.WorkManager;\n+import androidx.work.Worker;\n+import androidx.work.WorkerParameters;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSNotificationWorkManager {\n+\n+    private static final String ANDROID_NOTIF_ID_WORKER_DATA_PARAM = \"android_notif_id\";\n+    private static final String JSON_PAYLOAD_WORKER_DATA_PARAM = \"json_payload\";\n+    private static final String TIMESTAMP_WORKER_DATA_PARAM = \"timestamp\";\n+    private static final String IS_RESTORING_WORKER_DATA_PARAM = \"is_restoring\";\n+\n+    static void beginEnqueueingWork(Context context, int androidNotificationId, String jsonPayload, boolean isRestoring, long timestamp, boolean isHighPriority) {\n+        // TODO: Do we need isHighPriority only more?\n+\n+        Data inputData = new Data.Builder()\n+                .putInt(ANDROID_NOTIF_ID_WORKER_DATA_PARAM, androidNotificationId)\n+                .putString(JSON_PAYLOAD_WORKER_DATA_PARAM, jsonPayload)\n+                .putLong(TIMESTAMP_WORKER_DATA_PARAM, timestamp)\n+                .putBoolean(IS_RESTORING_WORKER_DATA_PARAM, isRestoring)\n+                .build();\n+\n+        OneTimeWorkRequest workRequest = new OneTimeWorkRequest.Builder(NotificationWorker.class)", "originalCommit": "59e052d05d0b89acdca4b453ab4b2e4d106d2cf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NzY3NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465867675", "bodyText": "Not sure but its a good point so a good idea would be to use the OS id as a tag for the job and make sure a job does not exist with that id name already. Otherwise im pretty sure we check for notifications being duplicate before this line of code", "author": "mikechoch", "createdAt": "2020-08-05T16:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk5MDAwNw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467990007", "bodyText": "Here is my solution to what you are brining up, but maybe we want to change this or modify... Just an idea for now though...\nWorkManager.getInstance(context)\n    .enqueueUniqueWork(osNotificationId, ExistingWorkPolicy.KEEP, workRequest);\nWhat does ExistingWorkPolicy.KEEP do?\nWell... If there is existing pending (uncompleted) work with the same unique name (in this case, OneSignal notification id), do nothing. Otherwise, insert the newly-specified work.", "author": "mikechoch", "createdAt": "2020-08-10T15:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE2Njg1Mg=="}], "type": "inlineReview"}, {"oid": "bec8c350e2eb7d5824b251c941612ac1568811d8", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/bec8c350e2eb7d5824b251c941612ac1568811d8", "message": "WIP - Working on a single Worker `NotificationWorker`\n* `NotificationWillShowInForegroundHandler`\n* `NotificationProcessingHandler`", "committedDate": "2020-07-28T16:35:38Z", "type": "commit"}, {"oid": "e8a735219f52efd22611c53bed4b0f8988aed72f", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/e8a735219f52efd22611c53bed4b0f8988aed72f", "message": "WIP - Single Worker for notification processing and foreground handlers\n* `Worker` class resides within the `OSNotificationWorkManager` class\n  * `NotificationWorker` extends `Worker` class\n  * Constructs a `OSNotificationReceived` instance inside `doWork` override and fires the `OneSignal.NotificationProcessingHandler`\n* Converted `NotificationExtenderService` to `OSNotificationExtender`\n  * Removed extended `JobIntentService`\n  * Removed `onNotificationProcessing` and created a public `OneSignal.NotificationProcessingHandler`\n  * Belongs to the `OSNotificationReceived` class now\n* `OSNotificationReceived` now has 3 methods for handling the `OneSignal.NotificationProcessingHandler`\n  * Extending `OSTimeoutHandler` now and this calls complete method if the `postDelayed` `runnable` is ran\n  * `setModifiedContent`, `display`, and `complete`\n  * Responsible for the `OSNotificationExtender` class so that `setModifiedContent`, `display`, and `complete` may be called\n* Commented out some broken UnitTests for now related to `startExtenderService` method\n  * Refactored now so UnitTests will need to be refactored to accommodate that change\n  * Added `setupWorkManager` to `HMSDataMessageReceivedIntegrationTestsRunner` `beforeEachTest` method\n  * Added `setupWorkManager` to `MainOneSignalClassRunner` `beforeEachTest` method\n* WIP - Need to find a solution for the high priority notifications\n  * Previously processed through a `JobIntentService` relying on `completeWakefulIntent`", "committedDate": "2020-07-28T16:51:07Z", "type": "commit"}, {"oid": "e9fa1416e6539f28cb7dc21da4fb343ebecbcb2f", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/e9fa1416e6539f28cb7dc21da4fb343ebecbcb2f", "message": "Merge branch 'feature/implement_notification_foreground_handler_with_in_focus_display_option' into feature/add_worker_class_for_processing_and_foreground_handler\n\n# Conflicts:\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationExtenderService.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java\n#\tOneSignalSDK/unittest/build.gradle\n#\tOneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java\n#\tOneSignalSDK/unittest/src/test/java/com/test/onesignal/TestHelpers.java\n\nAlso fixed unit tests related to changes on this PR in general not associated with the update merge\n* `hasExtenderService` within the `FCMBroadcastReceiver` is no longer necessary\n  * No need to have the `Extender` as a `boolean` anymore", "committedDate": "2020-07-28T19:29:12Z", "type": "commit"}, {"oid": "e9fa1416e6539f28cb7dc21da4fb343ebecbcb2f", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/e9fa1416e6539f28cb7dc21da4fb343ebecbcb2f", "message": "Merge branch 'feature/implement_notification_foreground_handler_with_in_focus_display_option' into feature/add_worker_class_for_processing_and_foreground_handler\n\n# Conflicts:\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationExtenderService.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java\n#\tOneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java\n#\tOneSignalSDK/unittest/build.gradle\n#\tOneSignalSDK/unittest/src/test/java/com/test/onesignal/GenerateNotificationRunner.java\n#\tOneSignalSDK/unittest/src/test/java/com/test/onesignal/TestHelpers.java\n\nAlso fixed unit tests related to changes on this PR in general not associated with the update merge\n* `hasExtenderService` within the `FCMBroadcastReceiver` is no longer necessary\n  * No need to have the `Extender` as a `boolean` anymore", "committedDate": "2020-07-28T19:29:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465934898", "bodyText": "Here we are creating a new thread, start it, and join right away. This is going to lock as if we don't have a thread at all.\nIs this always running off the main thread now with the new follow?\nWhat depends on this we need to wait for?", "author": "jkasten2", "createdAt": "2020-08-05T18:53:26Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/GenerateNotification.java", "diffHunk": "@@ -114,12 +112,20 @@ static void fromJsonPayload(final OSNotificationGenerationJob notifJob) {\n          return;\n \n       // New thread so that any Network usage is off the main thread before showing the notification\n-      new Thread(new Runnable() {\n+      Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n             showNotification(notifJob);\n          }\n-      }, OS_SHOW_NOTIFICATION_THREAD).start();\n+      }, OS_SHOW_NOTIFICATION_THREAD);\n+      thread.start();\n+\n+      // Stop all code until thread is done doing work to show notification\n+      try {\n+         thread.join();", "originalCommit": "76b94f52ea4aabba6b580710dc35a692042780ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0Njg1Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465946853", "bodyText": "Would easier to explain over a call if you have time.\nBasically the join method will await the current thread until the new thread is done with its work. It does not immediately join actually.\nThese docs explain it well as well as the diagram below", "author": "mikechoch", "createdAt": "2020-08-05T19:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0OTQ3NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465949475", "bodyText": "But where is the 2nd thread we are kicking off and where are we joining it?\nStill looking through the PR so that may uncover this question.", "author": "jkasten2", "createdAt": "2020-08-05T19:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk1NDA4Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465954082", "bodyText": "Ahh I understand, so there are two places we call GenerateNotification.fromJsonPayload and both routes come from this method NotificationBundleProcessor.processJobForDisplay\nOne is at this line (don't fire or has no foreground handlers)\n\n  \n    \n      OneSignal-Android-SDK/OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java\n    \n    \n         Line 127\n      in\n      76b94f5\n    \n    \n    \n    \n\n        \n          \n           GenerateNotification.fromJsonPayload(notifJob); \n        \n    \n  \n\n\nOther is at this line (should fire and has foreground handlers)\n\n  \n    \n      OneSignal-Android-SDK/OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java\n    \n    \n         Line 301\n      in\n      76b94f5\n    \n    \n    \n    \n\n        \n          \n           GenerateNotification.fromJsonPayload(getNotifJob()); \n        \n    \n  \n\n\nThe purpose is so we wait until the showNotification method inside of the new thread is done. Then we can start the next part of the NotificationBundleProcessor.processJobForDisplay and return the android notification id", "author": "mikechoch", "createdAt": "2020-08-05T19:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2MTIwMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465961200", "bodyText": "Also that diagram is only showing you how the Thread.join method works, we only kick off Thread 1 technically and its only for the showNotification method", "author": "mikechoch", "createdAt": "2020-08-05T19:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk2NjYxOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465966618", "bodyText": "Update based on our discussion.\nAdding the thread here prevents throwing an exception of downloading on the main thread, however this can create an ANR if downloading takes 5+ sec", "author": "jkasten2", "createdAt": "2020-08-05T19:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk2OTM2Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467969363", "bodyText": "Another update is we are not calling showNotification from Main Thread and therefore the new Thread is not necessary. Good talk though and after meeting with Josh to discuss this further we decided we should add a RuntimeException check right before the showNotification method PR for Main Thread RuntimeException check", "author": "mikechoch", "createdAt": "2020-08-10T15:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzNDg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465984880", "bodyText": "exi should be exists", "author": "jkasten2", "createdAt": "2020-08-05T20:28:58Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi", "originalCommit": "76b94f52ea4aabba6b580710dc35a692042780ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1OTcwOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467159709", "bodyText": "Good catch!", "author": "mikechoch", "createdAt": "2020-08-07T16:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDE3OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164179", "bodyText": "Fixed!", "author": "mikechoch", "createdAt": "2020-08-07T17:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r465984975", "bodyText": "Remove blank comment", "author": "jkasten2", "createdAt": "2020-08-05T20:29:10Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSNotificationGenerationJob.java", "diffHunk": "@@ -40,258 +40,266 @@\n \n public class OSNotificationGenerationJob {\n \n-   private final String TITLE_PAYLOAD_PARAM = \"title\";\n-   private final String ALERT_PAYLOAD_PARAM = \"alert\";\n-   private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n-   private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n-\n-   Context context;\n-   JSONObject jsonPayload;\n-   boolean isRestoring;\n-   boolean isIamPreview;\n-   OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n-\n-   Long shownTimeStamp;\n-\n-   CharSequence overriddenBodyFromExtender;\n-   CharSequence overriddenTitleFromExtender;\n-   Uri overriddenSound;\n-   Integer overriddenFlags;\n-   Integer orgFlags;\n-   Uri orgSound;\n-\n-   NotificationExtenderService.OverrideSettings overrideSettings;\n-\n-   OSNotificationGenerationJob(Context context) {\n-      this.context = context;\n-   }\n-\n-   String getApiNotificationId() {\n-      return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n-   }\n-\n-   int getAndroidIdWithoutCreate() {\n-      if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n-         return -1;\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   Integer getAndroidId() {\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      if (overrideSettings.androidNotificationId == null)\n-         overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n-\n-      return overrideSettings.androidNotificationId;\n-   }\n-\n-   /**\n-    * Get the notification title from the payload\n-    */\n-   CharSequence getTitle() {\n-      if (overriddenTitleFromExtender != null)\n-         return overriddenTitleFromExtender;\n-      return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification body from the payload\n-    */\n-   CharSequence getBody() {\n-      if (overriddenBodyFromExtender != null)\n-         return overriddenBodyFromExtender;\n-      return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n-   }\n-\n-   /**\n-    * Get the notification additional data json from the payload\n-    */\n-   JSONObject getAdditionalData() {\n-      try {\n-         return new JSONObject(jsonPayload\n-                 .optString(CUSTOM_PAYLOAD_PARAM))\n-                 .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n-      } catch (JSONException e) {\n-         e.printStackTrace();\n-      }\n-\n-      return new JSONObject();\n-   }\n-\n-   /**\n-    * If androidNotificationId is -1 then the notification is a silent one\n-    */\n-   boolean isNotificationToDisplay() {\n-      return getAndroidIdWithoutCreate() != -1;\n-   }\n-\n-   boolean hasExtender() {\n-      return overrideSettings != null && overrideSettings.extender != null;\n-   }\n-\n-   void setAndroidIdWithoutOverriding(Integer id) {\n-      if (id == null)\n-         return;\n-\n-      if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n-         return;\n-\n-      if (overrideSettings == null)\n-         overrideSettings = new NotificationExtenderService.OverrideSettings();\n-      overrideSettings.androidNotificationId = id;\n-   }\n-\n-   private OSNotificationDisplay getNotificationDisplayOption() {\n-      return this.displayOption;\n-   }\n-\n-   private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-      this.displayOption = displayOption;\n-   }\n-\n-   /**\n-    * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n-      return new ExtNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n-    *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n-    */\n-   AppNotificationGenerationJob toAppNotificationGenerationJob() {\n-      return new AppNotificationGenerationJob(this);\n-   }\n-\n-   /**\n-    * A wrapper for the {@link OSNotificationGenerationJob}\n-    * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n-    *    1. {@link ExtNotificationGenerationJob}\n-    *    2. {@link AppNotificationGenerationJob}\n-    */\n-   private static class NotificationGenerationJob extends OSTimeoutHandler {\n-\n-      // Timeout in seconds before applying defaults\n-      private static final long SHOW_NOTIFICATION_TIMEOUT = 30 * 1_000L;\n-\n-      // Used to toggle when complete is called so it can not be called more than once\n-      boolean isComplete = false;\n-\n-      // The actual notifJob with notification payload data\n-      private OSNotificationGenerationJob notifJob;\n-\n-      NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         this.notifJob = notifJob;\n-         setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n-      }\n-\n-      OSNotificationGenerationJob getNotifJob() {\n-         return notifJob;\n-      }\n-\n-      public String getApiNotificationId() {\n-         return notifJob.getApiNotificationId();\n-      }\n-\n-      public int getAndroidNotificationId() {\n-         return notifJob.getAndroidIdWithoutCreate();\n-      }\n-\n-      public String getTitle() {\n-         return notifJob.getTitle().toString();\n-      }\n-\n-      public String getBody() {\n-         return notifJob.getBody().toString();\n-      }\n-\n-      public JSONObject getAdditionalData() {\n-         return notifJob.getAdditionalData();\n-      }\n-\n-      public OSNotificationDisplay getNotificationDisplayOption() {\n-         return notifJob.getNotificationDisplayOption();\n-      }\n-\n-      public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n-         notifJob.setNotificationDisplayOption(displayOption);\n-      }\n-   }\n-\n-   /**\n-    * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n-    *    without exposing internals publicly\n-    */\n-   public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n-\n-      ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n-\n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               ExtNotificationGenerationJob.this.complete(true);\n-            }\n-         });\n-      }\n-\n-      // Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n-      public synchronized void complete(boolean bubble) {\n-         destroyTimeout();\n-\n-         if (isComplete)\n+    // Timeout in seconds before applying defaults\n+    private static final long SHOW_NOTIFICATION_TIMEOUT = 25 * 1_000L;\n+\n+    private final String TITLE_PAYLOAD_PARAM = \"title\";\n+    private final String ALERT_PAYLOAD_PARAM = \"alert\";\n+    private final String CUSTOM_PAYLOAD_PARAM = \"custom\";\n+    private final String ADDITIONAL_DATA_PAYLOAD_PARAM = \"a\";\n+\n+    Context context;\n+    JSONObject jsonPayload;\n+    boolean isRestoring;\n+    boolean isIamPreview;\n+    OSNotificationDisplay displayOption = OSNotificationDisplay.NOTIFICATION;\n+\n+    Long shownTimeStamp;\n+\n+    CharSequence overriddenBodyFromExtender;\n+    CharSequence overriddenTitleFromExtender;\n+    Uri overriddenSound;\n+    Integer overriddenFlags;\n+    Integer orgFlags;\n+    Uri orgSound;\n+\n+    OSNotificationExtender.OverrideSettings overrideSettings;\n+\n+    OSNotificationGenerationJob(Context context) {\n+        this.context = context;\n+    }\n+\n+    String getApiNotificationId() {\n+        return OneSignal.getNotificationIdFromFCMJson(jsonPayload);\n+    }\n+\n+    int getAndroidIdWithoutCreate() {\n+        if (overrideSettings == null || overrideSettings.androidNotificationId == null)\n+            return -1;\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    Integer getAndroidId() {\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+\n+        if (overrideSettings.androidNotificationId == null)\n+            overrideSettings.androidNotificationId = new SecureRandom().nextInt();\n+\n+        return overrideSettings.androidNotificationId;\n+    }\n+\n+    /**\n+     * Get the notification title from the payload\n+     */\n+    CharSequence getTitle() {\n+        if (overriddenTitleFromExtender != null)\n+            return overriddenTitleFromExtender;\n+        return jsonPayload.optString(TITLE_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification body from the payload\n+     */\n+    CharSequence getBody() {\n+        if (overriddenBodyFromExtender != null)\n+            return overriddenBodyFromExtender;\n+        return jsonPayload.optString(ALERT_PAYLOAD_PARAM, null);\n+    }\n+\n+    /**\n+     * Get the notification additional data json from the payload\n+     */\n+    JSONObject getAdditionalData() {\n+        try {\n+            return new JSONObject(jsonPayload\n+                    .optString(CUSTOM_PAYLOAD_PARAM))\n+                    .getJSONObject(ADDITIONAL_DATA_PAYLOAD_PARAM);\n+        } catch (JSONException e) {\n+            e.printStackTrace();\n+        }\n+\n+        return new JSONObject();\n+    }\n+\n+    /**\n+     * If androidNotificationId is -1 then the notification is a silent one\n+     */\n+    boolean isNotificationToDisplay() {\n+        return getAndroidIdWithoutCreate() != -1;\n+    }\n+\n+    boolean hasExtender() {\n+        return overrideSettings != null && overrideSettings.extender != null;\n+    }\n+\n+    void setAndroidIdWithoutOverriding(Integer id) {\n+        if (id == null)\n             return;\n \n-         isComplete = true;\n-\n-         // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exists or bubbling is set false\n-         if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n-            GenerateNotification.fromJsonPayload(getNotifJob());\n+        if (overrideSettings != null && overrideSettings.androidNotificationId != null)\n             return;\n-         }\n \n-         // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n-         //    the notificationWillShowInForeground implementation\n-         OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n-                 getNotifJob().toAppNotificationGenerationJob());\n-      }\n-   }\n+        if (overrideSettings == null)\n+            overrideSettings = new OSNotificationExtender.OverrideSettings();\n+        overrideSettings.androidNotificationId = id;\n+    }\n+\n+    private OSNotificationDisplay getNotificationDisplayOption() {\n+        return this.displayOption;\n+    }\n+\n+    private void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+        this.displayOption = displayOption;\n+    }\n+\n+    /**\n+     * Create a {@link ExtNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.ExtNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    ExtNotificationGenerationJob toExtNotificationGenerationJob() {\n+        return new ExtNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * Create a {@link AppNotificationGenerationJob} to manage the {@link OSNotificationGenerationJob}\n+     *  while the {@link OneSignal.AppNotificationWillShowInForegroundHandler} is being fired\n+     */\n+    AppNotificationGenerationJob toAppNotificationGenerationJob() {\n+        return new AppNotificationGenerationJob(this);\n+    }\n+\n+    /**\n+     * A wrapper for the {@link OSNotificationGenerationJob}\n+     * Contains two other classes which implement this one {@link NotificationGenerationJob}:\n+     *    1. {@link ExtNotificationGenerationJob}\n+     *    2. {@link AppNotificationGenerationJob}\n+     */\n+    static class NotificationGenerationJob extends OSTimeoutHandler {\n+\n+        // Used to toggle when complete is called so it can not be called more than once\n+        boolean isComplete = false;\n+\n+        // The actual notifJob with notification payload data\n+        private OSNotificationGenerationJob notifJob;\n+\n+        NotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            this.notifJob = notifJob;\n+            setTimeout(SHOW_NOTIFICATION_TIMEOUT);\n+        }\n+\n+        OSNotificationGenerationJob getNotifJob() {\n+            return notifJob;\n+        }\n+\n+        public String getApiNotificationId() {\n+            return notifJob.getApiNotificationId();\n+        }\n+\n+        public int getAndroidNotificationId() {\n+            return notifJob.getAndroidIdWithoutCreate();\n+        }\n+\n+        public String getTitle() {\n+            return notifJob.getTitle().toString();\n+        }\n+\n+        public String getBody() {\n+            return notifJob.getBody().toString();\n+        }\n+\n+        public JSONObject getAdditionalData() {\n+            return notifJob.getAdditionalData();\n+        }\n+\n+        public OSNotificationDisplay getNotificationDisplayOption() {\n+            return notifJob.getNotificationDisplayOption();\n+        }\n+\n+        public void setNotificationDisplayOption(OSNotificationDisplay displayOption) {\n+            notifJob.setNotificationDisplayOption(displayOption);\n+        }\n+    }\n+\n+    /**\n+     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.ExtNotificationWillShowInForegroundHandler}\n+     *    without exposing internals publicly\n+     */\n+    public static class ExtNotificationGenerationJob extends NotificationGenerationJob {\n+\n+        ExtNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n+\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    ExtNotificationGenerationJob.this.complete(true);\n+                }\n+            });\n+        }\n+\n+        /**\n+         * Method controlling bubbling from the ExtNotificationWillShowInForegroundHandler to the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and attempt to bubble to the AppNotificationWillShowInForegroundHandler automatically\n+         */\n+        public synchronized void complete(boolean bubble) {\n+            destroyTimeout();\n+\n+            if (isComplete)\n+                return;\n+\n+            isComplete = true;\n+\n+            // Move on to showing notification if no AppNotificationWillShowInForegroundHandler exi\n+            //    or bubbling is set false\n+            if (OneSignal.appNotificationWillShowInForegroundHandler == null || !bubble) {\n+                GenerateNotification.fromJsonPayload(getNotifJob());\n+                return;\n+            }\n+\n+            // If the appNotificationWillShowInForegroundHandler exists and we want to bubble, call\n+            //    the notificationWillShowInForeground implementation\n+            OneSignal.appNotificationWillShowInForegroundHandler.notificationWillShowInForeground(\n+                    getNotifJob().toAppNotificationGenerationJob());\n+        }\n+    }\n \n    /**\n     * Used to modify the {@link OSNotificationGenerationJob} inside of the {@link OneSignal.AppNotificationWillShowInForegroundHandler}\n     *    without exposing internals publicly\n     */\n    public static class AppNotificationGenerationJob extends NotificationGenerationJob {\n \n-      AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n-         super(notifJob);\n+        AppNotificationGenerationJob(OSNotificationGenerationJob notifJob) {\n+            super(notifJob);\n \n-         startTimeout(new Runnable() {\n-            @Override\n-            public void run() {\n-               AppNotificationGenerationJob.this.complete();\n-            }\n-         });\n-      }\n \n-      // Method controlling completion from the AppNotificationWillShowInForegroundHandler\n-      //    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n-      //    a 30 second timer and complete by default\n-      public synchronized void complete() {\n-         destroyTimeout();\n+            startTimeout(new Runnable() {\n+                @Override\n+                public void run() {\n+                    AppNotificationGenerationJob.this.complete();\n+                }\n+            });\n+        }\n \n-         if (isComplete)\n-            return;\n+        /**\n+         * Method controlling completion from the AppNotificationWillShowInForegroundHandler\n+         *    If a dev does not call this at the end of the notificationWillShowInForeground implementation, a runnable will fire after\n+         *    a 30 second timer and complete by default\n+         */\n+        public synchronized void complete() {\n+            destroyTimeout();\n \n-         isComplete = true;\n+            if (isComplete)\n+                return;\n \n-         GenerateNotification.fromJsonPayload(getNotifJob());\n-      }\n-   }\n+            isComplete = true;\n+\n+            //", "originalCommit": "76b94f52ea4aabba6b580710dc35a692042780ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1OTY0MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467159640", "bodyText": "Good catch!", "author": "mikechoch", "createdAt": "2020-08-07T16:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE2NDIxOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r467164219", "bodyText": "Fixed!", "author": "mikechoch", "createdAt": "2020-08-07T17:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk4NDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2ODY5NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r468168694", "bodyText": "We do this so app devs can run their UI update code without having to worry about getting themselves on the main thread.", "author": "jkasten2", "createdAt": "2020-08-10T20:31:28Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -2117,6 +2129,10 @@ private static OSNotificationOpenResult generateOsNotificationOpenResult(JSONArr\n    }\n \n    private static void fireNotificationOpenedHandler(final OSNotificationOpenResult openedResult) {\n+      // TODO: Is there a reason we need the opened handler to be fired from main thread?", "originalCommit": "fd5ad130abb51d983583a4a822083114cfa66c6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE2OTU2MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/1091#discussion_r468169560", "bodyText": "All the default behavior is done on a different thread before this call.\nThe reason we did a catch was so a notification would still be displayed, even though the app is going to crash from an uncaught exception.", "author": "jkasten2", "createdAt": "2020-08-10T20:33:14Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -2117,6 +2129,10 @@ private static OSNotificationOpenResult generateOsNotificationOpenResult(JSONArr\n    }\n \n    private static void fireNotificationOpenedHandler(final OSNotificationOpenResult openedResult) {\n+      // TODO: Is there a reason we need the opened handler to be fired from main thread?\n+\n+      // TODO: Once the NotificationOpenedHandler gets a Worker, we should make sure we add a catch", "originalCommit": "fd5ad130abb51d983583a4a822083114cfa66c6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6593a6b540eb109b29859c2f9bd5213d4793c01", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/e6593a6b540eb109b29859c2f9bd5213d4793c01", "message": "Notification restore revamp to use Worker now\n  * **Deleted Files:**\n    * `NotificationRestorer`\n    * `NotificationRestoreService`\n    * `RestoreJobService`\n    * `RestoreKickoffJobService`\n    * Services all removed from `AndroidManifest` as well since `Worker` acts as a replacement\n  * `UpgradeReceiver` and `BootUpReceiver` now kickoff notification restoring through `OSNotificationRestoreWorkManager`\n\nAdded boolean shouldDelay param to restore work manager\n  * `OSNotificationRestoreWorkManager.beginEnqueueingWork` should have a `boolean shouldDelay` param\n  * When app comes from boot or upgrade, add a 15 second delay to alleviate app doing to much work all at once\n\nFixed UnitTests related to app not being in foreground\n  * The foreground issue is related to foreground handlers not firing now when app is backgrounded\n  * Also fixed a network request assert in another UnitTest\n  * `shouldGenerate2BasicGroupNotifications`", "committedDate": "2020-08-20T21:39:52Z", "type": "forcePushed"}, {"oid": "80d08ca5211737ecd7a55ef1d3211a2556dcebc0", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/80d08ca5211737ecd7a55ef1d3211a2556dcebc0", "message": "Fixed all UnitTests related to old NotificationExtenderService\n  * Replaced by `NotificationProcessingHandler`, which will be an implemented `interface` in a developers custom app `NotificationExtensionService`\n    * Follows same similar implementation to the `ExtNotificationWillShowInForegroundHandler` as well as the `NotificationOpenedHandler`\n  * Added a `try-catch` around the `NotificationProcessingHandler.notificationProcessing` method call\n    * If something fails we can bail and still show the notification the correct way\n    * Might need to do this in the `NotificationWillShowInForegroundHandler` as well\n  * Added `OSNotificationExtender.setupNotificationExtensionServiceClass()` to `OneSignalPackagePrivateHelper`\n    * For UnitTests so we don't need OneSignal init (`setAppId` and `setAppContext`) to setup a dev's extension service\n  * When calling `showNotification` we will want to call `join` after so that work on thread is completely finished\n\nFixed UnitTest(s)\n  * `shouldNotFailedNotificationExtenderServiceWhenAlertIsNull` is now `testNotificationProcessing_whenAlertIsNull`\n  * `notificationExtenderServiceOverridePropertiesWithSummaryApi17` is now `testNotificationExtensionServiceOverridePropertiesWithSummaryApi17`\n  * `notificationExtenderServiceOverridePropertiesWithSummary` is now `testNotificationExtensionServiceOverridePropertiesWithSummary`\n  * `notificationExtenderServiceOverrideShouldOverrideAndroidNotificationId` is now `testNotificationProcessing_twoNotificationsWithSameOverrideAndroidNotificationId`\n  * `shouldFireNotificationExtenderService` is now `testNotificationExtensionService_notificationProcessingProperties`\n\n  * Commented out `shouldStartFCMServiceOnAndroidOWhenPriorityIsHighAndContainsRemoteResource`\n    * No solution for high priority (> 9) notifications as of now with the `WorkManager`\n\nMinor improvements\n  * Removed unnecessary `new Thread` wrapping the `showNotification` method\n  * Created helper methods for firing both `NotificationWillShowInForegroundHandlers`\n    * Added `try-catch` around the `extNotificationWillShowInForegroundHandler` as well as `appNotificationWillShowInForegroundHandler`\n  * Added comment to the `NotificationProcessingHandler` interface\n  * `TODOs` added to a few pieces of code that will be modified in future\n    * `NotificationOpenedHandler` fired from `fireNotificationOpenedHandler` method\n\nAdded `osNotificationId` param as a unique work id\n  * `OSNotificationWorkManager.beginEnqueueingWork` now has a `osNotificationId` param for giving the WorkRequest a unique id\n    * If we try to trigger another WorkRequest while one with that OS id is already running, we simply ignore the new attempt and let the current job finish\n    * Replaced `enqueue` method with `enqueueUniqueWork` and added the `ExistingWorkPolicy.KEEP`", "committedDate": "2020-08-20T21:43:41Z", "type": "commit"}, {"oid": "78c6d456b889c7d448905c1c1eb143bd1d766986", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/78c6d456b889c7d448905c1c1eb143bd1d766986", "message": "Fixed some notification restore UnitTests\n* WorkManager uses OneSignal notification id now for creating enqueueing a unique WorkRequest\n  * This should work for showing a new notification and restoring a notification\n  * Fixing the restoring notifications was done by adding the `NotificationTable.COLUMN_NAME_NOTIFICATION_ID` column to the array of String columns. Now when querying SQL for notifications to restore we can access the OneSignal notification id", "committedDate": "2020-08-20T21:45:38Z", "type": "commit"}, {"oid": "7ee5050197e2f1b3cac4f1bc00fe6f498444eb87", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/7ee5050197e2f1b3cac4f1bc00fe6f498444eb87", "message": "Added runtime check before showing a notification (#1110)\n\n* Added runtime check before showing a notification\r\n  * Notification should never be processed for display from the Main Thread\r\n  * This can cause an `ANR` if work is taking too long before showing the notification\r\n  * Created a `OSThrowable` class with a `OSMainThreadException`\r\n\r\n* Broken logic when processing a duplicate notification\r\n  * This was change in this PR #1010\r\n  * Added back the correct logic now and UnitTests pass\r\n\r\n* Replaced `processJobForDisplay` call with Worker kickoff now\r\n  * Found another spot where we may not be trying to kick off the Worker and hence would lead to showing the notification from the MainThread\r\n\r\n* Fix Test due to Roboelectric custom Main Thread Looper shadowing\r\n  * Added `Looper.prepare`, `Looper.loop`, and `Looper.quit` calls for handling the postDelayed runnables\r\n  * Add GenerateNotification.java MainThread check shadow\r\n  * Add to String methods for better log\r\n  * Make OSTimeoutHandler.java a composition reference instead of inheritance\r\n\r\nCo-authored-by: Jeasmine Nahui <jeas.nahui@gmail.com>", "committedDate": "2020-08-20T21:45:38Z", "type": "commit"}, {"oid": "cfd2c2fe55ce811125a9c8c2539c3c071e8670d4", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/cfd2c2fe55ce811125a9c8c2539c3c071e8670d4", "message": "Notification restore revamp to use Worker now\n  * **Deleted Files:**\n    * `NotificationRestorer`\n    * `NotificationRestoreService`\n    * `RestoreJobService`\n    * `RestoreKickoffJobService`\n    * Services all removed from `AndroidManifest` as well since `Worker` acts as a replacement\n  * `UpgradeReceiver` and `BootUpReceiver` now kickoff notification restoring through `OSNotificationRestoreWorkManager`\n\nAdded boolean shouldDelay param to restore work manager\n  * `OSNotificationRestoreWorkManager.beginEnqueueingWork` should have a `boolean shouldDelay` param\n  * When app comes from boot or upgrade, add a 15 second delay to alleviate app doing to much work all at once\n\nFixed UnitTests related to app not being in foreground\n  * The foreground issue is related to foreground handlers not firing now when app is backgrounded\n  * Also fixed a network request assert in another UnitTest\n  * `shouldGenerate2BasicGroupNotifications`", "committedDate": "2020-08-20T21:45:38Z", "type": "commit"}, {"oid": "cfd2c2fe55ce811125a9c8c2539c3c071e8670d4", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/cfd2c2fe55ce811125a9c8c2539c3c071e8670d4", "message": "Notification restore revamp to use Worker now\n  * **Deleted Files:**\n    * `NotificationRestorer`\n    * `NotificationRestoreService`\n    * `RestoreJobService`\n    * `RestoreKickoffJobService`\n    * Services all removed from `AndroidManifest` as well since `Worker` acts as a replacement\n  * `UpgradeReceiver` and `BootUpReceiver` now kickoff notification restoring through `OSNotificationRestoreWorkManager`\n\nAdded boolean shouldDelay param to restore work manager\n  * `OSNotificationRestoreWorkManager.beginEnqueueingWork` should have a `boolean shouldDelay` param\n  * When app comes from boot or upgrade, add a 15 second delay to alleviate app doing to much work all at once\n\nFixed UnitTests related to app not being in foreground\n  * The foreground issue is related to foreground handlers not firing now when app is backgrounded\n  * Also fixed a network request assert in another UnitTest\n  * `shouldGenerate2BasicGroupNotifications`", "committedDate": "2020-08-20T21:45:38Z", "type": "forcePushed"}]}