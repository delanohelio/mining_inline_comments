{"pr_number": 965, "pr_title": "IAM Tracking + Refactor", "pr_createdAt": "2020-03-03T01:27:52Z", "pr_url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965", "timeline": [{"oid": "0f794fe2808aa6addbcd95cd16604683b16cd5d3", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/0f794fe2808aa6addbcd95cd16604683b16cd5d3", "message": "Refactor Outcomes\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes", "committedDate": "2020-03-03T18:02:46Z", "type": "forcePushed"}, {"oid": "b3a634446d9d4c13a7907f8cb36f1749c7160d04", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/b3a634446d9d4c13a7907f8cb36f1749c7160d04", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T06:37:42Z", "type": "forcePushed"}, {"oid": "f4b9fd8f0578dc793437dfb084ea979e761706e7", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/f4b9fd8f0578dc793437dfb084ea979e761706e7", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T14:36:53Z", "type": "forcePushed"}, {"oid": "a973a3cb2e2a4fc9cdf71459d3bc617dc30c155a", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/a973a3cb2e2a4fc9cdf71459d3bc617dc30c155a", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T15:06:00Z", "type": "forcePushed"}, {"oid": "3babd4edfc3d6b27b45047f9fc2495de18bbeb26", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/3babd4edfc3d6b27b45047f9fc2495de18bbeb26", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T18:22:58Z", "type": "forcePushed"}, {"oid": "ffdefeb81816b2590e8fbed96e796c934f6d9cbc", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/ffdefeb81816b2590e8fbed96e796c934f6d9cbc", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T19:42:06Z", "type": "forcePushed"}, {"oid": "44a2d17ff912fca6a00d89c1fe2a0075617c843c", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/44a2d17ff912fca6a00d89c1fe2a0075617c843c", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T19:52:47Z", "type": "forcePushed"}, {"oid": "fddb9490b74e1f08f9a57f26d32b4abdaa9998ff", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/fddb9490b74e1f08f9a57f26d32b4abdaa9998ff", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T21:18:31Z", "type": "forcePushed"}, {"oid": "a9718358250c4fdddb6cd097e4c11a4199280ba6", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/a9718358250c4fdddb6cd097e4c11a4199280ba6", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-03T23:56:45Z", "type": "forcePushed"}, {"oid": "8c9156ee08053600699bb96d3e56024c3bb74d21", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/8c9156ee08053600699bb96d3e56024c3bb74d21", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-04T00:06:24Z", "type": "forcePushed"}, {"oid": "84df1539c2127babf43bd580efbfb4e879d5d50d", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/84df1539c2127babf43bd580efbfb4e879d5d50d", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-06T18:13:25Z", "type": "forcePushed"}, {"oid": "71c0327c06238e0a14c87e1ef5354c04a3559983", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/71c0327c06238e0a14c87e1ef5354c04a3559983", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-06T19:06:13Z", "type": "forcePushed"}, {"oid": "65217c8c7358f8e7a34a35af69daadf92b2d8dca", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/65217c8c7358f8e7a34a35af69daadf92b2d8dca", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-06T20:11:23Z", "type": "forcePushed"}, {"oid": "00bcbda09c7da44c3c907b877038571ca7ad4578", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/00bcbda09c7da44c3c907b877038571ca7ad4578", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-06T20:18:46Z", "type": "forcePushed"}, {"oid": "da27612326bc2ec3d6c21189e3f550115f064cf4", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/da27612326bc2ec3d6c21189e3f550115f064cf4", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T00:00:28Z", "type": "forcePushed"}, {"oid": "77190b634dc4eb1a6bdd1fe2e841e7c35ae3354e", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/77190b634dc4eb1a6bdd1fe2e841e7c35ae3354e", "message": "Add IAM tracking\n\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T01:42:42Z", "type": "forcePushed"}, {"oid": "3e45c93d016c9e718838f84183be729cc8f5a40d", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/3e45c93d016c9e718838f84183be729cc8f5a40d", "message": "Refactor outcomes and add IAM tracking\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T06:09:33Z", "type": "forcePushed"}, {"oid": "1dfa9cefe936db0e0e0bd298b07d801b55cb252e", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/1dfa9cefe936db0e0e0bd298b07d801b55cb252e", "message": "Refactor outcomes and add IAM tracking\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T06:28:40Z", "type": "forcePushed"}, {"oid": "a8534eb3708be9511ee8f7eab0e6dfaf175046c7", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/a8534eb3708be9511ee8f7eab0e6dfaf175046c7", "message": "Refactor outcomes and add IAM tracking\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T06:58:04Z", "type": "forcePushed"}, {"oid": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "message": "Refactor outcomes and add IAM tracking\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks", "committedDate": "2020-04-07T07:31:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg5NzI2NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404897265", "bodyText": "Just pointing this out in case you dont want it commit this app id", "author": "mikechoch", "createdAt": "2020-04-07T15:23:41Z", "path": "OneSignalSDK/app/src/main/java/com/onesignal/example/OneSignalExampleApp.java", "diffHunk": "@@ -60,8 +60,8 @@ public void onCreate() {\n       OneSignal.setLogLevel(OneSignal.LOG_LEVEL.VERBOSE, OneSignal.LOG_LEVEL.NONE);\n \n       String currentAppId = getOneSignalAppId(this);\n-      if (currentAppId == null)\n-         setOneSignalAppId(this, \"0ba9731b-33bd-43f4-8b59-61172e27447d\");", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkwMDAxMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404900011", "bodyText": "influencesString should be influenceStrings\nbut lets rename to influenceJsons", "author": "mikechoch", "createdAt": "2020-04-07T15:27:08Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/FocusTimeController.java", "diffHunk": "@@ -120,12 +134,53 @@ protected void sendTime(@NonNull FocusEventType focusType) {\n          PREF_KEY_FOR_UNSENT_TIME = OneSignalPrefs.PREFS_OS_UNSENT_ATTRIBUTED_ACTIVE_TIME;\n       }\n \n-      protected boolean timeTypeApplies(@NonNull OSSessionManager.Session session) {\n-         return session.isAttributed();\n+      private List<OSInfluence> getInfluences() {\n+         List<OSInfluence> influences = new ArrayList<>();\n+         Set<String> influencesString = OneSignalPrefs.getStringSet(", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkwMTIwNg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404901206", "bodyText": "influenceJSONString to influenceJson", "author": "mikechoch", "createdAt": "2020-04-07T15:28:42Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/FocusTimeController.java", "diffHunk": "@@ -120,12 +134,53 @@ protected void sendTime(@NonNull FocusEventType focusType) {\n          PREF_KEY_FOR_UNSENT_TIME = OneSignalPrefs.PREFS_OS_UNSENT_ATTRIBUTED_ACTIVE_TIME;\n       }\n \n-      protected boolean timeTypeApplies(@NonNull OSSessionManager.Session session) {\n-         return session.isAttributed();\n+      private List<OSInfluence> getInfluences() {\n+         List<OSInfluence> influences = new ArrayList<>();\n+         Set<String> influencesString = OneSignalPrefs.getStringSet(\n+                 OneSignalPrefs.PREFS_ONESIGNAL,\n+                 OneSignalPrefs.PREFS_OS_ATTRIBUTED_INFLUENCES,\n+                 new HashSet<String>()\n+         );\n+\n+         for (String influenceJSONString : influencesString) {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkwMjM2Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404902363", "bodyText": "Nice!", "author": "mikechoch", "createdAt": "2020-04-07T15:30:10Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/NotificationBundleProcessor.java", "diffHunk": "@@ -153,7 +153,7 @@ static void processNotification(NotificationGenerationJob notifiJob, boolean ope\n       if (!notifiJob.isNotificationToDisplay())\n          return;\n       String notificationId = notifiJob.getApiNotificationId();\n-      OutcomesUtils.markLastNotificationReceived(notificationId);", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkwNjIzOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404906238", "bodyText": "Nice!", "author": "mikechoch", "createdAt": "2020-04-07T15:35:01Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSInAppMessageController.java", "diffHunk": "@@ -655,6 +656,7 @@ void onSuccess(String response) {\n                     double displayDuration = jsonResponse.optDouble(\"display_duration\");\n                     message.setDisplayDuration(displayDuration);\n \n+                    OneSignal.getSessionManager().onInAppMessageReceived(message.messageId);", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxMTk3Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404911973", "bodyText": "yaaaay logging class", "author": "mikechoch", "createdAt": "2020-04-07T15:42:24Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSLogWrapper.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+class OSLogWrapper implements OSLogger {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxMjc0OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404912748", "bodyText": "lets create one more method that defaults to printing VERBOSE\nWhat do you think?\n@Override\npublic void log(@NonNull String message);", "author": "mikechoch", "createdAt": "2020-04-07T15:43:24Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSLogWrapper.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+class OSLogWrapper implements OSLogger {\n+\n+    @Override\n+    public void log(@NonNull OneSignal.LOG_LEVEL level, @NonNull String message) {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNTk4NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411015984", "bodyText": "Resolved! For some reason github isn't giving me a resolve button for this one though...\n@mikechoch @Jeasmine log without a level would indicate it would always log to me.\nIf we want helpers so we can omit LOG_LEVEL I would suggest making methods like verbose(@NonNull String message), warn(@NonNull String message), etc to make this more clear. Or even v, w, etc like the Android logcat does. I an open to other ideas as well.", "author": "jkasten2", "createdAt": "2020-04-19T23:28:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxMjc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNTk5MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404915990", "bodyText": "Maybe some rename ideas\nsetIdsToSourceChannel\nattachIdsToSourceChannel\nsetSourceChannelIds\nsetSourceChannelInluences", "author": "mikechoch", "createdAt": "2020-04-07T15:47:40Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";\n+\n+    // Keeps track of unique outcome events sent for UNATTRIBUTED sessions on a per session level\n+    private Set<String> unattributedUniqueOutcomeEventsSentOnSession;\n+\n+    @NonNull\n+    private final OSOutcomeEventsFactory outcomeEventsFactory;\n+    @NonNull\n+    private final OSSessionManager osSessionManager;\n+\n+    public OSOutcomeEventsController(@NonNull OSSessionManager osSessionManager, @NonNull OSOutcomeEventsFactory outcomeEventsFactory) {\n+        this.osSessionManager = osSessionManager;\n+        this.outcomeEventsFactory = outcomeEventsFactory;\n+\n+        initUniqueOutcomeEventsSentSets();\n+    }\n+\n+    /**\n+     * Init the sets used for tracking attributed and unattributed unique outcome events\n+     */\n+    private void initUniqueOutcomeEventsSentSets() {\n+        // Get all cached UNATTRIBUTED unique outcomes\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        Set<String> tempUnattributedUniqueOutcomeEventsSentSet = outcomeEventsFactory.getRepository().getUnattributedUniqueOutcomeEventsSent();\n+        if (tempUnattributedUniqueOutcomeEventsSentSet != null)\n+            unattributedUniqueOutcomeEventsSentOnSession = tempUnattributedUniqueOutcomeEventsSentSet;\n+    }\n+\n+    /**\n+     * Clean unattributed unique outcome events sent so they can be sent after a new session\n+     */\n+    void cleanOutcomes() {\n+        OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal cleanOutcomes for session\");\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        saveUnattributedUniqueOutcomeEvents();\n+    }\n+\n+    /**\n+     * Send all the outcomes that from some reason failed\n+     */\n+    void sendSavedOutcomes() {\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+\n+                List<OSOutcomeEventParams> outcomeEvents = outcomeEventsFactory.getRepository().getSavedOutcomeEvents();\n+                for (OSOutcomeEventParams event : outcomeEvents) {\n+                    sendSavedOutcomeEvent(event);\n+                }\n+            }\n+        }, OS_SEND_SAVED_OUTCOMES).start();\n+    }\n+\n+    private void sendSavedOutcomeEvent(@NonNull final OSOutcomeEventParams event) {\n+        int deviceType = new OSUtils().getDeviceType();\n+        String appId = OneSignal.appId;\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                outcomeEventsFactory.getRepository().removeEvent(event);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, event, responseHandler);\n+    }\n+\n+    void sendClickActionOutcomes(List<OSInAppMessageOutcome> outcomes) {\n+        for (OSInAppMessageOutcome outcome : outcomes) {\n+            String name = outcome.getName();\n+\n+            if (outcome.isUnique()) {\n+                sendUniqueOutcomeEvent(name, null);\n+            } else if (outcome.getWeight() > 0) {\n+                sendOutcomeEventWithValue(name, outcome.getWeight(), null);\n+            } else {\n+                sendOutcomeEvent(name, null);\n+            }\n+        }\n+        // Requests are sent or cached at this point\n+        osSessionManager.onDirectInfluenceFromIAMClickFinished();\n+    }\n+\n+    void sendUniqueOutcomeEvent(@NonNull final String name, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> sessionResult = osSessionManager.getInfluences();\n+        sendUniqueOutcomeEvent(name, sessionResult, callback);\n+    }\n+\n+    void sendOutcomeEvent(@NonNull final String name, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+    }\n+\n+    void sendOutcomeEventWithValue(@NonNull String name, float weight, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, weight, influences, callback);\n+    }\n+\n+    /**\n+     * An unique outcome is considered unattributed when all channels are unattributed\n+     * If one channel is attributed is enough reason to cache attribution\n+     */\n+    private void sendUniqueOutcomeEvent(@NonNull final String name, @NonNull List<OSInfluence> sessionInfluences, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = removeDisableInfluences(sessionInfluences);\n+        if (influences.isEmpty()) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"Unique Outcome disabled for current session\");\n+            return;\n+        }\n+\n+        boolean attributed = false;\n+        boolean unAttributed = false;\n+        for (OSInfluence influence : influences) {\n+            if (influence.getInfluenceType().isAttributed()) {\n+                // At least one channel attributed this outcome\n+                attributed = true;\n+                break;\n+            } else if (influence.getInfluenceType().isUnattributed()) {\n+                unAttributed = true;\n+            } // else DISABLED\n+        }\n+\n+        // Special handling for unique outcomes in the attributed and unattributed scenarios\n+        if (attributed) {\n+            // Make sure unique Ids exist before trying to make measure request\n+            final List<OSInfluence> uniqueInfluences = getUniqueIds(name, influences);\n+            if (uniqueInfluences == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSessionInfluences: \" + influences.toString() +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            sendAndCreateOutcomeEvent(name, 0, uniqueInfluences, callback);\n+        } else if (unAttributed) {\n+            // Make sure unique outcome has not been sent for current unattributed session\n+            if (unattributedUniqueOutcomeEventsSentOnSession.contains(name)) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSession: \" + OSInfluenceType.UNATTRIBUTED +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            unattributedUniqueOutcomeEventsSentOnSession.add(name);\n+            sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+        } else {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled\");\n+        }\n+    }\n+\n+    private void sendAndCreateOutcomeEvent(@NonNull final String name,\n+                                           @NonNull final float weight,\n+                                           @NonNull List<OSInfluence> influences,\n+                                           @Nullable final OneSignal.OutcomeCallback callback) {\n+        final long timestampSeconds = System.currentTimeMillis() / 1000;\n+        final int deviceType = new OSUtils().getDeviceType();\n+        final String appId = OneSignal.appId;\n+\n+        OSOutcomeSourceBody directSourceBody = null;\n+        OSOutcomeSourceBody indirectSourceBody = null;\n+        boolean unattributed = false;\n+\n+        for (OSInfluence influence : influences) {\n+            switch (influence.getInfluenceType()) {\n+                case DIRECT:\n+                    directSourceBody = setIdsOnSourceByChannel(influence, directSourceBody == null ? new OSOutcomeSourceBody() : directSourceBody);\n+                    break;\n+                case INDIRECT:\n+                    indirectSourceBody = setIdsOnSourceByChannel(influence, indirectSourceBody == null ? new OSOutcomeSourceBody() : indirectSourceBody);\n+                    break;\n+                case UNATTRIBUTED:\n+                    unattributed = true;\n+                    break;\n+                case DISABLED:\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for channel: \" + influence.getInfluenceChannel());\n+                    return; // finish method\n+            }\n+        }\n+\n+        if (directSourceBody == null && indirectSourceBody == null && !unattributed) {\n+            // Disabled for all channels\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for all channels\");\n+            return;\n+        }\n+\n+        OSOutcomeSource source = new OSOutcomeSource(directSourceBody, indirectSourceBody);\n+\n+        final OSOutcomeEventParams eventParams = new OSOutcomeEventParams(name, source, weight);\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                saveUniqueOutcome(eventParams);\n+\n+                // The only case where an actual success has occurred and the OutcomeEvent should be sent back\n+                if (callback != null)\n+                    callback.onSuccess(eventParams);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+                        // Only if we need to save and retry the outcome, then we will save the timestamp for future sending\n+                        eventParams.setTimestamp(timestampSeconds);\n+                        outcomeEventsFactory.getRepository().saveOutcomeEvent(eventParams);\n+                    }\n+                }, OS_SAVE_OUTCOMES).start();\n+\n+                OneSignal.onesignalLog(OneSignal.LOG_LEVEL.WARN,\n+                        \"Sending outcome with name: \" + name + \" failed with status code: \" + statusCode + \" and response: \" + response +\n+                                \"\\nOutcome event was cached and will be reattempted on app cold start\");\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, eventParams, responseHandler);\n+    }\n+\n+    private OSOutcomeSourceBody setIdsOnSourceByChannel(OSInfluence influence, OSOutcomeSourceBody sourceBody) {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMxNTExMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406315110", "bodyText": "setSourceChannelIds it is", "author": "Jeasmine", "createdAt": "2020-04-09T16:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxNzA1Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404917052", "bodyText": "removeDisableInfluences should be removeDisabledInfluences", "author": "mikechoch", "createdAt": "2020-04-07T15:49:02Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";\n+\n+    // Keeps track of unique outcome events sent for UNATTRIBUTED sessions on a per session level\n+    private Set<String> unattributedUniqueOutcomeEventsSentOnSession;\n+\n+    @NonNull\n+    private final OSOutcomeEventsFactory outcomeEventsFactory;\n+    @NonNull\n+    private final OSSessionManager osSessionManager;\n+\n+    public OSOutcomeEventsController(@NonNull OSSessionManager osSessionManager, @NonNull OSOutcomeEventsFactory outcomeEventsFactory) {\n+        this.osSessionManager = osSessionManager;\n+        this.outcomeEventsFactory = outcomeEventsFactory;\n+\n+        initUniqueOutcomeEventsSentSets();\n+    }\n+\n+    /**\n+     * Init the sets used for tracking attributed and unattributed unique outcome events\n+     */\n+    private void initUniqueOutcomeEventsSentSets() {\n+        // Get all cached UNATTRIBUTED unique outcomes\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        Set<String> tempUnattributedUniqueOutcomeEventsSentSet = outcomeEventsFactory.getRepository().getUnattributedUniqueOutcomeEventsSent();\n+        if (tempUnattributedUniqueOutcomeEventsSentSet != null)\n+            unattributedUniqueOutcomeEventsSentOnSession = tempUnattributedUniqueOutcomeEventsSentSet;\n+    }\n+\n+    /**\n+     * Clean unattributed unique outcome events sent so they can be sent after a new session\n+     */\n+    void cleanOutcomes() {\n+        OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal cleanOutcomes for session\");\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        saveUnattributedUniqueOutcomeEvents();\n+    }\n+\n+    /**\n+     * Send all the outcomes that from some reason failed\n+     */\n+    void sendSavedOutcomes() {\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+\n+                List<OSOutcomeEventParams> outcomeEvents = outcomeEventsFactory.getRepository().getSavedOutcomeEvents();\n+                for (OSOutcomeEventParams event : outcomeEvents) {\n+                    sendSavedOutcomeEvent(event);\n+                }\n+            }\n+        }, OS_SEND_SAVED_OUTCOMES).start();\n+    }\n+\n+    private void sendSavedOutcomeEvent(@NonNull final OSOutcomeEventParams event) {\n+        int deviceType = new OSUtils().getDeviceType();\n+        String appId = OneSignal.appId;\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                outcomeEventsFactory.getRepository().removeEvent(event);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, event, responseHandler);\n+    }\n+\n+    void sendClickActionOutcomes(List<OSInAppMessageOutcome> outcomes) {\n+        for (OSInAppMessageOutcome outcome : outcomes) {\n+            String name = outcome.getName();\n+\n+            if (outcome.isUnique()) {\n+                sendUniqueOutcomeEvent(name, null);\n+            } else if (outcome.getWeight() > 0) {\n+                sendOutcomeEventWithValue(name, outcome.getWeight(), null);\n+            } else {\n+                sendOutcomeEvent(name, null);\n+            }\n+        }\n+        // Requests are sent or cached at this point\n+        osSessionManager.onDirectInfluenceFromIAMClickFinished();\n+    }\n+\n+    void sendUniqueOutcomeEvent(@NonNull final String name, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> sessionResult = osSessionManager.getInfluences();\n+        sendUniqueOutcomeEvent(name, sessionResult, callback);\n+    }\n+\n+    void sendOutcomeEvent(@NonNull final String name, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+    }\n+\n+    void sendOutcomeEventWithValue(@NonNull String name, float weight, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, weight, influences, callback);\n+    }\n+\n+    /**\n+     * An unique outcome is considered unattributed when all channels are unattributed\n+     * If one channel is attributed is enough reason to cache attribution\n+     */\n+    private void sendUniqueOutcomeEvent(@NonNull final String name, @NonNull List<OSInfluence> sessionInfluences, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = removeDisableInfluences(sessionInfluences);\n+        if (influences.isEmpty()) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"Unique Outcome disabled for current session\");\n+            return;\n+        }\n+\n+        boolean attributed = false;\n+        boolean unAttributed = false;\n+        for (OSInfluence influence : influences) {\n+            if (influence.getInfluenceType().isAttributed()) {\n+                // At least one channel attributed this outcome\n+                attributed = true;\n+                break;\n+            } else if (influence.getInfluenceType().isUnattributed()) {\n+                unAttributed = true;\n+            } // else DISABLED\n+        }\n+\n+        // Special handling for unique outcomes in the attributed and unattributed scenarios\n+        if (attributed) {\n+            // Make sure unique Ids exist before trying to make measure request\n+            final List<OSInfluence> uniqueInfluences = getUniqueIds(name, influences);\n+            if (uniqueInfluences == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSessionInfluences: \" + influences.toString() +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            sendAndCreateOutcomeEvent(name, 0, uniqueInfluences, callback);\n+        } else if (unAttributed) {\n+            // Make sure unique outcome has not been sent for current unattributed session\n+            if (unattributedUniqueOutcomeEventsSentOnSession.contains(name)) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSession: \" + OSInfluenceType.UNATTRIBUTED +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            unattributedUniqueOutcomeEventsSentOnSession.add(name);\n+            sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+        } else {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled\");\n+        }\n+    }\n+\n+    private void sendAndCreateOutcomeEvent(@NonNull final String name,\n+                                           @NonNull final float weight,\n+                                           @NonNull List<OSInfluence> influences,\n+                                           @Nullable final OneSignal.OutcomeCallback callback) {\n+        final long timestampSeconds = System.currentTimeMillis() / 1000;\n+        final int deviceType = new OSUtils().getDeviceType();\n+        final String appId = OneSignal.appId;\n+\n+        OSOutcomeSourceBody directSourceBody = null;\n+        OSOutcomeSourceBody indirectSourceBody = null;\n+        boolean unattributed = false;\n+\n+        for (OSInfluence influence : influences) {\n+            switch (influence.getInfluenceType()) {\n+                case DIRECT:\n+                    directSourceBody = setIdsOnSourceByChannel(influence, directSourceBody == null ? new OSOutcomeSourceBody() : directSourceBody);\n+                    break;\n+                case INDIRECT:\n+                    indirectSourceBody = setIdsOnSourceByChannel(influence, indirectSourceBody == null ? new OSOutcomeSourceBody() : indirectSourceBody);\n+                    break;\n+                case UNATTRIBUTED:\n+                    unattributed = true;\n+                    break;\n+                case DISABLED:\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for channel: \" + influence.getInfluenceChannel());\n+                    return; // finish method\n+            }\n+        }\n+\n+        if (directSourceBody == null && indirectSourceBody == null && !unattributed) {\n+            // Disabled for all channels\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for all channels\");\n+            return;\n+        }\n+\n+        OSOutcomeSource source = new OSOutcomeSource(directSourceBody, indirectSourceBody);\n+\n+        final OSOutcomeEventParams eventParams = new OSOutcomeEventParams(name, source, weight);\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                saveUniqueOutcome(eventParams);\n+\n+                // The only case where an actual success has occurred and the OutcomeEvent should be sent back\n+                if (callback != null)\n+                    callback.onSuccess(eventParams);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+                        // Only if we need to save and retry the outcome, then we will save the timestamp for future sending\n+                        eventParams.setTimestamp(timestampSeconds);\n+                        outcomeEventsFactory.getRepository().saveOutcomeEvent(eventParams);\n+                    }\n+                }, OS_SAVE_OUTCOMES).start();\n+\n+                OneSignal.onesignalLog(OneSignal.LOG_LEVEL.WARN,\n+                        \"Sending outcome with name: \" + name + \" failed with status code: \" + statusCode + \" and response: \" + response +\n+                                \"\\nOutcome event was cached and will be reattempted on app cold start\");\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, eventParams, responseHandler);\n+    }\n+\n+    private OSOutcomeSourceBody setIdsOnSourceByChannel(OSInfluence influence, OSOutcomeSourceBody sourceBody) {\n+        switch (influence.getInfluenceChannel()) {\n+            case IAM:\n+                sourceBody.setInAppMessagesIds(influence.getIds());\n+                break;\n+            case NOTIFICATION:\n+                sourceBody.setNotificationIds(influence.getIds());\n+                break;\n+        }\n+\n+        return sourceBody;\n+    }\n+\n+    private List<OSInfluence> removeDisableInfluences(List<OSInfluence> influences) {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODk4MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404918980", "bodyText": "we should organize all of our thread name strings into a single class eventually", "author": "mikechoch", "createdAt": "2020-04-07T15:51:35Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMxNjEwOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406316108", "bodyText": "Uhm yeah, we should have a thread handler though. This will be something to improve with the refactor", "author": "Jeasmine", "createdAt": "2020-04-09T16:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyOTI0OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406529249", "bodyText": "that would be even better, just didnt wanna get ahead of myself and rec that. Good idea for future and we could backlog it or add in major release", "author": "mikechoch", "createdAt": "2020-04-09T23:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyOTM1MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406529351", "bodyText": "you can resolve this after reading", "author": "mikechoch", "createdAt": "2020-04-09T23:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1MDgyMg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407550822", "bodyText": "I made a ticket for this https://onesignal.atlassian.net/browse/OS-3741", "author": "Jeasmine", "createdAt": "2020-04-13T15:51:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkxODk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMjI2NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404922265", "bodyText": "Improved comment\nAny outcomes cached in local DB will be reattempted to be sent again\nCached outcomes come from the failure callback of the network request", "author": "mikechoch", "createdAt": "2020-04-07T15:56:00Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";\n+\n+    // Keeps track of unique outcome events sent for UNATTRIBUTED sessions on a per session level\n+    private Set<String> unattributedUniqueOutcomeEventsSentOnSession;\n+\n+    @NonNull\n+    private final OSOutcomeEventsFactory outcomeEventsFactory;\n+    @NonNull\n+    private final OSSessionManager osSessionManager;\n+\n+    public OSOutcomeEventsController(@NonNull OSSessionManager osSessionManager, @NonNull OSOutcomeEventsFactory outcomeEventsFactory) {\n+        this.osSessionManager = osSessionManager;\n+        this.outcomeEventsFactory = outcomeEventsFactory;\n+\n+        initUniqueOutcomeEventsSentSets();\n+    }\n+\n+    /**\n+     * Init the sets used for tracking attributed and unattributed unique outcome events\n+     */\n+    private void initUniqueOutcomeEventsSentSets() {\n+        // Get all cached UNATTRIBUTED unique outcomes\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        Set<String> tempUnattributedUniqueOutcomeEventsSentSet = outcomeEventsFactory.getRepository().getUnattributedUniqueOutcomeEventsSent();\n+        if (tempUnattributedUniqueOutcomeEventsSentSet != null)\n+            unattributedUniqueOutcomeEventsSentOnSession = tempUnattributedUniqueOutcomeEventsSentSet;\n+    }\n+\n+    /**\n+     * Clean unattributed unique outcome events sent so they can be sent after a new session\n+     */\n+    void cleanOutcomes() {\n+        OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal cleanOutcomes for session\");\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        saveUnattributedUniqueOutcomeEvents();\n+    }\n+\n+    /**\n+     * Send all the outcomes that from some reason failed", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTEzNQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404925135", "bodyText": "unAttributed should be unattributed", "author": "mikechoch", "createdAt": "2020-04-07T15:59:35Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";\n+\n+    // Keeps track of unique outcome events sent for UNATTRIBUTED sessions on a per session level\n+    private Set<String> unattributedUniqueOutcomeEventsSentOnSession;\n+\n+    @NonNull\n+    private final OSOutcomeEventsFactory outcomeEventsFactory;\n+    @NonNull\n+    private final OSSessionManager osSessionManager;\n+\n+    public OSOutcomeEventsController(@NonNull OSSessionManager osSessionManager, @NonNull OSOutcomeEventsFactory outcomeEventsFactory) {\n+        this.osSessionManager = osSessionManager;\n+        this.outcomeEventsFactory = outcomeEventsFactory;\n+\n+        initUniqueOutcomeEventsSentSets();\n+    }\n+\n+    /**\n+     * Init the sets used for tracking attributed and unattributed unique outcome events\n+     */\n+    private void initUniqueOutcomeEventsSentSets() {\n+        // Get all cached UNATTRIBUTED unique outcomes\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        Set<String> tempUnattributedUniqueOutcomeEventsSentSet = outcomeEventsFactory.getRepository().getUnattributedUniqueOutcomeEventsSent();\n+        if (tempUnattributedUniqueOutcomeEventsSentSet != null)\n+            unattributedUniqueOutcomeEventsSentOnSession = tempUnattributedUniqueOutcomeEventsSentSet;\n+    }\n+\n+    /**\n+     * Clean unattributed unique outcome events sent so they can be sent after a new session\n+     */\n+    void cleanOutcomes() {\n+        OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal cleanOutcomes for session\");\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        saveUnattributedUniqueOutcomeEvents();\n+    }\n+\n+    /**\n+     * Send all the outcomes that from some reason failed\n+     */\n+    void sendSavedOutcomes() {\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+\n+                List<OSOutcomeEventParams> outcomeEvents = outcomeEventsFactory.getRepository().getSavedOutcomeEvents();\n+                for (OSOutcomeEventParams event : outcomeEvents) {\n+                    sendSavedOutcomeEvent(event);\n+                }\n+            }\n+        }, OS_SEND_SAVED_OUTCOMES).start();\n+    }\n+\n+    private void sendSavedOutcomeEvent(@NonNull final OSOutcomeEventParams event) {\n+        int deviceType = new OSUtils().getDeviceType();\n+        String appId = OneSignal.appId;\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                outcomeEventsFactory.getRepository().removeEvent(event);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, event, responseHandler);\n+    }\n+\n+    void sendClickActionOutcomes(List<OSInAppMessageOutcome> outcomes) {\n+        for (OSInAppMessageOutcome outcome : outcomes) {\n+            String name = outcome.getName();\n+\n+            if (outcome.isUnique()) {\n+                sendUniqueOutcomeEvent(name, null);\n+            } else if (outcome.getWeight() > 0) {\n+                sendOutcomeEventWithValue(name, outcome.getWeight(), null);\n+            } else {\n+                sendOutcomeEvent(name, null);\n+            }\n+        }\n+        // Requests are sent or cached at this point\n+        osSessionManager.onDirectInfluenceFromIAMClickFinished();\n+    }\n+\n+    void sendUniqueOutcomeEvent(@NonNull final String name, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> sessionResult = osSessionManager.getInfluences();\n+        sendUniqueOutcomeEvent(name, sessionResult, callback);\n+    }\n+\n+    void sendOutcomeEvent(@NonNull final String name, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+    }\n+\n+    void sendOutcomeEventWithValue(@NonNull String name, float weight, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, weight, influences, callback);\n+    }\n+\n+    /**\n+     * An unique outcome is considered unattributed when all channels are unattributed\n+     * If one channel is attributed is enough reason to cache attribution\n+     */\n+    private void sendUniqueOutcomeEvent(@NonNull final String name, @NonNull List<OSInfluence> sessionInfluences, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = removeDisableInfluences(sessionInfluences);\n+        if (influences.isEmpty()) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"Unique Outcome disabled for current session\");\n+            return;\n+        }\n+\n+        boolean attributed = false;\n+        boolean unAttributed = false;", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTkwNw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404925907", "bodyText": "influencesCopy should be influenceCopies", "author": "mikechoch", "createdAt": "2020-04-07T16:00:45Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSOutcomeEventsController.java", "diffHunk": "@@ -0,0 +1,324 @@\n+package com.onesignal;\n+\n+import android.os.Process;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsController {\n+\n+    private static final String OS_SAVE_OUTCOMES = \"OS_SAVE_OUTCOMES\";\n+    private static final String OS_SEND_SAVED_OUTCOMES = \"OS_SEND_SAVED_OUTCOMES\";\n+    private static final String OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS = \"OS_SAVE_UNIQUE_OUTCOME_NOTIFICATIONS\";\n+\n+    // Keeps track of unique outcome events sent for UNATTRIBUTED sessions on a per session level\n+    private Set<String> unattributedUniqueOutcomeEventsSentOnSession;\n+\n+    @NonNull\n+    private final OSOutcomeEventsFactory outcomeEventsFactory;\n+    @NonNull\n+    private final OSSessionManager osSessionManager;\n+\n+    public OSOutcomeEventsController(@NonNull OSSessionManager osSessionManager, @NonNull OSOutcomeEventsFactory outcomeEventsFactory) {\n+        this.osSessionManager = osSessionManager;\n+        this.outcomeEventsFactory = outcomeEventsFactory;\n+\n+        initUniqueOutcomeEventsSentSets();\n+    }\n+\n+    /**\n+     * Init the sets used for tracking attributed and unattributed unique outcome events\n+     */\n+    private void initUniqueOutcomeEventsSentSets() {\n+        // Get all cached UNATTRIBUTED unique outcomes\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        Set<String> tempUnattributedUniqueOutcomeEventsSentSet = outcomeEventsFactory.getRepository().getUnattributedUniqueOutcomeEventsSent();\n+        if (tempUnattributedUniqueOutcomeEventsSentSet != null)\n+            unattributedUniqueOutcomeEventsSentOnSession = tempUnattributedUniqueOutcomeEventsSentSet;\n+    }\n+\n+    /**\n+     * Clean unattributed unique outcome events sent so they can be sent after a new session\n+     */\n+    void cleanOutcomes() {\n+        OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal cleanOutcomes for session\");\n+        unattributedUniqueOutcomeEventsSentOnSession = OSUtils.newConcurrentSet();\n+        saveUnattributedUniqueOutcomeEvents();\n+    }\n+\n+    /**\n+     * Send all the outcomes that from some reason failed\n+     */\n+    void sendSavedOutcomes() {\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+\n+                List<OSOutcomeEventParams> outcomeEvents = outcomeEventsFactory.getRepository().getSavedOutcomeEvents();\n+                for (OSOutcomeEventParams event : outcomeEvents) {\n+                    sendSavedOutcomeEvent(event);\n+                }\n+            }\n+        }, OS_SEND_SAVED_OUTCOMES).start();\n+    }\n+\n+    private void sendSavedOutcomeEvent(@NonNull final OSOutcomeEventParams event) {\n+        int deviceType = new OSUtils().getDeviceType();\n+        String appId = OneSignal.appId;\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                outcomeEventsFactory.getRepository().removeEvent(event);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, event, responseHandler);\n+    }\n+\n+    void sendClickActionOutcomes(List<OSInAppMessageOutcome> outcomes) {\n+        for (OSInAppMessageOutcome outcome : outcomes) {\n+            String name = outcome.getName();\n+\n+            if (outcome.isUnique()) {\n+                sendUniqueOutcomeEvent(name, null);\n+            } else if (outcome.getWeight() > 0) {\n+                sendOutcomeEventWithValue(name, outcome.getWeight(), null);\n+            } else {\n+                sendOutcomeEvent(name, null);\n+            }\n+        }\n+        // Requests are sent or cached at this point\n+        osSessionManager.onDirectInfluenceFromIAMClickFinished();\n+    }\n+\n+    void sendUniqueOutcomeEvent(@NonNull final String name, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> sessionResult = osSessionManager.getInfluences();\n+        sendUniqueOutcomeEvent(name, sessionResult, callback);\n+    }\n+\n+    void sendOutcomeEvent(@NonNull final String name, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+    }\n+\n+    void sendOutcomeEventWithValue(@NonNull String name, float weight, @Nullable final OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = osSessionManager.getInfluences();\n+        sendAndCreateOutcomeEvent(name, weight, influences, callback);\n+    }\n+\n+    /**\n+     * An unique outcome is considered unattributed when all channels are unattributed\n+     * If one channel is attributed is enough reason to cache attribution\n+     */\n+    private void sendUniqueOutcomeEvent(@NonNull final String name, @NonNull List<OSInfluence> sessionInfluences, @Nullable OneSignal.OutcomeCallback callback) {\n+        List<OSInfluence> influences = removeDisableInfluences(sessionInfluences);\n+        if (influences.isEmpty()) {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG, \"Unique Outcome disabled for current session\");\n+            return;\n+        }\n+\n+        boolean attributed = false;\n+        boolean unAttributed = false;\n+        for (OSInfluence influence : influences) {\n+            if (influence.getInfluenceType().isAttributed()) {\n+                // At least one channel attributed this outcome\n+                attributed = true;\n+                break;\n+            } else if (influence.getInfluenceType().isUnattributed()) {\n+                unAttributed = true;\n+            } // else DISABLED\n+        }\n+\n+        // Special handling for unique outcomes in the attributed and unattributed scenarios\n+        if (attributed) {\n+            // Make sure unique Ids exist before trying to make measure request\n+            final List<OSInfluence> uniqueInfluences = getUniqueIds(name, influences);\n+            if (uniqueInfluences == null) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSessionInfluences: \" + influences.toString() +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            sendAndCreateOutcomeEvent(name, 0, uniqueInfluences, callback);\n+        } else if (unAttributed) {\n+            // Make sure unique outcome has not been sent for current unattributed session\n+            if (unattributedUniqueOutcomeEventsSentOnSession.contains(name)) {\n+                OneSignal.Log(OneSignal.LOG_LEVEL.DEBUG,\n+                        \"Measure endpoint will not send because unique outcome already sent for: \" +\n+                                \"\\nSession: \" + OSInfluenceType.UNATTRIBUTED +\n+                                \"\\nOutcome name: \" + name);\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+\n+                return;\n+            }\n+\n+            unattributedUniqueOutcomeEventsSentOnSession.add(name);\n+            sendAndCreateOutcomeEvent(name, 0, influences, callback);\n+        } else {\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled\");\n+        }\n+    }\n+\n+    private void sendAndCreateOutcomeEvent(@NonNull final String name,\n+                                           @NonNull final float weight,\n+                                           @NonNull List<OSInfluence> influences,\n+                                           @Nullable final OneSignal.OutcomeCallback callback) {\n+        final long timestampSeconds = System.currentTimeMillis() / 1000;\n+        final int deviceType = new OSUtils().getDeviceType();\n+        final String appId = OneSignal.appId;\n+\n+        OSOutcomeSourceBody directSourceBody = null;\n+        OSOutcomeSourceBody indirectSourceBody = null;\n+        boolean unattributed = false;\n+\n+        for (OSInfluence influence : influences) {\n+            switch (influence.getInfluenceType()) {\n+                case DIRECT:\n+                    directSourceBody = setIdsOnSourceByChannel(influence, directSourceBody == null ? new OSOutcomeSourceBody() : directSourceBody);\n+                    break;\n+                case INDIRECT:\n+                    indirectSourceBody = setIdsOnSourceByChannel(influence, indirectSourceBody == null ? new OSOutcomeSourceBody() : indirectSourceBody);\n+                    break;\n+                case UNATTRIBUTED:\n+                    unattributed = true;\n+                    break;\n+                case DISABLED:\n+                    OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for channel: \" + influence.getInfluenceChannel());\n+                    return; // finish method\n+            }\n+        }\n+\n+        if (directSourceBody == null && indirectSourceBody == null && !unattributed) {\n+            // Disabled for all channels\n+            OneSignal.Log(OneSignal.LOG_LEVEL.VERBOSE, \"Outcomes disabled for all channels\");\n+            return;\n+        }\n+\n+        OSOutcomeSource source = new OSOutcomeSource(directSourceBody, indirectSourceBody);\n+\n+        final OSOutcomeEventParams eventParams = new OSOutcomeEventParams(name, source, weight);\n+\n+        OneSignalApiResponseHandler responseHandler = new OneSignalApiResponseHandler() {\n+            @Override\n+            public void onSuccess(String response) {\n+                saveUniqueOutcome(eventParams);\n+\n+                // The only case where an actual success has occurred and the OutcomeEvent should be sent back\n+                if (callback != null)\n+                    callback.onSuccess(eventParams);\n+            }\n+\n+            @Override\n+            public void onFailure(int statusCode, String response, Throwable throwable) {\n+                new Thread(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        Thread.currentThread().setPriority(Process.THREAD_PRIORITY_BACKGROUND);\n+                        // Only if we need to save and retry the outcome, then we will save the timestamp for future sending\n+                        eventParams.setTimestamp(timestampSeconds);\n+                        outcomeEventsFactory.getRepository().saveOutcomeEvent(eventParams);\n+                    }\n+                }, OS_SAVE_OUTCOMES).start();\n+\n+                OneSignal.onesignalLog(OneSignal.LOG_LEVEL.WARN,\n+                        \"Sending outcome with name: \" + name + \" failed with status code: \" + statusCode + \" and response: \" + response +\n+                                \"\\nOutcome event was cached and will be reattempted on app cold start\");\n+\n+                // Return null within the callback to determine not a failure, but not a success in terms of the request made\n+                if (callback != null)\n+                    callback.onSuccess(null);\n+            }\n+        };\n+\n+        outcomeEventsFactory.getRepository().requestMeasureOutcomeEvent(appId, deviceType, eventParams, responseHandler);\n+    }\n+\n+    private OSOutcomeSourceBody setIdsOnSourceByChannel(OSInfluence influence, OSOutcomeSourceBody sourceBody) {\n+        switch (influence.getInfluenceChannel()) {\n+            case IAM:\n+                sourceBody.setInAppMessagesIds(influence.getIds());\n+                break;\n+            case NOTIFICATION:\n+                sourceBody.setNotificationIds(influence.getIds());\n+                break;\n+        }\n+\n+        return sourceBody;\n+    }\n+\n+    private List<OSInfluence> removeDisableInfluences(List<OSInfluence> influences) {\n+        List<OSInfluence> influencesCopy = new ArrayList<>(influences);", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMxNzQ1Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406317456", "bodyText": "what about availableInfluences?", "author": "Jeasmine", "createdAt": "2020-04-09T16:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTkwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzOTU4Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406539587", "bodyText": "thats fine too!", "author": "mikechoch", "createdAt": "2020-04-10T00:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyNTkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyODkwMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404928903", "bodyText": "Lets just use the whole thing OSPreferencesWrapper should be OSSharedPreferencesWrapper", "author": "mikechoch", "createdAt": "2020-04-07T16:04:28Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSPreferencesWrapper.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import java.util.Set;\n+\n+class OSPreferencesWrapper implements OSSharedPreferences {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDE0MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404930140", "bodyText": "Lets add a global version number and increment it so we only need one\ngetPreferencesName", "author": "mikechoch", "createdAt": "2020-04-07T16:06:17Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSPreferencesWrapper.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import java.util.Set;\n+\n+class OSPreferencesWrapper implements OSSharedPreferences {\n+\n+    @Override\n+    public String getOutcomesV2KeyName() {\n+        return OneSignalPrefs.PREFS_OS_OUTCOMES_V2;\n+    }\n+\n+    @Override\n+    public String getPreferencesName() {\n+        return OneSignalPrefs.PREFS_ONESIGNAL;\n+    }", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMxODk1MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406318951", "bodyText": "Sorry didn't understand this one", "author": "Jeasmine", "createdAt": "2020-04-09T16:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzOTc2Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406539767", "bodyText": "Like for SQL we have a DB version, what if we have a Shared Prefs version? Idk just a thought", "author": "mikechoch", "createdAt": "2020-04-10T00:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1MTU4Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407551587", "bodyText": "oh gotcha, this isn't a version though is only the preference name. I was thinking of having all by default saved on OneSignalPrefs.PREFS_ONESIGNAL preference, but this will need more refactoring. I can create a ticket if you agree", "author": "Jeasmine", "createdAt": "2020-04-13T15:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMDYxMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407610610", "bodyText": "Its not a big deal, was just saying we should use the DB version to know which name to use to get the shared prefs", "author": "mikechoch", "createdAt": "2020-04-13T17:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzMDE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNDExMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404934110", "bodyText": "Inside of getOutcomesV2IsAvailable what do you mean V2Is?", "author": "mikechoch", "createdAt": "2020-04-07T16:11:48Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsCache.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.onesignal.outcomes;\n+\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteException;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.WorkerThread;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OSSharedPreferences;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalDb;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomesDbContract.CachedUniqueOutcomeTable;\n+import com.onesignal.outcomes.OSOutcomesDbContract.OutcomeEventsTable;\n+import com.onesignal.outcomes.model.OSCachedUniqueOutcome;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsCache {\n+\n+    private static final String PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT = \"PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT\";\n+\n+    private OSLogger logger;\n+    private OneSignalDb dbHelper;\n+    private OSSharedPreferences preferences;\n+\n+    OSOutcomeEventsCache(OSLogger logger, OneSignalDb dbHelper, OSSharedPreferences preferences) {\n+        this.logger = logger;\n+        this.dbHelper = dbHelper;\n+        this.preferences = preferences;\n+    }\n+\n+    boolean getOutcomesV2IsAvailable() {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMxOTE3NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406319174", "bodyText": "that we have V2 activated \ud83e\udd14", "author": "Jeasmine", "createdAt": "2020-04-09T16:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNDExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMzg1NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406533854", "bodyText": "OHHH read it wrong, maybe rename?\nisOutcomesV2Available something like this?", "author": "mikechoch", "createdAt": "2020-04-09T23:41:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNDExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1MTc2MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407551760", "bodyText": "much better indeed!", "author": "Jeasmine", "createdAt": "2020-04-13T15:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNDExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzNzI2Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404937266", "bodyText": "We aren't using this everywhere and its much longer text-wise. We should just remove this or be consistent and use it everywhere.\nWe should properly just replace strings that are actual text. I think I added this COMMA_SEP a while ago, cant rem though", "author": "mikechoch", "createdAt": "2020-04-07T16:16:06Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeTableProvider.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.onesignal.outcomes;\n+\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteException;\n+\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.outcomes.OSOutcomesDbContract.CachedUniqueOutcomeTable;\n+import com.onesignal.outcomes.OSOutcomesDbContract.OutcomeEventsTable;\n+\n+public class OSOutcomeTableProvider {\n+\n+    private static final String INTEGER_PRIMARY_KEY_TYPE = \" INTEGER PRIMARY KEY\";\n+    private static final String TEXT_TYPE = \" TEXT\";\n+    private static final String INT_TYPE = \" INTEGER\";\n+    private static final String FLOAT_TYPE = \" FLOAT\";\n+    private static final String TIMESTAMP_TYPE = \" TIMESTAMP\";\n+    private static final String COMMA_SEP = \",\";", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzOTA0NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404939044", "bodyText": "This forces a try catch outside of this method why not just leave the try-catch internal so we dont need to expose it", "author": "mikechoch", "createdAt": "2020-04-07T16:18:44Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/model/OSOutcomeEvent.java", "diffHunk": "@@ -49,38 +68,25 @@ public float getWeight() {\n         return weight;\n     }\n \n-    public JSONObject toJSONObject() {\n+    public JSONObject toJSONObject() throws JSONException {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyMDk1OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406320959", "bodyText": "Because technically with the new format, architecture, models will only beholders of data, any exception will be handle by the manager, controller, etc using this method. And I wanted to abstract the needing of a logger on a model class too", "author": "Jeasmine", "createdAt": "2020-04-09T16:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzOTA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzOTIwMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404939201", "bodyText": "This forces a try catch outside of this method why not just leave the try-catch internal so we dont need to expose it", "author": "mikechoch", "createdAt": "2020-04-07T16:18:57Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/model/OSOutcomeEvent.java", "diffHunk": "@@ -49,38 +68,25 @@ public float getWeight() {\n         return weight;\n     }\n \n-    public JSONObject toJSONObject() {\n+    public JSONObject toJSONObject() throws JSONException {\n         JSONObject json = new JSONObject();\n-\n-        try {\n-            json.put(SESSION, session);\n-            json.put(NOTIFICATION_IDS, notificationIds);\n-            json.put(OUTCOME_ID, name);\n-            json.put(TIMESTAMP, timestamp);\n-            json.put(WEIGHT, weight);\n-        } catch (JSONException exception) {\n-            OneSignal.Log(OneSignal.LOG_LEVEL.ERROR, \"Generating OutcomeEvent toJSONObject \", exception);\n-        }\n-\n+        json.put(SESSION, session);\n+        json.put(NOTIFICATION_IDS, notificationIds);\n+        json.put(OUTCOME_ID, name);\n+        json.put(TIMESTAMP, timestamp);\n+        json.put(WEIGHT, weight);\n         return json;\n     }\n \n-    JSONObject toJSONObjectForMeasure() {\n+    public JSONObject toJSONObjectForMeasure() throws JSONException {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMyMTA3Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406321073", "bodyText": "idem", "author": "Jeasmine", "createdAt": "2020-04-09T16:19:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkzOTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDk0NjEzMg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r404946132", "bodyText": "Nice!", "author": "mikechoch", "createdAt": "2020-04-07T16:28:23Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSPreferences.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public class MockOSPreferences extends OSPreferencesWrapper {", "originalCommit": "586b65deaab4e71768e0d001e0fcc6ba7f5249c2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97396d271391d43682499aa5234066161eac73e1", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/97396d271391d43682499aa5234066161eac73e1", "message": "Address codereview comments", "committedDate": "2020-04-09T16:19:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNDY5Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406534696", "bodyText": "comment should say 7", "author": "mikechoch", "createdAt": "2020-04-09T23:44:26Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/DatabaseRunner.java", "diffHunk": "@@ -37,270 +40,446 @@\n import static com.onesignal.OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerKind;\n import static com.test.onesignal.TestHelpers.getAllNotificationRecords;\n import static com.test.onesignal.TestHelpers.getAllOutcomesRecords;\n-import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecords;\n+import static com.test.onesignal.TestHelpers.getAllOutcomesRecordsDBv5;\n+import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecordsDB;\n+import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecordsDBv5;\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertTrue;\n \n @Config(packageName = \"com.onesignal.example\",\n-        instrumentedPackages = { \"com.onesignal\" },\n+        instrumentedPackages = {\"com.onesignal\"},\n         shadows = {\n-            ShadowOneSignalDbHelper.class\n+                ShadowOneSignalDbHelper.class\n         },\n         sdk = 26\n )\n \n @RunWith(RobolectricTestRunner.class)\n public class DatabaseRunner {\n-   @BeforeClass // Runs only once, before any tests\n-   public static void setUpClass() throws Exception {\n-      ShadowLog.stream = System.out;\n-      TestHelpers.beforeTestSuite();\n-      StaticResetHelper.saveStaticValues();\n-   }\n-\n-   @Before\n-   public void beforeEachTest() throws Exception {\n-      TestHelpers.beforeTestInitAndCleanup();\n-   }\n-\n-   @After\n-   public void afterEachTest() throws Exception {\n-      TestHelpers.afterTestCleanup();\n-   }\n-\n-   @AfterClass\n-   public static void afterEverything() throws Exception {\n-      TestHelpers.beforeTestInitAndCleanup();\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV2ToV3() {\n-      // 1. Init DB as version 2 and add one notification record\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 2;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.beginTransaction();\n-      ContentValues values = new ContentValues();\n-      values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, 1);\n-      writableDatabase.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n-      writableDatabase.setTransactionSuccessful();\n-      writableDatabase.endTransaction();\n-      writableDatabase.close();\n-\n-      // 2. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 3. Opening the DB will auto trigger the update.\n-      HashMap<String, Object> notif = getAllNotificationRecords().get(0);\n-\n-      long createdTime = (Long)notif.get(NotificationTable.COLUMN_NAME_CREATED_TIME);\n-      long expireTime = (Long)notif.get(NotificationTable.COLUMN_NAME_EXPIRE_TIME);\n-      assertEquals(createdTime + (72L * (60 * 60)), expireTime);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV3ToV4() throws Exception {\n-      // 1. Init DB as version 3\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 3;\n-      SQLiteDatabase readableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getReadableDatabase();\n-\n-      Cursor cursor = readableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + OutcomeEventsTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-          exist = cursor.getCount() > 0;\n-          cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      readableDatabase.close();\n-\n-      OutcomeEvent event = new OutcomeEvent(OSSessionManager.Session.UNATTRIBUTED, new JSONArray().put(\"notificationId\"), \"name\", 0, 0);\n-      ContentValues values = new ContentValues();\n-      values.put(OutcomeEventsTable.COLUMN_NAME_SESSION, event.getSession().toString().toLowerCase());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, event.getNotificationIds().toString());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NAME, event.getName());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP, event.getTimestamp());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NAME, event.getWeight());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<OutcomeEvent> events = getAllOutcomesRecords();\n-\n-      assertEquals(events.size(), 0);\n-\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(OutcomeEventsTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<OutcomeEvent> outcomeEvents = getAllOutcomesRecords();\n-\n-      assertEquals(outcomeEvents.size(), 1);\n-   }\n-\n-\n-   private static final String SQL_CREATE_OUTCOME_REVISION1_ENTRIES =\n-      \"CREATE TABLE outcome (\" +\n-         \"_id INTEGER PRIMARY KEY, \" +\n-         \"session TEXT,\" +\n-         \"notification_ids TEXT, \" +\n-         \"name TEXT, \" +\n-         \"timestamp TIMESTAMP, \" +\n-         \"params TEXT \" +\n-      \")\";\n-\n-   @Test\n-   public void shouldUpgradeDbFromV4ToV5() {\n-      // 1. Init DB as version 4\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 4;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + CachedUniqueOutcomeNotificationTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-         exist = cursor.getCount() > 0;\n-         cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      writableDatabase.close();\n-\n-      CachedUniqueOutcomeNotification notification = new CachedUniqueOutcomeNotification(\"notificationId\", \"outcome\");\n-      ContentValues values = new ContentValues();\n-      values.put(CachedUniqueOutcomeNotificationTable.COLUMN_NAME_NOTIFICATION_ID, notification.getNotificationId());\n-      values.put(CachedUniqueOutcomeNotificationTable.COLUMN_NAME_NAME, notification.getName());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<CachedUniqueOutcomeNotification> notifications = getAllUniqueOutcomeNotificationRecords();\n-\n-      assertEquals(notifications.size(), 0);\n-\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(CachedUniqueOutcomeNotificationTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<CachedUniqueOutcomeNotification> uniqueOutcomeNotifications = getAllUniqueOutcomeNotificationRecords();\n-\n-      assertEquals(uniqueOutcomeNotifications.size(), 1);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV5ToV6() {\n-      // 1. Init outcome table as version 5\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 5;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-\n-      // Create table with the schema we had in DB v4\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      // Insert one outcome record so we can test migration keeps it later on\n-      ContentValues values = new ContentValues();\n-      values.put(\"name\", \"a\");\n-      writableDatabase.insertOrThrow(\"outcome\", null, values);\n-      writableDatabase.setVersion(5);\n-      writableDatabase.close();\n-\n-      // 2. restSetStaticFields so the db reloads and upgrade is done to version 6\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-\n-      // 3. Ensure the upgrade kept our existing record\n-      Cursor cursor = writableDatabase.query(\n-         \"outcome\",\n-        null,\n-         null,\n-         null,\n-         null,\n-         null,\n-         null\n-      );\n-      assertTrue(cursor.moveToFirst());\n-      assertEquals(\"a\", cursor.getString(cursor.getColumnIndex(\"name\")));\n-\n-      // 4. Ensure new weight column exists\n-      values = new ContentValues();\n-      values.put(\"weight\", 1);\n-      long successful = writableDatabase.insert(\"outcome\", null, values);\n-      assertFalse(successful == -1);\n-\n-      // 5. Ensure params column does NOT exists\n-      values = new ContentValues();\n-      values.put(\"params\", 1);\n-      successful = writableDatabase.insert(\"outcome\", null, values);\n-      writableDatabase.close();\n-      assertEquals(-1, successful);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV6ToV7() throws JSONException {\n-      // 1. Init DB as version 6\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 6;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + InAppMessageTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-         exist = cursor.getCount() > 0;\n-         cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      writableDatabase.close();\n-\n-      // Create an IAM\n-      final OSTestInAppMessage inAppMessage = InAppMessagingHelpers.buildTestMessageWithSingleTrigger(\n-              OSTriggerKind.SESSION_TIME,\n-              null,\n-              OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerOperator.NOT_EXISTS.toString(),\n-              null);\n-\n-      inAppMessage.setDisplayedInSession(true);\n-      \n-      ContentValues values = new ContentValues();\n-      values.put(InAppMessageTable.COLUMN_NAME_MESSAGE_ID, inAppMessage.messageId);\n-      values.put(InAppMessageTable.COLUMN_NAME_DISPLAY_QUANTITY, inAppMessage.getDisplayStats().getDisplayQuantity());\n-      values.put(InAppMessageTable.COLUMN_NAME_LAST_DISPLAY, inAppMessage.getDisplayStats().getLastDisplayTime());\n-      values.put(InAppMessageTable.COLUMN_CLICK_IDS, inAppMessage.getClickedClickIds().toString());\n-      values.put(InAppMessageTable.COLUMN_DISPLAYED_IN_SESSION, inAppMessage.isDisplayedInSession());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<OSTestInAppMessage> savedInAppMessages = TestHelpers.getAllInAppMessages();\n-\n-      assertEquals(savedInAppMessages.size(), 0);\n-\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(InAppMessageTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<OSTestInAppMessage> savedInAppMessagesAfterCreation = TestHelpers.getAllInAppMessages();\n-\n-      assertEquals(savedInAppMessagesAfterCreation.size(), 1);\n-      OSTestInAppMessage savedInAppMessage = savedInAppMessagesAfterCreation.get(0);\n-      assertEquals(savedInAppMessage.getDisplayStats().getDisplayQuantity(), inAppMessage.getDisplayStats().getDisplayQuantity());\n-      assertEquals(savedInAppMessage.getDisplayStats().getLastDisplayTime(), inAppMessage.getDisplayStats().getLastDisplayTime());\n-      assertEquals(savedInAppMessage.getClickedClickIds().toString(), inAppMessage.getClickedClickIds().toString());\n-      assertEquals(savedInAppMessage.isDisplayedInSession(), inAppMessage.isDisplayedInSession());\n-   }\n+\n+    private static final String INTEGER_PRIMARY_KEY_TYPE = \" INTEGER PRIMARY KEY\";\n+    private static final String TEXT_TYPE = \" TEXT\";\n+    private static final String INT_TYPE = \" INTEGER\";\n+    private static final String FLOAT_TYPE = \" FLOAT\";\n+    private static final String TIMESTAMP_TYPE = \" TIMESTAMP\";\n+    private static final String COMMA_SEP = \",\";\n+\n+    private MockOneSignalDBHelper dbHelper;\n+    private MockOSOutcomeTableProvider outcomeTableProvider;\n+\n+    @BeforeClass // Runs only once, before any tests\n+    public static void setUpClass() throws Exception {\n+        ShadowLog.stream = System.out;\n+        TestHelpers.beforeTestSuite();\n+        StaticResetHelper.saveStaticValues();\n+    }\n+\n+    @Before\n+    public void beforeEachTest() throws Exception {\n+        TestHelpers.beforeTestInitAndCleanup();\n+\n+        outcomeTableProvider = new MockOSOutcomeTableProvider();\n+        dbHelper = new MockOneSignalDBHelper(RuntimeEnvironment.application);\n+        dbHelper.setOutcomeTableProvider(outcomeTableProvider);\n+    }\n+\n+    @After\n+    public void afterEachTest() throws Exception {\n+        outcomeTableProvider.clean();\n+        TestHelpers.afterTestCleanup();\n+    }\n+\n+    @AfterClass\n+    public static void afterEverything() throws Exception {\n+        TestHelpers.beforeTestInitAndCleanup();\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV2ToV3() {\n+        // 1. Init DB as version 2 and add one notification record\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 2;\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+        writableDatabase.beginTransaction();\n+        ContentValues values = new ContentValues();\n+        values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, 1);\n+        writableDatabase.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n+        writableDatabase.setTransactionSuccessful();\n+        writableDatabase.endTransaction();\n+        writableDatabase.setVersion(2);\n+        writableDatabase.close();\n+\n+        // 2. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 3. Opening the DB will auto trigger the update.\n+        HashMap<String, Object> notif = getAllNotificationRecords(dbHelper).get(0);\n+\n+        long createdTime = (Long) notif.get(NotificationTable.COLUMN_NAME_CREATED_TIME);\n+        long expireTime = (Long) notif.get(NotificationTable.COLUMN_NAME_EXPIRE_TIME);\n+        assertEquals(createdTime + (72L * (60 * 60)), expireTime);\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV3ToV4() throws Exception {\n+        // 1. Init DB as version 3\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 3;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + MockOSOutcomeEventsTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(3);\n+        writableDatabase.close();\n+\n+        OSOutcomeEvent event = new OSOutcomeEvent(OSInfluenceType.UNATTRIBUTED, new JSONArray().put(\"notificationId\"), \"name\", 0, 0);\n+        ContentValues values = new ContentValues();\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_SESSION, event.getSession().toString().toLowerCase());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, event.getNotificationIds().toString());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_NAME, event.getName());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_TIMESTAMP, event.getTimestamp());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_WEIGHT, event.getWeight());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSOutcomeEvent> events = getAllOutcomesRecordsDBv5(dbHelper);\n+\n+        assertEquals(events.size(), 0);\n+\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        // 5. Table now must exist\n+        writableDatabase.insert(MockOSOutcomeEventsTable.TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSOutcomeEvent> outcomeEvents = getAllOutcomesRecordsDBv5(dbHelper);\n+\n+        assertEquals(outcomeEvents.size(), 1);\n+    }\n+\n+    private static final String SQL_CREATE_OUTCOME_REVISION1_ENTRIES =\n+            \"CREATE TABLE outcome (\" +\n+                    \"_id INTEGER PRIMARY KEY, \" +\n+                    \"session TEXT,\" +\n+                    \"notification_ids TEXT, \" +\n+                    \"name TEXT, \" +\n+                    \"timestamp TIMESTAMP, \" +\n+                    \"params TEXT \" +\n+                    \")\";\n+\n+    private static final String SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES =\n+            \"CREATE TABLE \" + MockOSCachedUniqueOutcomeTable.OLD_TABLE_NAME + \" (\" +\n+                    MockOSCachedUniqueOutcomeTable._ID + INTEGER_PRIMARY_KEY_TYPE + COMMA_SEP +\n+                    MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NOTIFICATION_ID + TEXT_TYPE + COMMA_SEP +\n+                    MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME + TEXT_TYPE +\n+                    \");\";\n+\n+    @Test\n+    public void shouldUpgradeDbFromV4ToV5() {\n+        // 1. Init DB as version 4\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 4;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        outcomeTableProvider.setMockedSqlCreateUniqueOutcomeEntries(SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // Create table with the schema we had in DB v4\n+        writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + MockOSCachedUniqueOutcomeTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(4);\n+        writableDatabase.close();\n+\n+        OSCachedUniqueOutcome notification = new OSCachedUniqueOutcome(\"outcome\", \"notificationId\", OSInfluenceChannel.NOTIFICATION);\n+        ContentValues values = new ContentValues();\n+        values.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NOTIFICATION_ID, notification.getInfluenceId());\n+        values.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME, notification.getName());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSCachedUniqueOutcome> notifications = getAllUniqueOutcomeNotificationRecordsDBv5(dbHelper);\n+        assertEquals(notifications.size(), 0);\n+\n+        // 5. Table now must exist\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        writableDatabase.insert(MockOSCachedUniqueOutcomeTable.OLD_TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSCachedUniqueOutcome> uniqueOutcomeNotifications = getAllUniqueOutcomeNotificationRecordsDBv5(dbHelper);\n+\n+        assertEquals(1, uniqueOutcomeNotifications.size());\n+    }\n+\n+    private static final String SQL_CREATE_OUTCOME_REVISION2_ENTRIES =\n+            \"CREATE TABLE outcome (\" +\n+                    \"_id INTEGER PRIMARY KEY, \" +\n+                    \"session TEXT,\" +\n+                    \"notification_ids TEXT, \" +\n+                    \"name TEXT, \" +\n+                    \"timestamp TIMESTAMP, \" +\n+                    \"weight FLOAT \" +\n+                    \")\";\n+\n+\n+    @Test\n+    public void shouldUpgradeDbFromV5ToV6() {\n+        // 1. Init outcome table as version 5\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 5;\n+        // Create table with the schema we had in DB v4\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // Create table with the schema we had in DB v4\n+        writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+\n+        // Insert one outcome record so we can test migration keeps it later on\n+        ContentValues values = new ContentValues();\n+        values.put(\"name\", \"a\");\n+        writableDatabase.insertOrThrow(\"outcome\", null, values);\n+        writableDatabase.setVersion(5);\n+        writableDatabase.close();\n+\n+        // 2. restSetStaticFields so the db reloads and upgrade is done to version 6\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+\n+        // Create table with the schema we had in DB v6\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // 3. Ensure the upgrade kept our existing record\n+        Cursor cursor = writableDatabase.query(\n+                \"outcome\",\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null\n+        );\n+        assertTrue(cursor.moveToFirst());\n+        assertEquals(\"a\", cursor.getString(cursor.getColumnIndex(\"name\")));\n+\n+        // 4. Ensure new weight column exists\n+        values = new ContentValues();\n+        values.put(\"weight\", 1);\n+        long successful = writableDatabase.insert(\"outcome\", null, values);\n+        assertFalse(successful == -1);\n+\n+        // 5. Ensure params column does NOT exists\n+        values = new ContentValues();\n+        values.put(\"params\", 1);\n+        successful = writableDatabase.insert(\"outcome\", null, values);\n+        writableDatabase.close();\n+        assertEquals(-1, successful);\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV6ToV7() throws JSONException {\n+        // 1. Init DB as version 6\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 6;\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + InAppMessageTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(6);\n+        writableDatabase.close();\n+\n+        // Create an IAM\n+        final OSTestInAppMessage inAppMessage = InAppMessagingHelpers.buildTestMessageWithSingleTrigger(\n+                OSTriggerKind.SESSION_TIME,\n+                null,\n+                OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerOperator.NOT_EXISTS.toString(),\n+                null);\n+\n+        inAppMessage.setDisplayedInSession(true);\n+\n+        ContentValues values = new ContentValues();\n+        values.put(InAppMessageTable.COLUMN_NAME_MESSAGE_ID, inAppMessage.messageId);\n+        values.put(InAppMessageTable.COLUMN_NAME_DISPLAY_QUANTITY, inAppMessage.getDisplayStats().getDisplayQuantity());\n+        values.put(InAppMessageTable.COLUMN_NAME_LAST_DISPLAY, inAppMessage.getDisplayStats().getLastDisplayTime());\n+        values.put(InAppMessageTable.COLUMN_CLICK_IDS, inAppMessage.getClickedClickIds().toString());\n+        values.put(InAppMessageTable.COLUMN_DISPLAYED_IN_SESSION, inAppMessage.isDisplayedInSession());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSTestInAppMessage> savedInAppMessages = TestHelpers.getAllInAppMessages(dbHelper);\n+        assertEquals(savedInAppMessages.size(), 0);\n+\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        // 5. Table now must exist\n+        writableDatabase.insert(InAppMessageTable.TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSTestInAppMessage> savedInAppMessagesAfterCreation = TestHelpers.getAllInAppMessages(dbHelper);\n+\n+        assertEquals(savedInAppMessagesAfterCreation.size(), 1);\n+        OSTestInAppMessage savedInAppMessage = savedInAppMessagesAfterCreation.get(0);\n+        assertEquals(savedInAppMessage.getDisplayStats().getDisplayQuantity(), inAppMessage.getDisplayStats().getDisplayQuantity());\n+        assertEquals(savedInAppMessage.getDisplayStats().getLastDisplayTime(), inAppMessage.getDisplayStats().getLastDisplayTime());\n+        assertEquals(savedInAppMessage.getClickedClickIds().toString(), inAppMessage.getClickedClickIds().toString());\n+        assertEquals(savedInAppMessage.isDisplayedInSession(), inAppMessage.isDisplayedInSession());\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV7ToV8CacheUniqueOutcomeTable() throws JSONException {\n+        // 1. Init DB as version 6", "originalCommit": "97396d271391d43682499aa5234066161eac73e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzNDc4NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r406534784", "bodyText": "comment should say 7", "author": "mikechoch", "createdAt": "2020-04-09T23:44:47Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/DatabaseRunner.java", "diffHunk": "@@ -37,270 +40,446 @@\n import static com.onesignal.OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerKind;\n import static com.test.onesignal.TestHelpers.getAllNotificationRecords;\n import static com.test.onesignal.TestHelpers.getAllOutcomesRecords;\n-import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecords;\n+import static com.test.onesignal.TestHelpers.getAllOutcomesRecordsDBv5;\n+import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecordsDB;\n+import static com.test.onesignal.TestHelpers.getAllUniqueOutcomeNotificationRecordsDBv5;\n import static junit.framework.Assert.assertEquals;\n import static junit.framework.Assert.assertFalse;\n import static junit.framework.Assert.assertTrue;\n \n @Config(packageName = \"com.onesignal.example\",\n-        instrumentedPackages = { \"com.onesignal\" },\n+        instrumentedPackages = {\"com.onesignal\"},\n         shadows = {\n-            ShadowOneSignalDbHelper.class\n+                ShadowOneSignalDbHelper.class\n         },\n         sdk = 26\n )\n \n @RunWith(RobolectricTestRunner.class)\n public class DatabaseRunner {\n-   @BeforeClass // Runs only once, before any tests\n-   public static void setUpClass() throws Exception {\n-      ShadowLog.stream = System.out;\n-      TestHelpers.beforeTestSuite();\n-      StaticResetHelper.saveStaticValues();\n-   }\n-\n-   @Before\n-   public void beforeEachTest() throws Exception {\n-      TestHelpers.beforeTestInitAndCleanup();\n-   }\n-\n-   @After\n-   public void afterEachTest() throws Exception {\n-      TestHelpers.afterTestCleanup();\n-   }\n-\n-   @AfterClass\n-   public static void afterEverything() throws Exception {\n-      TestHelpers.beforeTestInitAndCleanup();\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV2ToV3() {\n-      // 1. Init DB as version 2 and add one notification record\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 2;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.beginTransaction();\n-      ContentValues values = new ContentValues();\n-      values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, 1);\n-      writableDatabase.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n-      writableDatabase.setTransactionSuccessful();\n-      writableDatabase.endTransaction();\n-      writableDatabase.close();\n-\n-      // 2. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 3. Opening the DB will auto trigger the update.\n-      HashMap<String, Object> notif = getAllNotificationRecords().get(0);\n-\n-      long createdTime = (Long)notif.get(NotificationTable.COLUMN_NAME_CREATED_TIME);\n-      long expireTime = (Long)notif.get(NotificationTable.COLUMN_NAME_EXPIRE_TIME);\n-      assertEquals(createdTime + (72L * (60 * 60)), expireTime);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV3ToV4() throws Exception {\n-      // 1. Init DB as version 3\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 3;\n-      SQLiteDatabase readableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getReadableDatabase();\n-\n-      Cursor cursor = readableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + OutcomeEventsTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-          exist = cursor.getCount() > 0;\n-          cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      readableDatabase.close();\n-\n-      OutcomeEvent event = new OutcomeEvent(OSSessionManager.Session.UNATTRIBUTED, new JSONArray().put(\"notificationId\"), \"name\", 0, 0);\n-      ContentValues values = new ContentValues();\n-      values.put(OutcomeEventsTable.COLUMN_NAME_SESSION, event.getSession().toString().toLowerCase());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, event.getNotificationIds().toString());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NAME, event.getName());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP, event.getTimestamp());\n-      values.put(OutcomeEventsTable.COLUMN_NAME_NAME, event.getWeight());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<OutcomeEvent> events = getAllOutcomesRecords();\n-\n-      assertEquals(events.size(), 0);\n-\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(OutcomeEventsTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<OutcomeEvent> outcomeEvents = getAllOutcomesRecords();\n-\n-      assertEquals(outcomeEvents.size(), 1);\n-   }\n-\n-\n-   private static final String SQL_CREATE_OUTCOME_REVISION1_ENTRIES =\n-      \"CREATE TABLE outcome (\" +\n-         \"_id INTEGER PRIMARY KEY, \" +\n-         \"session TEXT,\" +\n-         \"notification_ids TEXT, \" +\n-         \"name TEXT, \" +\n-         \"timestamp TIMESTAMP, \" +\n-         \"params TEXT \" +\n-      \")\";\n-\n-   @Test\n-   public void shouldUpgradeDbFromV4ToV5() {\n-      // 1. Init DB as version 4\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 4;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + CachedUniqueOutcomeNotificationTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-         exist = cursor.getCount() > 0;\n-         cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      writableDatabase.close();\n-\n-      CachedUniqueOutcomeNotification notification = new CachedUniqueOutcomeNotification(\"notificationId\", \"outcome\");\n-      ContentValues values = new ContentValues();\n-      values.put(CachedUniqueOutcomeNotificationTable.COLUMN_NAME_NOTIFICATION_ID, notification.getNotificationId());\n-      values.put(CachedUniqueOutcomeNotificationTable.COLUMN_NAME_NAME, notification.getName());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<CachedUniqueOutcomeNotification> notifications = getAllUniqueOutcomeNotificationRecords();\n-\n-      assertEquals(notifications.size(), 0);\n-\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(CachedUniqueOutcomeNotificationTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<CachedUniqueOutcomeNotification> uniqueOutcomeNotifications = getAllUniqueOutcomeNotificationRecords();\n-\n-      assertEquals(uniqueOutcomeNotifications.size(), 1);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV5ToV6() {\n-      // 1. Init outcome table as version 5\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 5;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-\n-      // Create table with the schema we had in DB v4\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      // Insert one outcome record so we can test migration keeps it later on\n-      ContentValues values = new ContentValues();\n-      values.put(\"name\", \"a\");\n-      writableDatabase.insertOrThrow(\"outcome\", null, values);\n-      writableDatabase.setVersion(5);\n-      writableDatabase.close();\n-\n-      // 2. restSetStaticFields so the db reloads and upgrade is done to version 6\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-\n-      // 3. Ensure the upgrade kept our existing record\n-      Cursor cursor = writableDatabase.query(\n-         \"outcome\",\n-        null,\n-         null,\n-         null,\n-         null,\n-         null,\n-         null\n-      );\n-      assertTrue(cursor.moveToFirst());\n-      assertEquals(\"a\", cursor.getString(cursor.getColumnIndex(\"name\")));\n-\n-      // 4. Ensure new weight column exists\n-      values = new ContentValues();\n-      values.put(\"weight\", 1);\n-      long successful = writableDatabase.insert(\"outcome\", null, values);\n-      assertFalse(successful == -1);\n-\n-      // 5. Ensure params column does NOT exists\n-      values = new ContentValues();\n-      values.put(\"params\", 1);\n-      successful = writableDatabase.insert(\"outcome\", null, values);\n-      writableDatabase.close();\n-      assertEquals(-1, successful);\n-   }\n-\n-   @Test\n-   public void shouldUpgradeDbFromV6ToV7() throws JSONException {\n-      // 1. Init DB as version 6\n-      ShadowOneSignalDbHelper.DATABASE_VERSION = 6;\n-      SQLiteDatabase writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n-\n-      Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + InAppMessageTable.TABLE_NAME + \"'\", null);\n-\n-      boolean exist = false;\n-      if (cursor != null) {\n-         exist = cursor.getCount() > 0;\n-         cursor.close();\n-      }\n-      // 2. Table must not exist\n-      assertFalse(exist);\n-\n-      writableDatabase.close();\n-\n-      // Create an IAM\n-      final OSTestInAppMessage inAppMessage = InAppMessagingHelpers.buildTestMessageWithSingleTrigger(\n-              OSTriggerKind.SESSION_TIME,\n-              null,\n-              OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerOperator.NOT_EXISTS.toString(),\n-              null);\n-\n-      inAppMessage.setDisplayedInSession(true);\n-      \n-      ContentValues values = new ContentValues();\n-      values.put(InAppMessageTable.COLUMN_NAME_MESSAGE_ID, inAppMessage.messageId);\n-      values.put(InAppMessageTable.COLUMN_NAME_DISPLAY_QUANTITY, inAppMessage.getDisplayStats().getDisplayQuantity());\n-      values.put(InAppMessageTable.COLUMN_NAME_LAST_DISPLAY, inAppMessage.getDisplayStats().getLastDisplayTime());\n-      values.put(InAppMessageTable.COLUMN_CLICK_IDS, inAppMessage.getClickedClickIds().toString());\n-      values.put(InAppMessageTable.COLUMN_DISPLAYED_IN_SESSION, inAppMessage.isDisplayedInSession());\n-\n-      // 3. Clear the cache of the DB so it reloads the file.\n-      ShadowOneSignalDbHelper.restSetStaticFields();\n-      ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n-\n-      // 4. Opening the DB will auto trigger the update.\n-      List<OSTestInAppMessage> savedInAppMessages = TestHelpers.getAllInAppMessages();\n-\n-      assertEquals(savedInAppMessages.size(), 0);\n-\n-      writableDatabase = OneSignalDbHelper.getInstance(RuntimeEnvironment.application).getWritableDatabase();\n-      // 5. Table now must exist\n-      writableDatabase.insert(InAppMessageTable.TABLE_NAME, null, values);\n-      writableDatabase.close();\n-\n-      List<OSTestInAppMessage> savedInAppMessagesAfterCreation = TestHelpers.getAllInAppMessages();\n-\n-      assertEquals(savedInAppMessagesAfterCreation.size(), 1);\n-      OSTestInAppMessage savedInAppMessage = savedInAppMessagesAfterCreation.get(0);\n-      assertEquals(savedInAppMessage.getDisplayStats().getDisplayQuantity(), inAppMessage.getDisplayStats().getDisplayQuantity());\n-      assertEquals(savedInAppMessage.getDisplayStats().getLastDisplayTime(), inAppMessage.getDisplayStats().getLastDisplayTime());\n-      assertEquals(savedInAppMessage.getClickedClickIds().toString(), inAppMessage.getClickedClickIds().toString());\n-      assertEquals(savedInAppMessage.isDisplayedInSession(), inAppMessage.isDisplayedInSession());\n-   }\n+\n+    private static final String INTEGER_PRIMARY_KEY_TYPE = \" INTEGER PRIMARY KEY\";\n+    private static final String TEXT_TYPE = \" TEXT\";\n+    private static final String INT_TYPE = \" INTEGER\";\n+    private static final String FLOAT_TYPE = \" FLOAT\";\n+    private static final String TIMESTAMP_TYPE = \" TIMESTAMP\";\n+    private static final String COMMA_SEP = \",\";\n+\n+    private MockOneSignalDBHelper dbHelper;\n+    private MockOSOutcomeTableProvider outcomeTableProvider;\n+\n+    @BeforeClass // Runs only once, before any tests\n+    public static void setUpClass() throws Exception {\n+        ShadowLog.stream = System.out;\n+        TestHelpers.beforeTestSuite();\n+        StaticResetHelper.saveStaticValues();\n+    }\n+\n+    @Before\n+    public void beforeEachTest() throws Exception {\n+        TestHelpers.beforeTestInitAndCleanup();\n+\n+        outcomeTableProvider = new MockOSOutcomeTableProvider();\n+        dbHelper = new MockOneSignalDBHelper(RuntimeEnvironment.application);\n+        dbHelper.setOutcomeTableProvider(outcomeTableProvider);\n+    }\n+\n+    @After\n+    public void afterEachTest() throws Exception {\n+        outcomeTableProvider.clean();\n+        TestHelpers.afterTestCleanup();\n+    }\n+\n+    @AfterClass\n+    public static void afterEverything() throws Exception {\n+        TestHelpers.beforeTestInitAndCleanup();\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV2ToV3() {\n+        // 1. Init DB as version 2 and add one notification record\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 2;\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+        writableDatabase.beginTransaction();\n+        ContentValues values = new ContentValues();\n+        values.put(NotificationTable.COLUMN_NAME_ANDROID_NOTIFICATION_ID, 1);\n+        writableDatabase.insertOrThrow(NotificationTable.TABLE_NAME, null, values);\n+        writableDatabase.setTransactionSuccessful();\n+        writableDatabase.endTransaction();\n+        writableDatabase.setVersion(2);\n+        writableDatabase.close();\n+\n+        // 2. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 3. Opening the DB will auto trigger the update.\n+        HashMap<String, Object> notif = getAllNotificationRecords(dbHelper).get(0);\n+\n+        long createdTime = (Long) notif.get(NotificationTable.COLUMN_NAME_CREATED_TIME);\n+        long expireTime = (Long) notif.get(NotificationTable.COLUMN_NAME_EXPIRE_TIME);\n+        assertEquals(createdTime + (72L * (60 * 60)), expireTime);\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV3ToV4() throws Exception {\n+        // 1. Init DB as version 3\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 3;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + MockOSOutcomeEventsTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(3);\n+        writableDatabase.close();\n+\n+        OSOutcomeEvent event = new OSOutcomeEvent(OSInfluenceType.UNATTRIBUTED, new JSONArray().put(\"notificationId\"), \"name\", 0, 0);\n+        ContentValues values = new ContentValues();\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_SESSION, event.getSession().toString().toLowerCase());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, event.getNotificationIds().toString());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_NAME, event.getName());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_TIMESTAMP, event.getTimestamp());\n+        values.put(MockOSOutcomeEventsTable.COLUMN_NAME_WEIGHT, event.getWeight());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSOutcomeEvent> events = getAllOutcomesRecordsDBv5(dbHelper);\n+\n+        assertEquals(events.size(), 0);\n+\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        // 5. Table now must exist\n+        writableDatabase.insert(MockOSOutcomeEventsTable.TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSOutcomeEvent> outcomeEvents = getAllOutcomesRecordsDBv5(dbHelper);\n+\n+        assertEquals(outcomeEvents.size(), 1);\n+    }\n+\n+    private static final String SQL_CREATE_OUTCOME_REVISION1_ENTRIES =\n+            \"CREATE TABLE outcome (\" +\n+                    \"_id INTEGER PRIMARY KEY, \" +\n+                    \"session TEXT,\" +\n+                    \"notification_ids TEXT, \" +\n+                    \"name TEXT, \" +\n+                    \"timestamp TIMESTAMP, \" +\n+                    \"params TEXT \" +\n+                    \")\";\n+\n+    private static final String SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES =\n+            \"CREATE TABLE \" + MockOSCachedUniqueOutcomeTable.OLD_TABLE_NAME + \" (\" +\n+                    MockOSCachedUniqueOutcomeTable._ID + INTEGER_PRIMARY_KEY_TYPE + COMMA_SEP +\n+                    MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NOTIFICATION_ID + TEXT_TYPE + COMMA_SEP +\n+                    MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME + TEXT_TYPE +\n+                    \");\";\n+\n+    @Test\n+    public void shouldUpgradeDbFromV4ToV5() {\n+        // 1. Init DB as version 4\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 4;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        outcomeTableProvider.setMockedSqlCreateUniqueOutcomeEntries(SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // Create table with the schema we had in DB v4\n+        writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + MockOSCachedUniqueOutcomeTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(4);\n+        writableDatabase.close();\n+\n+        OSCachedUniqueOutcome notification = new OSCachedUniqueOutcome(\"outcome\", \"notificationId\", OSInfluenceChannel.NOTIFICATION);\n+        ContentValues values = new ContentValues();\n+        values.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NOTIFICATION_ID, notification.getInfluenceId());\n+        values.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME, notification.getName());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSCachedUniqueOutcome> notifications = getAllUniqueOutcomeNotificationRecordsDBv5(dbHelper);\n+        assertEquals(notifications.size(), 0);\n+\n+        // 5. Table now must exist\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        writableDatabase.insert(MockOSCachedUniqueOutcomeTable.OLD_TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSCachedUniqueOutcome> uniqueOutcomeNotifications = getAllUniqueOutcomeNotificationRecordsDBv5(dbHelper);\n+\n+        assertEquals(1, uniqueOutcomeNotifications.size());\n+    }\n+\n+    private static final String SQL_CREATE_OUTCOME_REVISION2_ENTRIES =\n+            \"CREATE TABLE outcome (\" +\n+                    \"_id INTEGER PRIMARY KEY, \" +\n+                    \"session TEXT,\" +\n+                    \"notification_ids TEXT, \" +\n+                    \"name TEXT, \" +\n+                    \"timestamp TIMESTAMP, \" +\n+                    \"weight FLOAT \" +\n+                    \")\";\n+\n+\n+    @Test\n+    public void shouldUpgradeDbFromV5ToV6() {\n+        // 1. Init outcome table as version 5\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 5;\n+        // Create table with the schema we had in DB v4\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // Create table with the schema we had in DB v4\n+        writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION1_ENTRIES);\n+\n+        // Insert one outcome record so we can test migration keeps it later on\n+        ContentValues values = new ContentValues();\n+        values.put(\"name\", \"a\");\n+        writableDatabase.insertOrThrow(\"outcome\", null, values);\n+        writableDatabase.setVersion(5);\n+        writableDatabase.close();\n+\n+        // 2. restSetStaticFields so the db reloads and upgrade is done to version 6\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+\n+        // Create table with the schema we had in DB v6\n+        outcomeTableProvider.setMockedSqlCreateOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        writableDatabase = dbHelper.getWritableDatabase();\n+\n+        // 3. Ensure the upgrade kept our existing record\n+        Cursor cursor = writableDatabase.query(\n+                \"outcome\",\n+                null,\n+                null,\n+                null,\n+                null,\n+                null,\n+                null\n+        );\n+        assertTrue(cursor.moveToFirst());\n+        assertEquals(\"a\", cursor.getString(cursor.getColumnIndex(\"name\")));\n+\n+        // 4. Ensure new weight column exists\n+        values = new ContentValues();\n+        values.put(\"weight\", 1);\n+        long successful = writableDatabase.insert(\"outcome\", null, values);\n+        assertFalse(successful == -1);\n+\n+        // 5. Ensure params column does NOT exists\n+        values = new ContentValues();\n+        values.put(\"params\", 1);\n+        successful = writableDatabase.insert(\"outcome\", null, values);\n+        writableDatabase.close();\n+        assertEquals(-1, successful);\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV6ToV7() throws JSONException {\n+        // 1. Init DB as version 6\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 6;\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + InAppMessageTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+        writableDatabase.setVersion(6);\n+        writableDatabase.close();\n+\n+        // Create an IAM\n+        final OSTestInAppMessage inAppMessage = InAppMessagingHelpers.buildTestMessageWithSingleTrigger(\n+                OSTriggerKind.SESSION_TIME,\n+                null,\n+                OneSignalPackagePrivateHelper.OSTestTrigger.OSTriggerOperator.NOT_EXISTS.toString(),\n+                null);\n+\n+        inAppMessage.setDisplayedInSession(true);\n+\n+        ContentValues values = new ContentValues();\n+        values.put(InAppMessageTable.COLUMN_NAME_MESSAGE_ID, inAppMessage.messageId);\n+        values.put(InAppMessageTable.COLUMN_NAME_DISPLAY_QUANTITY, inAppMessage.getDisplayStats().getDisplayQuantity());\n+        values.put(InAppMessageTable.COLUMN_NAME_LAST_DISPLAY, inAppMessage.getDisplayStats().getLastDisplayTime());\n+        values.put(InAppMessageTable.COLUMN_CLICK_IDS, inAppMessage.getClickedClickIds().toString());\n+        values.put(InAppMessageTable.COLUMN_DISPLAYED_IN_SESSION, inAppMessage.isDisplayedInSession());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 4. Opening the DB will auto trigger the update.\n+        List<OSTestInAppMessage> savedInAppMessages = TestHelpers.getAllInAppMessages(dbHelper);\n+        assertEquals(savedInAppMessages.size(), 0);\n+\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        // 5. Table now must exist\n+        writableDatabase.insert(InAppMessageTable.TABLE_NAME, null, values);\n+        writableDatabase.close();\n+\n+        List<OSTestInAppMessage> savedInAppMessagesAfterCreation = TestHelpers.getAllInAppMessages(dbHelper);\n+\n+        assertEquals(savedInAppMessagesAfterCreation.size(), 1);\n+        OSTestInAppMessage savedInAppMessage = savedInAppMessagesAfterCreation.get(0);\n+        assertEquals(savedInAppMessage.getDisplayStats().getDisplayQuantity(), inAppMessage.getDisplayStats().getDisplayQuantity());\n+        assertEquals(savedInAppMessage.getDisplayStats().getLastDisplayTime(), inAppMessage.getDisplayStats().getLastDisplayTime());\n+        assertEquals(savedInAppMessage.getClickedClickIds().toString(), inAppMessage.getClickedClickIds().toString());\n+        assertEquals(savedInAppMessage.isDisplayedInSession(), inAppMessage.isDisplayedInSession());\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV7ToV8CacheUniqueOutcomeTable() throws JSONException {\n+        // 1. Init DB as version 6\n+        ShadowOneSignalDbHelper.DATABASE_VERSION = 7;\n+        // Mock table with the schema we had in DB v7\n+        outcomeTableProvider.setMockedSqlCreateUniqueOutcomeEntries(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        outcomeTableProvider.setMockedSqlCreateUniqueOutcomeEntries(SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES);\n+        SQLiteDatabase writableDatabase = dbHelper.getWritableDatabase();\n+        // disable tables upgrades on future versions\n+        outcomeTableProvider.disableUpgrade();\n+        // Create table with the schema we had in DB v7\n+        writableDatabase.execSQL(SQL_CREATE_OUTCOME_REVISION2_ENTRIES);\n+        writableDatabase.execSQL(SQL_CREATE_UNIQUE_OUTCOME_REVISION1_ENTRIES);\n+\n+        Cursor cursor = writableDatabase.rawQuery(\"SELECT name FROM sqlite_master WHERE type ='table' AND name='\" + MockOSCachedUniqueOutcomeTable.TABLE_NAME + \"'\", null);\n+\n+        boolean exist = false;\n+        if (cursor != null) {\n+            exist = cursor.getCount() > 0;\n+            cursor.close();\n+        }\n+        // 2. Table must not exist\n+        assertFalse(exist);\n+\n+        // Set data to check that modification on table keep data\n+        OSCachedUniqueOutcome cachedOutcomeBeforeUpdate = new OSCachedUniqueOutcome(\"outcome\", \"notificationId\", OSInfluenceChannel.NOTIFICATION);\n+        ContentValues uniqueOutcomeValuesBeforeUpdate = new ContentValues();\n+        uniqueOutcomeValuesBeforeUpdate.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NOTIFICATION_ID, cachedOutcomeBeforeUpdate.getInfluenceId());\n+        uniqueOutcomeValuesBeforeUpdate.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME, cachedOutcomeBeforeUpdate.getName());\n+\n+        writableDatabase.insert(MockOSCachedUniqueOutcomeTable.OLD_TABLE_NAME, null, uniqueOutcomeValuesBeforeUpdate);\n+\n+        List<OSCachedUniqueOutcome> cachedOutcomesBeforeUpdate = getAllUniqueOutcomeNotificationRecordsDBv5(dbHelper);\n+        assertEquals(1, cachedOutcomesBeforeUpdate.size());\n+\n+        outcomeTableProvider.clean();\n+        writableDatabase = dbHelper.getWritableDatabase();\n+        writableDatabase.setVersion(7);\n+        writableDatabase.close();\n+\n+        ContentValues uniqueOutcomeValues = new ContentValues();\n+        uniqueOutcomeValues.put(MockOSCachedUniqueOutcomeTable.COLUMN_CHANNEL_INFLUENCE_ID, cachedOutcomeBeforeUpdate.getInfluenceId());\n+        uniqueOutcomeValues.put(MockOSCachedUniqueOutcomeTable.COLUMN_CHANNEL_TYPE, cachedOutcomeBeforeUpdate.getChannel().toString());\n+        uniqueOutcomeValues.put(MockOSCachedUniqueOutcomeTable.COLUMN_NAME_NAME, cachedOutcomeBeforeUpdate.getName());\n+\n+        // 3. Clear the cache of the DB so it reloads the file.\n+        ShadowOneSignalDbHelper.restSetStaticFields();\n+        ShadowOneSignalDbHelper.ignoreDuplicatedFieldsOnUpgrade = true;\n+\n+        // 4. Opening the DB will auto trigger the update.\n+        writableDatabase = dbHelper.getWritableDatabase();\n+\n+        List<OSCachedUniqueOutcome> uniqueOutcomeNotifications = getAllUniqueOutcomeNotificationRecordsDB(dbHelper);\n+        assertEquals(1, uniqueOutcomeNotifications.size());\n+        assertEquals(cachedOutcomeBeforeUpdate.getInfluenceId(), uniqueOutcomeNotifications.get(0).getInfluenceId());\n+        assertEquals(cachedOutcomeBeforeUpdate.getChannel(), uniqueOutcomeNotifications.get(0).getChannel());\n+        assertEquals(cachedOutcomeBeforeUpdate.getName(), uniqueOutcomeNotifications.get(0).getName());\n+    }\n+\n+    @Test\n+    public void shouldUpgradeDbFromV7ToV8OutcomesTable() throws JSONException {\n+        // 1. Init DB as version 6", "originalCommit": "97396d271391d43682499aa5234066161eac73e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/7c6849bc9a4141868f62568835cf85eacf7f1cef", "message": "Address codereview comments", "committedDate": "2020-04-13T15:54:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMzI1OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407623258", "bodyText": "switch case should follow other switch cases like this\nDIRECT:\nINDIRECT:\nUNATTRIBUTED:\nDISABLED:", "author": "mikechoch", "createdAt": "2020-04-13T18:02:45Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsCache.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.onesignal.outcomes;\n+\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteException;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.WorkerThread;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OSSharedPreferences;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalDb;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomesDbContract.CachedUniqueOutcomeTable;\n+import com.onesignal.outcomes.OSOutcomesDbContract.OutcomeEventsTable;\n+import com.onesignal.outcomes.model.OSCachedUniqueOutcome;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsCache {\n+\n+    private static final String PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT = \"PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT\";\n+\n+    private OSLogger logger;\n+    private OneSignalDb dbHelper;\n+    private OSSharedPreferences preferences;\n+\n+    OSOutcomeEventsCache(OSLogger logger, OneSignalDb dbHelper, OSSharedPreferences preferences) {\n+        this.logger = logger;\n+        this.dbHelper = dbHelper;\n+        this.preferences = preferences;\n+    }\n+\n+    boolean isOutcomesV2Available() {\n+        return preferences.getBool(\n+                preferences.getPreferencesName(),\n+                preferences.getOutcomesV2KeyName(),\n+                false);\n+    }\n+\n+    Set<String> getUnattributedUniqueOutcomeEventsSentByChannel() {\n+        return preferences.getStringSet(\n+                preferences.getPreferencesName(),\n+                PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT,\n+                null);\n+    }\n+\n+    void saveUnattributedUniqueOutcomeEventsSentByChannel(Set<String> unattributedUniqueOutcomeEvents) {\n+        preferences.saveStringSet(\n+                preferences.getPreferencesName(),\n+                PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT,\n+                // Post success, store unattributed unique outcome event names\n+                unattributedUniqueOutcomeEvents);\n+    }\n+\n+    /**\n+     * Delete event from the DB\n+     */\n+    @WorkerThread\n+    synchronized void deleteOldOutcomeEvent(OSOutcomeEventParams event) {\n+        SQLiteDatabase writableDb = dbHelper.getWritableDbWithRetries();\n+\n+        try {\n+            writableDb.beginTransaction();\n+            writableDb.delete(OutcomeEventsTable.TABLE_NAME,\n+                    OutcomeEventsTable.COLUMN_NAME_TIMESTAMP + \" = ?\", new String[]{String.valueOf(event.getTimestamp())});\n+            writableDb.setTransactionSuccessful();\n+        } catch (SQLiteException e) {\n+            logger.log(OneSignal.LOG_LEVEL.ERROR, \"Error deleting old outcome event records! \", e);\n+        } finally {\n+            if (writableDb != null) {\n+                try {\n+                    writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                } catch (SQLiteException e) {\n+                    logger.log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Save an outcome event to send it on the future\n+     * <p>\n+     * For offline mode and contingency of errors\n+     */\n+    @WorkerThread\n+    synchronized void saveOutcomeEvent(OSOutcomeEventParams eventParams) {\n+        SQLiteDatabase writableDb = dbHelper.getWritableDbWithRetries();\n+        JSONArray notificationIds = new JSONArray();\n+        JSONArray iamIds = new JSONArray();\n+        OSInfluenceType notificationInfluenceType = OSInfluenceType.UNATTRIBUTED;\n+        OSInfluenceType iamInfluenceType = OSInfluenceType.UNATTRIBUTED;\n+\n+        if (eventParams.getOutcomeSource() != null) {\n+            OSOutcomeSource source = eventParams.getOutcomeSource();\n+            // Check for direct channels\n+            if (source.getDirectBody() != null) {\n+                OSOutcomeSourceBody directBody = source.getDirectBody();\n+\n+                if (directBody.getNotificationIds() != null && directBody.getNotificationIds().length() > 0) {\n+                    notificationInfluenceType = OSInfluenceType.DIRECT;\n+                    notificationIds = source.getDirectBody().getNotificationIds();\n+                }\n+\n+                if (directBody.getInAppMessagesIds() != null && directBody.getInAppMessagesIds().length() > 0) {\n+                    iamInfluenceType = OSInfluenceType.DIRECT;\n+                    iamIds = source.getDirectBody().getInAppMessagesIds();\n+                }\n+            }\n+            // Check for indirect channels\n+            if (source.getIndirectBody() != null) {\n+                OSOutcomeSourceBody indirectBody = source.getIndirectBody();\n+\n+                if (indirectBody.getNotificationIds() != null && indirectBody.getNotificationIds().length() > 0) {\n+                    notificationInfluenceType = OSInfluenceType.INDIRECT;\n+                    notificationIds = source.getIndirectBody().getNotificationIds();\n+                }\n+\n+                if (indirectBody.getInAppMessagesIds() != null && indirectBody.getInAppMessagesIds().length() > 0) {\n+                    iamInfluenceType = OSInfluenceType.INDIRECT;\n+                    iamIds = source.getIndirectBody().getInAppMessagesIds();\n+                }\n+            }\n+        }\n+\n+        ContentValues values = new ContentValues();\n+        // Save influence ids\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, notificationIds.toString());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_IAM_IDS, iamIds.toString());\n+        // Save influence types\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_INFLUENCE_TYPE, notificationInfluenceType.toString().toLowerCase());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_IAM_INFLUENCE_TYPE, iamInfluenceType.toString().toLowerCase());\n+        // Save outcome data\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NAME, eventParams.getOutcomeId());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_WEIGHT, eventParams.getWeight());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP, eventParams.getTimestamp());\n+\n+        writableDb.insert(OutcomeEventsTable.TABLE_NAME, null, values);\n+        writableDb.close();\n+    }\n+\n+    /**\n+     * Save an outcome event to send it on the future\n+     * <p>\n+     * For offline mode and contingency of errors\n+     */\n+    @WorkerThread\n+    synchronized List<OSOutcomeEventParams> getAllEventsToSend() {\n+        List<OSOutcomeEventParams> events = new ArrayList<>();\n+        Cursor cursor = null;\n+\n+        try {\n+            SQLiteDatabase readableDb = dbHelper.getReadableDbWithRetries();\n+            cursor = readableDb.query(\n+                    OutcomeEventsTable.TABLE_NAME,\n+                    null,\n+                    null,\n+                    null,\n+                    null,\n+                    null,\n+                    null\n+            );\n+\n+            if (cursor.moveToFirst()) {\n+                do {\n+                    // Retrieve influence types\n+                    String notificationInfluenceTypeString = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_INFLUENCE_TYPE));\n+                    OSInfluenceType notificationInfluenceType = OSInfluenceType.fromString(notificationInfluenceTypeString);\n+                    String iamInfluenceTypeString = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_IAM_INFLUENCE_TYPE));\n+                    OSInfluenceType iamInfluenceType = OSInfluenceType.fromString(iamInfluenceTypeString);\n+\n+                    // Retrieve influence ids\n+                    String notificationIds = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS));\n+                    notificationIds = notificationIds != null ? notificationIds : \"[]\";\n+                    String iamIds = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_IAM_IDS));\n+                    iamIds = iamIds != null ? iamIds : \"[]\";\n+\n+                    // Retrieve Outcome data\n+                    String name = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NAME));\n+                    float weight = cursor.getFloat(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_WEIGHT));\n+                    long timestamp = cursor.getLong(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP));\n+\n+                    try {\n+                        OSOutcomeSourceBody directSourceBody = new OSOutcomeSourceBody();\n+                        OSOutcomeSourceBody indirectSourceBody = new OSOutcomeSourceBody();\n+                        OSOutcomeSource source = null;\n+\n+                        switch (notificationInfluenceType) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMzMxNQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r407623315", "bodyText": "switch case should follow other switch cases like this\nDIRECT:\nINDIRECT:\nUNATTRIBUTED:\nDISABLED:", "author": "mikechoch", "createdAt": "2020-04-13T18:02:52Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsCache.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.onesignal.outcomes;\n+\n+import android.content.ContentValues;\n+import android.database.Cursor;\n+import android.database.sqlite.SQLiteDatabase;\n+import android.database.sqlite.SQLiteException;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.WorkerThread;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OSSharedPreferences;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalDb;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+import com.onesignal.outcomes.OSOutcomesDbContract.CachedUniqueOutcomeTable;\n+import com.onesignal.outcomes.OSOutcomesDbContract.OutcomeEventsTable;\n+import com.onesignal.outcomes.model.OSCachedUniqueOutcome;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+import com.onesignal.outcomes.model.OSOutcomeSource;\n+import com.onesignal.outcomes.model.OSOutcomeSourceBody;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+class OSOutcomeEventsCache {\n+\n+    private static final String PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT = \"PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT\";\n+\n+    private OSLogger logger;\n+    private OneSignalDb dbHelper;\n+    private OSSharedPreferences preferences;\n+\n+    OSOutcomeEventsCache(OSLogger logger, OneSignalDb dbHelper, OSSharedPreferences preferences) {\n+        this.logger = logger;\n+        this.dbHelper = dbHelper;\n+        this.preferences = preferences;\n+    }\n+\n+    boolean isOutcomesV2Available() {\n+        return preferences.getBool(\n+                preferences.getPreferencesName(),\n+                preferences.getOutcomesV2KeyName(),\n+                false);\n+    }\n+\n+    Set<String> getUnattributedUniqueOutcomeEventsSentByChannel() {\n+        return preferences.getStringSet(\n+                preferences.getPreferencesName(),\n+                PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT,\n+                null);\n+    }\n+\n+    void saveUnattributedUniqueOutcomeEventsSentByChannel(Set<String> unattributedUniqueOutcomeEvents) {\n+        preferences.saveStringSet(\n+                preferences.getPreferencesName(),\n+                PREFS_OS_UNATTRIBUTED_UNIQUE_OUTCOME_EVENTS_SENT,\n+                // Post success, store unattributed unique outcome event names\n+                unattributedUniqueOutcomeEvents);\n+    }\n+\n+    /**\n+     * Delete event from the DB\n+     */\n+    @WorkerThread\n+    synchronized void deleteOldOutcomeEvent(OSOutcomeEventParams event) {\n+        SQLiteDatabase writableDb = dbHelper.getWritableDbWithRetries();\n+\n+        try {\n+            writableDb.beginTransaction();\n+            writableDb.delete(OutcomeEventsTable.TABLE_NAME,\n+                    OutcomeEventsTable.COLUMN_NAME_TIMESTAMP + \" = ?\", new String[]{String.valueOf(event.getTimestamp())});\n+            writableDb.setTransactionSuccessful();\n+        } catch (SQLiteException e) {\n+            logger.log(OneSignal.LOG_LEVEL.ERROR, \"Error deleting old outcome event records! \", e);\n+        } finally {\n+            if (writableDb != null) {\n+                try {\n+                    writableDb.endTransaction(); // May throw if transaction was never opened or DB is full.\n+                } catch (SQLiteException e) {\n+                    logger.log(OneSignal.LOG_LEVEL.ERROR, \"Error closing transaction! \", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Save an outcome event to send it on the future\n+     * <p>\n+     * For offline mode and contingency of errors\n+     */\n+    @WorkerThread\n+    synchronized void saveOutcomeEvent(OSOutcomeEventParams eventParams) {\n+        SQLiteDatabase writableDb = dbHelper.getWritableDbWithRetries();\n+        JSONArray notificationIds = new JSONArray();\n+        JSONArray iamIds = new JSONArray();\n+        OSInfluenceType notificationInfluenceType = OSInfluenceType.UNATTRIBUTED;\n+        OSInfluenceType iamInfluenceType = OSInfluenceType.UNATTRIBUTED;\n+\n+        if (eventParams.getOutcomeSource() != null) {\n+            OSOutcomeSource source = eventParams.getOutcomeSource();\n+            // Check for direct channels\n+            if (source.getDirectBody() != null) {\n+                OSOutcomeSourceBody directBody = source.getDirectBody();\n+\n+                if (directBody.getNotificationIds() != null && directBody.getNotificationIds().length() > 0) {\n+                    notificationInfluenceType = OSInfluenceType.DIRECT;\n+                    notificationIds = source.getDirectBody().getNotificationIds();\n+                }\n+\n+                if (directBody.getInAppMessagesIds() != null && directBody.getInAppMessagesIds().length() > 0) {\n+                    iamInfluenceType = OSInfluenceType.DIRECT;\n+                    iamIds = source.getDirectBody().getInAppMessagesIds();\n+                }\n+            }\n+            // Check for indirect channels\n+            if (source.getIndirectBody() != null) {\n+                OSOutcomeSourceBody indirectBody = source.getIndirectBody();\n+\n+                if (indirectBody.getNotificationIds() != null && indirectBody.getNotificationIds().length() > 0) {\n+                    notificationInfluenceType = OSInfluenceType.INDIRECT;\n+                    notificationIds = source.getIndirectBody().getNotificationIds();\n+                }\n+\n+                if (indirectBody.getInAppMessagesIds() != null && indirectBody.getInAppMessagesIds().length() > 0) {\n+                    iamInfluenceType = OSInfluenceType.INDIRECT;\n+                    iamIds = source.getIndirectBody().getInAppMessagesIds();\n+                }\n+            }\n+        }\n+\n+        ContentValues values = new ContentValues();\n+        // Save influence ids\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS, notificationIds.toString());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_IAM_IDS, iamIds.toString());\n+        // Save influence types\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_INFLUENCE_TYPE, notificationInfluenceType.toString().toLowerCase());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_IAM_INFLUENCE_TYPE, iamInfluenceType.toString().toLowerCase());\n+        // Save outcome data\n+        values.put(OutcomeEventsTable.COLUMN_NAME_NAME, eventParams.getOutcomeId());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_WEIGHT, eventParams.getWeight());\n+        values.put(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP, eventParams.getTimestamp());\n+\n+        writableDb.insert(OutcomeEventsTable.TABLE_NAME, null, values);\n+        writableDb.close();\n+    }\n+\n+    /**\n+     * Save an outcome event to send it on the future\n+     * <p>\n+     * For offline mode and contingency of errors\n+     */\n+    @WorkerThread\n+    synchronized List<OSOutcomeEventParams> getAllEventsToSend() {\n+        List<OSOutcomeEventParams> events = new ArrayList<>();\n+        Cursor cursor = null;\n+\n+        try {\n+            SQLiteDatabase readableDb = dbHelper.getReadableDbWithRetries();\n+            cursor = readableDb.query(\n+                    OutcomeEventsTable.TABLE_NAME,\n+                    null,\n+                    null,\n+                    null,\n+                    null,\n+                    null,\n+                    null\n+            );\n+\n+            if (cursor.moveToFirst()) {\n+                do {\n+                    // Retrieve influence types\n+                    String notificationInfluenceTypeString = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_INFLUENCE_TYPE));\n+                    OSInfluenceType notificationInfluenceType = OSInfluenceType.fromString(notificationInfluenceTypeString);\n+                    String iamInfluenceTypeString = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_IAM_INFLUENCE_TYPE));\n+                    OSInfluenceType iamInfluenceType = OSInfluenceType.fromString(iamInfluenceTypeString);\n+\n+                    // Retrieve influence ids\n+                    String notificationIds = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NOTIFICATION_IDS));\n+                    notificationIds = notificationIds != null ? notificationIds : \"[]\";\n+                    String iamIds = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_IAM_IDS));\n+                    iamIds = iamIds != null ? iamIds : \"[]\";\n+\n+                    // Retrieve Outcome data\n+                    String name = cursor.getString(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_NAME));\n+                    float weight = cursor.getFloat(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_WEIGHT));\n+                    long timestamp = cursor.getLong(cursor.getColumnIndex(OutcomeEventsTable.COLUMN_NAME_TIMESTAMP));\n+\n+                    try {\n+                        OSOutcomeSourceBody directSourceBody = new OSOutcomeSourceBody();\n+                        OSOutcomeSourceBody indirectSourceBody = new OSOutcomeSourceBody();\n+                        OSOutcomeSource source = null;\n+\n+                        switch (notificationInfluenceType) {\n+                            case DIRECT:\n+                                directSourceBody.setNotificationIds(new JSONArray(notificationIds));\n+                                source = new OSOutcomeSource(directSourceBody, null);\n+                                break;\n+                            case DISABLED:\n+                                // We should not save disable\n+                                break;\n+                            case INDIRECT:\n+                                indirectSourceBody.setNotificationIds(new JSONArray(notificationIds));\n+                                source = new OSOutcomeSource(null, indirectSourceBody);\n+                                break;\n+                            case UNATTRIBUTED:\n+                                // Keep source as null, no source mean unattributed\n+                                break;\n+                        }\n+\n+                        switch (iamInfluenceType) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNzc2OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411017768", "bodyText": "Why have a mock boolean as a flag instead of just deciding to use MockOSSharedPreferences vs OSSharedPreferencesWrapper at the test level?", "author": "jkasten2", "createdAt": "2020-04-19T23:37:46Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOSSharedPreferences.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.onesignal;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Set;\n+\n+public class MockOSSharedPreferences extends OSSharedPreferencesWrapper {\n+\n+    private HashMap<String, Object> preferences = new HashMap<>();\n+    public boolean mock = false;", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMjI2MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413102261", "bodyText": "This is a good catch, I just wanted to have a dynamic class, but that will be more cleaner", "author": "Jeasmine", "createdAt": "2020-04-22T15:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAxNzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMTA4Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411021087", "bodyText": "Is the reason for this class is to make OSOutcomeEventsFactory public?", "author": "jkasten2", "createdAt": "2020-04-19T23:55:03Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/MockOutcomeEventsFactory.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.onesignal;\n+\n+import com.onesignal.outcomes.OSOutcomeEventsFactory;\n+\n+public class MockOutcomeEventsFactory extends OSOutcomeEventsFactory {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5MTE1MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413291151", "bodyText": "No, I deleted it, was created by default on the begining", "author": "Jeasmine", "createdAt": "2020-04-22T20:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMTA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMTE5Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411021197", "bodyText": "Should this be package-private?", "author": "jkasten2", "createdAt": "2020-04-19T23:55:29Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsFactory.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package com.onesignal.outcomes;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.outcomes.domain.OSOutcomeEventsRepository;\n+import com.onesignal.OSSharedPreferences;\n+import com.onesignal.OneSignalAPIClient;\n+import com.onesignal.OneSignalDb;\n+\n+public class OSOutcomeEventsFactory {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5MTc4Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413291783", "bodyText": "Factories will be public as they are the communication between different modules, and all their dependencies are interfaces so there is no way that the user ends modify something internal", "author": "Jeasmine", "createdAt": "2020-04-22T20:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2NTAzMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414365033", "bodyText": "\ud83d\udc4d ah gotcha, forgot the factories where the one class to expose the module!", "author": "jkasten2", "createdAt": "2020-04-24T07:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMjUxNQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411022515", "bodyText": "Maybe out of scope of this PR, but by the design pattern changes making made should classes like this one be moved into a mock class in a new file to make something public from package-private?", "author": "jkasten2", "createdAt": "2020-04-20T00:02:24Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/OneSignalPackagePrivateHelper.java", "diffHunk": "@@ -102,41 +105,54 @@ public void run() {\n       return true;\n    }\n \n-   public static OSSessionManager.Session OneSignal_getSessionType() {\n-      return OneSignal.getSessionManager().getSession();\n+   public static void OneSignal_sendPurchases(JSONArray purchases, boolean newAsExisting, OneSignalRestClient.ResponseHandler responseHandler) {\n+      OneSignal.sendPurchases(purchases, newAsExisting, responseHandler);\n    }\n \n-   public static String OneSignal_getSessionDirectNotification() {\n-      return OneSignal.getSessionManager().getDirectNotificationId();\n+   public static OSSessionManager.SessionListener OneSignal_getSessionListener() {\n+      return OneSignal.getSessionListener();\n    }\n \n-   public static JSONArray OneSignal_getSessionIndirectNotificationIds() {\n-      return OneSignal.getSessionManager().getIndirectNotificationIds();\n+   public static void OneSignal_setSharedPreferences(OSSharedPreferences preferences) {\n+      OneSignal.setSharedPreferences(preferences);\n    }\n \n-   public static void OneSignal_sendPurchases(JSONArray purchases, boolean newAsExisting, OneSignalRestClient.ResponseHandler responseHandler) {\n-      OneSignal.sendPurchases(purchases, newAsExisting, responseHandler);\n+   public static void OneSignal_setSessionManager(OSSessionManager sessionManager) {\n+      OneSignal.setSessionManager(sessionManager);\n    }\n \n-   public static class OSSessionManager extends com.onesignal.OSSessionManager {\n-      public OSSessionManager(@NonNull SessionListener sessionListener) {\n-         super(sessionListener);\n-      }\n+   public static void OneSignal_setTrackerFactory(OSTrackerFactory trackerFactory) {\n+      OneSignal.setTrackerFactory(trackerFactory);\n    }\n \n-   public static class CachedUniqueOutcomeNotification extends com.onesignal.CachedUniqueOutcomeNotification {\n-      public CachedUniqueOutcomeNotification(String notificationId, String name) {\n-         super(notificationId, name);\n+   public static class OSCachedUniqueOutcome extends com.onesignal.outcomes.model.OSCachedUniqueOutcome {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYwNjQ0Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414606447", "bodyText": "Agree!", "author": "Jeasmine", "createdAt": "2020-04-24T14:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMjUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMjk3MQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411022971", "bodyText": "Al these public static final String seem to not be used anywhere. If this was intentional can we add a comment on how these will be used later?", "author": "jkasten2", "createdAt": "2020-04-20T00:04:40Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/influence/MockOSInfluenceData.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.onesignal.influence;\n+\n+import com.onesignal.OSSharedPreferences;\n+\n+public class MockOSInfluenceData extends OSInfluenceDataRepository {\n+\n+    // OUTCOMES KEYS\n+    // Outcomes Influence Ids\n+    public static final String PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN = OSInfluenceDataRepository.PREFS_OS_LAST_ATTRIBUTED_NOTIFICATION_OPEN;", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5MjkyOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413292928", "bodyText": "I deleted the data not used", "author": "Jeasmine", "createdAt": "2020-04-22T20:09:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyMjk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNjQ0Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411026442", "bodyText": "Since the values are non-static I recommend we remove this clean method and instead new up a new instance each time. This way we don't need to maintain this clean method.", "author": "jkasten2", "createdAt": "2020-04-20T00:24:58Z", "path": "OneSignalSDK/unittest/src/test/java/com/onesignal/outcomes/MockOSOutcomeTableProvider.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.onesignal.outcomes;\n+\n+import android.database.sqlite.SQLiteDatabase;\n+\n+public class MockOSOutcomeTableProvider extends OSOutcomeTableProvider {\n+\n+    private boolean upgradeAvailable = true;\n+    private String mockedSqlCreateOutcomeEntries = null;\n+    private String mockedSqlCreateUniqueOutcomeEntries = null;\n+\n+    public void clean() {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDEwOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411034109", "bodyText": "We can use getJSONObject instead of get so we can remove the type cast here.", "author": "jkasten2", "createdAt": "2020-04-20T01:05:08Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/JsonAsserts.java", "diffHunk": "@@ -24,10 +24,13 @@ static void containsSubset(@NonNull JSONObject subject, @NonNull JSONObject cont\n       Iterator<String> iterator = contains.keys();\n       while (iterator.hasNext()) {\n          String key = iterator.next();\n-         assertEquals(\n-            normalizeType(contains.get(key)),\n-            normalizeType(subject.get(key))\n-         );\n+         if (contains.get(key) instanceof JSONObject && subject.get(key) instanceof JSONObject)\n+            equals((JSONObject) contains.get(key), (JSONObject) subject.get(key));", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NzMwMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413297301", "bodyText": "This won't work, because getJSONObject fails and it will make all the assert to fail, I'm extending this method to check for jsonObject equals inside containsSubset", "author": "Jeasmine", "createdAt": "2020-04-22T20:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2MzY1Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414363652", "bodyText": "Sorry I just mean with the equals on line 28.\n equals(contains.getJSONObject(key), subject.getJSONObject(key));", "author": "jkasten2", "createdAt": "2020-04-24T07:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYxMTg4Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414611883", "bodyText": "oh gotcha!", "author": "Jeasmine", "createdAt": "2020-04-24T14:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDY5Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411034697", "bodyText": "Let's create a new instance of this class each time, instead of needing to have this clear method.", "author": "jkasten2", "createdAt": "2020-04-20T01:07:49Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSTrackerFactory.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package com.onesignal.influence;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OSSharedPreferences;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalRemoteParams;\n+import com.onesignal.influence.model.OSInfluence;\n+\n+import org.json.JSONObject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+public class OSTrackerFactory {\n+\n+    private ConcurrentHashMap<String, OSChannelTracker> trackers = new ConcurrentHashMap<>();\n+\n+    private OSInfluenceDataRepository dataRepository;\n+\n+    public OSTrackerFactory(OSSharedPreferences preferences, OSLogger logger) {\n+        dataRepository = new OSInfluenceDataRepository(preferences);\n+\n+        trackers.put(OSInAppMessageTracker.TAG, new OSInAppMessageTracker(dataRepository, logger));\n+        trackers.put(OSNotificationTracker.TAG, new OSNotificationTracker(dataRepository, logger));\n+    }\n+\n+    /**\n+     * Test method\n+     */\n+    public void clearInfluenceData() {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDgzMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411034831", "bodyText": "Let's create a new instance of this class each time, instead of needing to have this clear method.", "author": "jkasten2", "createdAt": "2020-04-20T01:08:26Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.onesignal.influence;\n+\n+import android.os.Build;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OneSignal;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSInAppMessageTracker extends OSChannelTracker {\n+\n+    public static final String TAG = OSInAppMessageTracker.class.getCanonicalName();\n+    private static final String IAM_ID = \"iam_id\";\n+\n+    OSInAppMessageTracker(@NonNull OSInfluenceDataRepository dataRepository, OSLogger logger) {\n+        super(dataRepository, logger);\n+    }\n+\n+    @Override\n+    public String getIdTag() {\n+        return IAM_ID;\n+    }\n+\n+    @Override\n+    OSInfluenceChannel getChannelType() {\n+        return OSInfluenceChannel.IAM;\n+    }\n+\n+    @Override\n+    JSONArray getLastChannelObjects() throws JSONException {\n+        return dataRepository.getLastIAMsReceivedData();\n+    }\n+\n+    @Override\n+    int getChannelLimit() {\n+        return dataRepository.getIAMLimit();\n+    }\n+\n+    @Override\n+    int getIndirectAttributionWindow() {\n+        return dataRepository.getIAMIndirectAttributionWindow();\n+    }\n+\n+    @Override\n+    void saveChannelObjects(JSONArray channelObjects) {\n+        dataRepository.saveIAMs(channelObjects);\n+    }\n+\n+    @Override\n+    void initInfluencedTypeFromCache() {\n+        setInfluenceType(dataRepository.getIAMCachedInfluenceType());\n+        if (influenceType != null && influenceType.isIndirect())\n+            setIndirectIds(getLastReceivedIds());\n+\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal InAppMessageTracker initInfluencedTypeFromCache: \" + this.toString());\n+    }\n+\n+    @Override\n+    void addSessionData(@NonNull JSONObject jsonObject, OSInfluence influence) {\n+        // In app message don't influence the session\n+    }\n+\n+    @Override\n+    void clearInfluenceData() {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzNDgzOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411034839", "bodyText": "Let's create a new instance of this class each time, instead of needing to have this clear method.", "author": "jkasten2", "createdAt": "2020-04-20T01:08:32Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSNotificationTracker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.onesignal.influence;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OneSignal;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSNotificationTracker extends OSChannelTracker {\n+\n+    public static final String TAG = OSNotificationTracker.class.getCanonicalName();\n+    private static final String NOTIFICATIONS_IDS = \"notification_ids\";\n+    private static final String NOTIFICATION_ID = \"notification_id\";\n+\n+    OSNotificationTracker(@NonNull OSInfluenceDataRepository dataRepository, OSLogger logger) {\n+        super(dataRepository, logger);\n+    }\n+\n+    @Override\n+    public String getIdTag() {\n+        return NOTIFICATION_ID;\n+    }\n+\n+    @Override\n+    JSONArray getLastChannelObjects() throws JSONException {\n+        return dataRepository.getLastNotificationsReceivedData();\n+    }\n+\n+    @Override\n+    OSInfluenceChannel getChannelType() {\n+        return OSInfluenceChannel.NOTIFICATION;\n+    }\n+\n+    @Override\n+    int getChannelLimit() {\n+        return dataRepository.getNotificationLimit();\n+    }\n+\n+    @Override\n+    int getIndirectAttributionWindow() {\n+        return dataRepository.getNotificationIndirectAttributionWindow();\n+    }\n+\n+    @Override\n+    void saveChannelObjects(JSONArray channelObjects) {\n+        dataRepository.saveNotifications(channelObjects);\n+    }\n+\n+    @Override\n+    void initInfluencedTypeFromCache() {\n+        OSInfluenceType influenceType = dataRepository.getNotificationCachedInfluenceType();\n+        setInfluenceType(influenceType);\n+\n+        if (influenceType.isIndirect())\n+            setIndirectIds(getLastReceivedIds());\n+        else if (influenceType.isDirect())\n+            setDirectId(dataRepository.getCachedNotificationOpenId());\n+\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal NotificationTracker initInfluencedTypeFromCache: \" + this.toString());\n+    }\n+\n+    @Override\n+    void addSessionData(@NonNull JSONObject jsonObject, OSInfluence influence) {\n+        if (influence.getInfluenceType().isAttributed())\n+            try {\n+                jsonObject.put(DIRECT_TAG, influence.getInfluenceType().isDirect());\n+                jsonObject.put(NOTIFICATIONS_IDS, influence.getIds());\n+            } catch (JSONException exception) {\n+                logger.log(OneSignal.LOG_LEVEL.ERROR, \"Generating notification tracker addSessionData JSONObject \", exception);\n+            }\n+    }\n+\n+    @Override\n+    void clearInfluenceData() {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzOTI5Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411039292", "bodyText": "Why run this on it's own thread?", "author": "jkasten2", "createdAt": "2020-04-20T01:28:39Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/OutcomeEventV2UnitTests.java", "diffHunk": "@@ -0,0 +1,728 @@\n+/**\n+ * Modified MIT License\n+ * <p>\n+ * Copyright 2018 OneSignal\n+ * <p>\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * <p>\n+ * 1. The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * <p>\n+ * 2. All copies of substantial portions of the Software may only be used in connection\n+ * with services provided by OneSignal.\n+ * <p>\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package com.test.onesignal;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.onesignal.MockOSLog;\n+import com.onesignal.MockOSSharedPreferences;\n+import com.onesignal.MockOneSignalAPIClient;\n+import com.onesignal.MockOneSignalDBHelper;\n+import com.onesignal.MockOutcomeEventsController;\n+import com.onesignal.MockOutcomeEventsFactory;\n+import com.onesignal.MockSessionManager;\n+import com.onesignal.OSSessionManager;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalPackagePrivateHelper;\n+import com.onesignal.OneSignalRemoteParams;\n+import com.onesignal.ShadowOSUtils;\n+import com.onesignal.StaticResetHelper;\n+import com.onesignal.influence.OSTrackerFactory;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.outcomes.domain.OSOutcomeEventsRepository;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.RuntimeEnvironment;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.shadows.ShadowLog;\n+\n+import java.util.List;\n+\n+import static com.test.onesignal.TestHelpers.lockTimeTo;\n+import static com.test.onesignal.TestHelpers.threadAndTaskWait;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+@Config(packageName = \"com.onesignal.example\",\n+        instrumentedPackages = {\"com.onesignal\"},\n+        shadows = {\n+                ShadowOSUtils.class,\n+        },\n+        sdk = 21)\n+@RunWith(RobolectricTestRunner.class)\n+public class OutcomeEventV2UnitTests {\n+\n+    private static final String OUTCOME_NAME = \"testing\";\n+    private static final String GENERIC_ID = \"generic_id\";\n+    private static final String IAM_ID = \"iam_id\";\n+    private static final String NOTIFICATION_ID = \"notification_id\";\n+\n+    private MockOutcomeEventsController controller;\n+    private MockOneSignalAPIClient service;\n+    private OSOutcomeEventsRepository repository;\n+    private MockOSSharedPreferences preferences;\n+    private OSTrackerFactory trackerFactory;\n+    private MockSessionManager sessionManager;\n+    private MockOneSignalDBHelper dbHelper;\n+    private MockOSLog logWrapper = new MockOSLog();\n+    private OSSessionManager.SessionListener sessionListener = new OSSessionManager.SessionListener() {\n+        @Override\n+        public void onSessionEnding(@NonNull List<OSInfluence> lastInfluences) {\n+\n+        }\n+    };\n+\n+    private OneSignalRemoteParams.InfluenceParams disabledInfluenceParams = new OneSignalPackagePrivateHelper.RemoteOutcomeParams(false, false, false);\n+\n+    private static List<OSOutcomeEventParams> outcomeEvents;\n+\n+    public interface OutcomeEventsHandler {\n+\n+        void setOutcomes(List<OSOutcomeEventParams> outcomes);\n+    }\n+\n+    private OutcomeEventsHandler handler = new OutcomeEventsHandler() {\n+        @Override\n+        public void setOutcomes(List<OSOutcomeEventParams> outcomes) {\n+            outcomeEvents = outcomes;\n+        }\n+    };\n+\n+    @BeforeClass // Runs only once, before any tests\n+    public static void setUpClass() throws Exception {\n+        ShadowLog.stream = System.out;\n+\n+        TestHelpers.beforeTestSuite();\n+\n+        OneSignal.setLogLevel(OneSignal.LOG_LEVEL.VERBOSE, OneSignal.LOG_LEVEL.NONE);\n+        StaticResetHelper.saveStaticValues();\n+    }\n+\n+    @Before // Before each test\n+    public void beforeEachTest() throws Exception {\n+        outcomeEvents = null;\n+\n+        dbHelper = new MockOneSignalDBHelper(RuntimeEnvironment.application);\n+        preferences = new MockOSSharedPreferences();\n+        // Mock on a custom HashMap in order to not use custom context\n+        preferences.mock = true;\n+        // Save v2 flag\n+        String v2Name = preferences.getOutcomesV2KeyName();\n+        preferences.saveBool(preferences.getPreferencesName(), v2Name, true);\n+\n+        trackerFactory = new OSTrackerFactory(preferences, logWrapper);\n+        sessionManager = new MockSessionManager(sessionListener, trackerFactory, logWrapper);\n+        service = new MockOneSignalAPIClient();\n+        MockOutcomeEventsFactory factory = new MockOutcomeEventsFactory(logWrapper, service, dbHelper, preferences);\n+        controller = new MockOutcomeEventsController(sessionManager, factory);\n+\n+        TestHelpers.beforeTestInitAndCleanup();\n+        repository = factory.getRepository();\n+        trackerFactory.saveInfluenceParams(new OneSignalPackagePrivateHelper.RemoteOutcomeParams());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        trackerFactory.clearInfluenceData();\n+        preferences.reset();\n+        dbHelper.cleanOutcomeDatabase();\n+        dbHelper.close();\n+        StaticResetHelper.restSetStaticFields();\n+        threadAndTaskWait();\n+    }\n+\n+    @Test\n+    public void testDirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzODYzMw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413338633", "bodyText": "good catch, this was some legacy way kept because copy pasting", "author": "Jeasmine", "createdAt": "2020-04-22T21:16:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzOTI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzOTMyOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411039329", "bodyText": "Why run this on it's own thread?", "author": "jkasten2", "createdAt": "2020-04-20T01:28:49Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/OutcomeEventV2UnitTests.java", "diffHunk": "@@ -0,0 +1,728 @@\n+/**\n+ * Modified MIT License\n+ * <p>\n+ * Copyright 2018 OneSignal\n+ * <p>\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * <p>\n+ * 1. The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * <p>\n+ * 2. All copies of substantial portions of the Software may only be used in connection\n+ * with services provided by OneSignal.\n+ * <p>\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package com.test.onesignal;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.onesignal.MockOSLog;\n+import com.onesignal.MockOSSharedPreferences;\n+import com.onesignal.MockOneSignalAPIClient;\n+import com.onesignal.MockOneSignalDBHelper;\n+import com.onesignal.MockOutcomeEventsController;\n+import com.onesignal.MockOutcomeEventsFactory;\n+import com.onesignal.MockSessionManager;\n+import com.onesignal.OSSessionManager;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalPackagePrivateHelper;\n+import com.onesignal.OneSignalRemoteParams;\n+import com.onesignal.ShadowOSUtils;\n+import com.onesignal.StaticResetHelper;\n+import com.onesignal.influence.OSTrackerFactory;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.outcomes.domain.OSOutcomeEventsRepository;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.RuntimeEnvironment;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.shadows.ShadowLog;\n+\n+import java.util.List;\n+\n+import static com.test.onesignal.TestHelpers.lockTimeTo;\n+import static com.test.onesignal.TestHelpers.threadAndTaskWait;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+@Config(packageName = \"com.onesignal.example\",\n+        instrumentedPackages = {\"com.onesignal\"},\n+        shadows = {\n+                ShadowOSUtils.class,\n+        },\n+        sdk = 21)\n+@RunWith(RobolectricTestRunner.class)\n+public class OutcomeEventV2UnitTests {\n+\n+    private static final String OUTCOME_NAME = \"testing\";\n+    private static final String GENERIC_ID = \"generic_id\";\n+    private static final String IAM_ID = \"iam_id\";\n+    private static final String NOTIFICATION_ID = \"notification_id\";\n+\n+    private MockOutcomeEventsController controller;\n+    private MockOneSignalAPIClient service;\n+    private OSOutcomeEventsRepository repository;\n+    private MockOSSharedPreferences preferences;\n+    private OSTrackerFactory trackerFactory;\n+    private MockSessionManager sessionManager;\n+    private MockOneSignalDBHelper dbHelper;\n+    private MockOSLog logWrapper = new MockOSLog();\n+    private OSSessionManager.SessionListener sessionListener = new OSSessionManager.SessionListener() {\n+        @Override\n+        public void onSessionEnding(@NonNull List<OSInfluence> lastInfluences) {\n+\n+        }\n+    };\n+\n+    private OneSignalRemoteParams.InfluenceParams disabledInfluenceParams = new OneSignalPackagePrivateHelper.RemoteOutcomeParams(false, false, false);\n+\n+    private static List<OSOutcomeEventParams> outcomeEvents;\n+\n+    public interface OutcomeEventsHandler {\n+\n+        void setOutcomes(List<OSOutcomeEventParams> outcomes);\n+    }\n+\n+    private OutcomeEventsHandler handler = new OutcomeEventsHandler() {\n+        @Override\n+        public void setOutcomes(List<OSOutcomeEventParams> outcomes) {\n+            outcomeEvents = outcomes;\n+        }\n+    };\n+\n+    @BeforeClass // Runs only once, before any tests\n+    public static void setUpClass() throws Exception {\n+        ShadowLog.stream = System.out;\n+\n+        TestHelpers.beforeTestSuite();\n+\n+        OneSignal.setLogLevel(OneSignal.LOG_LEVEL.VERBOSE, OneSignal.LOG_LEVEL.NONE);\n+        StaticResetHelper.saveStaticValues();\n+    }\n+\n+    @Before // Before each test\n+    public void beforeEachTest() throws Exception {\n+        outcomeEvents = null;\n+\n+        dbHelper = new MockOneSignalDBHelper(RuntimeEnvironment.application);\n+        preferences = new MockOSSharedPreferences();\n+        // Mock on a custom HashMap in order to not use custom context\n+        preferences.mock = true;\n+        // Save v2 flag\n+        String v2Name = preferences.getOutcomesV2KeyName();\n+        preferences.saveBool(preferences.getPreferencesName(), v2Name, true);\n+\n+        trackerFactory = new OSTrackerFactory(preferences, logWrapper);\n+        sessionManager = new MockSessionManager(sessionListener, trackerFactory, logWrapper);\n+        service = new MockOneSignalAPIClient();\n+        MockOutcomeEventsFactory factory = new MockOutcomeEventsFactory(logWrapper, service, dbHelper, preferences);\n+        controller = new MockOutcomeEventsController(sessionManager, factory);\n+\n+        TestHelpers.beforeTestInitAndCleanup();\n+        repository = factory.getRepository();\n+        trackerFactory.saveInfluenceParams(new OneSignalPackagePrivateHelper.RemoteOutcomeParams());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        trackerFactory.clearInfluenceData();\n+        preferences.reset();\n+        dbHelper.cleanOutcomeDatabase();\n+        dbHelper.close();\n+        StaticResetHelper.restSetStaticFields();\n+        threadAndTaskWait();\n+    }\n+\n+    @Test\n+    public void testDirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testUnattributedOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        // Init session should set UNATTRIBUTED influence\n+        sessionManager.initSessionFromCache();\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzOTM0Nw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411039347", "bodyText": "Why run this on it's own thread?", "author": "jkasten2", "createdAt": "2020-04-20T01:28:53Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/OutcomeEventV2UnitTests.java", "diffHunk": "@@ -0,0 +1,728 @@\n+/**\n+ * Modified MIT License\n+ * <p>\n+ * Copyright 2018 OneSignal\n+ * <p>\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ * <p>\n+ * 1. The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ * <p>\n+ * 2. All copies of substantial portions of the Software may only be used in connection\n+ * with services provided by OneSignal.\n+ * <p>\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+\n+package com.test.onesignal;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.onesignal.MockOSLog;\n+import com.onesignal.MockOSSharedPreferences;\n+import com.onesignal.MockOneSignalAPIClient;\n+import com.onesignal.MockOneSignalDBHelper;\n+import com.onesignal.MockOutcomeEventsController;\n+import com.onesignal.MockOutcomeEventsFactory;\n+import com.onesignal.MockSessionManager;\n+import com.onesignal.OSSessionManager;\n+import com.onesignal.OneSignal;\n+import com.onesignal.OneSignalPackagePrivateHelper;\n+import com.onesignal.OneSignalRemoteParams;\n+import com.onesignal.ShadowOSUtils;\n+import com.onesignal.StaticResetHelper;\n+import com.onesignal.influence.OSTrackerFactory;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.outcomes.domain.OSOutcomeEventsRepository;\n+import com.onesignal.outcomes.model.OSOutcomeEventParams;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.robolectric.RobolectricTestRunner;\n+import org.robolectric.RuntimeEnvironment;\n+import org.robolectric.annotation.Config;\n+import org.robolectric.shadows.ShadowLog;\n+\n+import java.util.List;\n+\n+import static com.test.onesignal.TestHelpers.lockTimeTo;\n+import static com.test.onesignal.TestHelpers.threadAndTaskWait;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+@Config(packageName = \"com.onesignal.example\",\n+        instrumentedPackages = {\"com.onesignal\"},\n+        shadows = {\n+                ShadowOSUtils.class,\n+        },\n+        sdk = 21)\n+@RunWith(RobolectricTestRunner.class)\n+public class OutcomeEventV2UnitTests {\n+\n+    private static final String OUTCOME_NAME = \"testing\";\n+    private static final String GENERIC_ID = \"generic_id\";\n+    private static final String IAM_ID = \"iam_id\";\n+    private static final String NOTIFICATION_ID = \"notification_id\";\n+\n+    private MockOutcomeEventsController controller;\n+    private MockOneSignalAPIClient service;\n+    private OSOutcomeEventsRepository repository;\n+    private MockOSSharedPreferences preferences;\n+    private OSTrackerFactory trackerFactory;\n+    private MockSessionManager sessionManager;\n+    private MockOneSignalDBHelper dbHelper;\n+    private MockOSLog logWrapper = new MockOSLog();\n+    private OSSessionManager.SessionListener sessionListener = new OSSessionManager.SessionListener() {\n+        @Override\n+        public void onSessionEnding(@NonNull List<OSInfluence> lastInfluences) {\n+\n+        }\n+    };\n+\n+    private OneSignalRemoteParams.InfluenceParams disabledInfluenceParams = new OneSignalPackagePrivateHelper.RemoteOutcomeParams(false, false, false);\n+\n+    private static List<OSOutcomeEventParams> outcomeEvents;\n+\n+    public interface OutcomeEventsHandler {\n+\n+        void setOutcomes(List<OSOutcomeEventParams> outcomes);\n+    }\n+\n+    private OutcomeEventsHandler handler = new OutcomeEventsHandler() {\n+        @Override\n+        public void setOutcomes(List<OSOutcomeEventParams> outcomes) {\n+            outcomeEvents = outcomes;\n+        }\n+    };\n+\n+    @BeforeClass // Runs only once, before any tests\n+    public static void setUpClass() throws Exception {\n+        ShadowLog.stream = System.out;\n+\n+        TestHelpers.beforeTestSuite();\n+\n+        OneSignal.setLogLevel(OneSignal.LOG_LEVEL.VERBOSE, OneSignal.LOG_LEVEL.NONE);\n+        StaticResetHelper.saveStaticValues();\n+    }\n+\n+    @Before // Before each test\n+    public void beforeEachTest() throws Exception {\n+        outcomeEvents = null;\n+\n+        dbHelper = new MockOneSignalDBHelper(RuntimeEnvironment.application);\n+        preferences = new MockOSSharedPreferences();\n+        // Mock on a custom HashMap in order to not use custom context\n+        preferences.mock = true;\n+        // Save v2 flag\n+        String v2Name = preferences.getOutcomesV2KeyName();\n+        preferences.saveBool(preferences.getPreferencesName(), v2Name, true);\n+\n+        trackerFactory = new OSTrackerFactory(preferences, logWrapper);\n+        sessionManager = new MockSessionManager(sessionListener, trackerFactory, logWrapper);\n+        service = new MockOneSignalAPIClient();\n+        MockOutcomeEventsFactory factory = new MockOutcomeEventsFactory(logWrapper, service, dbHelper, preferences);\n+        controller = new MockOutcomeEventsController(sessionManager, factory);\n+\n+        TestHelpers.beforeTestInitAndCleanup();\n+        repository = factory.getRepository();\n+        trackerFactory.saveInfluenceParams(new OneSignalPackagePrivateHelper.RemoteOutcomeParams());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        trackerFactory.clearInfluenceData();\n+        preferences.reset();\n+        dbHelper.cleanOutcomeDatabase();\n+        dbHelper.close();\n+        StaticResetHelper.restSetStaticFields();\n+        threadAndTaskWait();\n+    }\n+\n+    @Test\n+    public void testDirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Set DIRECT iam id influence\n+        sessionManager.onDirectInfluenceFromIAMClick(IAM_ID);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"direct\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+        // Set DIRECT notification id influence\n+        sessionManager.onDirectInfluenceFromNotificationOpen(NOTIFICATION_ID);\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testIndirectIAMAndNotificationOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        sessionManager.initSessionFromCache();\n+        sessionManager.onInAppMessageReceived(IAM_ID);\n+        sessionManager.onNotificationReceived(NOTIFICATION_ID);\n+\n+        // Restart session by app open should set INDIRECT influence\n+        sessionManager.restartSessionIfNeeded(OneSignal.AppEntryAction.APP_OPEN);\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{\\\"indirect\\\":{\\\"notification_ids\\\":[\\\"notification_id\\\"],\\\"in_app_message_ids\\\":[\\\"iam_id\\\"]}},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testUnattributedOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        // Init session should set UNATTRIBUTED influence\n+        sessionManager.initSessionFromCache();\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());\n+            }\n+        }, \"OS_GET_SAVED_OUTCOMES_SUCCESS\").start();\n+\n+        threadAndTaskWait();\n+        assertEquals(0, outcomeEvents.size());\n+        assertEquals(\"{\\\"id\\\":\\\"testing\\\",\\\"sources\\\":{},\\\"device_type\\\":1}\", service.getLastJsonObjectSent());\n+    }\n+\n+    @Test\n+    public void testDisabledOutcomeSuccess() throws Exception {\n+        service.setSuccess(true);\n+        // DISABLED influence\n+        trackerFactory.saveInfluenceParams(disabledInfluenceParams);\n+        // Init session should set UNATTRIBUTED influence but is DISABLED\n+        sessionManager.initSessionFromCache();\n+\n+        controller.sendOutcomeEvent(OUTCOME_NAME);\n+        threadAndTaskWait();\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                handler.setOutcomes(repository.getSavedOutcomeEvents());", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYxNTY5NA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414615694", "bodyText": "removed", "author": "Jeasmine", "createdAt": "2020-04-24T14:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAzOTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0MDYwMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411040600", "bodyText": "Remove import, it wasn't used in this PR.", "author": "jkasten2", "createdAt": "2020-04-20T01:34:48Z", "path": "OneSignalSDK/unittest/src/test/java/com/test/onesignal/RestClientAsserts.java", "diffHunk": "@@ -4,6 +4,7 @@\n import android.support.annotation.Nullable;\n \n import com.onesignal.OneSignalPackagePrivateHelper.UserState;\n+import com.onesignal.ShadowOSUtils;", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMTkyOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413301928", "bodyText": "cleaned imports", "author": "Jeasmine", "createdAt": "2020-04-22T20:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0MDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0NDMxOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411044318", "bodyText": "In order to ship this PR before the major release we can do this rename. The class rename nor the namespace move.\nHowever it might be possible to keep this class and instead inherit from OutcomeEvent after putting it back. This way not all references you already made in this PR would have to be undone.", "author": "jkasten2", "createdAt": "2020-04-20T01:50:17Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/model/OSOutcomeEvent.java", "diffHunk": "@@ -1,35 +1,54 @@\n-package com.onesignal;\n+package com.onesignal.outcomes.model;\n \n import android.support.annotation.NonNull;\n import android.support.annotation.Nullable;\n \n+import com.onesignal.influence.model.OSInfluenceType;\n+\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-public class OutcomeEvent {\n+public class OSOutcomeEvent {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMzNjMwMQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413336301", "bodyText": "It wont hurt to move it back to onesignal package, in the future I can make a single PR only for moving it back to outcomes.model package", "author": "Jeasmine", "createdAt": "2020-04-22T21:12:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0NDMxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2MDA4MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414360080", "bodyText": "@Jeasmine In addition to the namespace we need to put back the class name too to OutcomeEvent and rename the file back to OutcomeEvent.java", "author": "jkasten2", "createdAt": "2020-04-24T07:34:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0NDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0NDU1OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411044558", "bodyText": "Please put this back to OutcomeEvent, see my comment in OSOutcomeEvent.java", "author": "jkasten2", "createdAt": "2020-04-20T01:51:14Z", "path": "OneSignalSDK/app/src/main/java/com/onesignal/MainActivity.java", "diffHunk": "@@ -370,7 +371,7 @@ public void onFailure(OneSignal.EmailUpdateError error) {\n    public void onSendOutcomeClicked(View view) {\n       OneSignal.sendOutcome(outcomeName.getText().toString(), new OneSignal.OutcomeCallback() {\n          @Override\n-         public void onSuccess(@Nullable OutcomeEvent outcomeEvent) {\n+         public void onSuccess(@Nullable OSOutcomeEventParams outcomeEvent) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA0Nzc1Mg==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411047752", "bodyText": "\ud83d\udc4d Nice clean up!", "author": "jkasten2", "createdAt": "2020-04-20T02:04:01Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OSInAppMessageController.java", "diffHunk": "@@ -333,20 +343,9 @@ public void completed(boolean accepted) {\n         }\n     }\n \n-    //TODO This is a temporal solution for IAMs outcomes\n-    //     and will potentially change when we track IAMs\n-    private void fireOutcomesForClick(@NonNull final List<OSInAppMessageOutcome> outcomes) {\n-        for (OSInAppMessageOutcome outcome : outcomes) {\n-            String name = outcome.getName();\n-\n-            if (outcome.isUnique()) {\n-                OneSignal.sendClickActionUniqueOutcome(name);\n-            } else if (outcome.getWeight() > 0) {\n-                OneSignal.sendClickActionOutcomeWithValue(name, outcome.getWeight());\n-            } else {\n-                OneSignal.sendClickActionOutcome(name);\n-            }\n-        }\n+    private void fireOutcomesForClick(String messageId, @NonNull final List<OSInAppMessageOutcome> outcomes) {\n+        OneSignal.getSessionManager().onDirectInfluenceFromIAMClick(messageId);", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA2OTQwOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411069408", "bodyText": "public interface needs to stay OutcomeEvent so it can be included before the 4.0.0 release.", "author": "jkasten2", "createdAt": "2020-04-20T03:29:49Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignal.java", "diffHunk": "@@ -3225,12 +3255,12 @@ private static boolean isValidOutcomeEntry(String name) {\n \n    /**\n     * OutcomeEvent will be null in cases where the request was not sent:\n-    *    1. OutcomeEvent cached already for re-attempt in future\n-    *    2. Unique OutcomeEvent already sent for ATTRIBUTED session and notification(s)\n-    *    3. Unique OutcomeEvent already sent for UNATTRIBUTED session during session\n+    *    1. OutcomeEventParams cached already for re-attempt in future\n+    *    2. Unique OutcomeEventParams already sent for ATTRIBUTED session and notification(s)\n+    *    3. Unique OutcomeEventParams already sent for UNATTRIBUTED session during session\n     */\n    public interface OutcomeCallback {\n-      void onSuccess(@Nullable OutcomeEvent outcomeEvent);\n+      void onSuccess(@Nullable OSOutcomeEventParams outcomeEvent);", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMjM0OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413302348", "bodyText": "gotcha!", "author": "Jeasmine", "createdAt": "2020-04-22T20:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA2OTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5NTkwOA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411095908", "bodyText": "nit, remove extra ;", "author": "jkasten2", "createdAt": "2020-04-20T05:07:22Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/OneSignalRemoteParams.java", "diffHunk": "@@ -159,4 +187,34 @@ static private void processJson(String json, final @NonNull CallBack callBack) {\n \n       callBack.complete(params);\n    }\n+\n+   static private void processOutcomeJson(JSONObject outcomeJson, InfluenceParams influenceParams) {\n+      if (outcomeJson.has(V2_PARAM))\n+         influenceParams.v2Enabled = outcomeJson.optBoolean(V2_PARAM);;", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMTk2OQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411101969", "bodyText": "Remove this Build.VERSION_CODES.KITKAT implementation in favor of one implementation for all versions of Android.\nThe performance benefits are negotiable, prefer a simpler implementation.", "author": "jkasten2", "createdAt": "2020-04-20T05:27:11Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSChannelTracker.java", "diffHunk": "@@ -0,0 +1,246 @@\n+package com.onesignal.influence;\n+\n+import android.os.Build;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OneSignal;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+abstract public class OSChannelTracker {\n+\n+    static final String DIRECT_TAG = \"direct\";\n+    private static final String TIME = \"time\";\n+\n+    protected OSLogger logger;\n+    @NonNull\n+    OSInfluenceDataRepository dataRepository;\n+    @Nullable\n+    OSInfluenceType influenceType;\n+    @Nullable\n+    JSONArray indirectIds;\n+    @Nullable\n+    String directId;\n+\n+    OSChannelTracker(@NonNull OSInfluenceDataRepository dataRepository, OSLogger logger) {\n+        this.dataRepository = dataRepository;\n+        this.logger = logger;\n+    }\n+\n+    public abstract String getIdTag();\n+\n+    abstract OSInfluenceChannel getChannelType();\n+\n+    abstract JSONArray getLastChannelObjects() throws JSONException;\n+\n+    abstract int getChannelLimit();\n+\n+    abstract int getIndirectAttributionWindow();\n+\n+    abstract void saveChannelObjects(JSONArray channelObjects);\n+\n+    abstract void initInfluencedTypeFromCache();\n+\n+    abstract void addSessionData(@NonNull JSONObject jsonObject, OSInfluence influence);\n+\n+    abstract void clearInfluenceData();\n+\n+    abstract JSONArray getLastChannelObjectsReceivedByNewId(String id);\n+\n+    public abstract void cacheState();\n+\n+    public void resetAndInitInfluence() {\n+        indirectIds = null;\n+        directId = null;\n+        indirectIds = getLastReceivedIds();\n+        influenceType = indirectIds != null && indirectIds.length() > 0 ? OSInfluenceType.INDIRECT : OSInfluenceType.UNATTRIBUTED;\n+\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal OSChannelTracker resetAndInitInfluence: \" + getIdTag() + \" finish with influenceType: \" + influenceType);\n+    }\n+\n+    /**\n+     * Get all received ids that may influence actions\n+     *\n+     * @return ids that happen between attribution window\n+     */\n+    public JSONArray getLastReceivedIds() {\n+        JSONArray ids = new JSONArray();\n+        try {\n+            JSONArray lastChannelObjectReceived = getLastChannelObjects();\n+            logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal ChannelTracker getLastReceivedIds lastChannelObjectReceived: \" + lastChannelObjectReceived);\n+\n+            long attributionWindow = getIndirectAttributionWindow() * 60 * 1_000L;\n+            long currentTime = System.currentTimeMillis();\n+            for (int i = 0; i < lastChannelObjectReceived.length(); i++) {\n+                JSONObject jsonObject = lastChannelObjectReceived.getJSONObject(i);\n+                long time = jsonObject.getLong(TIME);\n+                long difference = currentTime - time;\n+\n+                if (difference <= attributionWindow) {\n+                    String id = jsonObject.getString(getIdTag());\n+                    ids.put(id);\n+                }\n+            }\n+        } catch (JSONException exception) {\n+            logger.log(OneSignal.LOG_LEVEL.ERROR, \"Generating tracker getLastReceivedIds JSONObject \", exception);\n+        }\n+\n+        return ids;\n+    }\n+\n+    /**\n+     * Save state of last ids received\n+     */\n+    public void saveLastId(String id) {\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal OSChannelTracker for: \" + getIdTag() + \" saveLastId: \" + id);\n+        if (id == null || id.isEmpty())\n+            return;\n+\n+        JSONArray lastChannelObjectReceived = getLastChannelObjectsReceivedByNewId(id);\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal OSChannelTracker for: \" + getIdTag() + \" saveLastId with lastChannelObjectReceived: \" + lastChannelObjectReceived);\n+\n+        try {\n+            JSONObject newInfluenceId = new JSONObject()\n+                    .put(getIdTag(), id)\n+                    .put(TIME, System.currentTimeMillis());\n+            lastChannelObjectReceived.put(newInfluenceId);\n+        } catch (JSONException exception) {\n+            logger.log(OneSignal.LOG_LEVEL.ERROR, \"Generating tracker newInfluenceId JSONObject \", exception);\n+            // We don't have new data, stop logic\n+            return;\n+        }\n+\n+        int channelLimit = getChannelLimit();\n+        JSONArray channelObjectToSave = lastChannelObjectReceived;\n+\n+        // Only save the last ids without surpassing the limit\n+        // Always keep the max quantity of ids possible\n+        // If the attribution window increases, old ids might influence\n+        if (lastChannelObjectReceived.length() > channelLimit) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjI4Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411102283", "bodyText": "Remove this Build.VERSION_CODES.KITKAT implementation in favor of one implementation for all versions of Android.\nThe performance benefits are negotiable, prefer a simpler implementation.", "author": "jkasten2", "createdAt": "2020-04-20T05:28:23Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.java", "diffHunk": "@@ -0,0 +1,121 @@\n+package com.onesignal.influence;\n+\n+import android.os.Build;\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OneSignal;\n+import com.onesignal.influence.model.OSInfluence;\n+import com.onesignal.influence.model.OSInfluenceChannel;\n+import com.onesignal.influence.model.OSInfluenceType;\n+\n+import org.json.JSONArray;\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+class OSInAppMessageTracker extends OSChannelTracker {\n+\n+    public static final String TAG = OSInAppMessageTracker.class.getCanonicalName();\n+    private static final String IAM_ID = \"iam_id\";\n+\n+    OSInAppMessageTracker(@NonNull OSInfluenceDataRepository dataRepository, OSLogger logger) {\n+        super(dataRepository, logger);\n+    }\n+\n+    @Override\n+    public String getIdTag() {\n+        return IAM_ID;\n+    }\n+\n+    @Override\n+    OSInfluenceChannel getChannelType() {\n+        return OSInfluenceChannel.IAM;\n+    }\n+\n+    @Override\n+    JSONArray getLastChannelObjects() throws JSONException {\n+        return dataRepository.getLastIAMsReceivedData();\n+    }\n+\n+    @Override\n+    int getChannelLimit() {\n+        return dataRepository.getIAMLimit();\n+    }\n+\n+    @Override\n+    int getIndirectAttributionWindow() {\n+        return dataRepository.getIAMIndirectAttributionWindow();\n+    }\n+\n+    @Override\n+    void saveChannelObjects(JSONArray channelObjects) {\n+        dataRepository.saveIAMs(channelObjects);\n+    }\n+\n+    @Override\n+    void initInfluencedTypeFromCache() {\n+        setInfluenceType(dataRepository.getIAMCachedInfluenceType());\n+        if (influenceType != null && influenceType.isIndirect())\n+            setIndirectIds(getLastReceivedIds());\n+\n+        logger.log(OneSignal.LOG_LEVEL.DEBUG, \"OneSignal InAppMessageTracker initInfluencedTypeFromCache: \" + this.toString());\n+    }\n+\n+    @Override\n+    void addSessionData(@NonNull JSONObject jsonObject, OSInfluence influence) {\n+        // In app message don't influence the session\n+    }\n+\n+    @Override\n+    void clearInfluenceData() {\n+        dataRepository.clearIAMData();\n+    }\n+\n+    @Override\n+    JSONArray getLastChannelObjectsReceivedByNewId(String id) {\n+        JSONArray lastChannelObjectReceived;\n+        try {\n+            lastChannelObjectReceived = getLastChannelObjects();\n+        } catch (JSONException exception) {\n+            logger.log(OneSignal.LOG_LEVEL.ERROR, \"Generating IAM tracker getLastChannelObjects JSONObject \", exception);\n+            return new JSONArray();\n+        }\n+\n+        // For IAM we handle redisplay, we need to remove duplicates for new influence Id\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzMyOQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411117329", "bodyText": "This name fromOutcomeEventParams isn't clear. Did you mean something like fromOutcomeEventParamsFilteredToNotificationSource? This might be better to live in another spot completely too to filter down to just Notification sources.", "author": "jkasten2", "createdAt": "2020-04-20T06:11:23Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/model/OSOutcomeEvent.java", "diffHunk": "@@ -1,35 +1,54 @@\n-package com.onesignal;\n+package com.onesignal.outcomes.model;\n \n import android.support.annotation.NonNull;\n import android.support.annotation.Nullable;\n \n+import com.onesignal.influence.model.OSInfluenceType;\n+\n import org.json.JSONArray;\n import org.json.JSONException;\n import org.json.JSONObject;\n \n-public class OutcomeEvent {\n+public class OSOutcomeEvent {\n \n     private static final String SESSION = \"session\";\n     private static final String NOTIFICATION_IDS = \"notification_ids\";\n     private static final String OUTCOME_ID = \"id\";\n     private static final String TIMESTAMP = \"timestamp\";\n     private static final String WEIGHT = \"weight\";\n \n-    private OSSessionManager.Session session;\n+    private OSInfluenceType session;\n     private JSONArray notificationIds;\n     private String name;\n     private long timestamp;\n     private Float weight;\n \n-    public OutcomeEvent(@NonNull OSSessionManager.Session session, @Nullable JSONArray notificationIds, @NonNull String name, long timestamp, float weight) {\n+    public OSOutcomeEvent(@NonNull OSInfluenceType session, @Nullable JSONArray notificationIds, @NonNull String name, long timestamp, float weight) {\n         this.session = session;\n         this.notificationIds = notificationIds;\n         this.name = name;\n         this.timestamp = timestamp;\n         this.weight = weight;\n     }\n \n-    public OSSessionManager.Session getSession() {\n+    public static OSOutcomeEvent fromOutcomeEventParams(OSOutcomeEventParams outcomeEventParams) {", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwMzI4Ng==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413303286", "bodyText": "this is a mapping from OSOutcomeEventsParams to OutcomeEvent , should be something like fromOutcomeEventParamsV2toOutcomeEventV1", "author": "Jeasmine", "createdAt": "2020-04-22T20:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzMyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM3MjYxNQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414372615", "bodyText": "Resolved! Github is being broken again and not seeing a resolve button on this one.\n@Jeasmine Yes, this is more clear. Could you add a comment too to the method? Something like \"Creates a new OSOutcomeEvent with only notification_ids if it is influenced to make it compatible with the V1 measure endpoint.\"", "author": "jkasten2", "createdAt": "2020-04-24T07:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExNzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTExOTA0MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411119040", "bodyText": "OUTCOME_SOURCE should be OUTCOME_SOURCES", "author": "jkasten2", "createdAt": "2020-04-20T06:15:39Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/model/OSOutcomeEventParams.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.onesignal.outcomes.model;\n+\n+import android.support.annotation.NonNull;\n+import android.support.annotation.Nullable;\n+\n+import org.json.JSONException;\n+import org.json.JSONObject;\n+\n+public class OSOutcomeEventParams {\n+\n+    private static final String OUTCOME_ID = \"id\";\n+    private static final String OUTCOME_SOURCE = \"sources\";", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxMzQ2MA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411513460", "bodyText": "Thinking we should use /api/v1/outcomes/measure_sources for our \"v2\" measure endponit.", "author": "jkasten2", "createdAt": "2020-04-20T16:21:22Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsV2Service.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package com.onesignal.outcomes;\n+\n+import com.onesignal.OneSignalAPIClient;\n+import com.onesignal.OneSignalApiResponseHandler;\n+\n+import org.json.JSONObject;\n+\n+class OSOutcomeEventsV2Service extends OSOutcomeEventsClient {\n+\n+    OSOutcomeEventsV2Service(OneSignalAPIClient client) {\n+        super(client);\n+    }\n+\n+    /***\n+     * API endpoint /api/v1/outcomes/outcomes/measure", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDAxMA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r411514010", "bodyText": "\"outcomes\" is repeated in the comment.\n/api/v1/outcomes/outcomes/measure ->  /api/v1/outcomes/measure", "author": "jkasten2", "createdAt": "2020-04-20T16:22:08Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/outcomes/OSOutcomeEventsV1Service.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.onesignal.outcomes;\n+\n+import com.onesignal.OneSignalAPIClient;\n+import com.onesignal.OneSignalApiResponseHandler;\n+\n+import org.json.JSONObject;\n+\n+class OSOutcomeEventsV1Service extends OSOutcomeEventsClient {\n+\n+    OSOutcomeEventsV1Service(OneSignalAPIClient client) {\n+        super(client);\n+    }\n+\n+    /***\n+     * API endpoint /api/v1/outcomes/outcomes/measure", "originalCommit": "7c6849bc9a4141868f62568835cf85eacf7f1cef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwNDI1Mw==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r413304253", "bodyText": "good catch!", "author": "Jeasmine", "createdAt": "2020-04-22T20:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUxNDAxMA=="}], "type": "inlineReview"}, {"oid": "ff04e593ed4385fca74069f9c193a9bc9448b696", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/ff04e593ed4385fca74069f9c193a9bc9448b696", "message": "Code review changes", "committedDate": "2020-04-24T03:58:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2NjE4OA==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414366188", "bodyText": "Unused import", "author": "jkasten2", "createdAt": "2020-04-24T07:44:31Z", "path": "OneSignalSDK/onesignal/src/main/java/com/onesignal/influence/OSInAppMessageTracker.java", "diffHunk": "@@ -0,0 +1,101 @@\n+package com.onesignal.influence;\n+\n+import android.support.annotation.NonNull;\n+\n+import com.onesignal.OSLogger;\n+import com.onesignal.OneSignal;", "originalCommit": "ff04e593ed4385fca74069f9c193a9bc9448b696", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYxNzM5NQ==", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/pull/965#discussion_r414617395", "bodyText": "optimized imports", "author": "Jeasmine", "createdAt": "2020-04-24T14:25:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM2NjE4OA=="}], "type": "inlineReview"}, {"oid": "7495a8badebe4ee1bebbe7397fd7e4919b4e4882", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/7495a8badebe4ee1bebbe7397fd7e4919b4e4882", "message": "Codereview changes", "committedDate": "2020-04-24T22:30:52Z", "type": "forcePushed"}, {"oid": "35c0722a925e393ff34a2241836ad4cf08dc4b4c", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/35c0722a925e393ff34a2241836ad4cf08dc4b4c", "message": "Codereview changes", "committedDate": "2020-04-25T01:34:19Z", "type": "forcePushed"}, {"oid": "65883dbf5ea36b226df494ab21694ff1b872c0bb", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/65883dbf5ea36b226df494ab21694ff1b872c0bb", "message": "Codereview changes", "committedDate": "2020-04-27T13:49:17Z", "type": "forcePushed"}, {"oid": "b59c03487bd6e278cad8e2cea65b5d16a792850f", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/b59c03487bd6e278cad8e2cea65b5d16a792850f", "message": "Codereview changes", "committedDate": "2020-05-08T19:38:48Z", "type": "forcePushed"}, {"oid": "9bb576aae1f483ae5338233b861fc782ea4fd441", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/9bb576aae1f483ae5338233b861fc782ea4fd441", "message": "Rebase changes", "committedDate": "2020-05-21T13:52:46Z", "type": "forcePushed"}, {"oid": "ca879ef39f17a32ad024fc9c5446f3d4dcb536eb", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/ca879ef39f17a32ad024fc9c5446f3d4dcb536eb", "message": "Refactor outcomes and add IAM tracking\n\n  * Add new package privacy level for outcomes\n  * Add wrappers for static access\n  * Add OutcomesEventsFactory to decide which repository to use\n  * Add new outcome models given the new feature IAM v2 Outcomes\n  * Add concepts of channels and influence\n  * Add IAM tracking for indirect and direct influence\n  * Add ability for future channels\n  * Decouple influence tracking module to new package\n  * Several changes for decouple code for future dependency injection\n  * Add testing to new functionality\n  * Add testing for IAM tracking\n  * Add/Refactor to test with mocks\n  * Add testing for session ending\n  * Add testing for V2 measure", "committedDate": "2020-05-21T13:59:56Z", "type": "commit"}, {"oid": "c5bad744eb84b583ec8a520af15cf0527b930342", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/c5bad744eb84b583ec8a520af15cf0527b930342", "message": "Make IAM influence after IAM dismiss\nAdd click action handler\n\n  * Changes Tests to accomplish new functionality\n  * Minor improvements changes\n  * If the user sends and outcome from the click action handler callback,\n     that outcome should be DIRECT influenced by IAM\n     DIRECT influences by IAM can be from click action handler or click action outcome", "committedDate": "2020-05-21T14:00:39Z", "type": "forcePushed"}, {"oid": "772776b955f819b3fe3175d757c751a85acd7f81", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/772776b955f819b3fe3175d757c751a85acd7f81", "message": "Make IAM influence after IAM dismiss\nAdd click action handler\n\n  * Changes Tests to accomplish new functionality\n  * Minor improvements changes\n  * If the user sends and outcome from the click action handler callback,\n     that outcome should be DIRECT influenced by IAM\n     DIRECT influences by IAM can be from click action handler or click action outcome", "committedDate": "2020-05-21T14:45:48Z", "type": "commit"}, {"oid": "772776b955f819b3fe3175d757c751a85acd7f81", "url": "https://github.com/OneSignal/OneSignal-Android-SDK/commit/772776b955f819b3fe3175d757c751a85acd7f81", "message": "Make IAM influence after IAM dismiss\nAdd click action handler\n\n  * Changes Tests to accomplish new functionality\n  * Minor improvements changes\n  * If the user sends and outcome from the click action handler callback,\n     that outcome should be DIRECT influenced by IAM\n     DIRECT influences by IAM can be from click action handler or click action outcome", "committedDate": "2020-05-21T14:45:48Z", "type": "forcePushed"}]}