{"pr_number": 608, "pr_title": "Add ElasticsearchExprValueFactory in StorageEngine", "pr_createdAt": "2020-07-22T15:19:07Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/sql/pull/608", "timeline": [{"oid": "e7c110626f4472394fb3c7fc4232b32d8c478ed3", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/e7c110626f4472394fb3c7fc4232b32d8c478ed3", "message": "Add ElasticsearchExprValueFactory in StorageEngine", "committedDate": "2020-07-22T15:11:49Z", "type": "commit"}, {"oid": "816f88c5a1422e289b2c37a48b03881ae30447cd", "url": "https://github.com/opendistro-for-elasticsearch/sql/commit/816f88c5a1422e289b2c37a48b03881ae30447cd", "message": "update", "committedDate": "2020-07-22T18:03:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDc0MA==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/608#discussion_r459134740", "bodyText": "So in future we need to parse date field value based on the format configured in mapping, right?", "author": "dai-chen", "createdAt": "2020-07-22T23:12:47Z", "path": "elasticsearch/src/main/java/com/amazon/opendistroforelasticsearch/sql/elasticsearch/data/value/ElasticsearchExprValueFactory.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ *\n+ *    Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *    Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *    You may not use this file except in compliance with the License.\n+ *    A copy of the License is located at\n+ *\n+ *        http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *    or in the \"license\" file accompanying this file. This file is distributed\n+ *    on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *    express or implied. See the License for the specific language governing\n+ *    permissions and limitations under the License.\n+ *\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value;\n+\n+import static com.amazon.opendistroforelasticsearch.sql.data.model.ExprValueUtils.nullValue;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.ARRAY;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.BOOLEAN;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.DOUBLE;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.FLOAT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.INTEGER;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.LONG;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.STRING;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.STRUCT;\n+import static com.amazon.opendistroforelasticsearch.sql.data.type.ExprCoreType.TIMESTAMP;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchDateFormatters.SQL_LITERAL_DATE_TIME_FORMAT;\n+import static com.amazon.opendistroforelasticsearch.sql.elasticsearch.data.value.ElasticsearchDateFormatters.STRICT_DATE_OPTIONAL_TIME_FORMATTER;\n+\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprBooleanValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprCollectionValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprDoubleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprFloatValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprIntegerValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprLongValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprStringValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTimestampValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprTupleValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.model.ExprValue;\n+import com.amazon.opendistroforelasticsearch.sql.data.type.ExprType;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.JsonNodeType;\n+import java.time.Instant;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import lombok.RequiredArgsConstructor;\n+import org.elasticsearch.common.time.DateFormatters;\n+\n+/** Construct ExprValue from Elasticsearch response. */\n+@RequiredArgsConstructor\n+public class ElasticsearchExprValueFactory {\n+  /** The Mapping of Field and ExprType. */\n+  private final Map<String, ExprType> typeMapping;\n+\n+  private static final DateTimeFormatter DATE_TIME_FORMATTER =\n+      new DateTimeFormatterBuilder()\n+          .appendOptional(SQL_LITERAL_DATE_TIME_FORMAT)\n+          .appendOptional(STRICT_DATE_OPTIONAL_TIME_FORMATTER)\n+          .toFormatter();\n+\n+  private static final String TOP_PATH = \"\";\n+\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  /**\n+   * The struct construction has the following assumption. 1. The field has Elasticsearch Object\n+   * data type. https://www.elastic.co/guide/en/elasticsearch/reference/current/object.html 2. The\n+   * deeper field is flattened in the typeMapping. e.g. {\"employ\", \"STRUCT\"} {\"employ.id\",\n+   * \"INTEGER\"} {\"employ.state\", \"STRING\"}\n+   */\n+  public ExprTupleValue construct(String jsonString) {\n+    try {\n+      return constructStruct(OBJECT_MAPPER.readTree(jsonString), TOP_PATH);\n+    } catch (JsonProcessingException e) {\n+      throw new IllegalStateException(String.format(\"invalid json: %s.\", jsonString), e);\n+    }\n+  }\n+\n+  /** Construct ExprValue from field and value pair. */\n+  private ExprValue construct(String field, JsonNode value) {\n+    if (value.isNull()) {\n+      return nullValue();\n+    }\n+\n+    ExprType type = type(field);\n+    if (type.equals(INTEGER)) {\n+      return constructInteger(value);\n+    } else if (type.equals(LONG)) {\n+      return constructLong(value);\n+    } else if (type.equals(FLOAT)) {\n+      return constructFloat(value);\n+    } else if (type.equals(DOUBLE)) {\n+      return constructDouble(value);\n+    } else if (type.equals(STRING)) {\n+      return constructString(value);\n+    } else if (type.equals(BOOLEAN)) {\n+      return constructBoolean(value);\n+    } else if (type.equals(STRUCT)) {\n+      return constructStruct(value, field);\n+    } else if (type.equals(ARRAY)) {\n+      return constructArray(value, field);\n+    } else if (type.equals(TIMESTAMP)) {\n+      return constructTimestamp(value);\n+    } else {\n+      throw new IllegalStateException(\n+          String.format(\n+              \"Unsupported type: %s for field: %s, value: %s.\", type.typeName(), field, value));\n+    }\n+  }\n+\n+  private ExprType type(String field) {\n+    if (typeMapping.containsKey(field)) {\n+      return typeMapping.get(field);\n+    } else {\n+      throw new IllegalStateException(String.format(\"No type found for field: %s.\", field));\n+    }\n+  }\n+\n+  private ExprIntegerValue constructInteger(JsonNode value) {\n+    return new ExprIntegerValue(value.intValue());\n+  }\n+\n+  private ExprLongValue constructLong(JsonNode value) {\n+    return new ExprLongValue(value.longValue());\n+  }\n+\n+  private ExprFloatValue constructFloat(JsonNode value) {\n+    return new ExprFloatValue(value.floatValue());\n+  }\n+\n+  private ExprDoubleValue constructDouble(JsonNode value) {\n+    return new ExprDoubleValue(value.doubleValue());\n+  }\n+\n+  private ExprStringValue constructString(JsonNode value) {\n+    return new ExprStringValue(value.textValue());\n+  }\n+\n+  private ExprBooleanValue constructBoolean(JsonNode value) {\n+    return ExprBooleanValue.of(value.booleanValue());\n+  }\n+\n+  /**\n+   * Only default strict_date_optional_time||epoch_millis is supported.\n+   * https://www.elastic.co/guide/en/elasticsearch/reference/current/date.html\n+   * The customized date_format is not supported.\n+   */\n+  private ExprValue constructTimestamp(JsonNode value) {\n+    try {\n+      if (value.getNodeType().equals(JsonNodeType.NUMBER)) {\n+        return new ExprTimestampValue(Instant.ofEpochMilli(value.asLong()));\n+      } else {\n+        return new ExprTimestampValue(\n+            // Using Elasticsearch DateFormatters for now.\n+            DateFormatters.from(DATE_TIME_FORMATTER.parse(value.asText())).toInstant());", "originalCommit": "816f88c5a1422e289b2c37a48b03881ae30447cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU0MjQwNg==", "url": "https://github.com/opendistro-for-elasticsearch/sql/pull/608#discussion_r459542406", "bodyText": "Yes, currently we follow the Elasticsearch default format with additional yyyy-MM-dd HH:mm:ss which been in other SQL engine..", "author": "penghuo", "createdAt": "2020-07-23T15:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNDc0MA=="}], "type": "inlineReview"}]}