{"pr_number": 3893, "pr_title": "Fix NXP-28396 nuxeoctl console hang", "pr_createdAt": "2020-04-06T16:40:49Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3893", "timeline": [{"oid": "7f95da2807720e9eab4b9c7dda04757921584122", "url": "https://github.com/nuxeo/nuxeo/commit/7f95da2807720e9eab4b9c7dda04757921584122", "message": "NXP-28396: Rework error handling", "committedDate": "2020-04-07T06:37:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc3OTU1NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404779554", "bodyText": "Though ConfigurationGenerator.NUXEO_DEFAULT_CONF is only used once, what about using static import for consistency with NUXEO_CONF?", "author": "ataillefer", "createdAt": "2020-04-07T12:46:03Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -301,59 +267,47 @@\n             + \"The value is stored in {{%s}} by default unless a template name is provided; if so, it is then stored in the template's {{%s}} file.\\n\"\n             + \"If the value is empty (''), then the property is unset.\\n\"\n             + \"This option is implicit if no '--get' or '--get-regexp' option is used and there are exactly two parameters (key value).\",\n-            ConfigurationGenerator.NUXEO_CONF, ConfigurationGenerator.NUXEO_DEFAULT_CONF);\n+            NUXEO_CONF, ConfigurationGenerator.NUXEO_DEFAULT_CONF);", "originalCommit": "fbe1aa978db4977e4e104216afb8f10b2d47637b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc5MDAxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404790016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Relax the launcher strict option (ie: lenient mode).\n          \n          \n            \n                 * Relaxes the launcher strict option (ie: lenient mode).", "author": "ataillefer", "createdAt": "2020-04-07T13:01:58Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -2350,13 +2269,12 @@ protected static void setDebug(String[] loggerNames) {\n     }\n \n     /**\n-     * Sets the launcher strict option.\n+     * Relax the launcher strict option (ie: lenient mode).", "originalCommit": "37b30845d21f5c37b09bb06b9d94b557761c0f70", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMjg3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404802877", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @implNote the launcher has a specific log4j configuration check its log4j2.xml\n          \n          \n            \n             * @implNote the launcher has a specific log4j configuration, check its log4j2.xml", "author": "ataillefer", "createdAt": "2020-04-07T13:20:52Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -117,15 +121,15 @@\n import org.nuxeo.launcher.process.UnixProcessManager;\n import org.nuxeo.launcher.process.WindowsProcessManager;\n import org.nuxeo.log4j.Log4JHelper;\n-import org.nuxeo.log4j.ThreadedStreamGobbler;\n \n import com.sun.jersey.api.json.JSONConfiguration;\n import com.sun.jersey.json.impl.writer.JsonXmlStreamWriter;\n \n /**\n  * @author jcarsique\n  * @since 5.4.2\n- * @implNote launcher only handles Tomcat and is no more abstract since 11.1\n+ * @implNote since 11.1, launcher only handles Tomcat and is no more abstract\n+ * @implNote the launcher has a specific log4j configuration check its log4j2.xml", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgxMDI0Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404810242", "bodyText": "exitCode maybe?", "author": "ataillefer", "createdAt": "2020-04-07T13:31:03Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncherException.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *  Contributors:\n+ *      Kevin Leturc <kleturc@nuxeo.com>\n+ */\n+\n+package org.nuxeo.launcher;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class NuxeoLauncherException extends RuntimeException {\n+\n+    private final int errorValue;", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNDM1Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404824353", "bodyText": "is // NOSONAR try-with-resources really useful?", "author": "ataillefer", "createdAt": "2020-04-07T13:50:21Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNTM1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404825351", "bodyText": "yes, otherwise we get a warning about unused hook variable", "author": "kevinleturc", "createdAt": "2020-04-07T13:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgzNDIwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404834203", "bodyText": "OK, not in Eclipse :)", "author": "ataillefer", "createdAt": "2020-04-07T14:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgzOTM2Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404839362", "bodyText": "For Idea it's the //noinspection unused which does that, what is the eclipse equivalent?", "author": "kevinleturc", "createdAt": "2020-04-07T14:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNDM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg2MDUzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404860532", "bodyText": "NOSONAR removed", "author": "kevinleturc", "createdAt": "2020-04-07T14:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNDM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNjE0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404826140", "bodyText": "This line appears 3 times, don't know if it's interesting to refactor?", "author": "ataillefer", "createdAt": "2020-04-07T13:52:45Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always error, nuxeo process is not supposed to exit\n+                System.exit(EXIT_CODE_ERROR);\n+            });\n+        } catch (RuntimeException e) {\n+            // for errors in doStart\n+            hook.close();\n+            throw e;\n+        }\n+        if (!quiet) {\n+            log.info(\"Go to {}\", this::getURL);", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgzODU0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404838541", "bodyText": "I can write a method, I didn't do it because it would introduce more line than the one we're refactoring. Wdyt?", "author": "kevinleturc", "createdAt": "2020-04-07T14:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg0NjEyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404846120", "bodyText": "I think it's OK like this.", "author": "ataillefer", "createdAt": "2020-04-07T14:19:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNjE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyNzIyOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404827228", "bodyText": "Here you might want to use try-with-resources or add // NOSONAR.", "author": "ataillefer", "createdAt": "2020-04-07T13:54:07Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgyODQyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404828425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // always error, nuxeo process is not supposed to exit\n          \n          \n            \n                            // always terminate, nuxeo process is not supposed to exit", "author": "ataillefer", "createdAt": "2020-04-07T13:55:43Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always error, nuxeo process is not supposed to exit", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgzMDI1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r404830256", "bodyText": "extra blank line", "author": "ataillefer", "createdAt": "2020-04-07T13:58:09Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always error, nuxeo process is not supposed to exit\n+                System.exit(EXIT_CODE_ERROR);\n+            });\n+        } catch (RuntimeException e) {\n+            // for errors in doStart\n+            hook.close();\n+            throw e;\n+        }\n+        if (!quiet) {\n+            log.info(\"Go to {}\", this::getURL);\n+        }\n     }\n \n-    protected void removeShutdownHook() {\n+    /**\n+     * Starts the server in background.\n+     *\n+     * @return the nuxeo process\n+     * @throws NuxeoLauncherException if an error occurred\n+     */\n+    protected Process doStart(boolean logProcessOutput) {\n+        errorValue = EXIT_CODE_OK;\n         try {\n-            Runtime.getRuntime().removeShutdownHook(shutdownHook);\n-            log.debug(\"Removed shutdown hook\");\n+            configure();\n+            configurationGenerator.verifyInstallation();\n+\n+            log.debug(\"Check if install in progress...\");\n+            int tries = 0;\n+            while (configurationGenerator.isInstallInProgress()) {\n+                tries++;\n+                if (!getConnectBroker().executePending(configurationGenerator.getInstallFile(), true, true,\n+                        ignoreMissing) || tries > 9) {\n+                    throw new NuxeoLauncherException(String.format(\n+                            \"Start interrupted due to failure on pending actions. You can resume with a new start\"\n+                                    + \" or you can restore the file '%s', optionally using the '--%s' option.\",\n+                            configurationGenerator.getInstallFile().getName(), OPTION_IGNORE_MISSING), EXIT_CODE_ERROR);\n+                }\n+                // reload configuration\n+                configurationGenerator = new ConfigurationGenerator(quiet, debug);\n+                configurationGenerator.init();\n+                configure();\n+                configurationGenerator.verifyInstallation();\n+            }\n+            return start(logProcessOutput);\n+        } catch (ConfigurationException e) {\n+            throw new NuxeoLauncherException(\"Could not run configuration: \" + e.getMessage(), EXIT_CODE_NOT_CONFIGURED,\n+                    e);\n+        } catch (IOException e) {\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(), EXIT_CODE_ERROR, e);\n         } catch (IllegalStateException e) {\n-            // the virtual machine is already in the process of shutting down\n+            // in strict mode assume program is not configured because of http port binding conflict for exit value\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(),\n+                    strict ? EXIT_CODE_NOT_CONFIGURED : EXIT_CODE_ERROR, e);\n         }\n     }\n \n     /**\n-     * @return true if Nuxeo is ready\n+     * Do not directly call this method without a call to {@link #checkNoRunningServer()}\n+     *\n+     * @see #doStart()\n+     * @throws IOException in case of issue with process.\n      */\n-    protected boolean waitForEffectiveStart() throws InterruptedException {\n-        long startTime = new Date().getTime();\n+    protected Process start(boolean logProcessOutput) throws IOException {\n+        // build command to start nuxeo\n+        List<String> startCommand = new ArrayList<>();\n+        startCommand.add(getJavaExecutable().getPath());\n+        startCommand.addAll(getJavaOptsProperty(Function.identity()));\n+        startCommand.add(\"-cp\");\n+        startCommand.add(getClassPath());\n+        startCommand.addAll(getNuxeoProperties());\n+        startCommand.addAll(getServerProperties());\n+        if (strict) {\n+            startCommand.add(\"-Dnuxeo.start.strict=true\");\n+        }\n+\n+        startCommand.add(TomcatConfigurator.STARTUP_CLASS);\n+        startCommand.add(\"start\");\n+        startCommand.addAll(Arrays.asList(params));\n+\n+        // build and start process\n+        ProcessBuilder pb = new ProcessBuilder(getOSCommand(startCommand));\n+        pb.directory(configurationGenerator.getNuxeoHome());\n+        if (logProcessOutput) {\n+            // don't redirect input as we want a graceful shutdown\n+            pb.redirectOutput(ProcessBuilder.Redirect.INHERIT).redirectError(ProcessBuilder.Redirect.INHERIT);\n+        }\n+        log.debug(\"Server command: {}\", pb::command);\n+        Process nuxeoProcess = pb.start();\n+        nuxeoProcess.onExit().thenAccept(p -> {\n+            if (SystemUtils.IS_OS_WINDOWS && configurationGenerator.getNuxeoHome().getPath().contains(\" \")) {\n+                // NXP-17679\n+                log.error(\"The server path must not contain spaces under Windows.\");\n+            }\n+            int exitValue = p.exitValue();\n+            if (exitValue != 0) {\n+                log.error(\"Server stopped with status: {}\", exitValue);\n+            }\n+        });\n+\n+        // get pid and write it to the disk for later use\n+        String pid;\n+        try {\n+            pid = String.valueOf(nuxeoProcess.pid());\n+        } catch (UnsupportedOperationException e) {\n+            log.warn(\"Unable to get process ID from process: {}, please report it to Nuxeo\", nuxeoProcess);\n+            // fallback on process manager\n+            pid = processManager.findPid(processRegex).orElse(null);\n+        }\n+        if (pid == null) {\n+            log.warn(\"Sent server start command but could not get process ID.\");\n+        } else {\n+            log.warn(\"Server started with process ID {}.\", pid);\n+            File pidFile = new File(configurationGenerator.getPidDir(), \"nuxeo.pid\");\n+            try (FileWriter writer = new FileWriter(pidFile)) {\n+                writer.write(pid);\n+            }\n+        }\n+        return nuxeoProcess;\n+    }\n+\n+    protected void waitForEffectiveStart(Process nuxeoProcess) throws InterruptedException {\n         int startMaxWait = Integer.parseInt(\n-                configurationGenerator.getUserConfig().getProperty(START_MAX_WAIT_PARAM, getDefaultMaxWait()));\n+                configurationGenerator.getUserConfig().getProperty(START_MAX_WAIT_PARAM, START_MAX_WAIT_DEFAULT));\n+        var startTime = Instant.now();\n+        var waitUntil = startTime.plusSeconds(startMaxWait);\n         log.debug(\"Will wait for effective start during {} seconds.\", startMaxWait);\n         final StringBuilder startSummary = new StringBuilder();\n-        final String newLine = System.getProperty(\"line.separator\");\n-        boolean isReady = false;\n-        long deltaTime;\n-        // Wait for status servlet ready\n-        do {\n+        // Wait for effective start reported from status servlet\n+        boolean servletAvailable = false;\n+        int n = 0;\n+        while (Instant.now().isBefore(waitUntil) && nuxeoProcess.isAlive()) {\n             try {\n-                isReady = statusServletClient.init();\n-            } catch (SocketTimeoutException e) {\n-                if (!quiet) {\n-                    System.out.print(\".\");\n+                // delay will be 1s 10 times, then 2s 10 times... until reaching maximum of 1min\n+                Thread.sleep(Math.min((n % 10 + 1) * 1000, 60_000));\n+                if (servletAvailable && statusServletClient.isStarted()) {\n+                    if (!quiet) {\n+                        log.info(\".\");\n+                    }\n+                    break;\n+                } else {\n+                    statusServletClient.init();\n+                    servletAvailable = true;\n+                    n = 0;\n                 }\n-            }\n-            deltaTime = (new Date().getTime() - startTime) / 1000;\n-        } while (!isReady && deltaTime < startMaxWait && isRunning());\n-        // Wait for effective start reported from status servlet\n-        do {\n-            isReady = isStarted();\n-            if (!isReady) {\n+            } catch (SocketTimeoutException e) {\n                 if (!quiet) {\n-                    System.out.print(\".\");\n+                    log.info(NO_NEW_LINE, \".\");\n                 }\n-                Thread.sleep(1000);\n             }\n-            deltaTime = (new Date().getTime() - startTime) / 1000;\n-        } while (!isReady && deltaTime < startMaxWait && isRunning());\n-        if (isReady) {\n-            startSummary.append(newLine).append(getStartupSummary());\n-            long duration = (new Date().getTime() - startTime) / 1000;\n-            startSummary.append(String.format(\"Started in %dmin%02ds\", duration / 60, duration % 60));\n-            if (wasStartupFine()) {\n-                if (!quiet) {\n-                    System.out.println(startSummary);\n-                }\n-            } else {\n-                System.err.println(startSummary);\n-                if (strict) {\n-                    errorValue = EXIT_CODE_ERROR;\n-                    log.error(\"Shutting down because of unstarted component in strict mode...\");\n-                    stop();\n-                    return false;\n-                }\n+        }\n+\n+        if (Instant.now().isAfter(waitUntil)) {\n+            throw new NuxeoLauncherException(\"Starting process is taking too long - giving up.\", EXIT_CODE_ERROR);\n+        }\n+        if (!nuxeoProcess.isAlive()) {\n+            // Nuxeo has crashed - try to get its System.out\n+            String logs;\n+            try {\n+                logs = IOUtils.toString(nuxeoProcess.getInputStream(), UTF_8);\n+", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUwMTA1OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405501059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                log.error(\"Error during Framework Listener execution : \" + listener.getClass(), e);\n          \n          \n            \n                                log.error(\"Error during Framework Listener execution: \" + listener.getClass(), e);", "author": "troger", "createdAt": "2020-04-08T12:53:53Z", "path": "modules/runtime/nuxeo-runtime-osgi/src/main/java/org/nuxeo/osgi/OSGiAdapter.java", "diffHunk": "@@ -223,9 +223,10 @@ public void fireFrameworkEvent(FrameworkEvent event) {\n                 ((FrameworkListener) listener).frameworkEvent(event);\n                 log.debug(\"End execution of \" + listener.getClass() + \" listener\");\n             } catch (RuntimeException e) {\n-                log.error(\"Error during Framework Listener execution : \" + listener.getClass(), e);\n                 if (Boolean.getBoolean(\"nuxeo.start.strict\")) {\n                     throw e;\n+                } else {\n+                    log.error(\"Error during Framework Listener execution : \" + listener.getClass(), e);", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTUxNTIzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405515233", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final  String basename;\n          \n          \n            \n                private final String basename;", "author": "troger", "createdAt": "2020-04-08T13:15:22Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/daemon/DaemonThreadFactory.java", "diffHunk": "@@ -34,9 +33,9 @@\n \n     private static final AtomicInteger count = new AtomicInteger(0);\n \n-    private String basename;\n+    private final  String basename;", "originalCommit": "97145bc9615d9ddf14e97af0189d8b46aadfd0bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MTIyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405651220", "bodyText": "processPattern maybe? To match all the manager constructors?", "author": "troger", "createdAt": "2020-04-08T16:23:25Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/process/ProcessManager.java", "diffHunk": "@@ -1,32 +1,83 @@\n-//\n-// JODConverter - Java OpenDocument Converter\n-// Copyright 2009 Art of Solving Ltd\n-// Copyright 2004-2009 Mirko Nasato\n-//\n-// JODConverter is free software: you can redistribute it and/or\n-// modify it under the terms of the GNU Lesser General Public License\n-// as published by the Free Software Foundation, either version 3 of\n-// the License, or (at your option) any later version.\n-//\n-// JODConverter is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// Lesser General Public License for more details.\n-//\n-// You should have received a copy of the GNU Lesser General\n-// Public License along with JODConverter.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-//\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *  Contributors:\n+ *      Kevin Leturc <kleturc@nuxeo.com>\n+ */\n+\n package org.nuxeo.launcher.process;\n \n import java.io.IOException;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ProcessManager {\n+\n+    protected final Pattern commandPattern;\n \n-public interface ProcessManager {\n+    protected ProcessManager(Pattern commandPattern) {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzAxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405653016", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected List<String> execute0(String... command) throws IOException {\n          \n          \n            \n                protected List<String> execute0(String... commands) throws IOException {", "author": "troger", "createdAt": "2020-04-08T16:25:58Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/process/UnixProcessManager.java", "diffHunk": "@@ -32,47 +33,52 @@\n  * {@link ProcessManager} implementation for *nix systems. Uses the <tt>ps</tt> and <tt>kill</tt> commands.\n  * <p>\n  * Works for Linux. Works for Solaris too, except that the command line string returned by <tt>ps</tt> there is limited\n- * to 80 characters and this affects {@link #findPid(String)}.\n+ * to 80 characters and this affects {@link #findPid()}.\n  */\n-public class UnixProcessManager implements ProcessManager {\n-\n-    protected static final boolean PID_ENABLED = true;\n+public class UnixProcessManager extends ProcessManager {\n \n     private static final Pattern PS_OUTPUT_LINE = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+(.*)$\");\n \n+    protected UnixProcessManager(Pattern processPattern) {\n+        super(processPattern);\n+    }\n+\n     protected String[] psCommand() {\n         return new String[] { \"/bin/ps\", \"-e\", \"-o\", \"pid,args\" };\n     }\n \n     @Override\n-    public String findPid(String regex) throws IOException {\n-        Pattern commandPattern = Pattern.compile(regex);\n-        for (String line : execute(psCommand())) {\n-            Matcher lineMatcher = PS_OUTPUT_LINE.matcher(line);\n+    public Optional<String> findPid() throws IOException {\n+        for (String line : execute0(psCommand())) {\n+            Matcher lineMatcher = lineMatcher(line);\n             if (lineMatcher.matches()) {\n                 String command = lineMatcher.group(2);\n                 Matcher commandMatcher = commandPattern.matcher(command);\n                 if (commandMatcher.find()) {\n-                    return lineMatcher.group(1);\n+                    return Optional.ofNullable(lineMatcher.group(1));\n                 }\n             }\n         }\n-        return null;\n+        return super.findPid();\n+    }\n+\n+    protected Matcher lineMatcher(String line) {\n+        return PS_OUTPUT_LINE.matcher(line);\n     }\n \n     @Override\n-    public void kill(Process process, String pid) throws IOException {\n-        execute(\"/bin/kill\", \"-KILL\", pid);\n+    public void kill(ProcessHandle processHandle) throws IOException {\n+        execute0(\"/bin/kill\", \"-KILL\", String.valueOf(processHandle.pid()));\n     }\n \n-    protected List<String> execute(String... command) throws IOException {\n-        Process process = new ProcessBuilder(command).start();\n-        return IOUtils.readLines(process.getInputStream(), UTF_8);\n+    // non-static method to allow tests to mock it\n+    protected List<String> execute0(String... command) throws IOException {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyMzkyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406023921", "bodyText": "command is not plural because we aligned the naming on ProcessBuilder.\ncommand[0] represents the unix/windows command, followed by its arguments, thus the singular I think.", "author": "kevinleturc", "createdAt": "2020-04-09T07:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzEzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405653132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected static List<String> execute(String... command) throws IOException {\n          \n          \n            \n                protected static List<String> execute(String... commands) throws IOException {", "author": "troger", "createdAt": "2020-04-08T16:26:08Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/process/UnixProcessManager.java", "diffHunk": "@@ -32,47 +33,52 @@\n  * {@link ProcessManager} implementation for *nix systems. Uses the <tt>ps</tt> and <tt>kill</tt> commands.\n  * <p>\n  * Works for Linux. Works for Solaris too, except that the command line string returned by <tt>ps</tt> there is limited\n- * to 80 characters and this affects {@link #findPid(String)}.\n+ * to 80 characters and this affects {@link #findPid()}.\n  */\n-public class UnixProcessManager implements ProcessManager {\n-\n-    protected static final boolean PID_ENABLED = true;\n+public class UnixProcessManager extends ProcessManager {\n \n     private static final Pattern PS_OUTPUT_LINE = Pattern.compile(\"^\\\\s*(\\\\d+)\\\\s+(.*)$\");\n \n+    protected UnixProcessManager(Pattern processPattern) {\n+        super(processPattern);\n+    }\n+\n     protected String[] psCommand() {\n         return new String[] { \"/bin/ps\", \"-e\", \"-o\", \"pid,args\" };\n     }\n \n     @Override\n-    public String findPid(String regex) throws IOException {\n-        Pattern commandPattern = Pattern.compile(regex);\n-        for (String line : execute(psCommand())) {\n-            Matcher lineMatcher = PS_OUTPUT_LINE.matcher(line);\n+    public Optional<String> findPid() throws IOException {\n+        for (String line : execute0(psCommand())) {\n+            Matcher lineMatcher = lineMatcher(line);\n             if (lineMatcher.matches()) {\n                 String command = lineMatcher.group(2);\n                 Matcher commandMatcher = commandPattern.matcher(command);\n                 if (commandMatcher.find()) {\n-                    return lineMatcher.group(1);\n+                    return Optional.ofNullable(lineMatcher.group(1));\n                 }\n             }\n         }\n-        return null;\n+        return super.findPid();\n+    }\n+\n+    protected Matcher lineMatcher(String line) {\n+        return PS_OUTPUT_LINE.matcher(line);\n     }\n \n     @Override\n-    public void kill(Process process, String pid) throws IOException {\n-        execute(\"/bin/kill\", \"-KILL\", pid);\n+    public void kill(ProcessHandle processHandle) throws IOException {\n+        execute0(\"/bin/kill\", \"-KILL\", String.valueOf(processHandle.pid()));\n     }\n \n-    protected List<String> execute(String... command) throws IOException {\n-        Process process = new ProcessBuilder(command).start();\n-        return IOUtils.readLines(process.getInputStream(), UTF_8);\n+    // non-static method to allow tests to mock it\n+    protected List<String> execute0(String... command) throws IOException {\n+        return execute(command);\n     }\n \n-    @Override\n-    public boolean canFindPid() {\n-        return PID_ENABLED;\n+    protected static List<String> execute(String... command) throws IOException {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTY1MzU4Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405653582", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static List<String> execute(String... command) throws IOException {\n          \n          \n            \n                private static List<String> execute(String... commands) throws IOException {", "author": "troger", "createdAt": "2020-04-08T16:26:48Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/process/WindowsProcessManager.java", "diffHunk": "@@ -15,45 +16,36 @@\n  * Requires wmic.exe and taskkill.exe, that should be available at least on Windows XP, Windows Vista, and Windows 7\n  * (except Home versions).\n  */\n-public class WindowsProcessManager implements ProcessManager {\n-\n-    protected static final boolean PID_ENABLED = true;\n+public class WindowsProcessManager extends ProcessManager {\n \n     private static final Pattern PROCESS_GET_LINE = Pattern.compile(\"^(.*?)\\\\s+(\\\\d+)\\\\s*$\");\n \n+    protected WindowsProcessManager(Pattern processPattern) {\n+        super(processPattern);\n+    }\n+\n     @Override\n-    public String findPid(String regex) throws IOException {\n-        Pattern commandPattern = Pattern.compile(regex);\n+    public Optional<String> findPid() throws IOException {\n         for (String line : execute(\"wmic\", \"process\", \"get\", \"CommandLine,ProcessId\")) {\n             Matcher lineMatcher = PROCESS_GET_LINE.matcher(line);\n             if (lineMatcher.matches()) {\n                 String commandLine = lineMatcher.group(1);\n                 String pid = lineMatcher.group(2);\n                 Matcher commandMatcher = commandPattern.matcher(commandLine);\n                 if (commandMatcher.find()) {\n-                    return pid;\n+                    return Optional.of(pid);\n                 }\n             }\n         }\n-        return null;\n+        return super.findPid();\n     }\n \n     @Override\n-    public void kill(Process process, String pid) throws IOException {\n-        execute(\"taskkill\", \"/t\", \"/f\", \"/pid\", pid);\n-    }\n-\n-    public boolean isUsable() {\n-        try {\n-            execute(\"wmic\", \"quit\");\n-            execute(\"taskkill\", \"/?\");\n-            return true;\n-        } catch (IOException ioException) {\n-            return false;\n-        }\n+    public void kill(ProcessHandle processHandle) throws IOException {\n+        execute(\"taskkill\", \"/t\", \"/f\", \"/pid\", String.valueOf(processHandle.pid()));\n     }\n \n-    private List<String> execute(String... command) throws IOException {\n+    private static List<String> execute(String... command) throws IOException {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgwOTYwOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405809608", "bodyText": "Why not return an OptionalLong instead? It would avoid various map / valueOf stages.", "author": "efge", "createdAt": "2020-04-08T20:56:11Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/process/ProcessManager.java", "diffHunk": "@@ -1,32 +1,83 @@\n-//\n-// JODConverter - Java OpenDocument Converter\n-// Copyright 2009 Art of Solving Ltd\n-// Copyright 2004-2009 Mirko Nasato\n-//\n-// JODConverter is free software: you can redistribute it and/or\n-// modify it under the terms of the GNU Lesser General Public License\n-// as published by the Free Software Foundation, either version 3 of\n-// the License, or (at your option) any later version.\n-//\n-// JODConverter is distributed in the hope that it will be useful,\n-// but WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-// Lesser General Public License for more details.\n-//\n-// You should have received a copy of the GNU Lesser General\n-// Public License along with JODConverter.  If not, see\n-// <http://www.gnu.org/licenses/>.\n-//\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ *  Contributors:\n+ *      Kevin Leturc <kleturc@nuxeo.com>\n+ */\n+\n package org.nuxeo.launcher.process;\n \n import java.io.IOException;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.SystemUtils;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class ProcessManager {\n+\n+    protected final Pattern commandPattern;\n \n-public interface ProcessManager {\n+    protected ProcessManager(Pattern commandPattern) {\n+        this.commandPattern = commandPattern;\n+    }\n \n-    void kill(Process process, String pid) throws IOException;\n+    /**\n+     * Finds the pid associated to the regex used to build this manager.\n+     */\n+    public Optional<String> findPid() throws IOException {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAyNDU0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406024549", "bodyText": "No specific reasons, I'll give a try.", "author": "kevinleturc", "createdAt": "2020-04-09T08:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgwOTYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzAzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406033030", "bodyText": "I'll use Optional<Long> due to lack of map/flatMap methods on OptionalLong.\nIn the end, it moves map/valueOf stages from business code to process managers. I'm not sure, we're earning lines there. But in the near future, I would like to remove process managers to leverage only ProcessHandle classes from JDK and it's all about Long, I think we can keep the Long version.", "author": "kevinleturc", "createdAt": "2020-04-09T08:14:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgwOTYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzNzQxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406237411", "bodyText": "Ok it was just a suggestion.", "author": "efge", "createdAt": "2020-04-09T14:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgwOTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgxMTIyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r405811229", "bodyText": "The reordering of the start / waitForEffectiveStart methods makes the diff hard to read.", "author": "efge", "createdAt": "2020-04-08T20:58:57Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1814,131 +1563,232 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            // noinspection unused\n+            try (var hook = new ShutdownHook(this)) {\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this); // NOSONAR don't close the hook because doStart is not blocking\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always terminate, nuxeo process is not supposed to exit\n+                System.exit(EXIT_CODE_ERROR);\n+            });\n+        } catch (RuntimeException e) {\n+            // for errors in doStart\n+            hook.close();\n+            throw e;\n+        }\n+        if (!quiet) {\n+            log.info(\"Go to {}\", this::getURL);\n+        }\n     }\n \n-    protected void removeShutdownHook() {\n+    /**\n+     * Starts the server in background.\n+     *\n+     * @return the nuxeo process\n+     * @throws NuxeoLauncherException if an error occurred\n+     */\n+    protected Process doStart(boolean logProcessOutput) {\n         try {\n-            Runtime.getRuntime().removeShutdownHook(shutdownHook);\n-            log.debug(\"Removed shutdown hook\");\n+            configure();\n+            configurationGenerator.verifyInstallation();\n+\n+            log.debug(\"Check if install in progress...\");\n+            int tries = 0;\n+            while (configurationGenerator.isInstallInProgress()) {\n+                tries++;\n+                if (!getConnectBroker().executePending(configurationGenerator.getInstallFile(), true, true,\n+                        ignoreMissing) || tries > 9) {\n+                    throw new NuxeoLauncherException(String.format(\n+                            \"Start interrupted due to failure on pending actions. You can resume with a new start\"\n+                                    + \" or you can restore the file '%s', optionally using the '--%s' option.\",\n+                            configurationGenerator.getInstallFile().getName(), OPTION_IGNORE_MISSING), EXIT_CODE_ERROR);\n+                }\n+                // reload configuration\n+                configurationGenerator = new ConfigurationGenerator(quiet, debug);\n+                configurationGenerator.init();\n+                configure();\n+                configurationGenerator.verifyInstallation();\n+            }\n+            return start(logProcessOutput);\n+        } catch (ConfigurationException e) {\n+            throw new NuxeoLauncherException(\"Could not run configuration: \" + e.getMessage(), EXIT_CODE_NOT_CONFIGURED,\n+                    e);\n+        } catch (IOException e) {\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(), EXIT_CODE_ERROR, e);\n         } catch (IllegalStateException e) {\n-            // the virtual machine is already in the process of shutting down\n+            // in strict mode assume program is not configured because of http port binding conflict for exit value\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(),\n+                    strict ? EXIT_CODE_NOT_CONFIGURED : EXIT_CODE_ERROR, e);\n         }\n     }\n \n     /**\n-     * @return true if Nuxeo is ready\n+     * Do not directly call this method without a call to {@link #checkNoRunningServer()}\n+     *\n+     * @see #doStart()\n+     * @throws IOException in case of issue with process.\n      */\n-    protected boolean waitForEffectiveStart() throws InterruptedException {\n-        long startTime = new Date().getTime();\n+    protected Process start(boolean logProcessOutput) throws IOException {", "originalCommit": "7ed143704b81acc8b4c6da23a45763142a965cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NzcxMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406057712", "bodyText": "Sorry about that, it was a pain to scroll 1K lines to jump between doStart and start. Do you want me to isolate reordering into one commit?", "author": "kevinleturc", "createdAt": "2020-04-09T08:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgxMTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzOTAxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406239016", "bodyText": "Ideally it would be better but you shouldn't spend time on it of others have validated your changes.", "author": "efge", "createdAt": "2020-04-09T14:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTgxMTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODYyNg==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406688626", "bodyText": "this is weird I don't see where n is incremented and if it is you will never reach 1min (retries will be spaced by 1s, 2s, ... 9s, 10s, then again 1s, ...)", "author": "bdelbosc", "createdAt": "2020-04-10T09:50:05Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always error, nuxeo process is not supposed to exit\n+                System.exit(EXIT_CODE_ERROR);\n+            });\n+        } catch (RuntimeException e) {\n+            // for errors in doStart\n+            hook.close();\n+            throw e;\n+        }\n+        if (!quiet) {\n+            log.info(\"Go to {}\", this::getURL);\n+        }\n     }\n \n-    protected void removeShutdownHook() {\n+    /**\n+     * Starts the server in background.\n+     *\n+     * @return the nuxeo process\n+     * @throws NuxeoLauncherException if an error occurred\n+     */\n+    protected Process doStart(boolean logProcessOutput) {\n+        errorValue = EXIT_CODE_OK;\n         try {\n-            Runtime.getRuntime().removeShutdownHook(shutdownHook);\n-            log.debug(\"Removed shutdown hook\");\n+            configure();\n+            configurationGenerator.verifyInstallation();\n+\n+            log.debug(\"Check if install in progress...\");\n+            int tries = 0;\n+            while (configurationGenerator.isInstallInProgress()) {\n+                tries++;\n+                if (!getConnectBroker().executePending(configurationGenerator.getInstallFile(), true, true,\n+                        ignoreMissing) || tries > 9) {\n+                    throw new NuxeoLauncherException(String.format(\n+                            \"Start interrupted due to failure on pending actions. You can resume with a new start\"\n+                                    + \" or you can restore the file '%s', optionally using the '--%s' option.\",\n+                            configurationGenerator.getInstallFile().getName(), OPTION_IGNORE_MISSING), EXIT_CODE_ERROR);\n+                }\n+                // reload configuration\n+                configurationGenerator = new ConfigurationGenerator(quiet, debug);\n+                configurationGenerator.init();\n+                configure();\n+                configurationGenerator.verifyInstallation();\n+            }\n+            return start(logProcessOutput);\n+        } catch (ConfigurationException e) {\n+            throw new NuxeoLauncherException(\"Could not run configuration: \" + e.getMessage(), EXIT_CODE_NOT_CONFIGURED,\n+                    e);\n+        } catch (IOException e) {\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(), EXIT_CODE_ERROR, e);\n         } catch (IllegalStateException e) {\n-            // the virtual machine is already in the process of shutting down\n+            // in strict mode assume program is not configured because of http port binding conflict for exit value\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(),\n+                    strict ? EXIT_CODE_NOT_CONFIGURED : EXIT_CODE_ERROR, e);\n         }\n     }\n \n     /**\n-     * @return true if Nuxeo is ready\n+     * Do not directly call this method without a call to {@link #checkNoRunningServer()}\n+     *\n+     * @see #doStart()\n+     * @throws IOException in case of issue with process.\n      */\n-    protected boolean waitForEffectiveStart() throws InterruptedException {\n-        long startTime = new Date().getTime();\n+    protected Process start(boolean logProcessOutput) throws IOException {\n+        // build command to start nuxeo\n+        List<String> startCommand = new ArrayList<>();\n+        startCommand.add(getJavaExecutable().getPath());\n+        startCommand.addAll(getJavaOptsProperty(Function.identity()));\n+        startCommand.add(\"-cp\");\n+        startCommand.add(getClassPath());\n+        startCommand.addAll(getNuxeoProperties());\n+        startCommand.addAll(getServerProperties());\n+        if (strict) {\n+            startCommand.add(\"-Dnuxeo.start.strict=true\");\n+        }\n+\n+        startCommand.add(TomcatConfigurator.STARTUP_CLASS);\n+        startCommand.add(\"start\");\n+        startCommand.addAll(Arrays.asList(params));\n+\n+        // build and start process\n+        ProcessBuilder pb = new ProcessBuilder(getOSCommand(startCommand));\n+        pb.directory(configurationGenerator.getNuxeoHome());\n+        if (logProcessOutput) {\n+            // don't redirect input as we want a graceful shutdown\n+            pb.redirectOutput(ProcessBuilder.Redirect.INHERIT).redirectError(ProcessBuilder.Redirect.INHERIT);\n+        }\n+        log.debug(\"Server command: {}\", pb::command);\n+        Process nuxeoProcess = pb.start();\n+        nuxeoProcess.onExit().thenAccept(p -> {\n+            if (SystemUtils.IS_OS_WINDOWS && configurationGenerator.getNuxeoHome().getPath().contains(\" \")) {\n+                // NXP-17679\n+                log.error(\"The server path must not contain spaces under Windows.\");\n+            }\n+            int exitValue = p.exitValue();\n+            if (exitValue != 0) {\n+                log.error(\"Server stopped with status: {}\", exitValue);\n+            }\n+        });\n+\n+        // get pid and write it to the disk for later use\n+        String pid;\n+        try {\n+            pid = String.valueOf(nuxeoProcess.pid());\n+        } catch (UnsupportedOperationException e) {\n+            log.warn(\"Unable to get process ID from process: {}, please report it to Nuxeo\", nuxeoProcess);\n+            // fallback on process manager\n+            pid = processManager.findPid(processRegex).orElse(null);\n+        }\n+        if (pid == null) {\n+            log.warn(\"Sent server start command but could not get process ID.\");\n+        } else {\n+            log.warn(\"Server started with process ID {}.\", pid);\n+            File pidFile = new File(configurationGenerator.getPidDir(), \"nuxeo.pid\");\n+            try (FileWriter writer = new FileWriter(pidFile)) {\n+                writer.write(pid);\n+            }\n+        }\n+        return nuxeoProcess;\n+    }\n+\n+    protected void waitForEffectiveStart(Process nuxeoProcess) throws InterruptedException {\n         int startMaxWait = Integer.parseInt(\n-                configurationGenerator.getUserConfig().getProperty(START_MAX_WAIT_PARAM, getDefaultMaxWait()));\n+                configurationGenerator.getUserConfig().getProperty(START_MAX_WAIT_PARAM, START_MAX_WAIT_DEFAULT));\n+        var startTime = Instant.now();\n+        var waitUntil = startTime.plusSeconds(startMaxWait);\n         log.debug(\"Will wait for effective start during {} seconds.\", startMaxWait);\n         final StringBuilder startSummary = new StringBuilder();\n-        final String newLine = System.getProperty(\"line.separator\");\n-        boolean isReady = false;\n-        long deltaTime;\n-        // Wait for status servlet ready\n-        do {\n+        // Wait for effective start reported from status servlet\n+        boolean servletAvailable = false;\n+        int n = 0;\n+        while (Instant.now().isBefore(waitUntil) && nuxeoProcess.isAlive()) {\n             try {\n-                isReady = statusServletClient.init();\n-            } catch (SocketTimeoutException e) {\n-                if (!quiet) {\n-                    System.out.print(\".\");\n+                // delay will be 1s 10 times, then 2s 10 times... until reaching maximum of 1min\n+                Thread.sleep(Math.min((n % 10 + 1) * 1000, 60_000));", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MTIzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406691233", "bodyText": "Good catch \ud83d\udc4d. I tried different approaches on that without finding a way to detect fast startup (~22s). Do you have a clue to rework this waiting aspect?", "author": "kevinleturc", "createdAt": "2020-04-10T09:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcyODYzMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406728631", "bodyText": "Changed by:\nThread.sleep(Math.min((++n / 10 + 1) * 1000, 60_000));", "author": "kevinleturc", "createdAt": "2020-04-10T12:05:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODYyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjc0MjQ5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406742491", "bodyText": "maybe just trying every second is good enough then", "author": "bdelbosc", "createdAt": "2020-04-10T12:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY4ODYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY5MjU0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3893#discussion_r406692549", "bodyText": "If you could remove this trailing \".\" after the PID, it would finally be possible to copy the PID directly with the mouse, this will be a major UX improvement!", "author": "bdelbosc", "createdAt": "2020-04-10T10:01:37Z", "path": "server/nuxeo-launcher/src/main/java/org/nuxeo/launcher/NuxeoLauncher.java", "diffHunk": "@@ -1695,131 +1596,235 @@ protected void setConfigProperties() throws ConfigurationException, IOException,\n         log.debug(\"Old values: {}\", oldValues);\n     }\n \n-    /**\n-     * @see #doStartAndWait(boolean)\n-     */\n-    public boolean doStartAndWait() throws PackageException {\n-        boolean started = doStartAndWait(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n-        }\n-        return started;\n-    }\n-\n-    /**\n-     * @see #stop(boolean)\n-     */\n-    public void stop() {\n-        stop(false);\n-    }\n-\n     /**\n      * Call {@link #doStart(boolean)} with false as parameter.\n      *\n      * @see #doStart(boolean)\n      * @return true if the server started successfully\n      */\n-    public boolean doStart() throws PackageException {\n-        boolean started = doStart(false);\n-        if (started && !quiet) {\n-            log.info(\"Go to {}\", this::getURL);\n+    public boolean doStart() {\n+        if (doStart(false).isAlive()) {\n+            if (!quiet) {\n+                log.info(\"Go to {}\", this::getURL);\n+            }\n+            return true;\n         }\n-        return started;\n+        return false;\n     }\n \n     /**\n-     * Whereas {@link #doStart()} considers the server as started when the process is running, {@link #doStartAndWait()}\n-     * waits for effective start by watching the logs\n+     * Whereas {@link #doStart()} considers the server as started when the process is running, this method waits for\n+     * effective start by calling {@link #statusServletClient}.\n      *\n-     * @param logProcessOutput Must process output stream must be logged or not.\n      * @return true if the server started successfully\n      */\n-    public boolean doStartAndWait(boolean logProcessOutput) throws PackageException {\n-        boolean commandSucceeded = false;\n-        if (doStart(logProcessOutput)) {\n-            addShutdownHook();\n-            try {\n-                if (waitForEffectiveStart()) {\n-                    commandSucceeded = true;\n+    public boolean doStartAndWait() {\n+        var nuxeoProcess = doStart(false);\n+        if (nuxeoProcess.isAlive()) {\n+            //noinspection unused\n+            try (var hook = new ShutdownHook(this)) { // NOSONAR try-with-resources\n+                waitForEffectiveStart(nuxeoProcess);\n+                if (!quiet) {\n+                    log.info(\"Go to {}\", this::getURL);\n                 }\n-                removeShutdownHook();\n+                return true;\n             } catch (InterruptedException e) {\n                 Thread.currentThread().interrupt();\n                 throw new RuntimeException(e);\n             }\n         }\n-        return commandSucceeded;\n+        return false;\n+    }\n+\n+    /**\n+     * @since 11.1\n+     */\n+    public void doConsole() {\n+        var hook = new ShutdownHook(this);\n+        try {\n+            doStart(true).onExit().thenAccept(p -> {\n+                hook.close();\n+                // always error, nuxeo process is not supposed to exit\n+                System.exit(EXIT_CODE_ERROR);\n+            });\n+        } catch (RuntimeException e) {\n+            // for errors in doStart\n+            hook.close();\n+            throw e;\n+        }\n+        if (!quiet) {\n+            log.info(\"Go to {}\", this::getURL);\n+        }\n     }\n \n-    protected void removeShutdownHook() {\n+    /**\n+     * Starts the server in background.\n+     *\n+     * @return the nuxeo process\n+     * @throws NuxeoLauncherException if an error occurred\n+     */\n+    protected Process doStart(boolean logProcessOutput) {\n+        errorValue = EXIT_CODE_OK;\n         try {\n-            Runtime.getRuntime().removeShutdownHook(shutdownHook);\n-            log.debug(\"Removed shutdown hook\");\n+            configure();\n+            configurationGenerator.verifyInstallation();\n+\n+            log.debug(\"Check if install in progress...\");\n+            int tries = 0;\n+            while (configurationGenerator.isInstallInProgress()) {\n+                tries++;\n+                if (!getConnectBroker().executePending(configurationGenerator.getInstallFile(), true, true,\n+                        ignoreMissing) || tries > 9) {\n+                    throw new NuxeoLauncherException(String.format(\n+                            \"Start interrupted due to failure on pending actions. You can resume with a new start\"\n+                                    + \" or you can restore the file '%s', optionally using the '--%s' option.\",\n+                            configurationGenerator.getInstallFile().getName(), OPTION_IGNORE_MISSING), EXIT_CODE_ERROR);\n+                }\n+                // reload configuration\n+                configurationGenerator = new ConfigurationGenerator(quiet, debug);\n+                configurationGenerator.init();\n+                configure();\n+                configurationGenerator.verifyInstallation();\n+            }\n+            return start(logProcessOutput);\n+        } catch (ConfigurationException e) {\n+            throw new NuxeoLauncherException(\"Could not run configuration: \" + e.getMessage(), EXIT_CODE_NOT_CONFIGURED,\n+                    e);\n+        } catch (IOException e) {\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(), EXIT_CODE_ERROR, e);\n         } catch (IllegalStateException e) {\n-            // the virtual machine is already in the process of shutting down\n+            // in strict mode assume program is not configured because of http port binding conflict for exit value\n+            throw new NuxeoLauncherException(\"Could not start process: \" + e.getMessage(),\n+                    strict ? EXIT_CODE_NOT_CONFIGURED : EXIT_CODE_ERROR, e);\n         }\n     }\n \n     /**\n-     * @return true if Nuxeo is ready\n+     * Do not directly call this method without a call to {@link #checkNoRunningServer()}\n+     *\n+     * @see #doStart()\n+     * @throws IOException in case of issue with process.\n      */\n-    protected boolean waitForEffectiveStart() throws InterruptedException {\n-        long startTime = new Date().getTime();\n+    protected Process start(boolean logProcessOutput) throws IOException {\n+        // build command to start nuxeo\n+        List<String> startCommand = new ArrayList<>();\n+        startCommand.add(getJavaExecutable().getPath());\n+        startCommand.addAll(getJavaOptsProperty(Function.identity()));\n+        startCommand.add(\"-cp\");\n+        startCommand.add(getClassPath());\n+        startCommand.addAll(getNuxeoProperties());\n+        startCommand.addAll(getServerProperties());\n+        if (strict) {\n+            startCommand.add(\"-Dnuxeo.start.strict=true\");\n+        }\n+\n+        startCommand.add(TomcatConfigurator.STARTUP_CLASS);\n+        startCommand.add(\"start\");\n+        startCommand.addAll(Arrays.asList(params));\n+\n+        // build and start process\n+        ProcessBuilder pb = new ProcessBuilder(getOSCommand(startCommand));\n+        pb.directory(configurationGenerator.getNuxeoHome());\n+        if (logProcessOutput) {\n+            // don't redirect input as we want a graceful shutdown\n+            pb.redirectOutput(ProcessBuilder.Redirect.INHERIT).redirectError(ProcessBuilder.Redirect.INHERIT);\n+        }\n+        log.debug(\"Server command: {}\", pb::command);\n+        Process nuxeoProcess = pb.start();\n+        nuxeoProcess.onExit().thenAccept(p -> {\n+            if (SystemUtils.IS_OS_WINDOWS && configurationGenerator.getNuxeoHome().getPath().contains(\" \")) {\n+                // NXP-17679\n+                log.error(\"The server path must not contain spaces under Windows.\");\n+            }\n+            int exitValue = p.exitValue();\n+            if (exitValue != 0) {\n+                log.error(\"Server stopped with status: {}\", exitValue);\n+            }\n+        });\n+\n+        // get pid and write it to the disk for later use\n+        String pid;\n+        try {\n+            pid = String.valueOf(nuxeoProcess.pid());\n+        } catch (UnsupportedOperationException e) {\n+            log.warn(\"Unable to get process ID from process: {}, please report it to Nuxeo\", nuxeoProcess);\n+            // fallback on process manager\n+            pid = processManager.findPid(processRegex).orElse(null);\n+        }\n+        if (pid == null) {\n+            log.warn(\"Sent server start command but could not get process ID.\");\n+        } else {\n+            log.warn(\"Server started with process ID {}.\", pid);", "originalCommit": "95dbe2ea46e28d527785051f3645ae4855ba1ad3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c5bc1397a6ade6193e675467fae503fc69262ee", "url": "https://github.com/nuxeo/nuxeo/commit/4c5bc1397a6ade6193e675467fae503fc69262ee", "message": "NXP-28396: Rework error handling", "committedDate": "2020-04-10T12:09:23Z", "type": "forcePushed"}, {"oid": "9d2c692da54559046ef22a1f84cf27d478bfed42", "url": "https://github.com/nuxeo/nuxeo/commit/9d2c692da54559046ef22a1f84cf27d478bfed42", "message": "NXP-28396: Cleanup / Format", "committedDate": "2020-04-14T11:05:47Z", "type": "commit"}, {"oid": "cf69d50630406aead2427fb43fbe32a2d645c7ec", "url": "https://github.com/nuxeo/nuxeo/commit/cf69d50630406aead2427fb43fbe32a2d645c7ec", "message": "NXP-28396: Remove unused code", "committedDate": "2020-04-14T11:05:50Z", "type": "commit"}, {"oid": "3b1e926b1b166cde2b3136ee675e532d1058aaec", "url": "https://github.com/nuxeo/nuxeo/commit/3b1e926b1b166cde2b3136ee675e532d1058aaec", "message": "NXP-28396: Reorganizer methods", "committedDate": "2020-04-14T11:05:51Z", "type": "commit"}, {"oid": "96a5cfd0af40cd50337e660db3a15844a107c093", "url": "https://github.com/nuxeo/nuxeo/commit/96a5cfd0af40cd50337e660db3a15844a107c093", "message": "NXP-28396: Rework nuxeo start to make nuxeoctl console not blocking", "committedDate": "2020-04-14T11:19:19Z", "type": "commit"}, {"oid": "1fcdae8643dc902ac3bc2cfbfdbe327061ed8d90", "url": "https://github.com/nuxeo/nuxeo/commit/1fcdae8643dc902ac3bc2cfbfdbe327061ed8d90", "message": "NXP-28396: Rework ProcessManager", "committedDate": "2020-04-14T11:19:19Z", "type": "commit"}, {"oid": "01a75d317a902bec4be4c8d62743099ec263e652", "url": "https://github.com/nuxeo/nuxeo/commit/01a75d317a902bec4be4c8d62743099ec263e652", "message": "NXP-28396: Rework error handling", "committedDate": "2020-04-14T11:19:19Z", "type": "commit"}, {"oid": "01a75d317a902bec4be4c8d62743099ec263e652", "url": "https://github.com/nuxeo/nuxeo/commit/01a75d317a902bec4be4c8d62743099ec263e652", "message": "NXP-28396: Rework error handling", "committedDate": "2020-04-14T11:19:19Z", "type": "forcePushed"}]}