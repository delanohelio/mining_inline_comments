{"pr_number": 3655, "pr_title": "Feature NXP-27692 retention web ui 10.10", "pr_createdAt": "2020-01-09T17:00:55Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3655", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNjE5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365336191", "bodyText": "as it is a constants class can you add a private constructor to avoid / prevents any instantiation :\n// Prevents instantiation\nprivate RetentionConstants() {\n}", "author": "RSalem07", "createdAt": "2020-01-10T17:04:40Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/RetentionConstants.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention;\n+\n+import org.apache.commons.lang3.time.FastDateFormat;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionConstants {\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MTU0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365751549", "bodyText": "The class could also be final.", "author": "nmpcunha", "createdAt": "2020-01-13T11:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDY0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365340649", "bodyText": "wdyt about replacing the query concatenation constant by String.format:\n public static final String ACTIVE_EVENT_BASED_RETENTION_RULES_QUERY = String.format( //\n            \"SELECT * FROM Document WHERE ecm:mixinType = '%s' AND ecm:isTrashed = 0 AND ecm:isVersion = 0 AND %s = 1 AND %s = '%s'\",\n            RETENTION_RULE_FACET, ENABLED_PROP, STARTING_POINT_POLICY_PROP, EVENT_BASED.name().toLowerCase() //\n    );", "author": "RSalem07", "createdAt": "2020-01-10T17:15:01Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/RetentionConstants.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention;\n+\n+import org.apache.commons.lang3.time.FastDateFormat;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionConstants {\n+\n+    public static final String RULES_CONTAINER_TYPE = \"RetentionRules\";\n+\n+    public static final String DURATION_DAYS_PROP = \"retention_def:durationDays\";\n+\n+    public static final String DURATION_MONTHS_PROP = \"retention_def:durationMonths\";\n+\n+    public static final String DURATION_YEARS_PROP = \"retention_def:durationYears\";\n+\n+    public static final String RECORD_FACET = \"Record\";\n+\n+    public static final String RETENTION_RULE_FACET = \"RetentionRule\";\n+\n+    public static final String APPLICATION_POLICY_PROP = \"retention_rule:applicationPolicy\";\n+\n+    public static final String ENABLED_PROP = \"retention_rule:enabled\";\n+\n+    public static final String EXPRESSION_PROP = \"retention_def:expression\";\n+\n+    public static final String BEGIN_ACTIONS_PROP = \"retention_def:beginActions\";\n+\n+    public static final String END_ACTIONS_PROP = \"retention_def:endActions\";\n+\n+    public static final String DURATION_MILLIS_PROP = \"retention_def:durationMillis\";\n+\n+    public static final String EVENTS_DIRECTORY_NAME = \"RetentionEvent\";\n+\n+    public static final String OBSOLETE_FIELD_ID = \"obsolete\";\n+\n+    public static final String RETENTION_CHECKER_LISTENER_IGNORE = \"retentionRecordIgnore\";\n+\n+    public static final String STARTING_POINT_POLICY_PROP = \"retention_def:startingPointPolicy\";\n+\n+    public static final String STARTING_POINT_EXPRESSION_PROP = \"retention_def:startingPointExpression\";\n+\n+    public static final FastDateFormat DEFAULT_DATE_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd HH:mm:ss\");\n+\n+    public static final String STARTING_POINT_EVENT_PROP = \"retention_def:startingPointEvent\";\n+\n+    public static final String RECORD_MANAGER_GROUP_NAME = \"RecordManager\";\n+\n+    public static final String MANAGE_LEGAL_HOLD_PERMISSION = \"ManageLegalHold\";\n+\n+    public static final String MANAGE_RECORD_PERMISSION = \"ManageRecord\";\n+\n+    public static final String DOC_TYPES_PROP = \"retention_rule:docTypes\";\n+\n+    public static final String METADATA_XPATH_PROP = \"retention_def:metadataXPath\";\n+\n+    public static final String RECORD_RULE_IDS_PROP = \"record:ruleIds\";\n+\n+    public static final String INPUT_PROPERTY_KEY = \"input\";\n+\n+    public static final String RETAIN_UNTIL_PROP = \"record:retainUntil\";\n+\n+    public static final String ACTIVE_EVENT_BASED_RETENTION_RULES_QUERY = \"SELECT * FROM Document\" //\n+            + \" WHERE ecm:mixinType = '\" + RETENTION_RULE_FACET + \"'\" //\n+            + \" AND ecm:isTrashed = 0\" //\n+            + \" AND ecm:isVersion = 0\" //\n+            + \" AND \" + ENABLED_PROP + \" = 1\" //\n+            + \" AND \" + STARTING_POINT_POLICY_PROP + \" = '\"\n+            + RetentionRule.StartingPointPolicy.EVENT_BASED.name().toLowerCase() + \"'\";\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NjgwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365356809", "bodyText": "I don't think that's more readable.", "author": "efge", "createdAt": "2020-01-10T17:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MTE5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365341199", "bodyText": "same proposition as above :)", "author": "RSalem07", "createdAt": "2020-01-10T17:16:15Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/RetentionConstants.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention;\n+\n+import org.apache.commons.lang3.time.FastDateFormat;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionConstants {\n+\n+    public static final String RULES_CONTAINER_TYPE = \"RetentionRules\";\n+\n+    public static final String DURATION_DAYS_PROP = \"retention_def:durationDays\";\n+\n+    public static final String DURATION_MONTHS_PROP = \"retention_def:durationMonths\";\n+\n+    public static final String DURATION_YEARS_PROP = \"retention_def:durationYears\";\n+\n+    public static final String RECORD_FACET = \"Record\";\n+\n+    public static final String RETENTION_RULE_FACET = \"RetentionRule\";\n+\n+    public static final String APPLICATION_POLICY_PROP = \"retention_rule:applicationPolicy\";\n+\n+    public static final String ENABLED_PROP = \"retention_rule:enabled\";\n+\n+    public static final String EXPRESSION_PROP = \"retention_def:expression\";\n+\n+    public static final String BEGIN_ACTIONS_PROP = \"retention_def:beginActions\";\n+\n+    public static final String END_ACTIONS_PROP = \"retention_def:endActions\";\n+\n+    public static final String DURATION_MILLIS_PROP = \"retention_def:durationMillis\";\n+\n+    public static final String EVENTS_DIRECTORY_NAME = \"RetentionEvent\";\n+\n+    public static final String OBSOLETE_FIELD_ID = \"obsolete\";\n+\n+    public static final String RETENTION_CHECKER_LISTENER_IGNORE = \"retentionRecordIgnore\";\n+\n+    public static final String STARTING_POINT_POLICY_PROP = \"retention_def:startingPointPolicy\";\n+\n+    public static final String STARTING_POINT_EXPRESSION_PROP = \"retention_def:startingPointExpression\";\n+\n+    public static final FastDateFormat DEFAULT_DATE_FORMAT = FastDateFormat.getInstance(\"yyyy-MM-dd HH:mm:ss\");\n+\n+    public static final String STARTING_POINT_EVENT_PROP = \"retention_def:startingPointEvent\";\n+\n+    public static final String RECORD_MANAGER_GROUP_NAME = \"RecordManager\";\n+\n+    public static final String MANAGE_LEGAL_HOLD_PERMISSION = \"ManageLegalHold\";\n+\n+    public static final String MANAGE_RECORD_PERMISSION = \"ManageRecord\";\n+\n+    public static final String DOC_TYPES_PROP = \"retention_rule:docTypes\";\n+\n+    public static final String METADATA_XPATH_PROP = \"retention_def:metadataXPath\";\n+\n+    public static final String RECORD_RULE_IDS_PROP = \"record:ruleIds\";\n+\n+    public static final String INPUT_PROPERTY_KEY = \"input\";\n+\n+    public static final String RETAIN_UNTIL_PROP = \"record:retainUntil\";\n+\n+    public static final String ACTIVE_EVENT_BASED_RETENTION_RULES_QUERY = \"SELECT * FROM Document\" //\n+            + \" WHERE ecm:mixinType = '\" + RETENTION_RULE_FACET + \"'\" //\n+            + \" AND ecm:isTrashed = 0\" //\n+            + \" AND ecm:isVersion = 0\" //\n+            + \" AND \" + ENABLED_PROP + \" = 1\" //\n+            + \" AND \" + STARTING_POINT_POLICY_PROP + \" = '\"\n+            + RetentionRule.StartingPointPolicy.EVENT_BASED.name().toLowerCase() + \"'\";\n+\n+    public static final String RULE_RECORD_DOCUMENT_QUERY = \"SELECT * FROM Document\" //\n+            + \" WHERE ecm:mixinType = '\" + RECORD_FACET + \"'\" //", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MzAzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365343038", "bodyText": "Bulk action to attach the retention...", "author": "RSalem07", "createdAt": "2020-01-10T17:20:45Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/AttachRetentionRuleAction.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to attach retention rule.", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MzgzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365343830", "bodyText": "No need to cast to String,  here getParam is a generic method public <T> T getParam(String key)", "author": "RSalem07", "createdAt": "2020-01-10T17:22:41Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/AttachRetentionRuleAction.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to attach retention rule.\n+ * @since 11.1\n+ */\n+public class AttachRetentionRuleAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"attachRetentionRule\";\n+\n+    public static final String PARAM_RULE_ID = \"ruleId\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvaluateRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class EvaluateRuleComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(EvaluateRuleComputation.class);\n+\n+        protected boolean disableAudit;\n+\n+        protected RetentionManager retentionManager;\n+\n+        protected String ruleId;\n+\n+        public EvaluateRuleComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        public void startBucket(String bucketKey) {\n+            BulkCommand command = getCurrentCommand();\n+            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);\n+            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());\n+            retentionManager = Framework.getService(RetentionManager.class);\n+            ruleId = (String) command.getParam(PARAM_RULE_ID);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NDE3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365344170", "bodyText": "this field is unused ->   static final Logger log =....", "author": "RSalem07", "createdAt": "2020-01-10T17:23:33Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/EvalInputEventBasedRuleAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to evaluate expression on record documents with an attached event-based retention rule. Depending on the\n+ * expression evaluation outcome, a determinate retention period is computed and set on the record document.\n+ *\n+ * @since 11.1\n+ */\n+public class EvalInputEventBasedRuleAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"evalInputEventBasedRule\";\n+\n+    public static final String PARAM_EVENT = \"event\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvalEventBasedRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class EvalEventBasedRuleComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(EvalEventBasedRuleComputation.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNDM1OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368024359", "bodyText": "Actually it is used, in the compute method. Moving to private though.", "author": "efge", "createdAt": "2020-01-17T16:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NDE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NTYyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365345622", "bodyText": "this field is unused or it is here to be exposed to an external use", "author": "RSalem07", "createdAt": "2020-01-10T17:27:16Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/ProcessRetentionEventAction.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.core.repository.RepositoryService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to retrieve event-based retention rules. For each rule, a\n+ * #{@link org.nuxeo.retention.actions.EvalInputEventBasedRuleAction} is scheduled.\n+ *\n+ * @since 11.1\n+ */\n+public class ProcessRetentionEventAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"processRetentionEvent\";\n+\n+    public static final String PARAM_EVENT = \"event\";", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0NjIyNA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365346224", "bodyText": "add private -> private static final Logger log ...", "author": "RSalem07", "createdAt": "2020-01-10T17:28:39Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/ProcessRetentionEventAction.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.core.repository.RepositoryService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to retrieve event-based retention rules. For each rule, a\n+ * #{@link org.nuxeo.retention.actions.EvalInputEventBasedRuleAction} is scheduled.\n+ *\n+ * @since 11.1\n+ */\n+public class ProcessRetentionEventAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"processRetentionEvent\";\n+\n+    public static final String PARAM_EVENT = \"event\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvalEventBasedRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class EvalEventBasedRuleComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(EvalEventBasedRuleComputation.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0Njg2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365346864", "bodyText": "you can use a static import for more readability. wdty ;)", "author": "RSalem07", "createdAt": "2020-01-10T17:30:14Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/EvalInputEventBasedRuleAction.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to evaluate expression on record documents with an attached event-based retention rule. Depending on the\n+ * expression evaluation outcome, a determinate retention period is computed and set on the record document.\n+ *\n+ * @since 11.1\n+ */\n+public class EvalInputEventBasedRuleAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"evalInputEventBasedRule\";\n+\n+    public static final String PARAM_EVENT = \"event\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvalEventBasedRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class EvalEventBasedRuleComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(EvalEventBasedRuleComputation.class);\n+\n+        protected boolean disableAudit;\n+\n+        protected RetentionManager retentionManager;\n+\n+        public EvalEventBasedRuleComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        public void startBucket(String bucketKey) {\n+            BulkCommand command = getCurrentCommand();\n+            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);\n+            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());\n+            retentionManager = Framework.getService(RetentionManager.class);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            for (DocumentModel recordDoc : loadDocuments(session, ids)) {\n+                if (!recordDoc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                    log.debug(\"Document {} is not a record, ignoring ...\", recordDoc::getPathAsString);\n+                    continue;\n+                }\n+\n+                Record record = recordDoc.getAdapter(Record.class);\n+                if (!record.isRetainUntilInderterminate()) {\n+                    log.debug(\"Record {} has already a determinate retention date {}, ignoring ...\",\n+                            recordDoc::getPathAsString,\n+                            () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(recordDoc.getRetainUntil()));", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNjY2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368026664", "bodyText": "Not sure, DEFAULT_DATE_FORMAT by itself wouldn't give much context about which default. I'll probably change this to a standard ISO formatter later anyway.", "author": "efge", "createdAt": "2020-01-17T16:33:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0Njg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NjI0Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365696243", "bodyText": "cast is not needed.", "author": "RSalem07", "createdAt": "2020-01-13T09:05:21Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/HoldDocumentsAction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to set legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class HoldDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"holdDocumentsAction\";\n+\n+    public static final String PARAM_DESC = \"description\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);\n+\n+        protected String description;\n+\n+        public SetLegalHoldComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        public void startBucket(String bucketKey) {\n+            BulkCommand command = getCurrentCommand();\n+            description = (String) command.getParam(PARAM_DESC);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NjMxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365696319", "bodyText": "add private on the logger field", "author": "RSalem07", "createdAt": "2020-01-13T09:05:35Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/HoldDocumentsAction.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to set legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class HoldDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"holdDocumentsAction\";\n+\n+    public static final String PARAM_DESC = \"description\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyNzA0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368027040", "bodyText": "Actually unused, removed.", "author": "efge", "createdAt": "2020-01-17T16:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NzMxMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365697313", "bodyText": "seems unused", "author": "RSalem07", "createdAt": "2020-01-13T09:08:18Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/UnholdDocumentsAction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to unset legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class UnholdDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"unholdDocumentsAction\";\n+\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5NzgyOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365697828", "bodyText": "semicolon not needed at line 74", "author": "RSalem07", "createdAt": "2020-01-13T09:09:45Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/UnholdDocumentsAction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to unset legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class UnholdDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"unholdDocumentsAction\";\n+\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);\n+\n+        public SetLegalHoldComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            ids.stream()\n+               .map(id -> new IdRef(id))\n+               .filter((docRef) -> session.hasLegalHold(docRef)\n+                       && session.hasPermission(docRef, SecurityConstants.MANAGE_LEGAL_HOLD))\n+               .forEach((docRef) -> {\n+                   session.setLegalHold(docRef, false, null);\n+               });\n+            ;", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5OTE2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365699166", "bodyText": "can be replace by map(IdRef::new)", "author": "RSalem07", "createdAt": "2020-01-13T09:13:25Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/UnholdDocumentsAction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to unset legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class UnholdDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"unholdDocumentsAction\";\n+\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);\n+\n+        public SetLegalHoldComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            ids.stream()\n+               .map(id -> new IdRef(id))", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5OTY0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365699648", "bodyText": "curly bracket and parenthesis are not needed => ....forEach(docRef -> session.setLegalHold(docRef, false, null))", "author": "RSalem07", "createdAt": "2020-01-13T09:14:44Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/UnholdDocumentsAction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to unset legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class UnholdDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"unholdDocumentsAction\";\n+\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);\n+\n+        public SetLegalHoldComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            ids.stream()\n+               .map(id -> new IdRef(id))\n+               .filter((docRef) -> session.hasLegalHold(docRef)\n+                       && session.hasPermission(docRef, SecurityConstants.MANAGE_LEGAL_HOLD))\n+               .forEach((docRef) -> {", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMDI0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365700248", "bodyText": "at the end we can replace it by:\n               ids.stream()\n                    .map(IdRef::new)\n                    .filter(session::hasLegalHold)\n                    .forEach(docRef -> session.setLegalHold(docRef, false, null));\n\nbecause permissions are checked at AbstractSession level even for the read see  here and here", "author": "RSalem07", "createdAt": "2020-01-13T09:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5OTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTMxNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368029315", "bodyText": "But we want to skip those we can't manage, not throw an exception when we encounter them.", "author": "efge", "createdAt": "2020-01-17T16:39:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY5OTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwMzU4OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365703589", "bodyText": "parentheses are not need on (docRef) for more details see https://rules.sonarsource.com/java/RSPEC-1611", "author": "RSalem07", "createdAt": "2020-01-13T09:24:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/UnholdDocumentsAction.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to unset legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class UnholdDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"unholdDocumentsAction\";\n+\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class SetLegalHoldComputation extends AbstractBulkComputation {\n+\n+        static final Logger log = LogManager.getLogger(SetLegalHoldComputation.class);\n+\n+        public SetLegalHoldComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            ids.stream()\n+               .map(id -> new IdRef(id))\n+               .filter((docRef) -> session.hasLegalHold(docRef)", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwODczOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365708739", "bodyText": "can be replaced for one element on the list by return Collections.singletonList((String) propertyValue);", "author": "RSalem07", "createdAt": "2020-01-13T09:36:47Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAyOTc5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368029791", "bodyText": "That isn't shorter.", "author": "efge", "createdAt": "2020-01-17T16:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcwODczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMjgyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365712820", "bodyText": "body method can be replaced by the use of  Objects.equals(CoreSession.RETAIN_UNTIL_INDETERMINATE, retainUntil.getTimeInMillis());", "author": "RSalem07", "createdAt": "2020-01-13T09:45:42Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetainUntilInderterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        return retainUntil != null\n+                ? CoreSession.RETAIN_UNTIL_INDETERMINATE.getTimeInMillis() == retainUntil.getTimeInMillis()\n+                : false;\n+    }", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMTQyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368031425", "bodyText": "Hm no not at all. That would NPE if retainUntil is null.", "author": "efge", "createdAt": "2020-01-17T16:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMjgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNzkwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368037902", "bodyText": "i agree sorry about it :)", "author": "RSalem07", "createdAt": "2020-01-17T16:56:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcxMjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDYyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365720621", "bodyText": "i am wondering why we don't use directly the getDocument().isUnderRetentionOrLegalHold() because the second check  (retainUntil = getDocument().getRetainUntil()) == null || !Calendar.getInstance().before(retainUntil); is already covered by getDocument().isUnderRetentionOrLegalHold() or perhaps the need is to be sure that we was under retention and the data now is in the past and in this case  getDocument().getRetainUntil()) should be different from null", "author": "RSalem07", "createdAt": "2020-01-13T10:03:00Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetainUntilInderterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        return retainUntil != null\n+                ? CoreSession.RETAIN_UNTIL_INDETERMINATE.getTimeInMillis() == retainUntil.getTimeInMillis()\n+                : false;\n+    }\n+\n+    public boolean isRetentionExpired() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return true;\n+        }\n+        Calendar retainUntil;\n+        return (retainUntil = getDocument().getRetainUntil()) == null || !Calendar.getInstance().before(retainUntil);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMzYxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368033619", "bodyText": "This checks only retention expiration, whereas isUnderRetentionOrLegalHold can also return true when there's a legal hold.", "author": "efge", "createdAt": "2020-01-17T16:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMjMxNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365722317", "bodyText": "should use CoreSession#setRetainUtil which checks the permissions before setting the value, and the method can  be replaced by document.getCoreSession().setRetainUntil(getDocument().getRef(), retainUntil, null); but we should ensure that the document.getCorSession() is not null", "author": "RSalem07", "createdAt": "2020-01-13T10:06:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetainUntilInderterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        return retainUntil != null\n+                ? CoreSession.RETAIN_UNTIL_INDETERMINATE.getTimeInMillis() == retainUntil.getTimeInMillis()\n+                : false;\n+    }\n+\n+    public boolean isRetentionExpired() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return true;\n+        }\n+        Calendar retainUntil;\n+        return (retainUntil = getDocument().getRetainUntil()) == null || !Calendar.getInstance().before(retainUntil);\n+    }\n+\n+    protected void save(CoreSession session) {\n+        document.putContextData(DublinCoreListener.DISABLE_DUBLINCORE_LISTENER, true);\n+        document.putContextData(NotificationConstants.DISABLE_NOTIFICATION_SERVICE, true);\n+        document.putContextData(NXAuditEventsService.DISABLE_AUDIT_LOGGER, true);\n+        document.putContextData(VersioningService.DISABLE_AUTO_CHECKOUT, true);\n+        document.putContextData(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE, true);\n+        session.saveDocument(document);\n+        document.putContextData(DublinCoreListener.DISABLE_DUBLINCORE_LISTENER, null);\n+        document.putContextData(NotificationConstants.DISABLE_NOTIFICATION_SERVICE, null);\n+        document.putContextData(NXAuditEventsService.DISABLE_AUDIT_LOGGER, null);\n+        document.putContextData(VersioningService.DISABLE_AUTO_CHECKOUT, null);\n+        document.getContextData().remove(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE);\n+    }\n+\n+    public void saveRetainUntil(Calendar retainUntil) {\n+        document.setPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP, retainUntil);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNDkwNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368034905", "bodyText": "But this is an adapter for the current document, and the RETAIN_UNTIL_PROP here is not the low-level one you're thinking about.", "author": "efge", "createdAt": "2020-01-17T16:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMjMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyMjU5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365722596", "bodyText": "end break line at the end of the file.", "author": "RSalem07", "createdAt": "2020-01-13T10:07:31Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetainUntilInderterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        return retainUntil != null\n+                ? CoreSession.RETAIN_UNTIL_INDETERMINATE.getTimeInMillis() == retainUntil.getTimeInMillis()\n+                : false;\n+    }\n+\n+    public boolean isRetentionExpired() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return true;\n+        }\n+        Calendar retainUntil;\n+        return (retainUntil = getDocument().getRetainUntil()) == null || !Calendar.getInstance().before(retainUntil);\n+    }\n+\n+    protected void save(CoreSession session) {\n+        document.putContextData(DublinCoreListener.DISABLE_DUBLINCORE_LISTENER, true);\n+        document.putContextData(NotificationConstants.DISABLE_NOTIFICATION_SERVICE, true);\n+        document.putContextData(NXAuditEventsService.DISABLE_AUDIT_LOGGER, true);\n+        document.putContextData(VersioningService.DISABLE_AUTO_CHECKOUT, true);\n+        document.putContextData(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE, true);\n+        session.saveDocument(document);\n+        document.putContextData(DublinCoreListener.DISABLE_DUBLINCORE_LISTENER, null);\n+        document.putContextData(NotificationConstants.DISABLE_NOTIFICATION_SERVICE, null);\n+        document.putContextData(NXAuditEventsService.DISABLE_AUDIT_LOGGER, null);\n+        document.putContextData(VersioningService.DISABLE_AUTO_CHECKOUT, null);\n+        document.getContextData().remove(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE);\n+    }\n+\n+    public void saveRetainUntil(Calendar retainUntil) {\n+        document.setPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP, retainUntil);\n+    }\n+\n+    public void setRule(RetentionRule rule, CoreSession session) {\n+        setRuleIds(Arrays.asList(rule.getDocument().getId()));\n+        save(session);\n+    }\n+\n+    protected void setRuleIds(final List<String> ruleIds) {\n+        document.setPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP, (Serializable) ruleIds);\n+    }\n+}", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyNTIyMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365725222", "bodyText": "can be replaced by return Collections.singletonList((String)propertyValue);", "author": "RSalem07", "createdAt": "2020-01-13T10:13:16Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyNjU1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365726550", "bodyText": "1000000 -> 1_000_000, and i think we can replace plusNanos(getDurationMillis() * 1000000) by  .plus(getDurationMillis(), ChronoUnit.MILLIS); wdyt", "author": "RSalem07", "createdAt": "2020-01-13T10:16:23Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())\n+                                              .plusMonths(getDurationMonths())\n+                                              .plusDays(getDurationDays())\n+                                              .plusNanos(getDurationMillis() * 1000000);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTc3OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365729779", "bodyText": "can we make a new variable from datetime parameter to enforce immutability and defensive copy = > LocalDateTime localDateTime = LocalDateTime.from(datetime);", "author": "RSalem07", "createdAt": "2020-01-13T10:23:45Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNzA5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368037096", "bodyText": "They're already immutable, plusYears and friends already return a copy.", "author": "efge", "createdAt": "2020-01-17T16:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTcyOTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczMjY5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365732696", "bodyText": "isAfterDely -> isAfterDelay", "author": "RSalem07", "createdAt": "2020-01-13T10:30:28Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())\n+                                              .plusMonths(getDurationMonths())\n+                                              .plusDays(getDurationDays())\n+                                              .plusNanos(getDurationMillis() * 1000000);\n+        return GregorianCalendar.from(localDateTime.atZone(ZoneId.systemDefault()));\n+    }\n+\n+    public Calendar getRetainUntilDateFromNow() {\n+        return getRetainUntilDateFrom(LocalDateTime.now());\n+    }\n+\n+    public String getStartingPointEvent() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EVENT_PROP);\n+    }\n+\n+    public String getStartingPointExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EXPRESSION_PROP);\n+    }\n+\n+    public StartingPointPolicy getStartingPointPolicy() {\n+        String value = (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_POLICY_PROP);\n+        if (value != null) {\n+            return StartingPointPolicy.valueOf(value.toUpperCase());\n+        }\n+        return null;\n+\n+    }\n+\n+    public boolean isAfterDely() {", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczOTI3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365739278", "bodyText": "as getStartingPointPolicy returns the enum we can use directly the == operator instead of equals and i think getStartingPointPolicy can be adapted to be part of the enum itself  and i will see the enum improved with:\n    public enum StartingPointPolicy {\n        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED;\n\n        public static StartingPointPolicy fromValue(String value) {\n            if (value != null) {\n                return StartingPointPolicy.valueOf(value.toUpperCase());\n            }\n            return null;\n        }\n\n        public static StartingPointPolicy fromDocument(DocumentModel document) {\n            if (document != null) {\n                return fromValue((String) document.getPropertyValue(RetentionConstants.STARTING_POINT_POLICY_PROP));\n            }\n            return null;\n        }\n    }\n\nand the call\npublic boolean isAfterDely() {\n        return AFTER_DELAY == StartingPointPolicy.fromDocument(document);\n    }\n\nwdyt,  we can ask the team for more feedbacks ;)", "author": "RSalem07", "createdAt": "2020-01-13T10:46:04Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())\n+                                              .plusMonths(getDurationMonths())\n+                                              .plusDays(getDurationDays())\n+                                              .plusNanos(getDurationMillis() * 1000000);\n+        return GregorianCalendar.from(localDateTime.atZone(ZoneId.systemDefault()));\n+    }\n+\n+    public Calendar getRetainUntilDateFromNow() {\n+        return getRetainUntilDateFrom(LocalDateTime.now());\n+    }\n+\n+    public String getStartingPointEvent() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EVENT_PROP);\n+    }\n+\n+    public String getStartingPointExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EXPRESSION_PROP);\n+    }\n+\n+    public StartingPointPolicy getStartingPointPolicy() {\n+        String value = (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_POLICY_PROP);\n+        if (value != null) {\n+            return StartingPointPolicy.valueOf(value.toUpperCase());\n+        }\n+        return null;\n+\n+    }\n+\n+    public boolean isAfterDely() {\n+        return StartingPointPolicy.AFTER_DELAY.equals(getStartingPointPolicy());\n+    }\n+\n+    public boolean isAuto() {\n+        return ApplicationPolicy.AUTO.name().toLowerCase().equals(getApplicationPolicy());\n+    }\n+\n+    public boolean isDocTypeAccepted(String docType) {\n+        List<String> types = getDocTypes();\n+        return types == null || types.isEmpty() || types.contains(docType);\n+    }\n+\n+    public boolean isEnabled() {\n+        return (boolean) document.getPropertyValue(RetentionConstants.ENABLED_PROP);\n+    }\n+\n+    public boolean isEventBased() {\n+        return StartingPointPolicy.EVENT_BASED.equals(getStartingPointPolicy());", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0MjgxMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368042810", "bodyText": "Ok for ==, I'll refactor the upper/lower stuff later it's rather ugly.", "author": "efge", "createdAt": "2020-01-17T17:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTczOTI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0MDExMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365740113", "bodyText": "same proposition as above on the three last methods or at least just use ==operator instead equals", "author": "RSalem07", "createdAt": "2020-01-13T10:48:01Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,246 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED\n+    }\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public Long getDurationDays() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+    }\n+\n+    public Long getDurationMillis() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+    }\n+\n+    public Long getDurationMonths() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+    }\n+\n+    public Long getDurationYears() {\n+        return (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())\n+                                              .plusMonths(getDurationMonths())\n+                                              .plusDays(getDurationDays())\n+                                              .plusNanos(getDurationMillis() * 1000000);\n+        return GregorianCalendar.from(localDateTime.atZone(ZoneId.systemDefault()));\n+    }\n+\n+    public Calendar getRetainUntilDateFromNow() {\n+        return getRetainUntilDateFrom(LocalDateTime.now());\n+    }\n+\n+    public String getStartingPointEvent() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EVENT_PROP);\n+    }\n+\n+    public String getStartingPointExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EXPRESSION_PROP);\n+    }\n+\n+    public StartingPointPolicy getStartingPointPolicy() {\n+        String value = (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_POLICY_PROP);\n+        if (value != null) {\n+            return StartingPointPolicy.valueOf(value.toUpperCase());\n+        }\n+        return null;\n+\n+    }\n+\n+    public boolean isAfterDely() {\n+        return StartingPointPolicy.AFTER_DELAY.equals(getStartingPointPolicy());\n+    }\n+\n+    public boolean isAuto() {\n+        return ApplicationPolicy.AUTO.name().toLowerCase().equals(getApplicationPolicy());\n+    }\n+\n+    public boolean isDocTypeAccepted(String docType) {\n+        List<String> types = getDocTypes();\n+        return types == null || types.isEmpty() || types.contains(docType);\n+    }\n+\n+    public boolean isEnabled() {\n+        return (boolean) document.getPropertyValue(RetentionConstants.ENABLED_PROP);\n+    }\n+\n+    public boolean isEventBased() {\n+        return StartingPointPolicy.EVENT_BASED.equals(getStartingPointPolicy());\n+    }\n+\n+    public boolean isImmediate() {\n+        return StartingPointPolicy.IMMEDIATE.equals(getStartingPointPolicy());\n+    }\n+\n+    public boolean isManual() {\n+        return ApplicationPolicy.MANUAL.name().toLowerCase().equals(getApplicationPolicy());\n+    }\n+\n+    public boolean isMetadataBased() {\n+        return StartingPointPolicy.METADATA_BASED.equals(getStartingPointPolicy());\n+    }\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0MjcwMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365742702", "bodyText": "i am wondering what if we cast directly instead of the check because  ( return (String)getProperty(RetentionConstants.INPUT_PROPERTY_KEY))if the type is not a string, i think we can find ourself with a non consistent data and this code will returns null and we have the setInput  which will do the insertion correctly", "author": "RSalem07", "createdAt": "2020-01-13T10:53:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/event/RetentionEventContext.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.event;\n+\n+import java.io.Serializable;\n+\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.event.impl.UnboundEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * Specialized event context for retention events.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionEventContext extends UnboundEventContext {\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public RetentionEventContext(NuxeoPrincipal principal) {\n+        super(principal, null);\n+        setProperty(\"category\", RetentionConstants.EVENT_CATEGORY);\n+    }\n+\n+    public String getInput() {\n+        Serializable input = getProperty(RetentionConstants.INPUT_PROPERTY_KEY);\n+        if (input instanceof String) {\n+            return (String) input;", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjQzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365746435", "bodyText": "you can use diamond operator\n    Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n    Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n\nshould be replaced by\n    Map<String, Set<String>> docsToCheckAndEvents = new HashMap<>();\n     Map<String, Boolean> documentModifiedIgnored = new HashMap<>();", "author": "RSalem07", "createdAt": "2020-01-13T11:02:47Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzczMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365747733", "bodyText": "log.trace(\"Proceeding event \" + event.getName()); ->  log.trace(\"Proceeding event {}\" , event::getName);", "author": "RSalem07", "createdAt": "2020-01-13T11:06:09Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0ODYzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365748637", "bodyText": "log.trace(\"Document is not a record\", doc::getPathAsString); -> log.trace(\"Document {} is not a record\", doc::getPathAsString); --> missing {}", "author": "RSalem07", "createdAt": "2020-01-13T11:08:37Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();\n+            DocumentEventContext docEventCtx = (DocumentEventContext) evtCtx;\n+            DocumentModel doc = docEventCtx.getSourceDocument();\n+            String docId = doc.getId();\n+            if (docEventCtx.getProperties().containsKey(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE)\n+                    && !documentModifiedIgnored.containsKey(docId)) {\n+                // ignore only once per document per bundle, the rule can be attached and document later modified\n+                // into\n+                // the same transaction\n+                documentModifiedIgnored.put(docId, true);\n+                continue;\n+            }\n+            if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                log.trace(\"Document is not a record\", doc::getPathAsString);\n+                continue;", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0ODkwMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365748900", "bodyText": "log.trace(\"Record already expired\", doc::getPathAsString); ->  log.trace(\"Record {} already expired\", doc::getPathAsString); --> missing {}", "author": "RSalem07", "createdAt": "2020-01-13T11:09:21Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();\n+            DocumentEventContext docEventCtx = (DocumentEventContext) evtCtx;\n+            DocumentModel doc = docEventCtx.getSourceDocument();\n+            String docId = doc.getId();\n+            if (docEventCtx.getProperties().containsKey(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE)\n+                    && !documentModifiedIgnored.containsKey(docId)) {\n+                // ignore only once per document per bundle, the rule can be attached and document later modified\n+                // into\n+                // the same transaction\n+                documentModifiedIgnored.put(docId, true);\n+                continue;\n+            }\n+            if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                log.trace(\"Document is not a record\", doc::getPathAsString);\n+                continue;\n+            }\n+            Record record = doc.getAdapter(Record.class);\n+            RetentionRule rule = record.getRule(docEventCtx.getCoreSession());\n+            if (rule == null) {\n+                log.trace(\"Record {} does not have rule\", doc::getPathAsString);\n+                continue;\n+            }\n+            if (!rule.isEventBased()) {\n+                log.trace(\"Rule {} is not event-based\", () -> rule.getDocument().getPathAsString());\n+                continue;\n+            }\n+            if (record.isRetentionExpired()) {\n+                log.trace(\"Record already expired\", doc::getPathAsString);\n+                retentionManager.proceedRetentionExpired(record, event.getContext().getCoreSession());", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1MDA2MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365750061", "bodyText": "diamond operator, new HashSet<String>(); can be replaced by new HashSet<>();", "author": "RSalem07", "createdAt": "2020-01-13T11:12:35Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();\n+            DocumentEventContext docEventCtx = (DocumentEventContext) evtCtx;\n+            DocumentModel doc = docEventCtx.getSourceDocument();\n+            String docId = doc.getId();\n+            if (docEventCtx.getProperties().containsKey(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE)\n+                    && !documentModifiedIgnored.containsKey(docId)) {\n+                // ignore only once per document per bundle, the rule can be attached and document later modified\n+                // into\n+                // the same transaction\n+                documentModifiedIgnored.put(docId, true);\n+                continue;\n+            }\n+            if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                log.trace(\"Document is not a record\", doc::getPathAsString);\n+                continue;\n+            }\n+            Record record = doc.getAdapter(Record.class);\n+            RetentionRule rule = record.getRule(docEventCtx.getCoreSession());\n+            if (rule == null) {\n+                log.trace(\"Record {} does not have rule\", doc::getPathAsString);\n+                continue;\n+            }\n+            if (!rule.isEventBased()) {\n+                log.trace(\"Rule {} is not event-based\", () -> rule.getDocument().getPathAsString());\n+                continue;\n+            }\n+            if (record.isRetentionExpired()) {\n+                log.trace(\"Record already expired\", doc::getPathAsString);\n+                retentionManager.proceedRetentionExpired(record, event.getContext().getCoreSession());\n+                // XXX should we check if the record should be under retention again?\n+                continue;\n+            }\n+            if (docsToCheckAndEvents.containsKey(docId)) {\n+                Set<String> eventsToCheck = docsToCheckAndEvents.get(docId);\n+                if (!eventsToCheck.contains(event.getName())) {\n+                    eventsToCheck.add(event.getName());\n+                }\n+                docsToCheckAndEvents.put(docId, eventsToCheck);\n+            } else {\n+                Set<String> evts = new HashSet<String>();", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2MDkyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365760927", "bodyText": "i am wondering if we can find a way to simply this part of code, and for more information Sonar reports that with Cognitive Complexity of methods should not be too high squid: S3776  i tried some things like the use of Map#merge:\nreplace the\nif (docsToCheckAndEvents.containsKey(docId)) {\n                Set<String> eventsToCheck = docsToCheckAndEvents.get(docId);\n                if (!eventsToCheck.contains(event.getName())) {\n                    eventsToCheck.add(event.getName());\n                }\n                docsToCheckAndEvents.put(docId, eventsToCheck);\n            } else {\n                Set<String> evts = new HashSet<String>();\n                evts.add(event.getName());\n                docsToCheckAndEvents.put(docId, evts);\n            }\n\nby\n docsToCheckAndEvents.merge(docId, new HashSet<>(singleton(event.getName())), (oldV, newV) -> {\n                oldV.add(event.getName());\n                return oldV;\n            });\n\ni told my self what if we separate the events to two lists when that will processed  and a second just logged, wdyth about:\nprotected boolean accept(Event event) {\n        DocumentEventContext eventContext = (DocumentEventContext) event.getContext();\n        DocumentModel document = eventContext.getSourceDocument();\n        RetentionRule rule;\n        Record record = document.getAdapter(Record.class);\n        return document.hasFacet(RetentionConstants.RECORD_FACET) //\n                && ((rule = record.getRule(document.getCoreSession())) != null && rule.isEventBased()) //\n                && !record.isRetentionExpired();\n    }\n\n @Override\n    public void handleEvent(EventBundle events) {\n       ......\n      \n//Separate the two list \nMap<Boolean, List<Event>> map = StreamSupport.stream(events.spliterator(), false)\n                                                     .collect(Collectors.groupingBy(this::accept, Collectors.toList()));\n\n// log because something is missing on the event / document \n  map.get(false).forEach();\n//process the accepted \nmap.get(true).map or map.get(true).foreach to use the second part //see above", "author": "RSalem07", "createdAt": "2020-01-13T11:41:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();\n+            DocumentEventContext docEventCtx = (DocumentEventContext) evtCtx;\n+            DocumentModel doc = docEventCtx.getSourceDocument();\n+            String docId = doc.getId();\n+            if (docEventCtx.getProperties().containsKey(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE)\n+                    && !documentModifiedIgnored.containsKey(docId)) {\n+                // ignore only once per document per bundle, the rule can be attached and document later modified\n+                // into\n+                // the same transaction\n+                documentModifiedIgnored.put(docId, true);\n+                continue;\n+            }\n+            if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                log.trace(\"Document is not a record\", doc::getPathAsString);\n+                continue;\n+            }\n+            Record record = doc.getAdapter(Record.class);\n+            RetentionRule rule = record.getRule(docEventCtx.getCoreSession());\n+            if (rule == null) {\n+                log.trace(\"Record {} does not have rule\", doc::getPathAsString);\n+                continue;\n+            }\n+            if (!rule.isEventBased()) {\n+                log.trace(\"Rule {} is not event-based\", () -> rule.getDocument().getPathAsString());\n+                continue;\n+            }\n+            if (record.isRetentionExpired()) {\n+                log.trace(\"Record already expired\", doc::getPathAsString);\n+                retentionManager.proceedRetentionExpired(record, event.getContext().getCoreSession());\n+                // XXX should we check if the record should be under retention again?\n+                continue;\n+            }\n+            if (docsToCheckAndEvents.containsKey(docId)) {\n+                Set<String> eventsToCheck = docsToCheckAndEvents.get(docId);\n+                if (!eventsToCheck.contains(event.getName())) {\n+                    eventsToCheck.add(event.getName());\n+                }\n+                docsToCheckAndEvents.put(docId, eventsToCheck);\n+            } else {\n+                Set<String> evts = new HashSet<String>();\n+                evts.add(event.getName());\n+                docsToCheckAndEvents.put(docId, evts);\n+            }\n+        }\n+        if (!docsToCheckAndEvents.isEmpty()) {\n+            retentionManager.evalRules(docsToCheckAndEvents);\n+        }\n+\n+    }", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2MzMzMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365763331", "bodyText": "eventsToCheck  is a Set implementation no need to check the unicity (call to contains method)", "author": "RSalem07", "createdAt": "2020-01-13T11:48:45Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionDocumentEventListener.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventBundle;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.PostCommitFilteringEventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listener processing events with a {@link org.nuxeo.ecm.core.event.impl.DocumentEventContext}). If the targeted\n+ * document is a record and has an attached event-based, the rule is then evaluated to check if the retention expiration\n+ * date has to be recomputed.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionDocumentEventListener implements PostCommitFilteringEventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionDocumentEventListener.class);\n+\n+    @Override\n+    public boolean acceptEvent(Event event) {\n+        EventContext eventCtx = event.getContext();\n+        if (!(eventCtx instanceof DocumentEventContext)) {\n+            return false;\n+        }\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        if (retentionManager == null) {\n+            log.trace(\"RetentionManager not started yet?!\");\n+            return false;\n+        }\n+        return retentionManager.getAcceptedEvents().contains(event.getName());\n+    }\n+\n+    @Override\n+    public void handleEvent(EventBundle events) {\n+\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+\n+        Map<String, Set<String>> docsToCheckAndEvents = new HashMap<String, Set<String>>();\n+\n+        Map<String, Boolean> documentModifiedIgnored = new HashMap<String, Boolean>();\n+        for (Event event : events) {\n+            log.trace(\"Proceeding event \" + event.getName());\n+            EventContext evtCtx = event.getContext();\n+            DocumentEventContext docEventCtx = (DocumentEventContext) evtCtx;\n+            DocumentModel doc = docEventCtx.getSourceDocument();\n+            String docId = doc.getId();\n+            if (docEventCtx.getProperties().containsKey(RetentionConstants.RETENTION_CHECKER_LISTENER_IGNORE)\n+                    && !documentModifiedIgnored.containsKey(docId)) {\n+                // ignore only once per document per bundle, the rule can be attached and document later modified\n+                // into\n+                // the same transaction\n+                documentModifiedIgnored.put(docId, true);\n+                continue;\n+            }\n+            if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                log.trace(\"Document is not a record\", doc::getPathAsString);\n+                continue;\n+            }\n+            Record record = doc.getAdapter(Record.class);\n+            RetentionRule rule = record.getRule(docEventCtx.getCoreSession());\n+            if (rule == null) {\n+                log.trace(\"Record {} does not have rule\", doc::getPathAsString);\n+                continue;\n+            }\n+            if (!rule.isEventBased()) {\n+                log.trace(\"Rule {} is not event-based\", () -> rule.getDocument().getPathAsString());\n+                continue;\n+            }\n+            if (record.isRetentionExpired()) {\n+                log.trace(\"Record already expired\", doc::getPathAsString);\n+                retentionManager.proceedRetentionExpired(record, event.getContext().getCoreSession());\n+                // XXX should we check if the record should be under retention again?\n+                continue;\n+            }\n+            if (docsToCheckAndEvents.containsKey(docId)) {\n+                Set<String> eventsToCheck = docsToCheckAndEvents.get(docId);\n+                if (!eventsToCheck.contains(event.getName())) {", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NjUwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368056503", "bodyText": "Actually I'm replacing the whole block with computeIfAbsent.\ndocsToCheckAndEvents.computeIfAbsent(docId, k -> new HashSet<>()).add(event.getName());", "author": "efge", "createdAt": "2020-01-17T17:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2MzMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5ODcyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365798725", "bodyText": "what if we group the different checks at the beginning, perhaps something like:\n EventContext ctx = event.getContext();\n        DocumentEventContext docCxt;\n        if (!event.getName().equals(DocumentEventTypes.RETENTION_EXPIRED) //\n                || !(ctx instanceof DocumentEventContext) //\n                || !(docCxt = (DocumentEventContext) event.getContext()).getSourceDocument().hasFacet(RECORD_FACET)) {\n            return;\n        }\n\n        DocumentModel doc = docCxt.getSourceDocument();\n        log.debug(\"Retention expired on {}\", doc::getPathAsString);\n        Record record = doc.getAdapter(Record.class);\n        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n        CoreSession session = ctx.getCoreSession();\n        record.saveRetainUntil((Calendar) docCxt.getProperty(CoreEventConstants.RETAIN_UNTIL));\n        retentionManager.proceedRetentionExpired(record, session);\n        session.saveDocument(doc);", "author": "RSalem07", "createdAt": "2020-01-13T13:19:46Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/listeners/RetentionExpiredListener.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.listeners;\n+\n+import java.util.Calendar;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventContext;\n+import org.nuxeo.ecm.core.event.EventListener;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Listens the #{@link org.nuxeo.ecm.core.api.event.DocumentEventTypes#RETENTION_EXPIRED} event on a document to proceed\n+ * potential post-actions.\n+ *\n+ * @since 11.1\n+ */\n+public class RetentionExpiredListener implements EventListener {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionExpiredListener.class);\n+\n+    @Override\n+    public void handleEvent(Event event) {\n+        EventContext ctx = event.getContext();\n+        if (!(ctx instanceof DocumentEventContext)) {\n+            return;\n+        }\n+\n+        final String eventId = event.getName();\n+\n+        final DocumentEventContext docCxt = (DocumentEventContext) event.getContext();\n+\n+        DocumentModel doc = null;\n+        if (eventId.equals(DocumentEventTypes.RETENTION_EXPIRED)) {\n+            doc = docCxt.getSourceDocument();\n+        } else {\n+            return;\n+        }\n+        if (!doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            return;\n+        }\n+        log.debug(\"Retention expired on {}\", doc::getPathAsString);\n+        Record record = doc.getAdapter(Record.class);\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        CoreSession session = ctx.getCoreSession();\n+        record.saveRetainUntil((Calendar) docCxt.getProperty(CoreEventConstants.RETAIN_UNTIL));\n+        retentionManager.proceedRetentionExpired(record, session);\n+        session.saveDocument(doc);\n+    }", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1ODI2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368058267", "bodyText": "Rewriting it a bit, but keeping local variables.", "author": "efge", "createdAt": "2020-01-17T17:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5ODcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwMDA4Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365800087", "bodyText": "String.format(... is not needed here, or perhaps you need to passe the rule you process in it", "author": "RSalem07", "createdAt": "2020-01-13T13:22:58Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/operations/AttachRetentionRule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.operations;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Operation(id = AttachRetentionRule.ID, category = Constants.CAT_DOCUMENT, label = \"Attach Retation Rule\", description = \"Attach the given retation rule to the input document.\")\n+public class AttachRetentionRule {\n+\n+    public static final String ID = \"Retention.AttachRule\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Context\n+    protected RetentionManager retentionManager;\n+\n+    @Param(name = \"rule\")\n+    protected DocumentModel rule;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel document) {\n+        if (!rule.hasFacet(RetentionConstants.RETENTION_RULE_FACET)) {\n+            throw new NuxeoException(String.format(\"Document is not a rule\"));", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgwMDcwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365800703", "bodyText": "extra space here ;)", "author": "RSalem07", "createdAt": "2020-01-13T13:24:20Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/operations/FireRetentionEvent.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.operations;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventProducer;\n+import org.nuxeo.ecm.platform.audit.api.AuditLogger;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.event.RetentionEventContext;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Operation(id = FireRetentionEvent.ID, category = Constants.CAT_NOTIFICATION, label = \"Fire Retention Event\", description = \"Fire a retention business related event.\")\n+public class FireRetentionEvent {\n+\n+    public static final String ID = \"Retention.FireEvent\";\n+\n+    @Context\n+    protected OperationContext ctx;\n+\n+    @Context\n+    protected EventProducer service;\n+\n+    @Param(name = \"name\")\n+    protected String name;\n+\n+    @Param(name = \"audit\", required = false)\n+    protected boolean audit = true;\n+\n+    @OperationMethod\n+    public void run() {\n+        CoreSession session = ctx.getCoreSession();\n+        Object input = ctx.getInput();\n+        RetentionEventContext evctx = new RetentionEventContext(session.getPrincipal());\n+        if (input != null) {\n+            if (input instanceof String) {\n+                evctx.setInput((String) input);\n+            }\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNzg1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365817856", "bodyText": "i am wondering why we set the RETAIN_UNTIL_INDETERMINATE when the provided value is null, because the implementation here lets the null value", "author": "RSalem07", "createdAt": "2020-01-13T14:00:11Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/operations/RetainDocument.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.operations;\n+\n+import java.util.Calendar;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Operation(id = RetainDocument.ID, category = Constants.CAT_DOCUMENT, label = \"Retain\", description = \"Turn the input document into a record and retain it until the until date. Returns back the retained document.\")\n+public class RetainDocument {\n+\n+    public static final String ID = \"Document.Retain\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Param(name = \"until\", required = false, description = \"If empty, the input document will be retained indeterminately\")\n+    protected Calendar until;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentRef doc) {\n+        session.makeRecord(doc);\n+        session.setRetainUntil(doc, until != null ? until : CoreSession.RETAIN_UNTIL_INDETERMINATE, null);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1OTI5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368059299", "bodyText": "That's part of the contract for this parameter: If empty, the input document will be retained indeterminately", "author": "efge", "createdAt": "2020-01-17T17:49:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgxNzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyNDQ3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365824478", "bodyText": "can be replaced by\n log.debug(\"Attaching event-based rule on {} matching  \\\"{}\\\"\", rule::getStartingPointEvent,\n                    () -> rule.getStartingPointExpression());", "author": "RSalem07", "createdAt": "2020-01-13T14:13:18Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyNjYwOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365826609", "bodyText": "missing the specific format -> %s", "author": "RSalem07", "createdAt": "2020-01-13T14:17:31Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type % is expected to have a DateType\", xpath, prop.getType()));\n+            }", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgyNzE1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365827151", "bodyText": "i am wondering if we can rework this part to reduce the number of the control flow. perhaps separate the control/validation from the processing", "author": "RSalem07", "createdAt": "2020-01-13T14:18:34Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type % is expected to have a DateType\", xpath, prop.getType()));\n+            }\n+            Calendar value = (Calendar) prop.getValue();\n+            if (value == null) {\n+                retainUntil = rule.getRetainUntilDateFromNow();\n+            } else {\n+                retainUntil = rule.getRetainUntilDateFrom(value);\n+                Calendar now = Calendar.getInstance();\n+                if (now.after(retainUntil)) {\n+                    log.info(\n+                            \"Metabased-based rule found past date {} as retention expiration date on {} from {} property. Ignoring...\",\n+                            () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()),\n+                            document::getPathAsString, () -> xpath);\n+                    return session.getDocument(document.getRef());\n+                }\n+            }\n+            log.debug(\"Attaching rule base on {} with value {}\", () -> xpath,\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown starting point policy: \" + rule.getStartingPointPolicy());\n+        }\n+        document.addFacet(RetentionConstants.RECORD_FACET);\n+        Record record = document.getAdapter(Record.class);\n+        record.setRule(rule, session);\n+        executeRuleBeginActions(record, session);\n+        session.setRetainUntil(document.getRef(), retainUntil, null);\n+        notifyAttachRule(record, rule, session);\n+        return session.getDocument(document.getRef());", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMTQ0Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365831442", "bodyText": "i think you mean / Do not lock document if already locked, and unlock if already unlocked (triggers an err... ->\nDo not lock document if already locked, and lock if already unlocked... or i am wrong", "author": "RSalem07", "createdAt": "2020-01-13T14:26:26Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type % is expected to have a DateType\", xpath, prop.getType()));\n+            }\n+            Calendar value = (Calendar) prop.getValue();\n+            if (value == null) {\n+                retainUntil = rule.getRetainUntilDateFromNow();\n+            } else {\n+                retainUntil = rule.getRetainUntilDateFrom(value);\n+                Calendar now = Calendar.getInstance();\n+                if (now.after(retainUntil)) {\n+                    log.info(\n+                            \"Metabased-based rule found past date {} as retention expiration date on {} from {} property. Ignoring...\",\n+                            () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()),\n+                            document::getPathAsString, () -> xpath);\n+                    return session.getDocument(document.getRef());\n+                }\n+            }\n+            log.debug(\"Attaching rule base on {} with value {}\", () -> xpath,\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown starting point policy: \" + rule.getStartingPointPolicy());\n+        }\n+        document.addFacet(RetentionConstants.RECORD_FACET);\n+        Record record = document.getAdapter(Record.class);\n+        record.setRule(rule, session);\n+        executeRuleBeginActions(record, session);\n+        session.setRetainUntil(document.getRef(), retainUntil, null);\n+        notifyAttachRule(record, rule, session);\n+        return session.getDocument(document.getRef());\n+    }\n+\n+    protected void notifyAttachRule(Record record, RetentionRule rule, CoreSession session) {\n+        DocumentModel doc = record.getDocument();\n+        DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, session.getRepositoryName());\n+        ctx.setProperty(CoreEventConstants.SESSION_ID, session.getSessionId());\n+        ctx.setProperty(DocumentEventContext.CATEGORY_PROPERTY_KEY, DocumentEventCategories.EVENT_DOCUMENT_CATEGORY);\n+        ctx.setProperty(DocumentEventContext.COMMENT_PROPERTY_KEY, rule.getDocument().getPathAsString());\n+        Event event = ctx.newEvent(RetentionConstants.RULE_ATTACHED_EVENT);\n+        Framework.getService(EventService.class).fireEvent(event);\n+    }\n+\n+    protected void checkCanAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        if (!principal.isAdministrator() && !principal.isMemberOf(RetentionConstants.RECORD_MANAGER_GROUP_NAME)) {\n+            if (!session.hasPermission(document.getRef(), SecurityConstants.MAKE_RECORD)\n+                    || !session.hasPermission(document.getRef(), SecurityConstants.SET_RETENTION))\n+                throw new NuxeoException(\"User is not authorized to attach retention rule\", SC_FORBIDDEN);\n+        }\n+        if (!rule.isEnabled()) {\n+            throw new NuxeoException(String.format(\"Rule is disabled\"));\n+        }\n+        if (!rule.isDocTypeAccepted(document.getType())) {\n+            throw new NuxeoException(\"Rule does not accept this document type\");\n+        }\n+        if (document.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            throw new NuxeoException(\"Document is already a record\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean canAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        try {\n+            checkCanAttachRule(document, rule, session);\n+            return true;\n+        } catch (NuxeoException e) {\n+            log.info(\"Cannot attach rule {} on document {}\", () -> rule.getDocument().getPathAsString(),\n+                    document::getPathAsString);\n+            return false;\n+        }\n+    }\n+\n+    public void executeRuleBeginActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getBeginActions(), session);\n+        }\n+    }\n+\n+    public void executeRuleEndActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getEndActions(), session);\n+        }\n+    }\n+\n+    protected void executeRuleActions(DocumentModel doc, List<String> actionIds, CoreSession session) {\n+        if (actionIds != null) {\n+            AutomationService automationService = Framework.getService(AutomationService.class);\n+            for (String operationId : actionIds) {\n+                log.debug(\"Executing {} action on {}\", () -> operationId, doc::getPathAsString);\n+                // Do not lock document if already locked, and unlock if already unlocked (triggers an error)\n+                // Also, if it's time to delete, unlock it first, etc.", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MDg3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368060872", "bodyText": "Replaced with clearer Do not lock document if already locked, nor unlock if already unlocked (would trigger an error)", "author": "efge", "createdAt": "2020-01-17T17:53:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMTQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMjk3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365832971", "bodyText": "the second parameter is missed or the second {} is not needed", "author": "RSalem07", "createdAt": "2020-01-13T14:28:59Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type % is expected to have a DateType\", xpath, prop.getType()));\n+            }\n+            Calendar value = (Calendar) prop.getValue();\n+            if (value == null) {\n+                retainUntil = rule.getRetainUntilDateFromNow();\n+            } else {\n+                retainUntil = rule.getRetainUntilDateFrom(value);\n+                Calendar now = Calendar.getInstance();\n+                if (now.after(retainUntil)) {\n+                    log.info(\n+                            \"Metabased-based rule found past date {} as retention expiration date on {} from {} property. Ignoring...\",\n+                            () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()),\n+                            document::getPathAsString, () -> xpath);\n+                    return session.getDocument(document.getRef());\n+                }\n+            }\n+            log.debug(\"Attaching rule base on {} with value {}\", () -> xpath,\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown starting point policy: \" + rule.getStartingPointPolicy());\n+        }\n+        document.addFacet(RetentionConstants.RECORD_FACET);\n+        Record record = document.getAdapter(Record.class);\n+        record.setRule(rule, session);\n+        executeRuleBeginActions(record, session);\n+        session.setRetainUntil(document.getRef(), retainUntil, null);\n+        notifyAttachRule(record, rule, session);\n+        return session.getDocument(document.getRef());\n+    }\n+\n+    protected void notifyAttachRule(Record record, RetentionRule rule, CoreSession session) {\n+        DocumentModel doc = record.getDocument();\n+        DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, session.getRepositoryName());\n+        ctx.setProperty(CoreEventConstants.SESSION_ID, session.getSessionId());\n+        ctx.setProperty(DocumentEventContext.CATEGORY_PROPERTY_KEY, DocumentEventCategories.EVENT_DOCUMENT_CATEGORY);\n+        ctx.setProperty(DocumentEventContext.COMMENT_PROPERTY_KEY, rule.getDocument().getPathAsString());\n+        Event event = ctx.newEvent(RetentionConstants.RULE_ATTACHED_EVENT);\n+        Framework.getService(EventService.class).fireEvent(event);\n+    }\n+\n+    protected void checkCanAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        if (!principal.isAdministrator() && !principal.isMemberOf(RetentionConstants.RECORD_MANAGER_GROUP_NAME)) {\n+            if (!session.hasPermission(document.getRef(), SecurityConstants.MAKE_RECORD)\n+                    || !session.hasPermission(document.getRef(), SecurityConstants.SET_RETENTION))\n+                throw new NuxeoException(\"User is not authorized to attach retention rule\", SC_FORBIDDEN);\n+        }\n+        if (!rule.isEnabled()) {\n+            throw new NuxeoException(String.format(\"Rule is disabled\"));\n+        }\n+        if (!rule.isDocTypeAccepted(document.getType())) {\n+            throw new NuxeoException(\"Rule does not accept this document type\");\n+        }\n+        if (document.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            throw new NuxeoException(\"Document is already a record\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean canAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        try {\n+            checkCanAttachRule(document, rule, session);\n+            return true;\n+        } catch (NuxeoException e) {\n+            log.info(\"Cannot attach rule {} on document {}\", () -> rule.getDocument().getPathAsString(),\n+                    document::getPathAsString);\n+            return false;\n+        }\n+    }\n+\n+    public void executeRuleBeginActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getBeginActions(), session);\n+        }\n+    }\n+\n+    public void executeRuleEndActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getEndActions(), session);\n+        }\n+    }\n+\n+    protected void executeRuleActions(DocumentModel doc, List<String> actionIds, CoreSession session) {\n+        if (actionIds != null) {\n+            AutomationService automationService = Framework.getService(AutomationService.class);\n+            for (String operationId : actionIds) {\n+                log.debug(\"Executing {} action on {}\", () -> operationId, doc::getPathAsString);\n+                // Do not lock document if already locked, and unlock if already unlocked (triggers an error)\n+                // Also, if it's time to delete, unlock it first, etc.\n+                // (more generally, be ready to handle specific operations and context)\n+                switch (operationId) {\n+                case LockDocument.ID:\n+                    if (doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+\n+                case UnlockDocument.ID:\n+                    if (!doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+\n+                case DeleteDocument.ID:\n+                case TrashDocument.ID:\n+                    if (doc.isLocked()) {\n+                        session.removeLock(doc.getRef());\n+                        doc = session.getDocument(doc.getRef());\n+                    }\n+                    break;\n+                }\n+                OperationContext context = getExecutionContext(doc, session);\n+                try {\n+                    automationService.run(context, operationId);\n+                } catch (OperationException e) {\n+                    throw new NuxeoException(\"Error running operation: \" + operationId, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected OperationContext getExecutionContext(DocumentModel doc, CoreSession session) {\n+        OperationContext context = new OperationContext(session);\n+        context.put(\"document\", doc);\n+        context.setCommit(false); // no session save at end\n+        context.setInput(doc);\n+        return context;\n+    }\n+\n+    @Override\n+    public void evalRules(Map<String, Set<String>> docsToCheckAndEvents) {\n+        if (docsToCheckAndEvents.isEmpty()) {\n+            return;\n+        }\n+        RuleEvaluationWorker work = new RuleEvaluationWorker(docsToCheckAndEvents);\n+        Framework.getService(WorkManager.class).schedule(work, WorkManager.Scheduling.ENQUEUE);\n+    }\n+\n+    protected ELActionContext initActionContext(DocumentModel doc, CoreSession session) {\n+        ELActionContext ctx = new ELActionContext(new ExpressionContext(), new ExpressionFactoryImpl());\n+        ctx.setCurrentPrincipal(session.getPrincipal());\n+        doc.detach(true);\n+        ctx.setCurrentDocument(doc);\n+        return ctx;\n+    }\n+\n+    protected Boolean evaluateConditionExpression(ELActionContext ctx, String expression) {\n+        Calendar now = Calendar.getInstance();\n+        if (StringUtils.isEmpty(expression)) {\n+            return true;\n+        }\n+        ctx.putLocalVariable(\"currentDate\", now);\n+        return ctx.checkCondition(expression);\n+    }\n+\n+    @Override\n+    public void evalExpressionEventBasedRules(Record record, Set<String> events, CoreSession session) {\n+        if (record == null) {\n+            return; // nothing to do\n+        }\n+        RetentionRule rule = record.getRule(session);\n+        if (rule == null) {\n+            return; // nothing to do\n+        }\n+        if (!rule.isEventBased()) {\n+            log.trace(\"Record is not event-based\");\n+            return;\n+        }\n+        log.debug(\"Evaluating event-based rules for record {}\", () -> record.getDocument().getPathAsString());\n+        if (record.isRetentionExpired()) {\n+            // retention expired, nothing to do\n+            log.debug(\"Evaluating event-based found retention expired\");\n+            proceedRetentionExpired(record, session);\n+            return;\n+\n+        }\n+        String startingPointEvent = rule.getStartingPointEvent();\n+        if (StringUtils.isBlank(startingPointEvent)) {\n+            log.warn(\"Evaluating event-based rules  on record {} found no event specified\",\n+                    () -> record.getDocument().getPathAsString());\n+            return;\n+        }\n+        if (events.contains(startingPointEvent)) {\n+            ELActionContext actionContext = initActionContext(record.getDocument(), session);\n+            String expression = rule.getStartingPointExpression();\n+            Boolean startNow = evaluateConditionExpression(actionContext, expression);\n+            if (startNow) {\n+                session.setRetainUntil(record.getDocument().getRef(), rule.getRetainUntilDateFromNow(), null);\n+                log.debug(\"Evaluating event-based rules: expression {} matched on event {}\", startingPointEvent);\n+            } else {", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMzQ0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365833441", "bodyText": "chaching -> caching or i am wrong :)", "author": "RSalem07", "createdAt": "2020-01-13T14:29:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\",\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else if (rule.isAfterDely()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule.getStartingPointEvent(),\n+                    rule.getStartingPointExpression());\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type % is expected to have a DateType\", xpath, prop.getType()));\n+            }\n+            Calendar value = (Calendar) prop.getValue();\n+            if (value == null) {\n+                retainUntil = rule.getRetainUntilDateFromNow();\n+            } else {\n+                retainUntil = rule.getRetainUntilDateFrom(value);\n+                Calendar now = Calendar.getInstance();\n+                if (now.after(retainUntil)) {\n+                    log.info(\n+                            \"Metabased-based rule found past date {} as retention expiration date on {} from {} property. Ignoring...\",\n+                            () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()),\n+                            document::getPathAsString, () -> xpath);\n+                    return session.getDocument(document.getRef());\n+                }\n+            }\n+            log.debug(\"Attaching rule base on {} with value {}\", () -> xpath,\n+                    () -> RetentionConstants.DEFAULT_DATE_FORMAT.format(retainUntil.getTime()));\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown starting point policy: \" + rule.getStartingPointPolicy());\n+        }\n+        document.addFacet(RetentionConstants.RECORD_FACET);\n+        Record record = document.getAdapter(Record.class);\n+        record.setRule(rule, session);\n+        executeRuleBeginActions(record, session);\n+        session.setRetainUntil(document.getRef(), retainUntil, null);\n+        notifyAttachRule(record, rule, session);\n+        return session.getDocument(document.getRef());\n+    }\n+\n+    protected void notifyAttachRule(Record record, RetentionRule rule, CoreSession session) {\n+        DocumentModel doc = record.getDocument();\n+        DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, session.getRepositoryName());\n+        ctx.setProperty(CoreEventConstants.SESSION_ID, session.getSessionId());\n+        ctx.setProperty(DocumentEventContext.CATEGORY_PROPERTY_KEY, DocumentEventCategories.EVENT_DOCUMENT_CATEGORY);\n+        ctx.setProperty(DocumentEventContext.COMMENT_PROPERTY_KEY, rule.getDocument().getPathAsString());\n+        Event event = ctx.newEvent(RetentionConstants.RULE_ATTACHED_EVENT);\n+        Framework.getService(EventService.class).fireEvent(event);\n+    }\n+\n+    protected void checkCanAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        if (!principal.isAdministrator() && !principal.isMemberOf(RetentionConstants.RECORD_MANAGER_GROUP_NAME)) {\n+            if (!session.hasPermission(document.getRef(), SecurityConstants.MAKE_RECORD)\n+                    || !session.hasPermission(document.getRef(), SecurityConstants.SET_RETENTION))\n+                throw new NuxeoException(\"User is not authorized to attach retention rule\", SC_FORBIDDEN);\n+        }\n+        if (!rule.isEnabled()) {\n+            throw new NuxeoException(String.format(\"Rule is disabled\"));\n+        }\n+        if (!rule.isDocTypeAccepted(document.getType())) {\n+            throw new NuxeoException(\"Rule does not accept this document type\");\n+        }\n+        if (document.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            throw new NuxeoException(\"Document is already a record\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean canAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        try {\n+            checkCanAttachRule(document, rule, session);\n+            return true;\n+        } catch (NuxeoException e) {\n+            log.info(\"Cannot attach rule {} on document {}\", () -> rule.getDocument().getPathAsString(),\n+                    document::getPathAsString);\n+            return false;\n+        }\n+    }\n+\n+    public void executeRuleBeginActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getBeginActions(), session);\n+        }\n+    }\n+\n+    public void executeRuleEndActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getEndActions(), session);\n+        }\n+    }\n+\n+    protected void executeRuleActions(DocumentModel doc, List<String> actionIds, CoreSession session) {\n+        if (actionIds != null) {\n+            AutomationService automationService = Framework.getService(AutomationService.class);\n+            for (String operationId : actionIds) {\n+                log.debug(\"Executing {} action on {}\", () -> operationId, doc::getPathAsString);\n+                // Do not lock document if already locked, and unlock if already unlocked (triggers an error)\n+                // Also, if it's time to delete, unlock it first, etc.\n+                // (more generally, be ready to handle specific operations and context)\n+                switch (operationId) {\n+                case LockDocument.ID:\n+                    if (doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+\n+                case UnlockDocument.ID:\n+                    if (!doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+\n+                case DeleteDocument.ID:\n+                case TrashDocument.ID:\n+                    if (doc.isLocked()) {\n+                        session.removeLock(doc.getRef());\n+                        doc = session.getDocument(doc.getRef());\n+                    }\n+                    break;\n+                }\n+                OperationContext context = getExecutionContext(doc, session);\n+                try {\n+                    automationService.run(context, operationId);\n+                } catch (OperationException e) {\n+                    throw new NuxeoException(\"Error running operation: \" + operationId, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected OperationContext getExecutionContext(DocumentModel doc, CoreSession session) {\n+        OperationContext context = new OperationContext(session);\n+        context.put(\"document\", doc);\n+        context.setCommit(false); // no session save at end\n+        context.setInput(doc);\n+        return context;\n+    }\n+\n+    @Override\n+    public void evalRules(Map<String, Set<String>> docsToCheckAndEvents) {\n+        if (docsToCheckAndEvents.isEmpty()) {\n+            return;\n+        }\n+        RuleEvaluationWorker work = new RuleEvaluationWorker(docsToCheckAndEvents);\n+        Framework.getService(WorkManager.class).schedule(work, WorkManager.Scheduling.ENQUEUE);\n+    }\n+\n+    protected ELActionContext initActionContext(DocumentModel doc, CoreSession session) {\n+        ELActionContext ctx = new ELActionContext(new ExpressionContext(), new ExpressionFactoryImpl());\n+        ctx.setCurrentPrincipal(session.getPrincipal());\n+        doc.detach(true);\n+        ctx.setCurrentDocument(doc);\n+        return ctx;\n+    }\n+\n+    protected Boolean evaluateConditionExpression(ELActionContext ctx, String expression) {\n+        Calendar now = Calendar.getInstance();\n+        if (StringUtils.isEmpty(expression)) {\n+            return true;\n+        }\n+        ctx.putLocalVariable(\"currentDate\", now);\n+        return ctx.checkCondition(expression);\n+    }\n+\n+    @Override\n+    public void evalExpressionEventBasedRules(Record record, Set<String> events, CoreSession session) {\n+        if (record == null) {\n+            return; // nothing to do\n+        }\n+        RetentionRule rule = record.getRule(session);\n+        if (rule == null) {\n+            return; // nothing to do\n+        }\n+        if (!rule.isEventBased()) {\n+            log.trace(\"Record is not event-based\");\n+            return;\n+        }\n+        log.debug(\"Evaluating event-based rules for record {}\", () -> record.getDocument().getPathAsString());\n+        if (record.isRetentionExpired()) {\n+            // retention expired, nothing to do\n+            log.debug(\"Evaluating event-based found retention expired\");\n+            proceedRetentionExpired(record, session);\n+            return;\n+\n+        }\n+        String startingPointEvent = rule.getStartingPointEvent();\n+        if (StringUtils.isBlank(startingPointEvent)) {\n+            log.warn(\"Evaluating event-based rules  on record {} found no event specified\",\n+                    () -> record.getDocument().getPathAsString());\n+            return;\n+        }\n+        if (events.contains(startingPointEvent)) {\n+            ELActionContext actionContext = initActionContext(record.getDocument(), session);\n+            String expression = rule.getStartingPointExpression();\n+            Boolean startNow = evaluateConditionExpression(actionContext, expression);\n+            if (startNow) {\n+                session.setRetainUntil(record.getDocument().getRef(), rule.getRetainUntilDateFromNow(), null);\n+                log.debug(\"Evaluating event-based rules: expression {} matched on event {}\", startingPointEvent);\n+            } else {\n+                log.debug(\"Evaluating event-based rules: expression {} did not match on event {}\", expression,\n+                        startingPointEvent);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void proceedRetentionExpired(Record record, CoreSession session) {\n+        executeRuleEndActions(record, session);\n+    }\n+\n+    protected List<String> acceptedEvents;\n+\n+    @Override\n+    public List<String> getAcceptedEvents() {\n+        if (acceptedEvents == null) {\n+            synchronized (this) {\n+                if (acceptedEvents == null) {\n+                    DirectoryService directoryService = Framework.getService(DirectoryService.class);\n+                    Directory dir = directoryService.getDirectory(RetentionConstants.EVENTS_DIRECTORY_NAME);\n+                    try (Session session = dir.getSession()) {\n+                        Map<String, Serializable> filter = new HashMap<>();\n+                        filter.put(RetentionConstants.OBSOLETE_FIELD_ID, Long.valueOf(0));\n+                        List<String> evts = session.getProjection(filter, session.getIdField());\n+                        if (evts.isEmpty()) {\n+                            log.trace(\"Empty accepted events, not chaching anything\");\n+                            return evts;", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2MjIyMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368062220", "bodyText": "catching actually", "author": "efge", "createdAt": "2020-01-17T17:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTgzMzQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2Mjc0Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365862743", "bodyText": "new ArrayList<String>(); -> new ArrayList<>();", "author": "RSalem07", "createdAt": "2020-01-13T15:23:58Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed #{link {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    protected Date dateToCheck;\n+\n+    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {\n+        this.docsToCheckAndEvents = docsToCheckAndEvents;\n+        List<String> docs = new ArrayList<String>();", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2NDU2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365864566", "bodyText": "i am wondering if we can find ourself with race condition when populating this map -> perhaps should we use the ConcurrentHashMap", "author": "RSalem07", "createdAt": "2020-01-13T15:27:10Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed #{link {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected Map<String, Set<String>> docsToCheckAndEvents;\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNTkxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368315911", "bodyText": "No need, Work construction and evaluation is always single-threaded.", "author": "efge", "createdAt": "2020-01-19T19:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2NDU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2NDg4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365864886", "bodyText": "it seems unused", "author": "RSalem07", "createdAt": "2020-01-13T15:27:49Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed #{link {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    protected Date dateToCheck;\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2NzQ3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365867478", "bodyText": "Framework.getService(RetentionManager.class) can be extract outer the for loop", "author": "RSalem07", "createdAt": "2020-01-13T15:32:29Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed #{link {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    protected Date dateToCheck;\n+\n+    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {\n+        this.docsToCheckAndEvents = docsToCheckAndEvents;\n+        List<String> docs = new ArrayList<String>();\n+        docs.addAll(docsToCheckAndEvents.keySet());\n+        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);\n+    }\n+\n+    @Override\n+    public String getTitle() {\n+        return TITLE;\n+    }\n+\n+    @Override\n+    public String getCategory() {\n+        return CATEGORY;\n+    }\n+\n+    @Override\n+    public void work() {\n+        openSystemSession();\n+        for (String string : docIds) {\n+            DocumentModel doc = null;\n+            try {\n+                doc = session.getDocument(new IdRef(string));\n+            } catch (DocumentNotFoundException e) {\n+                // this is executed post commit so the document could have been modified to start retention and removed\n+                // in the same transaction\n+                log.warn(\"Document impacted by retention no longer exists {}\", string);\n+                continue;\n+\n+            }\n+            Record record = doc.getAdapter(Record.class);\n+            if (record == null) {\n+                log.warn(\"Document should be impacted by retention but is no longer a Record: {}\", string);\n+                continue;\n+            }\n+            Framework.getService(RetentionManager.class)\n+                     .evalExpressionEventBasedRules(record, docsToCheckAndEvents.get(string), session);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2ODAxMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365868010", "bodyText": "can be replaced by session.exists as below\n           if (!session.exists(new IdRef(docId))) {\n                // this is executed post commit so the document could have been modified to start retention and removed\n                // in the same transaction\n                log.warn(\"Document impacted by retention no longer exists {}\", docId);\n                continue;\n            }", "author": "RSalem07", "createdAt": "2020-01-13T15:33:27Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed #{link {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    protected Date dateToCheck;\n+\n+    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {\n+        this.docsToCheckAndEvents = docsToCheckAndEvents;\n+        List<String> docs = new ArrayList<String>();\n+        docs.addAll(docsToCheckAndEvents.keySet());\n+        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);\n+    }\n+\n+    @Override\n+    public String getTitle() {\n+        return TITLE;\n+    }\n+\n+    @Override\n+    public String getCategory() {\n+        return CATEGORY;\n+    }\n+\n+    @Override\n+    public void work() {\n+        openSystemSession();\n+        for (String string : docIds) {\n+            DocumentModel doc = null;\n+            try {\n+                doc = session.getDocument(new IdRef(string));\n+            } catch (DocumentNotFoundException e) {\n+                // this is executed post commit so the document could have been modified to start retention and removed\n+                // in the same transaction\n+                log.warn(\"Document impacted by retention no longer exists {}\", string);\n+                continue;\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNjA3Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368316073", "bodyText": "But we need to do session.getDocument just afterwards anyway.", "author": "efge", "createdAt": "2020-01-19T19:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg2ODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3MTUwNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365871507", "bodyText": "not need for PlatformFeature as its imported by AutomationFeature", "author": "RSalem07", "createdAt": "2020-01-13T15:39:51Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.ecm.platform.test.PlatformFeature;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ PlatformFeature.class, TransactionalFeature.class, AutomationFeature.class })", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3ODE0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365878148", "bodyText": "i am wondering if we replace the whole method by a Builder to avoid passing 0 values or an empty list ...\n    protected class RetentionRuleBuilder {\n\n        protected DocumentModel documentModel;\n\n        protected RetentionRule rule;\n\n        protected RetentionRuleBuilder() {\n            DocumentModel doc = session.createDocumentModel(\"/RetentionRules\", \"testRule\", \"RetentionRule\");\n            rule = doc.getAdapter(RetentionRule.class);\n        }\n\n        RetentionRuleBuilder durationYears(long years) {\n            rule.setDurationYears(years);\n            return this;\n        }\n\n    }\n....", "author": "RSalem07", "createdAt": "2020-01-13T15:51:31Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.ecm.platform.test.PlatformFeature;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ PlatformFeature.class, TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-vocabularies.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-content-template.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-service-framework.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-listeners.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-operations.xml\")\n+public class RetentionTestCase {\n+\n+    @Inject\n+    protected RetentionManager service;\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    protected DocumentModel file;\n+\n+    @Before\n+    public void setup() {\n+        file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file = session.saveDocument(file);\n+    }\n+\n+    protected void assertStillUnderRetentionAfter(DocumentModel doc, RetentionRule rule, int timeoutMillis)\n+            throws InterruptedException {\n+        doc = service.attachRule(doc, rule, session);\n+        assertTrue(doc.isRecord());\n+\n+        awaitRetentionExpiration(1_000);\n+\n+        doc = session.getDocument(doc.getRef());\n+\n+        // it is still under retention and has a retention date\n+        assertTrue(session.isUnderRetentionOrLegalHold(doc.getRef()));\n+        assertNotNull(session.getRetainUntil(doc.getRef()));\n+    }\n+\n+    protected void awaitRetentionExpiration(long millis) throws InterruptedException {\n+        // wait a bit more than retention period to pass retention expiration date\n+        coreFeature.waitForAsyncCompletion();\n+        Thread.sleep(millis);\n+        // trigger manually instead of waiting for scheduler\n+        new RetentionExpiredFinderListener().handleEvent(null);\n+        assertTrue(\"Bulk action didn't finish\", bulkService.await(Duration.ofSeconds(60)));\n+        coreFeature.waitForAsyncCompletion();\n+    }\n+\n+    protected RetentionRule createRuleWithActions(RetentionRule.ApplicationPolicy policy,\n+            StartingPointPolicy startingPointPolicy, List<String> docTypes, String startingPointEventId,\n+            String startingPointExpression, String matadataXPath, long years, long months, long days,\n+            long durationMillis, List<String> beginActions, List<String> endActions) {\n+        DocumentModel doc = session.createDocumentModel(\"/RetentionRules\", \"testRule\", \"RetentionRule\");\n+        RetentionRule rule = doc.getAdapter(RetentionRule.class);\n+        rule.setDurationYears(years);\n+        rule.setDurationMonths(months);\n+        rule.setDurationDays(days);\n+        rule.setApplicationPolicy(policy);\n+        rule.setStartingPointPolicy(startingPointPolicy);\n+        rule.setDocTypes(docTypes);\n+        rule.setStartingPointEvent(startingPointEventId);\n+        rule.setStartingPointExpression(startingPointExpression);\n+        rule.setMetadataXpath(matadataXPath);\n+        rule.setDurationMillis(durationMillis);\n+        rule.setBeginActions(beginActions);\n+        rule.setEndActions(endActions);\n+        doc = session.createDocument(doc);\n+        return session.saveDocument(rule.getDocument()).getAdapter(RetentionRule.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNjU3OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368316578", "bodyText": "It's ok for tests", "author": "efge", "createdAt": "2020-01-19T19:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3ODE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg3OTQ2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365879467", "bodyText": "wdyt if we add a control / assertion on the message exception", "author": "RSalem07", "createdAt": "2020-01-13T15:53:46Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionAdapters.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ CoreFeature.class })\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+public class TestRetentionAdapters {\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Test\n+    public void testRecordAdapterRetainDate() {\n+        DocumentModel file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file.addFacet(RetentionConstants.RECORD_FACET);\n+        file = session.saveDocument(file);\n+\n+        Record record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+\n+        session.makeRecord(file.getRef());\n+        session.setRetainUntil(file.getRef(), CoreSession.RETAIN_UNTIL_INDETERMINATE, null);\n+        file = session.getDocument(file.getRef());\n+\n+        record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+\n+        Calendar retainUntil = Calendar.getInstance();\n+        retainUntil.add(Calendar.HOUR, -1);\n+        session.setRetainUntil(file.getRef(), retainUntil, null);\n+        file = session.getDocument(file.getRef());\n+        record = file.getAdapter(Record.class);\n+\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertTrue(record.isRetentionExpired());\n+\n+        retainUntil = Calendar.getInstance();\n+        retainUntil.add(Calendar.HOUR, 2);\n+        session.setRetainUntil(file.getRef(), retainUntil, null);\n+        file = session.getDocument(file.getRef());\n+        record = file.getAdapter(Record.class);\n+\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+    }\n+\n+    @Test\n+    public void testRecordAdapterPolicy() {\n+        DocumentModel ruleDoc = session.createDocumentModel(\"/\", \"RetentionRule\", \"RetentionRule\");\n+        RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+        rule.setStartingPointPolicy(RetentionRule.StartingPointPolicy.IMMEDIATE);\n+        rule.setApplicationPolicy(RetentionRule.ApplicationPolicy.AUTO);\n+        ruleDoc = session.createDocument(ruleDoc);\n+        ruleDoc = session.saveDocument(ruleDoc);\n+        rule = ruleDoc.getAdapter(RetentionRule.class);\n+\n+        assertTrue(rule.isAuto());\n+        assertFalse(rule.isManual());\n+        rule.setApplicationPolicy(RetentionRule.ApplicationPolicy.MANUAL);\n+        assertFalse(rule.isAuto());\n+        assertTrue(rule.isManual());\n+\n+        assertTrue(rule.isImmediate());\n+        assertFalse(rule.isAfterDely());\n+        assertFalse(rule.isEventBased());\n+        assertFalse(rule.isMetadataBased());\n+\n+        rule.setStartingPointPolicy(RetentionRule.StartingPointPolicy.AFTER_DELAY);\n+        assertFalse(rule.isImmediate());\n+        assertTrue(rule.isAfterDely());\n+        assertFalse(rule.isEventBased());\n+        assertFalse(rule.isMetadataBased());\n+\n+        rule.setStartingPointPolicy(RetentionRule.StartingPointPolicy.EVENT_BASED);\n+        assertFalse(rule.isImmediate());\n+        assertFalse(rule.isAfterDely());\n+        assertTrue(rule.isEventBased());\n+        assertFalse(rule.isMetadataBased());\n+\n+        rule.setStartingPointPolicy(RetentionRule.StartingPointPolicy.METADATA_BASED);\n+        assertFalse(rule.isImmediate());\n+        assertFalse(rule.isAfterDely());\n+        assertFalse(rule.isEventBased());\n+        assertTrue(rule.isMetadataBased());\n+    }\n+\n+    @Test\n+    public void testMetadataXPathValidity() {\n+        DocumentModel ruleDoc = session.createDocumentModel(\"/\", \"RetentionRule\", \"RetentionRule\");\n+        RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+        rule.setStartingPointPolicy(RetentionRule.StartingPointPolicy.IMMEDIATE);\n+        rule.setApplicationPolicy(RetentionRule.ApplicationPolicy.MANUAL);\n+        ruleDoc = session.createDocument(ruleDoc);\n+        ruleDoc = session.saveDocument(ruleDoc);\n+        rule = ruleDoc.getAdapter(RetentionRule.class);\n+\n+        try {\n+            rule.setMetadataXpath(\"dc:title\");\n+            fail(\"Metatada xpath should be of type Date\");\n+        } catch (IllegalArgumentException e) {\n+            // expected", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MTAzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365881035", "bodyText": "can be replaced by 1_000 and i think the L litteral is not needed here (awaitRetentionExpiration takes a primitif type), i used awaitRetentionExpiration(1_000); and the code compile", "author": "RSalem07", "createdAt": "2020-01-13T15:56:23Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    public static Log log = LogFactory.getLog(TestRetentionManager.class);\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    @Test\n+    public void testRuleOnlyFile() throws InterruptedException {\n+        DocumentModel workspace = session.createDocumentModel(\"/\", \"workspace\", \"Workspace\");\n+        workspace = session.createDocument(workspace);\n+        workspace = session.saveDocument(workspace);\n+        try {\n+            service.attachRule(workspace, createManualImmediateRuleMillis(100L), session);\n+            fail(\"Should not accept workspace document\");\n+        } catch (NuxeoException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void test1DayManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 0L, 1L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1MonthManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 1L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1YearManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 1L, 0L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void testManualImmediateRuleWithActions() throws InterruptedException {\n+        RetentionRule testRule = createImmediateRuleMillis(RetentionRule.ApplicationPolicy.MANUAL, 100L,\n+                null, Arrays.asList(\"Document.Trash\"));\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(session.isRecord(file.getRef()));\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNjczMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368316733", "bodyText": "Removing useless L, but 1000 is readable enough as it is.", "author": "efge", "createdAt": "2020-01-19T19:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MTAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MTI0Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365881242", "bodyText": "same as above ;)", "author": "RSalem07", "createdAt": "2020-01-13T15:56:44Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    public static Log log = LogFactory.getLog(TestRetentionManager.class);\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    @Test\n+    public void testRuleOnlyFile() throws InterruptedException {\n+        DocumentModel workspace = session.createDocumentModel(\"/\", \"workspace\", \"Workspace\");\n+        workspace = session.createDocument(workspace);\n+        workspace = session.saveDocument(workspace);\n+        try {\n+            service.attachRule(workspace, createManualImmediateRuleMillis(100L), session);\n+            fail(\"Should not accept workspace document\");\n+        } catch (NuxeoException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void test1DayManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 0L, 1L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1MonthManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 1L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1YearManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 1L, 0L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void testManualImmediateRuleWithActions() throws InterruptedException {\n+        RetentionRule testRule = createImmediateRuleMillis(RetentionRule.ApplicationPolicy.MANUAL, 100L,\n+                null, Arrays.asList(\"Document.Trash\"));\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(session.isRecord(file.getRef()));\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore and trashed\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(file.isTrashed());\n+    }\n+\n+    @Test\n+    public void testManualImmediateRule() throws InterruptedException {\n+        RetentionRule testRule = createManualImmediateRuleMillis(100L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertFalse(file.isLocked());\n+\n+        awaitRetentionExpiration(1000L);\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MjEzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365882130", "bodyText": "awaitRetentionExpiration(500L); -> awaitRetentionExpiration(500); for the three last use", "author": "RSalem07", "createdAt": "2020-01-13T15:58:15Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    public static Log log = LogFactory.getLog(TestRetentionManager.class);\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    @Test\n+    public void testRuleOnlyFile() throws InterruptedException {\n+        DocumentModel workspace = session.createDocumentModel(\"/\", \"workspace\", \"Workspace\");\n+        workspace = session.createDocument(workspace);\n+        workspace = session.saveDocument(workspace);\n+        try {\n+            service.attachRule(workspace, createManualImmediateRuleMillis(100L), session);\n+            fail(\"Should not accept workspace document\");\n+        } catch (NuxeoException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void test1DayManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 0L, 1L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1MonthManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 1L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1YearManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 1L, 0L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void testManualImmediateRuleWithActions() throws InterruptedException {\n+        RetentionRule testRule = createImmediateRuleMillis(RetentionRule.ApplicationPolicy.MANUAL, 100L,\n+                null, Arrays.asList(\"Document.Trash\"));\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(session.isRecord(file.getRef()));\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore and trashed\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(file.isTrashed());\n+    }\n+\n+    @Test\n+    public void testManualImmediateRule() throws InterruptedException {\n+        RetentionRule testRule = createManualImmediateRuleMillis(100L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertFalse(file.isLocked());\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+    }\n+\n+    @Test\n+    public void testManualDocumentMovedToFolderRule() throws InterruptedException {\n+\n+        RetentionRule testRule = createManualEventBasedRuleMillis(DocumentEventTypes.DOCUMENT_MOVED,\n+                \"document.getPathAsString().startsWith('/testFolder')\", 1000L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        Record record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        awaitRetentionExpiration(500L);\n+\n+        file = session.getDocument(file.getRef());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"testFolder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        folder = session.saveDocument(folder);\n+\n+        file = session.move(file.getRef(), folder.getRef(), null);\n+\n+        awaitRetentionExpiration(500L);\n+\n+        record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(500L);\n+", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MjMzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365882333", "bodyText": "awaitRetentionExpiration(1000L); -> awaitRetentionExpiration(1_000);", "author": "RSalem07", "createdAt": "2020-01-13T15:58:35Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    public static Log log = LogFactory.getLog(TestRetentionManager.class);\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    @Test\n+    public void testRuleOnlyFile() throws InterruptedException {\n+        DocumentModel workspace = session.createDocumentModel(\"/\", \"workspace\", \"Workspace\");\n+        workspace = session.createDocument(workspace);\n+        workspace = session.saveDocument(workspace);\n+        try {\n+            service.attachRule(workspace, createManualImmediateRuleMillis(100L), session);\n+            fail(\"Should not accept workspace document\");\n+        } catch (NuxeoException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void test1DayManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 0L, 1L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1MonthManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 1L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1YearManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 1L, 0L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void testManualImmediateRuleWithActions() throws InterruptedException {\n+        RetentionRule testRule = createImmediateRuleMillis(RetentionRule.ApplicationPolicy.MANUAL, 100L,\n+                null, Arrays.asList(\"Document.Trash\"));\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(session.isRecord(file.getRef()));\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore and trashed\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(file.isTrashed());\n+    }\n+\n+    @Test\n+    public void testManualImmediateRule() throws InterruptedException {\n+        RetentionRule testRule = createManualImmediateRuleMillis(100L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertFalse(file.isLocked());\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+    }\n+\n+    @Test\n+    public void testManualDocumentMovedToFolderRule() throws InterruptedException {\n+\n+        RetentionRule testRule = createManualEventBasedRuleMillis(DocumentEventTypes.DOCUMENT_MOVED,\n+                \"document.getPathAsString().startsWith('/testFolder')\", 1000L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        Record record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        awaitRetentionExpiration(500L);\n+\n+        file = session.getDocument(file.getRef());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"testFolder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        folder = session.saveDocument(folder);\n+\n+        file = session.move(file.getRef(), folder.getRef(), null);\n+\n+        awaitRetentionExpiration(500L);\n+\n+        record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(500L);\n+\n+        file = session.getDocument(file.getRef());\n+        record = file.getAdapter(Record.class);\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(record.isRetentionExpired());\n+    }\n+\n+    @Test\n+    public void testManualMetadataBasedRule() throws InterruptedException {\n+        RetentionRule testRule = createManualMetadataBasedRuleMillis(\"dc:expired\", 1000L);\n+        Calendar haldSecond = Calendar.getInstance();\n+        haldSecond.add(Calendar.MILLISECOND, 500);\n+        file.setPropertyValue(\"dc:expired\", haldSecond);\n+        file = session.saveDocument(file);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        Record record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MjQ4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365882486", "bodyText": "same as above", "author": "RSalem07", "createdAt": "2020-01-13T15:58:52Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    public static Log log = LogFactory.getLog(TestRetentionManager.class);\n+\n+    @Inject\n+    protected AutomationService automationService;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    @Test\n+    public void testRuleOnlyFile() throws InterruptedException {\n+        DocumentModel workspace = session.createDocumentModel(\"/\", \"workspace\", \"Workspace\");\n+        workspace = session.createDocument(workspace);\n+        workspace = session.saveDocument(workspace);\n+        try {\n+            service.attachRule(workspace, createManualImmediateRuleMillis(100L), session);\n+            fail(\"Should not accept workspace document\");\n+        } catch (NuxeoException e) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void test1DayManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 0L, 1L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1MonthManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 0L, 1L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void test1YearManualImmediateRuleRunningRetention() throws InterruptedException {\n+        assertStillUnderRetentionAfter(file, createRuleWithActions(RetentionRule.ApplicationPolicy.MANUAL,\n+                RetentionRule.StartingPointPolicy.IMMEDIATE, null, null, null, null, 1L, 0L, 0L, 0L, null, null), 1_000);\n+    }\n+\n+    @Test\n+    public void testManualImmediateRuleWithActions() throws InterruptedException {\n+        RetentionRule testRule = createImmediateRuleMillis(RetentionRule.ApplicationPolicy.MANUAL, 100L,\n+                null, Arrays.asList(\"Document.Trash\"));\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(session.isRecord(file.getRef()));\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore and trashed\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(file.isTrashed());\n+    }\n+\n+    @Test\n+    public void testManualImmediateRule() throws InterruptedException {\n+        RetentionRule testRule = createManualImmediateRuleMillis(100L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertFalse(file.isLocked());\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+    }\n+\n+    @Test\n+    public void testManualDocumentMovedToFolderRule() throws InterruptedException {\n+\n+        RetentionRule testRule = createManualEventBasedRuleMillis(DocumentEventTypes.DOCUMENT_MOVED,\n+                \"document.getPathAsString().startsWith('/testFolder')\", 1000L);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        Record record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        awaitRetentionExpiration(500L);\n+\n+        file = session.getDocument(file.getRef());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        record = file.getAdapter(Record.class);\n+        assertTrue(record.isRetainUntilInderterminate());\n+\n+        DocumentModel folder = session.createDocumentModel(\"/\", \"testFolder\", \"Folder\");\n+        folder = session.createDocument(folder);\n+        folder = session.saveDocument(folder);\n+\n+        file = session.move(file.getRef(), folder.getRef(), null);\n+\n+        awaitRetentionExpiration(500L);\n+\n+        record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(500L);\n+\n+        file = session.getDocument(file.getRef());\n+        record = file.getAdapter(Record.class);\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(record.isRetentionExpired());\n+    }\n+\n+    @Test\n+    public void testManualMetadataBasedRule() throws InterruptedException {\n+        RetentionRule testRule = createManualMetadataBasedRuleMillis(\"dc:expired\", 1000L);\n+        Calendar haldSecond = Calendar.getInstance();\n+        haldSecond.add(Calendar.MILLISECOND, 500);\n+        file.setPropertyValue(\"dc:expired\", haldSecond);\n+        file = session.saveDocument(file);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        Record record = file.getAdapter(Record.class);\n+        assertFalse(record.isRetainUntilInderterminate());\n+        assertFalse(record.isRetentionExpired());\n+        assertTrue(session.isUnderRetentionOrLegalHold(file.getRef()));\n+\n+        awaitRetentionExpiration(1000L);\n+\n+        file = session.getDocument(file.getRef());\n+        record = file.getAdapter(Record.class);\n+\n+        // it has no retention anymore\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+        assertTrue(record.isRetentionExpired());\n+    }\n+\n+    @Test\n+    public void testManualPastMetadataBasedRule() throws InterruptedException {\n+        RetentionRule testRule = createManualMetadataBasedRuleMillis(\"dc:expired\", 500L);\n+        Calendar haldSecond = Calendar.getInstance();\n+        haldSecond.add(Calendar.MILLISECOND, -1000);\n+        file.setPropertyValue(\"dc:expired\", haldSecond);\n+        file = session.saveDocument(file);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+    }\n+\n+    @Test\n+    public void testRetainUntilDateSaved() throws InterruptedException {\n+        RetentionRule testRule = createManualImmediateRuleMillis(100L);\n+        file = service.attachRule(file, testRule, session);\n+        Calendar original = file.getRetainUntil();\n+        awaitRetentionExpiration(1000L);\n+        Record record = session.getDocument(file.getRef()).getAdapter(Record.class);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4MzEzMg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365883132", "bodyText": "throw LoginException is not needed on these three tests methods", "author": "RSalem07", "createdAt": "2020-01-13T16:00:02Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import javax.security.auth.login.LoginException;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            file = service.attachRule(file, createManualImmediateRuleMillis(5000L), userSession);\n+            assertTrue(userSession.isUnderRetentionOrLegalHold(file.getRef()));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAuthorizedToSetLegalHold() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowLegalHold = new ACE(\"user\", RetentionConstants.MANAGE_LEGAL_HOLD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowLegalHold });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            userSession.makeRecord(file.getRef());\n+            userSession.setLegalHold(file.getRef(), true, null);\n+        }\n+    }", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4Mzc3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365883770", "bodyText": "can be replaced by the use of acp.getOrCreateACL()...\n        ACP acp = new ACPImpl();\n        acp.getOrCreateACL().add(new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true))\n        file.setACP(acp, true);\n        file = session.saveDocument(file);", "author": "RSalem07", "createdAt": "2020-01-13T16:01:07Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import javax.security.auth.login.LoginException;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            file = service.attachRule(file, createManualImmediateRuleMillis(5000L), userSession);\n+            assertTrue(userSession.isUnderRetentionOrLegalHold(file.getRef()));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAuthorizedToSetLegalHold() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowLegalHold = new ACE(\"user\", RetentionConstants.MANAGE_LEGAL_HOLD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowLegalHold });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNzA2Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368317062", "bodyText": "Leaving for later cleanup in the numerous tests having similar code.", "author": "efge", "createdAt": "2020-01-19T19:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4Mzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4NDI0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365884248", "bodyText": "the literal L is not needed as the method createManualImmediateRuleMillis  takes a primitif type", "author": "RSalem07", "createdAt": "2020-01-13T16:01:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import javax.security.auth.login.LoginException;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            file = service.attachRule(file, createManualImmediateRuleMillis(5000L), userSession);\n+            assertTrue(userSession.isUnderRetentionOrLegalHold(file.getRef()));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAuthorizedToSetLegalHold() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowLegalHold = new ACE(\"user\", RetentionConstants.MANAGE_LEGAL_HOLD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowLegalHold });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            userSession.makeRecord(file.getRef());\n+            userSession.setLegalHold(file.getRef(), true, null);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAllowedToAttachTwoRules() {\n+        RetentionRule rr = createManualImmediateRuleMillis(100L);\n+        file = service.attachRule(file, rr, session);", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg4NDk3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365884970", "bodyText": "wdyt if we add an assertion about the message type or the exception status NuxeoException#statusCode", "author": "RSalem07", "createdAt": "2020-01-13T16:03:11Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import javax.security.auth.login.LoginException;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() throws LoginException {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100L), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            // Expected\n+            assertEquals(javax.servlet.http.HttpServletResponse.SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            file = service.attachRule(file, createManualImmediateRuleMillis(5000L), userSession);\n+            assertTrue(userSession.isUnderRetentionOrLegalHold(file.getRef()));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAuthorizedToSetLegalHold() throws LoginException {\n+        ACP acp = new ACPImpl();\n+        ACE allowLegalHold = new ACE(\"user\", RetentionConstants.MANAGE_LEGAL_HOLD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowLegalHold });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            userSession.makeRecord(file.getRef());\n+            userSession.setLegalHold(file.getRef(), true, null);\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAllowedToAttachTwoRules() {\n+        RetentionRule rr = createManualImmediateRuleMillis(100L);\n+        file = service.attachRule(file, rr, session);\n+        try  {\n+            service.attachRule(file, rr, session);\n+            fail(\"Should not be abe to attach rule twice\");\n+        } catch (NuxeoException e) {\n+            // Expected", "originalCommit": "791d48515fd8b4c1c9feb5ab4ece3788fcf56fc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MTQ0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365891444", "bodyText": "createManualMetadataBasedRuleMillis(\"dc:expired\", 500L); -> reateManualMetadataBasedRuleMillis(\"dc:expired\", 500); and .... -1000); ->  -1_000);", "author": "RSalem07", "createdAt": "2020-01-13T16:15:20Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -203,6 +203,18 @@ public void testManualPastMetadataBasedRule() throws InterruptedException {\n         assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n     }\n \n+    @Test\n+    public void testManualNullMetadataBasedRule() throws InterruptedException {\n+        RetentionRule testRule = createManualMetadataBasedRuleMillis(\"dc:expired\", 500L);\n+        Calendar haldSecond = Calendar.getInstance();\n+        haldSecond.add(Calendar.MILLISECOND, -1000);", "originalCommit": "36690648b12930c0505c606bf2fc0cdd385bd190", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MTYzOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365891639", "bodyText": "throw InterruptedException is not needed", "author": "RSalem07", "createdAt": "2020-01-13T16:15:39Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -203,6 +203,18 @@ public void testManualPastMetadataBasedRule() throws InterruptedException {\n         assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n     }\n \n+    @Test\n+    public void testManualNullMetadataBasedRule() throws InterruptedException {\n+        RetentionRule testRule = createManualMetadataBasedRuleMillis(\"dc:expired\", 500L);\n+        Calendar haldSecond = Calendar.getInstance();\n+        haldSecond.add(Calendar.MILLISECOND, -1000);\n+        file = session.saveDocument(file);\n+\n+        file = service.attachRule(file, testRule, session);\n+        assertTrue(file.isRecord());\n+        assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+    }\n+\n     @Test\n     public void testRetainUntilDateSaved() throws InterruptedException {\n         RetentionRule testRule = createManualImmediateRuleMillis(100L);", "originalCommit": "36690648b12930c0505c606bf2fc0cdd385bd190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxNzM4OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r368317388", "bodyText": "It is actually, due to call to awaitRetentionExpiration that throws it.", "author": "efge", "createdAt": "2020-01-19T19:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTg5MjAyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3655#discussion_r365892027", "bodyText": "throws InterruptedException is not needed", "author": "RSalem07", "createdAt": "2020-01-13T16:16:22Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -203,6 +203,18 @@ public void testManualPastMetadataBasedRule() throws InterruptedException {\n         assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));", "originalCommit": "36690648b12930c0505c606bf2fc0cdd385bd190", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31c6a0dbe66dbc5e744d03e9fb344545bee45c68", "url": "https://github.com/nuxeo/nuxeo/commit/31c6a0dbe66dbc5e744d03e9fb344545bee45c68", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-15T17:56:06Z", "type": "forcePushed"}, {"oid": "90337b0d51ce9211b05acff2cb4c519fea72a747", "url": "https://github.com/nuxeo/nuxeo/commit/90337b0d51ce9211b05acff2cb4c519fea72a747", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-16T17:24:35Z", "type": "forcePushed"}, {"oid": "bc622a16859c5c4fcf804bea8c1cea5fac1e972e", "url": "https://github.com/nuxeo/nuxeo/commit/bc622a16859c5c4fcf804bea8c1cea5fac1e972e", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-19T20:36:49Z", "type": "forcePushed"}, {"oid": "a720bb8ebb5bd9ac8e08e28916a1249792599ef5", "url": "https://github.com/nuxeo/nuxeo/commit/a720bb8ebb5bd9ac8e08e28916a1249792599ef5", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-20T13:35:45Z", "type": "forcePushed"}, {"oid": "8ef67b7641733ef3158b1cb9583bfbd832d4fe3c", "url": "https://github.com/nuxeo/nuxeo/commit/8ef67b7641733ef3158b1cb9583bfbd832d4fe3c", "message": "NXP-27692: add retention addon", "committedDate": "2020-01-20T13:49:27Z", "type": "commit"}, {"oid": "6b3fbf88a6e775894bd1340fc75a1f81dcd6a897", "url": "https://github.com/nuxeo/nuxeo/commit/6b3fbf88a6e775894bd1340fc75a1f81dcd6a897", "message": "NXP-28135: null or past metadata retention just turn doc into record", "committedDate": "2020-01-20T13:49:31Z", "type": "commit"}, {"oid": "44a5061ec27423e027afc62fa4227d072cc8f8c6", "url": "https://github.com/nuxeo/nuxeo/commit/44a5061ec27423e027afc62fa4227d072cc8f8c6", "message": "NXP-28367: fix label and style of retention actions", "committedDate": "2020-01-20T13:49:36Z", "type": "commit"}, {"oid": "92e2278b1d4da4296cb32184050304c3a8e9451b", "url": "https://github.com/nuxeo/nuxeo/commit/92e2278b1d4da4296cb32184050304c3a8e9451b", "message": "NXP-28367: fix retention layouts", "committedDate": "2020-01-20T13:49:42Z", "type": "commit"}, {"oid": "2d533b2c809dabfdcaa89a72ba7c37caacef2c00", "url": "https://github.com/nuxeo/nuxeo/commit/2d533b2c809dabfdcaa89a72ba7c37caacef2c00", "message": "NXP-28367: blacklist RetentionRule and RetentionRules for import in Web UI", "committedDate": "2020-01-20T13:49:47Z", "type": "commit"}, {"oid": "13d68069636846e405debfa1be6fc1a3124d0276", "url": "https://github.com/nuxeo/nuxeo/commit/13d68069636846e405debfa1be6fc1a3124d0276", "message": "NXP-28367: optimize doc type and schema fetching", "committedDate": "2020-01-20T13:49:52Z", "type": "commit"}, {"oid": "f919e2d685b2301fbd5ae827e386a87bc8e52362", "url": "https://github.com/nuxeo/nuxeo/commit/f919e2d685b2301fbd5ae827e386a87bc8e52362", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-20T13:49:57Z", "type": "commit"}, {"oid": "f919e2d685b2301fbd5ae827e386a87bc8e52362", "url": "https://github.com/nuxeo/nuxeo/commit/f919e2d685b2301fbd5ae827e386a87bc8e52362", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-01-20T13:49:57Z", "type": "forcePushed"}]}