{"pr_number": 4237, "pr_title": "Fix nxp 29237 nuxeo drive mongodb", "pr_createdAt": "2020-08-04T16:16:17Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/4237", "timeline": [{"oid": "1b4f518d795eb3588bd694e9f156f631611da792", "url": "https://github.com/nuxeo/nuxeo/commit/1b4f518d795eb3588bd694e9f156f631611da792", "message": "NXP-29237: temp", "committedDate": "2020-08-04T16:17:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NzY2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465187665", "bodyText": "MongoDB audit feature for Nuxeo Drive. is enough I think", "author": "ataillefer", "createdAt": "2020-08-04T16:45:32Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/test/java/org/nuxeo/drive/test/MongoDBAuditFeature.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.test;\n+\n+import org.nuxeo.drive.mongodb.TestMongoDBAuditChangeFinder;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.platform.audit.AuditFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+\n+/**\n+ * MongoDB audit feature for nuxeo drive. This Feature is necessary for the deployment annotations to be taken into\n+ * account by {@link TestMongoDBAuditChangeFinder}.", "originalCommit": "1b4f518d795eb3588bd694e9f156f631611da792", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MDU3Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465690573", "bodyText": "since we changed the name how about only keeping the since ?", "author": "NourNuxeo", "createdAt": "2020-08-05T12:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NzY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyMjMyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465722327", "bodyText": "Yes, its name is explicit \ud83d\udc4d", "author": "ataillefer", "createdAt": "2020-08-05T13:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE4NzY2NQ=="}], "type": "inlineReview"}, {"oid": "a6598fab4520575af5e180ecaf1fa1facd56b86f", "url": "https://github.com/nuxeo/nuxeo/commit/a6598fab4520575af5e180ecaf1fa1facd56b86f", "message": "NXP-29237: temp", "committedDate": "2020-08-04T18:08:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNTc0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465635741", "bodyText": "Simply\nFramework.getService(AuditLogger.class).await(duration.toMillis(), TimeUnit.MILLISECONDS)\n\nSonar should warn you about\n\nReplace this if-then-else statement by a single return statement.", "author": "ataillefer", "createdAt": "2020-08-05T10:43:33Z", "path": "modules/platform/nuxeo-platform-audit/nuxeo-platform-audit-mongodb/src/test/java/org/nuxeo/mongodb/audit/MongoDBAuditFeature.java", "diffHunk": "@@ -43,6 +45,18 @@\n @Features({ MongoDBFeature.class, CoreFeature.class })\n public class MongoDBAuditFeature implements RunnerFeature {\n \n+    @Override\n+    public void initialize(FeaturesRunner runner) {\n+        runner.getFeature(TransactionalFeature.class).addWaiter(duration -> {\n+            // Wait for audit completion\n+            long before = System.currentTimeMillis();\n+            if (!Framework.getService(AuditLogger.class).await(duration.toMillis(), TimeUnit.MILLISECONDS)) {\n+                return false;\n+            }\n+            return true;", "originalCommit": "a6598fab4520575af5e180ecaf1fa1facd56b86f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTYzNTk5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465635997", "bodyText": "Unused variable.\nSonar should warn you about\n\nRemove this unused \"before\" local variable.", "author": "ataillefer", "createdAt": "2020-08-05T10:44:05Z", "path": "modules/platform/nuxeo-platform-audit/nuxeo-platform-audit-mongodb/src/test/java/org/nuxeo/mongodb/audit/MongoDBAuditFeature.java", "diffHunk": "@@ -43,6 +45,18 @@\n @Features({ MongoDBFeature.class, CoreFeature.class })\n public class MongoDBAuditFeature implements RunnerFeature {\n \n+    @Override\n+    public void initialize(FeaturesRunner runner) {\n+        runner.getFeature(TransactionalFeature.class).addWaiter(duration -> {\n+            // Wait for audit completion\n+            long before = System.currentTimeMillis();", "originalCommit": "a6598fab4520575af5e180ecaf1fa1facd56b86f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0MDUyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465640523", "bodyText": "You don't need this since it will now be handled by the MongoDBAuditFeature.\nThen, of course, we'll have to validate that this change in MongoDBAuditFeature doesn't break other tests using it.\nThough the T&P will validate it, you can already run locally the 6 tests using it in nuxeo-audit-storage-directory and nuxeo-platform-audit-mongodb.", "author": "ataillefer", "createdAt": "2020-08-05T10:53:30Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/test/java/org/nuxeo/drive/test/NuxeoDriveMongoDBAuditFeature.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.test;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.nuxeo.drive.mongodb.TestMongoDBAuditChangeFinder;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.platform.audit.AuditFeature;\n+import org.nuxeo.ecm.platform.audit.api.AuditLogger;\n+import org.nuxeo.mongodb.audit.MongoDBAuditFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * MongoDB audit feature for nuxeo drive. This Feature is necessary for the deployment annotations to be taken into\n+ * account by {@link TestMongoDBAuditChangeFinder}.\n+ *\n+ * @since 11.2\n+ */\n+@Features({ AutomationFeature.class, AuditFeature.class, MongoDBAuditFeature.class })\n+@Deploy(\"org.nuxeo.drive.mongodb\")\n+public class NuxeoDriveMongoDBAuditFeature implements RunnerFeature {\n+\n+    @Override\n+    public void initialize(FeaturesRunner runner) {\n+        runner.getFeature(TransactionalFeature.class)\n+              .addWaiter(duration -> {\n+                  // Wait for audit completion\n+                  return Framework.getService(AuditLogger.class).await(duration.toMillis(), TimeUnit.MILLISECONDS);\n+              });\n+    }", "originalCommit": "a6598fab4520575af5e180ecaf1fa1facd56b86f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcxMzAwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465713003", "bodyText": "org.nuxeo.audit.storage.impl.TestRestorationFromDirectoryAuditStorage is affected by the initialize overriding:\nThe test takes 400 seconds instead of 40 and gives a lot of errors while trying and retrying. Sometimes eclipse marks it as failing sometimes succeeding. Here the exceptions I get:\n2020-08-05 15:05:50,208 [audit/writerPool-00,in:1,inCheckpoint:0,out:0,lastRead:1596632627011,lastTimer:1596632626942,wm:209273831663206400,loop:504,record] WARN  [AbstractBatchComputation] Computation: audit/writer fails to process batch of 1 records, last record: audit-audit-00:+79366700662784, retrying ...\ncom.mongodb.MongoBulkWriteException: Bulk write operation error on server localhost:27017. Write errors: [BulkWriteError{index=0, code=11000, message='E11000 duplicate key error collection: unittests.audit index: _id_ dup key: { : 7 }', details={}}]. \n\tat com.mongodb.connection.BulkWriteBatchCombiner.getError(BulkWriteBatchCombiner.java:173) ~[mongo-java-driver-3.12.1.jar:?]\n\nOther tests are fine", "author": "NourNuxeo", "createdAt": "2020-08-05T13:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0MDUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTcyNzcwNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465727704", "bodyText": "OK, strange. So you can keep th code in the NuxeoDriveMongoDBAuditFeature.\nHoping the Drive tests will pass.", "author": "ataillefer", "createdAt": "2020-08-05T13:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0MDUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc0MTM1MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r465741351", "bodyText": "~ Not yet \ud83d\ude2d ~\nNow drive tests do pass \ud83d\udcaa", "author": "NourNuxeo", "createdAt": "2020-08-05T13:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY0MDUyMw=="}], "type": "inlineReview"}, {"oid": "078f245fdc88bb38188b8c402b2796a4b6313ebe", "url": "https://github.com/nuxeo/nuxeo/commit/078f245fdc88bb38188b8c402b2796a4b6313ebe", "message": "NXP-29237: temp", "committedDate": "2020-08-06T19:14:57Z", "type": "forcePushed"}, {"oid": "cb4c9237f6dbf32a22eff52066cf22b6b801e48a", "url": "https://github.com/nuxeo/nuxeo/commit/cb4c9237f6dbf32a22eff52066cf22b6b801e48a", "message": "NXP-29237: temp", "committedDate": "2020-08-06T20:47:30Z", "type": "forcePushed"}, {"oid": "6bd356127bd4aff277c016ceaa5a60329c2f1894", "url": "https://github.com/nuxeo/nuxeo/commit/6bd356127bd4aff277c016ceaa5a60329c2f1894", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-06T20:53:41Z", "type": "forcePushed"}, {"oid": "7851b498bcfa847d9ee4b47e36e811f855848750", "url": "https://github.com/nuxeo/nuxeo/commit/7851b498bcfa847d9ee4b47e36e811f855848750", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-06T21:02:31Z", "type": "forcePushed"}, {"oid": "fde17e0b5319eb9b2dfede88dc17456fca52baeb", "url": "https://github.com/nuxeo/nuxeo/commit/fde17e0b5319eb9b2dfede88dc17456fca52baeb", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-06T22:28:33Z", "type": "forcePushed"}, {"oid": "27ff2a3dc340e4ffdb01bb5a9fdb4087d9157318", "url": "https://github.com/nuxeo/nuxeo/commit/27ff2a3dc340e4ffdb01bb5a9fdb4087d9157318", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T08:41:58Z", "type": "forcePushed"}, {"oid": "b17d67632ab4fa46a59d56aab9eb12d6257a8752", "url": "https://github.com/nuxeo/nuxeo/commit/b17d67632ab4fa46a59d56aab9eb12d6257a8752", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T10:18:37Z", "type": "forcePushed"}, {"oid": "f500620fea6b4bc6c4bec1cec4da1e0e5fb910c7", "url": "https://github.com/nuxeo/nuxeo/commit/f500620fea6b4bc6c4bec1cec4da1e0e5fb910c7", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T14:23:01Z", "type": "forcePushed"}, {"oid": "80bb943544605089b983d921abbe36940f2ee7eb", "url": "https://github.com/nuxeo/nuxeo/commit/80bb943544605089b983d921abbe36940f2ee7eb", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T14:49:16Z", "type": "forcePushed"}, {"oid": "5fc50ef00b7a5f847be1c0fb92d379ea5da40a57", "url": "https://github.com/nuxeo/nuxeo/commit/5fc50ef00b7a5f847be1c0fb92d379ea5da40a57", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T15:21:34Z", "type": "forcePushed"}, {"oid": "4547e7a8c9f9c0ffa4fe7a81d79957b5ec51a846", "url": "https://github.com/nuxeo/nuxeo/commit/4547e7a8c9f9c0ffa4fe7a81d79957b5ec51a846", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-07T21:20:40Z", "type": "forcePushed"}, {"oid": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "url": "https://github.com/nuxeo/nuxeo/commit/52302effea7e5c470ed301f2b68d5b516fcf0e96", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-10T08:13:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4Mjg0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468582844", "bodyText": "An estimated count can be better here.", "author": "kevinleturc", "createdAt": "2020-08-11T13:34:34Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4OTI3Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468589276", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    var sorts = List.of(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n          \n          \n            \n                    var order = Sorts.orderBy(sorts);\n          \n          \n            \n                    var sort = Sorts.orderBy(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));", "author": "kevinleturc", "createdAt": "2020-08-11T13:43:41Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);\n+        // first conditional filter\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            // We open an $or array here in case the next conditional filter is needed as it's this or that\n+            queryBuilder.append(\"{ \\\"$or\\\" : [\");\n+            queryBuilder.append(getCurrentRootFilteringClause(activeRoots.getPaths(), params) + \"\\n\");\n+        }\n+        // second conditional filter\n+        if (collectionSyncRootMemberIds != null && !collectionSyncRootMemberIds.isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            queryBuilder.append(getCollectionSyncRootFilteringClause(collectionSyncRootMemberIds, params) + \"\\n\");\n+        }\n+        // if the first conditional filter was set, then an $or array has been opened and needs to be closed\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\"]}\\n\");\n+        }\n+        if(queryEnd == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryEnd.json\")) {\n+                queryEnd = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query end template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryEnd);\n+\n+        Bson filter = auditService.buildFilter(queryBuilder.toString(), params);\n+        var sorts = List.of(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n+        var order = Sorts.orderBy(sorts);", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTcxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468649711", "bodyText": "FindIterable#spliterator is backed by the default method in Iterable which leverages Iterable#iterator, or in this case MongoIterableImpl#iterator which returns a MongoCursor which needs to be closed. You have an example of what to do in MongoDBConnection.\nOtherwise, you could use the MongoDB API there, something like:\nList<LogEntry> entries = auditCollection.find(filter).sort(order).map(MongoDBAuditEntryReader::read).into(new ArrayList<>());", "author": "kevinleturc", "createdAt": "2020-08-11T15:01:17Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);\n+        // first conditional filter\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            // We open an $or array here in case the next conditional filter is needed as it's this or that\n+            queryBuilder.append(\"{ \\\"$or\\\" : [\");\n+            queryBuilder.append(getCurrentRootFilteringClause(activeRoots.getPaths(), params) + \"\\n\");\n+        }\n+        // second conditional filter\n+        if (collectionSyncRootMemberIds != null && !collectionSyncRootMemberIds.isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            queryBuilder.append(getCollectionSyncRootFilteringClause(collectionSyncRootMemberIds, params) + \"\\n\");\n+        }\n+        // if the first conditional filter was set, then an $or array has been opened and needs to be closed\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\"]}\\n\");\n+        }\n+        if(queryEnd == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryEnd.json\")) {\n+                queryEnd = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query end template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryEnd);\n+\n+        Bson filter = auditService.buildFilter(queryBuilder.toString(), params);\n+        var sorts = List.of(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n+        var order = Sorts.orderBy(sorts);\n+        FindIterable<Document> iterable = auditCollection.find(filter).sort(order);\n+        List<LogEntry> entries = StreamSupport.stream(iterable.spliterator(), false)", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468666427", "bodyText": "This could be expressed in the MongoDB query?", "author": "kevinleturc", "createdAt": "2020-08-11T15:23:52Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);\n+        // first conditional filter\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            // We open an $or array here in case the next conditional filter is needed as it's this or that\n+            queryBuilder.append(\"{ \\\"$or\\\" : [\");\n+            queryBuilder.append(getCurrentRootFilteringClause(activeRoots.getPaths(), params) + \"\\n\");\n+        }\n+        // second conditional filter\n+        if (collectionSyncRootMemberIds != null && !collectionSyncRootMemberIds.isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            queryBuilder.append(getCollectionSyncRootFilteringClause(collectionSyncRootMemberIds, params) + \"\\n\");\n+        }\n+        // if the first conditional filter was set, then an $or array has been opened and needs to be closed\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\"]}\\n\");\n+        }\n+        if(queryEnd == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryEnd.json\")) {\n+                queryEnd = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query end template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryEnd);\n+\n+        Bson filter = auditService.buildFilter(queryBuilder.toString(), params);\n+        var sorts = List.of(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n+        var order = Sorts.orderBy(sorts);\n+        FindIterable<Document> iterable = auditCollection.find(filter).sort(order);\n+        List<LogEntry> entries = StreamSupport.stream(iterable.spliterator(), false)\n+                                              .map(MongoDBAuditEntryReader::read)\n+                                              .collect(Collectors.toList());\n+\n+        // Post filter the output to remove (un)registration that are unrelated\n+        // to the current user.\n+        List<LogEntry> postFilteredEntries = new ArrayList<>();\n+        String principalName = session.getPrincipal().getName();\n+        for (LogEntry entry : entries) {\n+            ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(\"impactedUserName\");\n+            if (impactedUserInfo != null && !principalName.equals(impactedUserInfo.getValue(String.class))) {\n+                // ignore event that only impact other users\n+                continue;\n+            }\n+            log.debug(\"Change detected: {}\", entry);\n+            postFilteredEntries.add(entry);\n+        }\n+        return postFilteredEntries;", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk1MjA0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468952045", "bodyText": "This could be expressed in the MongoDB query?\n\nCould be yes, that's not an option we had in JPA but here if the underlying structure of impactedUserName can be queried directly (to be checked) it'd be more efficient.", "author": "efge", "createdAt": "2020-08-12T01:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4MjgzNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470582836", "bodyText": "To be continued", "author": "NourNuxeo", "createdAt": "2020-08-14T12:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIxNzQ1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472217455", "bodyText": "It seems to me we never fall into continue here because the impactedUserName property does not exist.\nNone of the existing tests covers this post filtering aspect which seems not to be working to me.\nI added this to the mongo query (using the extended.user property in place of impactedUserName) and it seems test get broken when filtering really works.", "author": "NourNuxeo", "createdAt": "2020-08-18T13:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIyNDUxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472224518", "bodyText": "This was added by 6b8901e but indeed I can't find any use", "author": "efge", "createdAt": "2020-08-18T14:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIyNjIwNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472226204", "bodyText": "How about removing this whole chunk of code since it has never been of use and since nobody complained about wrong behavior?", "author": "NourNuxeo", "createdAt": "2020-08-18T14:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIzODMxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472238311", "bodyText": "Ok with me. @kevinleturc ?", "author": "efge", "createdAt": "2020-08-18T14:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI2MzAzNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472263034", "bodyText": "Ok too \ud83d\udc4d", "author": "kevinleturc", "createdAt": "2020-08-18T14:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxMDEyOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472410129", "bodyText": "Seems it's set here: https://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/listener/NuxeoDriveFileSystemDeletionListener.java#L249", "author": "troger", "createdAt": "2020-08-18T18:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0NjI2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472446266", "bodyText": "Indeed and it's set by https://github.com/nuxeo/nuxeo/blob/11ef171/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/NuxeoDriveManagerImpl.java#L313 and fireEvent is called with a specific userName.\nSo I retract my comment and we should keep this code.", "author": "efge", "createdAt": "2020-08-18T20:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgxOTIxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r472819218", "bodyText": "Instead of keeping the code, how about adding this filter at the end of the root AND\n        Bson isUser = and(or(exists(\"extended.impactedUser\", false),\n                eq(\"extended.impactedUser\", session.getPrincipal().getName())));\n\n        // Build final filter\n        Bson filter = and(sessionRepository, or(isGeneral, isDrive), idRange, isUser);\n\n(Pushed this to launch some early T&Ps)", "author": "NourNuxeo", "createdAt": "2020-08-19T07:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk5MzI4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r473993286", "bodyText": "While working more on the subject I have noticed my debug queries are always printed twice. I think this is why:\nhttps://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/AuditChangeFinder.java#L101-L116\nWe query once the log entries and if there is a change in the drive roots, we update them and do the query again.\nThe check done after the first query could be done as a simple query rather than post filtering the log entries.\nWdyt ?", "author": "NourNuxeo", "createdAt": "2020-08-20T13:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0OTAxNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474149014", "bodyText": "What do you mean exactly?", "author": "ataillefer", "createdAt": "2020-08-20T17:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxODg0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475518845", "bodyText": "https://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/AuditChangeFinder.java#L69 queries the logs.\nIf it finds NuxeoDrive events it invalidates the roots cache and does the same query again:\nhttps://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/AuditChangeFinder.java#L101-L117\nI have factorized things so invalidation stays unique but instead of doing that for loop I proposed making a mongo query. The change has been rejected because doing an extra query has been deemed too expensive while doing the same query twice just relies on costless cached results (efge will be able to explain more). However If you want to see, I have stashed it.", "author": "NourNuxeo", "createdAt": "2020-08-24T10:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NjQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3MDE5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468670190", "bodyText": "Is it really needed? AuditFeature already declare a waiter for this.", "author": "kevinleturc", "createdAt": "2020-08-11T15:28:53Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/test/java/org/nuxeo/drive/test/NuxeoDriveMongoDBAuditFeature.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.test;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.platform.audit.AuditFeature;\n+import org.nuxeo.ecm.platform.audit.api.AuditLogger;\n+import org.nuxeo.mongodb.audit.MongoDBAuditFeature;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/** @since 11.2 */\n+@Features({ AutomationFeature.class, AuditFeature.class, MongoDBAuditFeature.class })\n+@Deploy(\"org.nuxeo.drive.mongodb\")\n+public class NuxeoDriveMongoDBAuditFeature implements RunnerFeature {\n+\n+    @Override\n+    public void initialize(FeaturesRunner runner) {\n+        runner.getFeature(TransactionalFeature.class).addWaiter(duration -> {\n+            return Framework.getService(AuditLogger.class).await(duration.toMillis(), TimeUnit.MILLISECONDS);\n+        });\n+    }", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0ODM4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468948380", "bodyText": "Space before (", "author": "efge", "createdAt": "2020-08-12T01:09:22Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0ODc0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468948749", "bodyText": "Space before (", "author": "efge", "createdAt": "2020-08-12T01:10:31Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);\n+        // first conditional filter\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            // We open an $or array here in case the next conditional filter is needed as it's this or that\n+            queryBuilder.append(\"{ \\\"$or\\\" : [\");\n+            queryBuilder.append(getCurrentRootFilteringClause(activeRoots.getPaths(), params) + \"\\n\");\n+        }\n+        // second conditional filter\n+        if (collectionSyncRootMemberIds != null && !collectionSyncRootMemberIds.isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            queryBuilder.append(getCollectionSyncRootFilteringClause(collectionSyncRootMemberIds, params) + \"\\n\");\n+        }\n+        // if the first conditional filter was set, then an $or array has been opened and needs to be closed\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\"]}\\n\");\n+        }\n+        if(queryEnd == null) {", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0ODkxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468948916", "bodyText": "Then rethrow wrapped in NuxeoException, we can't do anything more.", "author": "efge", "createdAt": "2020-08-12T01:11:11Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU4MjU1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470582556", "bodyText": "solved with #4237 (comment)", "author": "NourNuxeo", "createdAt": "2020-08-14T12:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk0ODkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk1MDE0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468950144", "bodyText": "I would very much prefer if we had only one file with the whole JSON query and in the middle a special pattern, maybe like __BODY__ (or something else that makes sense), that gets replaced by what we want. It will make the file much more readable.\nBut actually after reading more of the code all this string replacement to in the end get a BSON object is really unnatural, it would be better to directly create a BSON object (using new Document() etc). This applies also to methods getCurrentRootFilteringClause and getCollectionSyncRootFilteringClause which should work at the BSON/Document level, not strings.", "author": "efge", "createdAt": "2020-08-12T01:15:31Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODk1MTYzMA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r468951630", "bodyText": "If this has to be backported to 10.10 you'd bette not use var, or be ready to update the backport for Java 8.", "author": "efge", "createdAt": "2020-08-12T01:21:11Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.FindIterable;\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.2\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        AuditReader auditService = Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        var entries = (List<LogEntry>) auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                List<LogEntry> allEntries = (List<LogEntry>) auditService.nativeQuery(\"\", 1, 1);\n+                if (!allEntries.isEmpty()) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+        StringBuilder queryBuilder = new StringBuilder();\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(\"repositoryId\", session.getRepositoryName());\n+        params.put(\"lowerBound\", lowerBound);\n+        params.put(\"upperBound\", upperBound);\n+\n+        if(queryStart == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryStart.json\")) {\n+                queryStart = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query start template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryStart);\n+        // first conditional filter\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            // We open an $or array here in case the next conditional filter is needed as it's this or that\n+            queryBuilder.append(\"{ \\\"$or\\\" : [\");\n+            queryBuilder.append(getCurrentRootFilteringClause(activeRoots.getPaths(), params) + \"\\n\");\n+        }\n+        // second conditional filter\n+        if (collectionSyncRootMemberIds != null && !collectionSyncRootMemberIds.isEmpty()) {\n+            queryBuilder.append(\",\\n\");\n+            queryBuilder.append(getCollectionSyncRootFilteringClause(collectionSyncRootMemberIds, params) + \"\\n\");\n+        }\n+        // if the first conditional filter was set, then an $or array has been opened and needs to be closed\n+        if (!activeRoots.getPaths().isEmpty()) {\n+            queryBuilder.append(\"]}\\n\");\n+        }\n+        if(queryEnd == null) {\n+            try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"OSGI-INF/queryEnd.json\")) {\n+                queryEnd = IOUtils.toString(is, \"UTF-8\");\n+            } catch (IOException e) {\n+                log.error(\"couldn't read query end template\", e);\n+            }\n+        }\n+        queryBuilder.append(queryEnd);\n+\n+        Bson filter = auditService.buildFilter(queryBuilder.toString(), params);\n+        var sorts = List.of(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));", "originalCommit": "52302effea7e5c470ed301f2b68d5b516fcf0e96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67a2153b1b837a78f418bde29457d474dde89877", "url": "https://github.com/nuxeo/nuxeo/commit/67a2153b1b837a78f418bde29457d474dde89877", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T11:55:15Z", "type": "forcePushed"}, {"oid": "8ad1a94dc3de0abe9577a22d937d659e19c38e20", "url": "https://github.com/nuxeo/nuxeo/commit/8ad1a94dc3de0abe9577a22d937d659e19c38e20", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T11:58:19Z", "type": "forcePushed"}, {"oid": "47da88d7b9a2e38857165dae6fd3755b65d7ca53", "url": "https://github.com/nuxeo/nuxeo/commit/47da88d7b9a2e38857165dae6fd3755b65d7ca53", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T12:06:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDU5Njg0Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470596843", "bodyText": "This is hard to read, you can't understand what's ANDde or ORed with what. You should use intermediate variables with meaningful names to construct the global filter step by step.", "author": "efge", "createdAt": "2020-08-14T12:35:35Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        Bson filter = and(eq(\"repositoryId\", session.getRepositoryName()), or(\n+                and(or(and(eq(\"category\", \"eventDocumentCategory\"),\n+                        in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                                \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                                \"documentUnlocked\", \"documentUntrashed\")),\n+                        and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                                ne(\"docLifeCycle\", \"deleted\"))),\n+                        or(regex(\"docPath\", getRootsRegex(activeRoots.getPaths())),\n+                                in(\"docUUID\", collectionSyncRootMemberIds))),\n+                and(eq(\"category\", \"NuxeoDrive\"), ne(\"eventId\", \"rootUnregistered\"))), gt(\"_id\", lowerBound),\n+                lte(\"_id\", upperBound));", "originalCommit": "47da88d7b9a2e38857165dae6fd3755b65d7ca53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a1597a4b38a681482d4a48749ea64505facab2a5", "url": "https://github.com/nuxeo/nuxeo/commit/a1597a4b38a681482d4a48749ea64505facab2a5", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T13:07:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyMzM5Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470623392", "bodyText": "Both unused.", "author": "kevinleturc", "createdAt": "2020-08-14T13:28:47Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNDk5MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470624991", "bodyText": "Format", "author": "kevinleturc", "createdAt": "2020-08-14T13:31:30Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson inRootPath = regex(\"docPath\", getRootsRegex(activeRoots.getPaths()));\n+        Bson inRootId = in(\"docUUID\", collectionSyncRootMemberIds);\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson isGeneral = and(or(documentEvent, lifeCycleEvent), or(inRootPath, inRootId));\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral,\n+                isDrive), idRange);", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNjQ1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470626455", "bodyText": "The query evaluation should be done in a lazy way:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    BsonDocument bsonDocument = filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry());\n          \n          \n            \n                    log.debug(\"Query on MongoDB-Audit: {}\", bsonDocument.toJson());\n          \n          \n            \n                    log.debug(\"Query on MongoDB-Audit: {}\", () -> filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry()).toJson());", "author": "kevinleturc", "createdAt": "2020-08-14T13:34:13Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson inRootPath = regex(\"docPath\", getRootsRegex(activeRoots.getPaths()));\n+        Bson inRootId = in(\"docUUID\", collectionSyncRootMemberIds);\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson isGeneral = and(or(documentEvent, lifeCycleEvent), or(inRootPath, inRootId));\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral,\n+                isDrive), idRange);\n+\n+        BsonDocument bsonDocument = filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry());\n+        log.debug(\"Query on MongoDB-Audit: {}\", bsonDocument.toJson());", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1MjAyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470652025", "bodyText": "Totally forgot that aspect", "author": "NourNuxeo", "createdAt": "2020-08-14T14:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyNjQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYyODU5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470628595", "bodyText": "What do you think about importing statically orderBy, ascending and descending like you do for Filters' method?", "author": "kevinleturc", "createdAt": "2020-08-14T13:37:55Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson inRootPath = regex(\"docPath\", getRootsRegex(activeRoots.getPaths()));\n+        Bson inRootId = in(\"docUUID\", collectionSyncRootMemberIds);\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson isGeneral = and(or(documentEvent, lifeCycleEvent), or(inRootPath, inRootId));\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral,\n+                isDrive), idRange);\n+\n+        BsonDocument bsonDocument = filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry());\n+        log.debug(\"Query on MongoDB-Audit: {}\", bsonDocument.toJson());\n+\n+        Bson order = Sorts.orderBy(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNDc0Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470634746", "bodyText": "If the roots is empty, I think we shouldn't append the filter otherwise it will result in something like below and I don't know what MongoDB does on such thing:\n{ \"docPath\": { \"$regex\": // } }", "author": "kevinleturc", "createdAt": "2020-08-14T13:49:05Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson inRootPath = regex(\"docPath\", getRootsRegex(activeRoots.getPaths()));\n+        Bson inRootId = in(\"docUUID\", collectionSyncRootMemberIds);\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson isGeneral = and(or(documentEvent, lifeCycleEvent), or(inRootPath, inRootId));\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral,\n+                isDrive), idRange);\n+\n+        BsonDocument bsonDocument = filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry());\n+        log.debug(\"Query on MongoDB-Audit: {}\", bsonDocument.toJson());\n+\n+        Bson order = Sorts.orderBy(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n+        List<LogEntry> entries = auditCollection.find(filter)\n+                                                .sort(order)\n+                                                .map(MongoDBAuditEntryReader::read)\n+                                                .into(new ArrayList<>());\n+\n+        // Post filter the output to remove (un)registration that are unrelated\n+        // to the current user.\n+        List<LogEntry> postFilteredEntries = new ArrayList<>();\n+        String principalName = session.getPrincipal().getName();\n+        for (LogEntry entry : entries) {\n+            ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(\"impactedUserName\");\n+            if (impactedUserInfo != null && !principalName.equals(impactedUserInfo.getValue(String.class))) {\n+                // ignore event that only impact other users\n+                continue;\n+            }\n+            log.debug(\"Change detected: {}\", entry);\n+            postFilteredEntries.add(entry);\n+        }\n+        return postFilteredEntries;\n+    }\n+\n+    protected String getRootsRegex(Set<String> roots) {\n+        if(roots.isEmpty()) {\n+            return \"\";", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY2MTQ2MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470661461", "bodyText": "+1. This can be refactored into a method that builds the whole filter for inRootPath or or(inRootPath, inRootId) actually.", "author": "efge", "createdAt": "2020-08-14T14:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNDc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY5OTk4Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470699987", "bodyText": "made it conditional now with a call to addRoots\nMade sure not to add extra useless ORs and ANDs on the way", "author": "NourNuxeo", "createdAt": "2020-08-14T15:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNTY5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470635690", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuilder rootPathClause = new StringBuilder(\"^\");\n          \n          \n            \n                    rootPathClause.append(String.join(\"|^\", roots));\n          \n          \n            \n                    return rootPathClause.toString();\n          \n          \n            \n                    return \"^\" + String.join(\"|^\", rootPathClause);\n          \n      \n    \n    \n  \n\nYou don't need the StringBuilder here. As it is a simple append (no if or loop around), the compilator will produce more or less the same byte code.\nNote: + is replaced by StringBuilder during compilation.", "author": "kevinleturc", "createdAt": "2020-08-14T13:50:44Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.BsonDocument;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+import com.mongodb.client.model.Sorts;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    protected String queryStart;\n+\n+    protected String queryEnd;\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson inRootPath = regex(\"docPath\", getRootsRegex(activeRoots.getPaths()));\n+        Bson inRootId = in(\"docUUID\", collectionSyncRootMemberIds);\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson isGeneral = and(or(documentEvent, lifeCycleEvent), or(inRootPath, inRootId));\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral,\n+                isDrive), idRange);\n+\n+        BsonDocument bsonDocument = filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry());\n+        log.debug(\"Query on MongoDB-Audit: {}\", bsonDocument.toJson());\n+\n+        Bson order = Sorts.orderBy(Sorts.ascending(\"repositoryId\"), Sorts.descending(\"eventDate\"));\n+        List<LogEntry> entries = auditCollection.find(filter)\n+                                                .sort(order)\n+                                                .map(MongoDBAuditEntryReader::read)\n+                                                .into(new ArrayList<>());\n+\n+        // Post filter the output to remove (un)registration that are unrelated\n+        // to the current user.\n+        List<LogEntry> postFilteredEntries = new ArrayList<>();\n+        String principalName = session.getPrincipal().getName();\n+        for (LogEntry entry : entries) {\n+            ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(\"impactedUserName\");\n+            if (impactedUserInfo != null && !principalName.equals(impactedUserInfo.getValue(String.class))) {\n+                // ignore event that only impact other users\n+                continue;\n+            }\n+            log.debug(\"Change detected: {}\", entry);\n+            postFilteredEntries.add(entry);\n+        }\n+        return postFilteredEntries;\n+    }\n+\n+    protected String getRootsRegex(Set<String> roots) {\n+        if(roots.isEmpty()) {\n+            return \"\";\n+        }\n+        StringBuilder rootPathClause = new StringBuilder(\"^\");\n+        rootPathClause.append(String.join(\"|^\", roots));\n+        return rootPathClause.toString();", "originalCommit": "a1597a4b38a681482d4a48749ea64505facab2a5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY1Nzc3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470657775", "bodyText": "Yes + is better. Note that in recent JDKs there are even better internal strategies than StringBuilder that are used to implement + on a fixed set of arguments.", "author": "efge", "createdAt": "2020-08-14T14:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYzNTY5MA=="}], "type": "inlineReview"}, {"oid": "a9382774e6d93fcbb7d6eb5279326695804143d3", "url": "https://github.com/nuxeo/nuxeo/commit/a9382774e6d93fcbb7d6eb5279326695804143d3", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T15:32:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxODM0MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470718340", "bodyText": "This should be clearer:\n      List<Bson> rootFilters = new ArrayList<>();\n      if (!rootPaths.isEmpty()) {\n          rootFilters.add(regex(\"docPath\", \"^\" + String.join(\"|^\", rootPaths)));\n      }\n      if (!collectionSyncRootMemberIds.isEmpty()) {\n          rootFilters.add(in(\"docUUID\", collectionSyncRootMemberIds));\n      }\n      if (rootFilters.isEmpty()) {\n          return baseFilter;\n      } else {\n          rootFilters.add(baseFilter);\n          return and(rootFilters);\n      }", "author": "efge", "createdAt": "2020-08-14T16:08:39Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.ExtendedInfo;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {\n+                    log.debug(\"Found no audit log entries matching the criterias but some exist, returning 0\");\n+                    return 0;\n+                }\n+            }\n+            log.debug(\"Found no audit log entries, returning -1\");\n+            return -1;\n+        }\n+        return entries.get(0).getId();\n+    }\n+\n+    @Override\n+    protected List<LogEntry> queryAuditEntries(CoreSession session, SynchronizationRoots activeRoots,\n+            Set<String> collectionSyncRootMemberIds, long lowerBound, long upperBound, int limit) {\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        MongoCollection<Document> auditCollection = auditService.getAuditCollection();\n+\n+        // Build intermediate filters\n+        Bson lifeCycleEvent = and(eq(\"category\", \"eventLifeCycleCategory\"), eq(\"eventId\", \"lifecycle_transition_event\"),\n+                ne(\"docLifeCycle\", \"deleted\"));\n+        Bson documentEvent = and(eq(\"category\", \"eventDocumentCategory\"),\n+                in(\"eventId\", \"documentCreated\", \"documentModified\", \"documentMoved\", \"documentCreatedByCopy\",\n+                        \"documentRestored\", \"addedToCollection\", \"documentProxyPublished\", \"documentLocked\",\n+                        \"documentUnlocked\", \"documentUntrashed\"));\n+        Bson sessionRepository = eq(\"repositoryId\", session.getRepositoryName());\n+        Bson driveCategory = eq(\"category\", \"NuxeoDrive\");\n+        Bson notRootUnregistered = ne(\"eventId\", \"rootUnregistered\");\n+        Bson inEvents = or(documentEvent, lifeCycleEvent);\n+        Bson isGeneral = addRoots(inEvents, activeRoots.getPaths(), collectionSyncRootMemberIds);\n+        Bson isDrive = and(driveCategory, notRootUnregistered);\n+        Bson idRange = and(gt(\"_id\", lowerBound), lte(\"_id\", upperBound));\n+\n+        // Build final filter\n+        Bson filter = and(sessionRepository, or(isGeneral, isDrive), idRange);\n+\n+        log.debug(\"Query on MongoDB-Audit: {}\",\n+                () -> filter.toBsonDocument(Document.class, auditCollection.getCodecRegistry()).toJson());\n+\n+        Bson order = orderBy(ascending(\"repositoryId\"), descending(\"eventDate\"));\n+        List<LogEntry> entries = auditCollection.find(filter)\n+                                                .sort(order)\n+                                                .map(MongoDBAuditEntryReader::read)\n+                                                .into(new ArrayList<>());\n+\n+        // Post filter the output to remove (un)registration that are unrelated\n+        // to the current user.\n+        List<LogEntry> postFilteredEntries = new ArrayList<>();\n+        String principalName = session.getPrincipal().getName();\n+        for (LogEntry entry : entries) {\n+            ExtendedInfo impactedUserInfo = entry.getExtendedInfos().get(\"impactedUserName\");\n+            if (impactedUserInfo != null && !principalName.equals(impactedUserInfo.getValue(String.class))) {\n+                // ignore event that only impact other users\n+                continue;\n+            }\n+            log.debug(\"Change detected: {}\", entry);\n+            postFilteredEntries.add(entry);\n+        }\n+        return postFilteredEntries;\n+    }\n+\n+    protected Bson addRoots(Bson baseFilter, Set<String> rootPaths, Set<String> collectionSyncRootMemberIds) {\n+        if (rootPaths.isEmpty() && collectionSyncRootMemberIds.isEmpty()) {\n+            return and(baseFilter);\n+        }\n+        List<Bson> rootFilters = new ArrayList<>();\n+        if (!rootPaths.isEmpty()) {\n+            rootFilters.add(regex(\"docPath\", \"^\" + String.join(\"|^\", rootPaths)));\n+        }\n+        if (!collectionSyncRootMemberIds.isEmpty()) {\n+            rootFilters.add(in(\"docUUID\", collectionSyncRootMemberIds));\n+        }\n+        if (rootFilters.size() > 1) {\n+            return and(baseFilter, or(rootFilters));\n+        }\n+        return and(baseFilter, rootFilters.get(0));", "originalCommit": "a9382774e6d93fcbb7d6eb5279326695804143d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc1OTg4NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470759884", "bodyText": "That doesn't cut the unit tests because ORs between rootFilters are missing.\noverflood erased here", "author": "NourNuxeo", "createdAt": "2020-08-14T17:31:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxODM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc2NTI3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r470765270", "bodyText": "Hm yeah I misread the original code. But it's ugly to test twice for rootPaths.isEmpty and collectionSyncRootMemberIds.isEmpty(). Just change my code a bit to do at the end:\n      return and(baseFilter, or(rootFilters));", "author": "efge", "createdAt": "2020-08-14T17:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxODM0MA=="}], "type": "inlineReview"}, {"oid": "cbb07b7746637e33b7c5d52229b41073bcf28c50", "url": "https://github.com/nuxeo/nuxeo/commit/cbb07b7746637e33b7c5d52229b41073bcf28c50", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-14T17:48:25Z", "type": "forcePushed"}, {"oid": "88966b586c65ba7916491906db1e5ff616cb101e", "url": "https://github.com/nuxeo/nuxeo/commit/88966b586c65ba7916491906db1e5ff616cb101e", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-18T15:10:43Z", "type": "forcePushed"}, {"oid": "114cce7714d85bda48b0da131e7f62dd40c95f4f", "url": "https://github.com/nuxeo/nuxeo/commit/114cce7714d85bda48b0da131e7f62dd40c95f4f", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-19T07:56:41Z", "type": "forcePushed"}, {"oid": "0bdd3e2efaf5d2daf3b06602037a6d8c7e01d9f7", "url": "https://github.com/nuxeo/nuxeo/commit/0bdd3e2efaf5d2daf3b06602037a6d8c7e01d9f7", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-20T15:04:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA1NTU5Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474055593", "bodyText": "Not sure why try/finally is needed here", "author": "efge", "createdAt": "2020-08-20T15:06:43Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,35 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        try {\n+            nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder2, session);\n+        } finally {\n+            txFeature.nextTransaction();\n+        }", "originalCommit": "0bdd3e2efaf5d2daf3b06602037a6d8c7e01d9f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA2MjE3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474062171", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<FileSystemItemChange> changes2 = getChanges(foo);\n          \n          \n            \n                    assertEquals(0, changes2.size());\n          \n          \n            \n                    assertEquals(0, getChanges(foo).size());", "author": "NourNuxeo", "createdAt": "2020-08-20T15:16:26Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,35 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        try {\n+            nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder2, session);\n+        } finally {\n+            txFeature.nextTransaction();\n+        }\n+\n+        // We need to save the lower bound id\n+        long replayFrom = lastEventLogId;\n+        List<FileSystemItemChange> changes = getChanges();\n+        assertEquals(2, changes.size());\n+\n+        // So we can query the same id range again\n+        lastEventLogId = replayFrom;\n+        NuxeoPrincipalImpl foo = new NuxeoPrincipalImpl(\"foo\");\n+        List<FileSystemItemChange> changes2 = getChanges(foo);\n+        assertEquals(0, changes2.size());", "originalCommit": "0bdd3e2efaf5d2daf3b06602037a6d8c7e01d9f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d21314cc96142e399385aea6ecdc0b115bf5525f", "url": "https://github.com/nuxeo/nuxeo/commit/d21314cc96142e399385aea6ecdc0b115bf5525f", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-20T15:24:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MTc0NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474091745", "bodyText": "I think this feature should not depend on the AuditFeature, which in fact should be called SQLAuditFeature: it deploys a JDB datasource and uses an EntityManager to perform some cleanup.\nThen, we need to put back the waiter registration:\n    @Override\n    public void initialize(FeaturesRunner runner) {\n        runner.getFeature(TransactionalFeature.class).addWaiter(duration -> {\n            return Framework.getService(AuditLogger.class).await(duration.toMillis(), TimeUnit.MILLISECONDS);\n        });\n    }\n\nDo you agree @kevinleturc?", "author": "ataillefer", "createdAt": "2020-08-20T15:54:16Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/test/java/org/nuxeo/drive/test/NuxeoDriveMongoDBAuditFeature.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.test;\n+\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.platform.audit.AuditFeature;\n+import org.nuxeo.mongodb.audit.MongoDBAuditFeature;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.RunnerFeature;\n+\n+/** @since 11.3 */\n+@Features({ AutomationFeature.class, AuditFeature.class, MongoDBAuditFeature.class })\n+@Deploy(\"org.nuxeo.drive.mongodb\")\n+public class NuxeoDriveMongoDBAuditFeature implements RunnerFeature {\n+", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NzE1NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474147154", "bodyText": "Sure \ud83d\udc4d", "author": "kevinleturc", "createdAt": "2020-08-20T17:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA5MTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0ODU2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474148567", "bodyText": "This doesn't seem the right test, indeed, commenting https://github.com/nuxeo/nuxeo/pull/4237/files#diff-d4ec341d2c4e8ec9ac9ff5775f2f006bR152 doesn't fail the test.\nIn fact, independently from the MongoDB implementation, commenting the related lines in the AuditChangeFinder, see https://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/AuditChangeFinder.java#L350, don't fail the test when run through TestSQLAuditChangeFinder.\nThe test should involve a sync root unregistration or something related, see NuxeoDriveFileSystemDeletionListener.", "author": "ataillefer", "createdAt": "2020-08-20T17:17:12Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,31 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder2, session);\n+        txFeature.nextTransaction();\n+\n+        // We need to save the lower bound id...\n+        long replayFrom = lastEventLogId;\n+        List<FileSystemItemChange> changes = getChanges();\n+        assertEquals(2, changes.size());\n+\n+        // ...So we can query the same id range again\n+        lastEventLogId = replayFrom;\n+        NuxeoPrincipalImpl foo = new NuxeoPrincipalImpl(\"foo\");\n+        assertEquals(0, getChanges(foo).size());\n+\n+        // Now we check the found logs:\n+        FileSystemItemChange change = changes.get(0);\n+        assertEquals(folder2.getId(), change.getDocUuid());\n+        assertEquals(\"rootRegistered\", change.getEventId());\n+        change = changes.get(1);\n+        assertEquals(folder2.getId(), change.getDocUuid());\n+        assertEquals(\"documentCreated\", change.getEventId());", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNTg3Mg==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475535872", "bodyText": "I have definitely missed something because I was pretty sure it worked in my local tests but well...obviously...\nhowever I'm not sure I understood your point.\nThe mongo filter linked (https://github.com/nuxeo/nuxeo/pull/4237/files#diff-d4ec341d2c4e8ec9ac9ff5775f2f006bR152)\nis not equivalent to the SQL clause: https://github.com/nuxeo/nuxeo/blob/master/modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/main/java/org/nuxeo/drive/service/impl/AuditChangeFinder.java#L350\nThe mongo filter that corresponds to it is https://github.com/nuxeo/nuxeo/pull/4237/files#diff-d4ec341d2c4e8ec9ac9ff5775f2f006bR157-R158 and is always \"ANDed\" at the end of the top-level filter array: https://github.com/nuxeo/nuxeo/pull/4237/files#diff-d4ec341d2c4e8ec9ac9ff5775f2f006bR161\nAlso when registering a root, NuxeoDrive events are fired as well, not only when deleting.", "author": "NourNuxeo", "createdAt": "2020-08-24T11:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0ODU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU0MDEwNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475540105", "bodyText": "Replaying the tests it seems to work correctly:\n\"foo\" can't see the logs where impacted user is \"Administrator\" in both SQL and MongoDB tests\nif I do the same query as foo with Administrator, I see the logs again, so it means the bounds are correct.\nThere is still a big issue with the clustering test going on. And it seems to me the mongo driver has a problem with dates and timestamps handling.", "author": "NourNuxeo", "createdAt": "2020-08-24T11:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0ODU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcwMzg3Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475703877", "bodyText": "Sorry about the links, they must've moved with the PR evolving.\nThe point is, whatever implementation you take, SQL or Mongo, remove the code that handles the impacted user name in the XXChangeFinder and the test will still pass => the test doesn't test what it should.\nBy debugging, you'll see that the reason why the foo user gets an empty list of changes is not what you think, it's because it simply doesn't have access to folder2 (no Read ACL). Indeed, the audit entry relevant to this root registration by Administrator is returned by the audit query for foo but is then filtered in AuditChangeFinder by the following code:\n                if (!session.exists(docRef)) {\n                    log.debug(\"Document {} ({}) doesn't exist, not adding entry to the change summary.\",\n                            entry::getDocPath, () -> docRef);\n                    // Deleted or non accessible documents are mapped to\n                    // deleted file system items in a separate event: no need to\n                    // try to propagate this event.\n                    continue;\n                }\n\nLook at when the impactedUserName property is added to the virtual audit event by NuxeoDriveFileSystemDeletionListener.", "author": "ataillefer", "createdAt": "2020-08-24T15:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0ODU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1NzA4OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474157089", "bodyText": "This shouldn't be removed, otherwise clustering isn't enabled for this test suite.", "author": "ataillefer", "createdAt": "2020-08-20T17:32:22Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderClusteringEnabledTestSuite.java", "diffHunk": "@@ -34,14 +34,12 @@\n import org.nuxeo.drive.service.FileSystemItemChange;\n import org.nuxeo.ecm.core.api.DocumentModel;\n import org.nuxeo.ecm.core.api.impl.blob.StringBlob;\n-import org.nuxeo.runtime.test.runner.Deploy;\n \n /**\n  * Tests the {@link FileSystemChangeFinder} on a repository with clustering enabled.\n  *\n  * @since 8.2\n  */\n-@Deploy(\"org.nuxeo.drive.core:OSGI-INF/test-nuxeodrive-clustering-enabled-repo-contrib.xml\")", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU2MTI3MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475561270", "bodyText": "Back in place.\nNow the problem is the following:\nthe query transferred by the java driver to MongoDB doesn't work consistently \ud83d\udd34\n{\"repositoryId\": {\"$in\": [\"test\"]}, \"logDate\": {\"$lt\": {\"$date\": 1598265956818}}}\n\nThe date is given in the first inconsistent way. It is inconsistent because:\nThe date sent is given by the formula: now - 2 * clusteringDelay as milliseconds and fails \ud83d\udd34\nIf I give the date without substracting 2 * clusteringDelay as millis works from java \ud83d\udfe2 not in the shell \ud83d\udd34\nIf I give the date now - 2 * clusteringDelay as **nanos** works from java \ud83d\udfe2 not in the shell \ud83d\udd34\nIf I send the same date (now - 2 * clusteringDelay as milliseconds) in the mongo shell as an ISODate it will work \ud83d\udfe2 :\n{\"repositoryId\": {\"$in\": [\"test\"]}, \"logDate\": {\"$lt\": ISODate(\"2020-08-24T12:45:56.818556+02:00\")}}\n\nNow more inconsistency:\nI have faced the same problem with upper and lower bound:\nThe query sent by the java driver was of the form:\n{\"lowerbound\": {\"$gt\": {\"$numberLong\": \"0\"}}} \ud83d\udfe2\nThe same query copied in the mongo shell would fail \ud83d\udd34\nin the mongoShell I had to write: {\"lowerbound\": {\"$gt\": 0}} \ud83d\udfe2\nspiced up my life...", "author": "NourNuxeo", "createdAt": "2020-08-24T12:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1NzA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1ODM4NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474158384", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns the last available log id in the audit index considering events older than the last clustering\n          \n          \n            \n                 * Returns the last available log id in the audit collection considering events older than the last clustering", "author": "ataillefer", "createdAt": "2020-08-20T17:34:45Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474162007", "bodyText": "What's the semantics of this predicate?\nI think we can assume that any audit log entry has a repository id among the existing ones.", "author": "ataillefer", "createdAt": "2020-08-20T17:41:16Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1NTE0OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475555148", "bodyText": "This is my way of avoiding giving an AND() predicate with an empty array when clustering is disabled. Mongo would complain about it.\nThis is because the AuditQueryBuilder will init with an empty AND()\nSo I tell it to search all log repositories (if I guessEngineered correctly ?)\nin(LOG_REPOSITORY_ID, repositoryNames));\nmeans the field repositoryId's value is in the list of names repositoryNames.\nSo if I search all the logs that are in [\"foo\", \"bar\", \"baz\"]\nif I get a log with {\"repositoryId\": \"foo\"} I will take it, same for other entries of the repositoryNames list \"bar\" and \"baz\"", "author": "NourNuxeo", "createdAt": "2020-08-24T12:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMjQ1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475732450", "bodyText": "Oh! So it's a hack for a missing feature (no predicates) in MongoDBAuditBackend.\nMight be interesting to have a new API in MongoDBAuditBackend such as:\npublic List<LogEntry> queryLogs(OrderByList orders, long offset, protected long limit)\n\n@efge WDYT?", "author": "ataillefer", "createdAt": "2020-08-24T16:17:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2MTQ0OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475761449", "bodyText": "I'm not sure I understand what the issue is here or why we need a new API. If clustering is disabled then there is no clustering delay stuff and nothing to query about repositories.", "author": "efge", "createdAt": "2020-08-24T17:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5OTEyMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475799123", "bodyText": "If I pass an empty predicate here is what happens\ncom.mongodb.MongoQueryException: Query failed with error code 2 and error message '$and/$or/$nor must be a nonempty array' on server localhost:27017\n\tat com.mongodb.operation.FindOperation$1.call(FindOperation.java:735)\n\tat com.mongodb.operation.FindOperation$1.call(FindOperation.java:725)\n\tat com.mongodb.operation.OperationHelper.withReadConnectionSource(OperationHelper.java:463)\n\tat com.mongodb.operation.FindOperation.execute(FindOperation.java:725)\n\tat com.mongodb.operation.FindOperation.execute(FindOperation.java:89)\n\tat com.mongodb.client.internal.MongoClientDelegate$DelegateOperationExecutor.execute(MongoClientDelegate.java:196)\n\tat com.mongodb.client.internal.MongoIterableImpl.execute(MongoIterableImpl.java:143)\n\tat com.mongodb.client.internal.MongoIterableImpl.iterator(MongoIterableImpl.java:92)\n\tat com.mongodb.client.internal.MongoIterableImpl.iterator(MongoIterableImpl.java:39)\n\tat java.base/java.lang.Iterable.spliterator(Iterable.java:101)\n\tat org.nuxeo.mongodb.audit.MongoDBAuditBackend.buildLogEntries(MongoDBAuditBackend.java:371)\n\tat org.nuxeo.mongodb.audit.MongoDBAuditBackend.queryLogs(MongoDBAuditBackend.java:186)\n\tat org.nuxeo.drive.mongodb.MongoDBAuditChangeFinder.getUpperBound(MongoDBAuditChangeFinder.java:119)", "author": "NourNuxeo", "createdAt": "2020-08-24T18:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg1Njk4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475856986", "bodyText": "This is because the QueryBuilder is initialized with an AND filter and, in MongoDBAuditBackend, we always apply the filters.\nSo, currently, there's no way to query the audit logs without any predicate through a QueryBuilder.", "author": "ataillefer", "createdAt": "2020-08-24T19:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg3NzE5NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475877195", "bodyText": "So, currently, there's no way to query the audit logs without any predicate through a QueryBuilder.\n\nYes because that's never been a use case. As a quick workaround if the repositoryNames is empty let's just replace the predicate with something like gt(eventDate, new Date(0)) that should match everything and let us move forward, we'll refine it later.", "author": "efge", "createdAt": "2020-08-24T20:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjEyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474166127", "bodyText": "Have you checked the impact of such an ordered query on a huge collection?\nI'm referring to the crucial optimization that was done for the Elasticsearch change finder in the context of https://jira.nuxeo.com/browse/NXP-24232..", "author": "ataillefer", "createdAt": "2020-08-20T17:49:00Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1NTYxNg==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475555616", "bodyText": "No, I didn't think about that aspect. I need to check that thanks !", "author": "NourNuxeo", "createdAt": "2020-08-24T12:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ0ODM4Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477448387", "bodyText": "It happens the reverted index is kinda built in. This explains why one can sort or desc _id easily.\nTested it with 10 millions documents anyway and the result was instant.", "author": "NourNuxeo", "createdAt": "2020-08-26T16:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQ2OA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r474168468", "bodyText": "Sonar: Merge this if statement with the enclosing one.", "author": "ataillefer", "createdAt": "2020-08-20T17:53:11Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            long lastClusteringInvalidationDate = System.currentTimeMillis() - 2 * clusteringDelay;\n+            queryBuilder.and(Predicates.lt(LOG_LOG_DATE, lastClusteringInvalidationDate));\n+        }\n+        queryBuilder.order(OrderByExprs.desc(LOG_ID));\n+        queryBuilder.limit(1);\n+        List<LogEntry> entries = auditService.queryLogs(queryBuilder);\n+\n+        if (entries.isEmpty()) {\n+            if (clusteringDelay > -1) {\n+                // Check for existing entries without the clustering invalidation date filter to not return -1 in this\n+                // case and make sure the lower bound of the next call to NuxeoDriveManager#getChangeSummary will be >=\n+                // 0\n+                if (auditService.getAuditCollection().estimatedDocumentCount() == 0) {", "originalCommit": "d21314cc96142e399385aea6ecdc0b115bf5525f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyODUzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475528533", "bodyText": "thanks, it happens my sonar was broken and I never noticed...(the secured storage bug again)", "author": "NourNuxeo", "createdAt": "2020-08-24T11:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzMTcxMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r475531713", "bodyText": "strangely sonar is working now but this rule doesn't show (I can provoke other rules to test it works)", "author": "NourNuxeo", "createdAt": "2020-08-24T11:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQ2OA=="}], "type": "inlineReview"}, {"oid": "b4c5b57d441a31153b4d7378e1ab418305d42724", "url": "https://github.com/nuxeo/nuxeo/commit/b4c5b57d441a31153b4d7378e1ab418305d42724", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-20T23:36:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU4MDUzNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r476580534", "bodyText": "Don't forget to add back the other suites!", "author": "ataillefer", "createdAt": "2020-08-25T16:29:54Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/test/java/org/nuxeo/drive/mongodb/TestMongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Suite.SuiteClasses;\n+import org.nuxeo.drive.fixtures.AbstractChangeFinderTestCase;\n+import org.nuxeo.drive.fixtures.AuditChangeFinderClusteringEnabledTestSuite;\n+import org.nuxeo.drive.fixtures.AuditChangeFinderTestSuite;\n+import org.nuxeo.drive.fixtures.GroupChangesTestSuite;\n+import org.nuxeo.drive.test.NuxeoDriveMongoDBAuditFeature;\n+import org.nuxeo.runtime.test.runner.ContributableFeaturesRunner;\n+import org.nuxeo.runtime.test.runner.Features;\n+\n+/**\n+ * Runs the {@link AbstractChangeFinderTestCase} implementations using the {@link MongoDBAuditChangeFinder}.\n+ *\n+ * @since 11.3\n+ */\n+@RunWith(ContributableFeaturesRunner.class)\n+@Features(NuxeoDriveMongoDBAuditFeature.class)\n+@SuiteClasses({ AuditChangeFinderClusteringEnabledTestSuite.class,\n+        })", "originalCommit": "b4c5b57d441a31153b4d7378e1ab418305d42724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYwNTMyNA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r476605324", "bodyText": "Don't forget to remove or change the log level.", "author": "ataillefer", "createdAt": "2020-08-25T17:10:15Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_REPOSITORY_ID;\n+\n+import java.time.ZoneId;\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit index considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.in(LOG_REPOSITORY_ID, repositoryNames));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            ZonedDateTime lastClusteringInvalidationDate = ZonedDateTime.now()\n+                                                                        .minus(2 * clusteringDelay, ChronoUnit.MILLIS);\n+            log.error(\"preparing upperBound millis: {}\", lastClusteringInvalidationDate);", "originalCommit": "b4c5b57d441a31153b4d7378e1ab418305d42724", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "159d603bd1741b1585210e6b041ee99337cdb783", "url": "https://github.com/nuxeo/nuxeo/commit/159d603bd1741b1585210e6b041ee99337cdb783", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-25T21:19:13Z", "type": "forcePushed"}, {"oid": "75d7b9e757e80971fbe013bed3ba4cc7b8e86d10", "url": "https://github.com/nuxeo/nuxeo/commit/75d7b9e757e80971fbe013bed3ba4cc7b8e86d10", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-26T02:58:32Z", "type": "forcePushed"}, {"oid": "6a06d83ec5b3c9a6180ea7a8f89c3dab48f35cf7", "url": "https://github.com/nuxeo/nuxeo/commit/6a06d83ec5b3c9a6180ea7a8f89c3dab48f35cf7", "message": "NXP-29237: AuditChangeFinderTestSuite#testImpactedUser", "committedDate": "2020-08-26T08:07:52Z", "type": "commit"}, {"oid": "0088a23f15bc1447a3b71c98a40d947ef0c88590", "url": "https://github.com/nuxeo/nuxeo/commit/0088a23f15bc1447a3b71c98a40d947ef0c88590", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-26T08:08:01Z", "type": "forcePushed"}, {"oid": "b8e93ba5366cd3126b84edd6cfb3a1ea3c73484a", "url": "https://github.com/nuxeo/nuxeo/commit/b8e93ba5366cd3126b84edd6cfb3a1ea3c73484a", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-26T08:12:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNTE3NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477115175", "bodyText": "You could have the newline here, as suggested initially, to separate the actions from the expected check, as in the other tests.", "author": "ataillefer", "createdAt": "2020-08-26T08:10:35Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,25 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        log.trace(\"Register a sync root for Administrator\");\n+        nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder1, session);\n+        txFeature.nextTransaction();", "originalCommit": "0088a23f15bc1447a3b71c98a40d947ef0c88590", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNTU4NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477115584", "bodyText": "Please add a newline.", "author": "ataillefer", "createdAt": "2020-08-26T08:11:17Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,25 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        log.trace(\"Register a sync root for Administrator\");\n+        nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder1, session);\n+        txFeature.nextTransaction();\n+        // Check changes, expecting 2:\n+        // - rootRegistered for folder1\n+        // - documentCreated for folder1\n+        List<FileSystemItemChange> changes = getChanges();\n+        assertEquals(2, changes.size());", "originalCommit": "0088a23f15bc1447a3b71c98a40d947ef0c88590", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzExNTcwMw==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477115703", "bodyText": "Please add a newline.", "author": "ataillefer", "createdAt": "2020-08-26T08:11:28Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-core/src/test/java/org/nuxeo/drive/fixtures/AuditChangeFinderTestSuite.java", "diffHunk": "@@ -79,6 +79,25 @@\n     @Inject\n     protected TrashService trashService;\n \n+    /** @since 11.3 */\n+    @Test\n+    public void testImpactedUser() {\n+        log.trace(\"Register a sync root for Administrator\");\n+        nuxeoDriveManager.registerSynchronizationRoot(session.getPrincipal(), folder1, session);\n+        txFeature.nextTransaction();\n+        // Check changes, expecting 2:\n+        // - rootRegistered for folder1\n+        // - documentCreated for folder1\n+        List<FileSystemItemChange> changes = getChanges();\n+        assertEquals(2, changes.size());\n+        log.trace(\"Unregister the sync root for Administrator\");\n+        nuxeoDriveManager.unregisterSynchronizationRoot(session.getPrincipal(), folder1, session);\n+        txFeature.nextTransaction();", "originalCommit": "0088a23f15bc1447a3b71c98a40d947ef0c88590", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEyMjU2NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477122565", "bodyText": "I'd say either remove or be more precise, think about the admin who will check the logs.\nThe message could simply be: \"Last clustering invalidation date in milliseconds for the upper bound check: {}\"", "author": "ataillefer", "createdAt": "2020-08-26T08:22:37Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:\n+ *\n+ * <pre>\n+ * from LogEntry log where log.repositoryId = :repositoryId\n+ *\n+ * + AND if ActiveRoots (activeRoots) NOT empty\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and (\n+ * LIST_DOC_EVENTS_IDS_QUERY and ( ROOT_PATHS or COLECTIONS_PATHS) or\n+ * (log.category = 'NuxeoDrive' and log.eventId != 'rootUnregistered') )\n+ *\n+ *\n+ * if ActiveRoots EMPTY:\n+ *\n+ * from LogEntry log where log.repositoryId = :repositoryId and ((log.category =\n+ * 'NuxeoDrive' and log.eventId != 'rootUnregistered'))\n+ *\n+ * + AND (log.id > :lowerBound and log.id <= :upperBound) + order by\n+ * log.repositoryId asc, log.eventDate desc\n+ * </pre>\n+ *\n+ * @since 11.3\n+ */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit collection considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.gt(\"eventDate\", new Date(0)));\n+        if (clusteringDelay > -1) {\n+            // Double the delay in case of overlapping, see https://jira.nuxeo.com/browse/NXP-14826\n+            ZonedDateTime lastClusteringInvalidationDate = ZonedDateTime.now()\n+                                                                        .minus(2 * clusteringDelay, ChronoUnit.MILLIS);\n+            log.debug(\"preparing upperBound millis: {}\", lastClusteringInvalidationDate);", "originalCommit": "b8e93ba5366cd3126b84edd6cfb3a1ea3c73484a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bc3550ed176862e4028ba559d671759d9c4bbbf7", "url": "https://github.com/nuxeo/nuxeo/commit/bc3550ed176862e4028ba559d671759d9c4bbbf7", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-26T09:00:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzMyOTQ1Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r477329456", "bodyText": "Actually this whole comment and the query examples (which are JPA-specific) are not useful in a Javadoc-level comment. And I suspect they're not up to date anymore anyway", "author": "efge", "createdAt": "2020-08-26T14:07:38Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/**\n+ * Override the JPA audit based change finder to execute query in BSON.\n+ * <p>\n+ * The structure of the query executed by the {@link AuditChangeFinder} is:", "originalCommit": "bc3550ed176862e4028ba559d671759d9c4bbbf7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1f4cd71bef22c03caa5e5be5a111a9f3c159961a", "url": "https://github.com/nuxeo/nuxeo/commit/1f4cd71bef22c03caa5e5be5a111a9f3c159961a", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-26T16:56:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MTM5NA==", "url": "https://github.com/nuxeo/nuxeo/pull/4237#discussion_r478371394", "bodyText": "Could you please add a comment explaining why we do this, because we don't have APIs to do a query with no predicate at all? Like // TODO remove this dummy predicate once we can query with no predicate at all", "author": "efge", "createdAt": "2020-08-27T12:13:30Z", "path": "modules/platform/nuxeo-drive-server/nuxeo-drive-mongodb/src/main/java/org/nuxeo/drive/mongodb/MongoDBAuditChangeFinder.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * (C) Copyright 2020 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package org.nuxeo.drive.mongodb;\n+\n+import static com.mongodb.client.model.Filters.and;\n+import static com.mongodb.client.model.Filters.eq;\n+import static com.mongodb.client.model.Filters.exists;\n+import static com.mongodb.client.model.Filters.gt;\n+import static com.mongodb.client.model.Filters.in;\n+import static com.mongodb.client.model.Filters.lte;\n+import static com.mongodb.client.model.Filters.ne;\n+import static com.mongodb.client.model.Filters.or;\n+import static com.mongodb.client.model.Filters.regex;\n+import static com.mongodb.client.model.Sorts.ascending;\n+import static com.mongodb.client.model.Sorts.descending;\n+import static com.mongodb.client.model.Sorts.orderBy;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_ID;\n+import static org.nuxeo.ecm.platform.audit.api.BuiltinLogEntryData.LOG_LOG_DATE;\n+\n+import java.time.ZonedDateTime;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.bson.Document;\n+import org.bson.conversions.Bson;\n+import org.nuxeo.drive.service.SynchronizationRoots;\n+import org.nuxeo.drive.service.impl.AuditChangeFinder;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.query.sql.model.OrderByExprs;\n+import org.nuxeo.ecm.core.query.sql.model.Predicates;\n+import org.nuxeo.ecm.core.query.sql.model.QueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditQueryBuilder;\n+import org.nuxeo.ecm.platform.audit.api.AuditReader;\n+import org.nuxeo.ecm.platform.audit.api.LogEntry;\n+import org.nuxeo.mongodb.audit.MongoDBAuditBackend;\n+import org.nuxeo.mongodb.audit.MongoDBAuditEntryReader;\n+import org.nuxeo.runtime.api.Framework;\n+\n+import com.mongodb.client.MongoCollection;\n+\n+/** @since 11.3 */\n+public class MongoDBAuditChangeFinder extends AuditChangeFinder {\n+\n+    private static final Logger log = LogManager.getLogger(MongoDBAuditChangeFinder.class);\n+\n+    @Override\n+    public long getUpperBound() {\n+        RepositoryManager repositoryManager = Framework.getService(RepositoryManager.class);\n+        return getUpperBound(new HashSet<>(repositoryManager.getRepositoryNames()));\n+    }\n+\n+    /**\n+     * Returns the last available log id in the audit collection considering events older than the last clustering\n+     * invalidation date if clustering is enabled for at least one of the given repositories. This is to make sure the\n+     * {@code DocumentModel} further fetched from the session using the audit entry doc id is fresh.\n+     */\n+    @Override\n+    public long getUpperBound(Set<String> repositoryNames) {\n+        long clusteringDelay = getClusteringDelay(repositoryNames);\n+        MongoDBAuditBackend auditService = (MongoDBAuditBackend) Framework.getService(AuditReader.class);\n+        QueryBuilder queryBuilder = new AuditQueryBuilder().predicate(\n+                Predicates.gt(\"eventDate\", new Date(0)));", "originalCommit": "1f4cd71bef22c03caa5e5be5a111a9f3c159961a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "644331bb8cd2b083e1a9abcbedc6d7cfad7d2b14", "url": "https://github.com/nuxeo/nuxeo/commit/644331bb8cd2b083e1a9abcbedc6d7cfad7d2b14", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-27T13:22:07Z", "type": "commit"}, {"oid": "644331bb8cd2b083e1a9abcbedc6d7cfad7d2b14", "url": "https://github.com/nuxeo/nuxeo/commit/644331bb8cd2b083e1a9abcbedc6d7cfad7d2b14", "message": "NXP-29237: nuxeo-drive-mongodb module", "committedDate": "2020-08-27T13:22:07Z", "type": "forcePushed"}]}