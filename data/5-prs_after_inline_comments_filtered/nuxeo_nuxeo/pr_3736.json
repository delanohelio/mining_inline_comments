{"pr_number": 3736, "pr_title": "task-NXP-28000-portRetentionAddon", "pr_createdAt": "2020-02-10T13:46:22Z", "pr_url": "https://github.com/nuxeo/nuxeo/pull/3736", "timeline": [{"oid": "3359eec6c69b617063f3bb14baafa40783c95022", "url": "https://github.com/nuxeo/nuxeo/commit/3359eec6c69b617063f3bb14baafa40783c95022", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-02-11T08:23:39Z", "type": "forcePushed"}, {"oid": "32c042d3d27237ade9e663d0aa40cadc4816933e", "url": "https://github.com/nuxeo/nuxeo/commit/32c042d3d27237ade9e663d0aa40cadc4816933e", "message": "NXP-28000: move l10nvocabulary as default contrib", "committedDate": "2020-02-11T11:28:00Z", "type": "forcePushed"}, {"oid": "1e538f0b1e4d046831381f421325aaf5ee4583fb", "url": "https://github.com/nuxeo/nuxeo/commit/1e538f0b1e4d046831381f421325aaf5ee4583fb", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-02-11T11:28:00Z", "type": "forcePushed"}, {"oid": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "url": "https://github.com/nuxeo/nuxeo/commit/7aac3d5b6773c0bfde6a1287e4605d056476545f", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-02-20T09:23:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5ODIzOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386398238", "bodyText": "RULES_CONTAINER_TYPE  -> seems unused", "author": "RSalem07", "createdAt": "2020-03-02T13:41:39Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/RetentionConstants.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention;\n+\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionConstants {\n+\n+    public static final String RULES_CONTAINER_TYPE = \"RetentionRules\";\n+", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwMTQ5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386401499", "bodyText": "can be replaced by the use of List.of", "author": "RSalem07", "createdAt": "2020-03-02T13:48:12Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/HoldDocumentsAction.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to set legal hold.\n+ *\n+ * @since 11.1\n+ */\n+public class HoldDocumentsAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"holdDocumentsAction\";\n+\n+    public static final String PARAM_DESC = \"description\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(SetLegalHoldComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwMjA1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386402050", "bodyText": "can be replaced by List.of", "author": "RSalem07", "createdAt": "2020-03-02T13:49:17Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/AttachRetentionRuleAction.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to attach a retention rule.\n+ *\n+ * @since 11.1\n+ */\n+public class AttachRetentionRuleAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"attachRetentionRule\";\n+\n+    public static final String PARAM_RULE_ID = \"ruleId\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvaluateRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwMzQyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386403427", "bodyText": "a event-based -> an event-based", "author": "RSalem07", "createdAt": "2020-03-02T13:51:55Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/EvalInputEventBasedRuleAction.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to evaluate expression on record documents with an attached event-based retention rule. Depending on the\n+ * expression evaluation outcome, a determinate retention period is computed and set on the record document.\n+ *\n+ * @since 11.1\n+ */\n+public class EvalInputEventBasedRuleAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"evalInputEventBasedRule\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(EvalInputEventBasedRuleComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class EvalInputEventBasedRuleComputation extends AbstractBulkComputation {\n+\n+        private static final Logger log = LogManager.getLogger(EvalInputEventBasedRuleComputation.class);\n+\n+        protected boolean disableAudit;\n+\n+        protected RetentionManager retentionManager;\n+\n+        public EvalInputEventBasedRuleComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        public void startBucket(String bucketKey) {\n+            BulkCommand command = getCurrentCommand();\n+            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);\n+            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());\n+            retentionManager = Framework.getService(RetentionManager.class);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            for (DocumentModel recordDoc : loadDocuments(session, ids)) {\n+                if (!recordDoc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+                    log.debug(\"Document {} is not a record, ignoring ...\", recordDoc::getPathAsString);\n+                    continue;\n+                }\n+                Record record = recordDoc.getAdapter(Record.class);\n+                if (!record.isRetentionIndeterminate()) {\n+                    log.debug(\"Record {} has already a determinate retention date {}, ignoring ...\",\n+                            recordDoc::getPathAsString,\n+                            () -> (recordDoc.getRetainUntil() == null ? null : recordDoc.getRetainUntil().toInstant()));\n+                    continue;\n+                }\n+                RetentionRule rule = record.getRule(session);\n+                if (!rule.isEventBased()) {\n+                    log.debug(\"Record {} does not have a event-based rule, ignoring ...\", recordDoc::getPathAsString);\n+                    continue;", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNjM5OA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386406398", "bodyText": "org.nuxeo.ecm.core.bulk.message.BulkCommand.Builder#Builder(java.lang.String, java.lang.String) is a deprecated constructor, we can replace it by:\nBulkCommand command = new BulkCommand.Builder(EvalInputEventBasedRuleAction.ACTION_NAME,\n                        query.toString(), SecurityConstants.SYSTEM_USERNAME).repository(repositoryName).build();", "author": "RSalem07", "createdAt": "2020-03-02T13:57:23Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/actions/ProcessRetentionEventAction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.actions;\n+\n+import static org.nuxeo.ecm.core.bulk.BulkServiceImpl.STATUS_STREAM;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.INPUT_1;\n+import static org.nuxeo.lib.stream.computation.AbstractComputation.OUTPUT_1;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.bulk.action.computation.AbstractBulkComputation;\n+import org.nuxeo.ecm.core.bulk.message.BulkCommand;\n+import org.nuxeo.ecm.core.repository.RepositoryService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.lib.stream.computation.Topology;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.stream.StreamProcessorTopology;\n+\n+/**\n+ * Bulk action to retrieve event-based retention rules. For each rule, a\n+ * {@link org.nuxeo.retention.actions.EvalInputEventBasedRuleAction} is scheduled.\n+ *\n+ * @since 11.1\n+ */\n+public class ProcessRetentionEventAction implements StreamProcessorTopology {\n+\n+    public static final String ACTION_NAME = \"processRetentionEvent\";\n+\n+    @Override\n+    public Topology getTopology(Map<String, String> options) {\n+        return Topology.builder()\n+                       .addComputation(ProcessRetentionEventComputation::new,\n+                               Arrays.asList(INPUT_1 + \":\" + ACTION_NAME, OUTPUT_1 + \":\" + STATUS_STREAM))\n+                       .build();\n+    }\n+\n+    public static class ProcessRetentionEventComputation extends AbstractBulkComputation {\n+\n+        private static final Logger log = LogManager.getLogger(ProcessRetentionEventComputation.class);\n+\n+        protected boolean disableAudit;\n+\n+        protected RetentionManager retentionManager;\n+\n+        public ProcessRetentionEventComputation() {\n+            super(ACTION_NAME);\n+        }\n+\n+        @Override\n+        public void startBucket(String bucketKey) {\n+            BulkCommand command = getCurrentCommand();\n+            Serializable auditParam = command.getParam(NXAuditEventsService.DISABLE_AUDIT_LOGGER);\n+            disableAudit = auditParam != null && Boolean.parseBoolean(auditParam.toString());\n+            retentionManager = Framework.getService(RetentionManager.class);\n+        }\n+\n+        @Override\n+        protected void compute(CoreSession session, List<String> ids, Map<String, Serializable> properties) {\n+            for (DocumentModel ruleDoc : loadDocuments(session, ids)) {\n+                if (!ruleDoc.hasFacet(RetentionConstants.RETENTION_RULE_FACET)) {\n+                    log.debug(\"Document {} is not a retention rule, ignoring ...\", ruleDoc::getPathAsString);\n+                    continue;\n+                }\n+                RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+                scheduleInputEventBasedRule(rule);\n+            }\n+        }\n+\n+        protected void scheduleInputEventBasedRule(RetentionRule rule) {\n+            if (!rule.isEnabled() || !rule.isEventBased()) {\n+                throw new IllegalArgumentException(\"Rule is disabled or not event-based\");\n+            }\n+            BulkService bulkService = Framework.getService(BulkService.class);\n+            RepositoryService repositoryService = Framework.getService(RepositoryService.class);\n+            StringBuilder query = new StringBuilder(RetentionConstants.RULE_RECORD_DOCUMENT_QUERY);\n+            query.append(\" AND \") //\n+                 .append(RetentionConstants.RECORD_RULE_IDS_PROP) //\n+                 .append(\" = '\" + rule.getDocument().getId() + \"'\");\n+            for (String repositoryName : repositoryService.getRepositoryNames()) {\n+                BulkCommand command = new BulkCommand.Builder(EvalInputEventBasedRuleAction.ACTION_NAME,\n+                        query.toString()).user(SecurityConstants.SYSTEM_USERNAME).repository(repositoryName).build();\n+                bulkService.submit(command);", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxMDk0MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386410941", "bodyText": "can be replaced by the shorted version:\n public Calendar getSavedRetainUntil() {\n        return (Calendar) document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n    }", "author": "RSalem07", "createdAt": "2020-03-02T14:05:53Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNDAzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386414035", "bodyText": "perhaps the shorted version:\n return getDocument().isUnderRetentionOrLegalHold()\n                && CoreSession.RETAIN_UNTIL_INDETERMINATE.compareTo(getDocument().getRetainUntil()) == 0;", "author": "RSalem07", "createdAt": "2020-03-02T14:11:25Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetentionIndeterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        if (retainUntil == null) {\n+            return false;\n+        }\n+        return retainUntil.compareTo(CoreSession.RETAIN_UNTIL_INDETERMINATE) == 0;\n+    }\n+", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNTY1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386415650", "bodyText": "No, we want to do the fast path getDocument().getRetainUntil() == null first, because Calendar.compareTo is much more expensive.", "author": "efge", "createdAt": "2020-03-02T14:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNDAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNjY0NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386416644", "bodyText": "And anyway Calendar.compareTo(null) throws a NPE.", "author": "efge", "createdAt": "2020-03-02T14:16:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNDAzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNzQxOQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386417419", "bodyText": "you are right, initially i was going to use equals and just copy past the wrong proposition.\nthx", "author": "RSalem07", "createdAt": "2020-03-02T14:17:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNDAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNTMxOA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386415318", "bodyText": "wdyt about:\n Calendar retainUntil = getDocument().getRetainUntil();\n        return (retainUntil == null || !Calendar.getInstance().before(retainUntil));", "author": "RSalem07", "createdAt": "2020-03-02T14:13:47Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/Record.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.versioning.VersioningService;\n+import org.nuxeo.ecm.platform.audit.service.NXAuditEventsService;\n+import org.nuxeo.ecm.platform.dublincore.listener.DublinCoreListener;\n+import org.nuxeo.ecm.platform.ec.notification.NotificationConstants;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class Record {\n+\n+    private static final Logger log = LogManager.getLogger(Record.class);\n+\n+    protected DocumentModel document;\n+\n+    public Record(final DocumentModel doc) {\n+        document = doc;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public RetentionRule getRule(CoreSession session) {\n+        List<String> ruleIds = getRuleIds();\n+        if (ruleIds == null) {\n+            return null;\n+        }\n+        for (String ruleId : ruleIds) {\n+            IdRef ruleRef = new IdRef(ruleId);\n+            if (!session.exists(ruleRef)) {\n+                log.trace(\"Rule {} does not exist\", ruleRef);\n+                continue;\n+            }\n+            DocumentModel ruleDoc = session.getDocument(ruleRef);\n+            RetentionRule rule = ruleDoc.getAdapter(RetentionRule.class);\n+            if (!rule.isEnabled()) {\n+                log.debug(\"Rule {} id disabled\", ruleDoc::getPathAsString);\n+                continue;\n+            }\n+            return rule;\n+        }\n+        log.debug(\"No active rules found for {}\", document::getPathAsString);\n+        return null;\n+\n+    }\n+\n+    protected List<String> getRuleIds() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.RECORD_RULE_IDS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public Calendar getSavedRetainUntil() {\n+        Serializable savedRetainUntil = document.getPropertyValue(RetentionConstants.RETAIN_UNTIL_PROP);\n+        if (savedRetainUntil != null) {\n+            return (Calendar) savedRetainUntil;\n+        }\n+        return null;\n+    }\n+\n+    public boolean isRetentionIndeterminate() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return false;\n+        }\n+        Calendar retainUntil = getDocument().getRetainUntil();\n+        if (retainUntil == null) {\n+            return false;\n+        }\n+        return retainUntil.compareTo(CoreSession.RETAIN_UNTIL_INDETERMINATE) == 0;\n+    }\n+\n+    public boolean isRetentionExpired() {\n+        if (!getDocument().isUnderRetentionOrLegalHold()) {\n+            return true;\n+        }\n+        Calendar retainUntil;\n+        return (retainUntil = getDocument().getRetainUntil()) == null || !Calendar.getInstance().before(retainUntil);\n+    }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNzYzNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386417637", "bodyText": "Why not. OTOH all this is a forward-port of something already in 10.10 so it's best not to have gratuitous changes between the branches.", "author": "efge", "createdAt": "2020-03-02T14:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxNTMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxODUyMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386418521", "bodyText": "can be replaced by:\n        if (doc.hasFacet(RetentionConstants.RETENTION_RULE_FACET)) {\n            return new RetentionRule(doc);\n        } else if (doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n            return new Record(doc);\n        }\n        return null;\n\nto avoid the third branch", "author": "RSalem07", "createdAt": "2020-03-02T14:19:24Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionAdapterFactory.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.adapter.DocumentAdapterFactory;\n+import org.nuxeo.retention.RetentionConstants;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionAdapterFactory implements DocumentAdapterFactory {\n+\n+    @Override\n+    public Object getAdapter(DocumentModel doc, Class<?> itf) {\n+        if (doc.hasFacet(RetentionConstants.RETENTION_RULE_FACET)) {\n+            return new RetentionRule(doc);\n+        } else if (doc.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            return new Record(doc);\n+        } else {\n+            return null;\n+        }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ1MDA1Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386450057", "bodyText": "This is 100% equivalent and generates the same bytecode, I'm not sure in what way it's better. It's just style.", "author": "efge", "createdAt": "2020-03-02T15:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQxODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyMDkyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386420927", "bodyText": "can be replaced by return ApplicationPolicy.MANUAL.name().equalsIgnoreCase(getApplicationPolicy());", "author": "RSalem07", "createdAt": "2020-03-02T14:23:20Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED;\n+    }\n+\n+    protected DocumentModel document;\n+\n+    public RetentionRule(DocumentModel doc) {\n+        this.document = doc;\n+    }\n+\n+    public void disable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, false);\n+    }\n+\n+    public void enable() {\n+        document.setPropertyValue(RetentionConstants.ENABLED_PROP, true);\n+    }\n+\n+    public String getApplicationPolicy() {\n+        return (String) document.getPropertyValue(RetentionConstants.APPLICATION_POLICY_PROP);\n+    }\n+\n+    public List<String> getBeginActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.BEGIN_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public List<String> getDocTypes() {\n+        @SuppressWarnings(\"unchecked\")\n+        List<String> propertyValue = (List<String>) document.getPropertyValue(RetentionConstants.DOC_TYPES_PROP);\n+        return propertyValue;\n+    }\n+\n+    public DocumentModel getDocument() {\n+        return document;\n+    }\n+\n+    public long getDurationDays() {\n+        Long days = (Long) document.getPropertyValue(RetentionConstants.DURATION_DAYS_PROP);\n+        return days == null ? 0 : days;\n+    }\n+\n+    public long getDurationMillis() {\n+        Long millis = (Long) document.getPropertyValue(RetentionConstants.DURATION_MILLIS_PROP);\n+        return millis == null ? 0 : millis;\n+    }\n+\n+    public long getDurationMonths() {\n+        Long months = (Long) document.getPropertyValue(RetentionConstants.DURATION_MONTHS_PROP);\n+        return months == null ? 0 : months;\n+    }\n+\n+    public long getDurationYears() {\n+        Long years = (Long) document.getPropertyValue(RetentionConstants.DURATION_YEARS_PROP);\n+        return years == null ? 0 : years;\n+    }\n+\n+    public List<String> getEndActions() {\n+        Serializable propertyValue = document.getPropertyValue(RetentionConstants.END_ACTIONS_PROP);\n+        if (propertyValue == null) {\n+            return Collections.emptyList();\n+        }\n+        return Arrays.asList((String[]) propertyValue);\n+    }\n+\n+    public String getExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.EXPRESSION_PROP);\n+    }\n+\n+    public String getMetadataXpath() {\n+        return (String) document.getPropertyValue(RetentionConstants.METADATA_XPATH_PROP);\n+    }\n+\n+    public Calendar getRetainUntilDateFrom(Calendar calendar) {\n+        LocalDateTime datetime = LocalDateTime.ofInstant(calendar.getTime().toInstant(), ZoneId.systemDefault());\n+        return getRetainUntilDateFrom(datetime);\n+    }\n+\n+    protected Calendar getRetainUntilDateFrom(LocalDateTime datetime) {\n+        LocalDateTime localDateTime = datetime.plusYears(getDurationYears())\n+                                              .plusMonths(getDurationMonths())\n+                                              .plusDays(getDurationDays())\n+                                              .plus(getDurationMillis(), ChronoUnit.MILLIS);\n+        return GregorianCalendar.from(localDateTime.atZone(ZoneId.systemDefault()));\n+    }\n+\n+    public Calendar getRetainUntilDateFromNow() {\n+        return getRetainUntilDateFrom(LocalDateTime.now());\n+    }\n+\n+    public String getStartingPointEvent() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EVENT_PROP);\n+    }\n+\n+    public String getStartingPointExpression() {\n+        return (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_EXPRESSION_PROP);\n+    }\n+\n+    public StartingPointPolicy getStartingPointPolicy() {\n+        String value = (String) document.getPropertyValue(RetentionConstants.STARTING_POINT_POLICY_PROP);\n+        if (value != null) {\n+            return StartingPointPolicy.valueOf(value.toUpperCase());\n+        }\n+        return null;\n+\n+    }\n+\n+    public boolean isAfterDelay() {\n+        return StartingPointPolicy.AFTER_DELAY.equals(getStartingPointPolicy());\n+    }\n+\n+    public boolean isAuto() {\n+        return ApplicationPolicy.AUTO.name().toLowerCase().equals(getApplicationPolicy());\n+    }\n+\n+    public boolean isDocTypeAccepted(String docType) {\n+        List<String> types = getDocTypes();\n+        return types == null || types.isEmpty() || types.contains(docType);\n+    }\n+\n+    public boolean isEnabled() {\n+        Boolean enabled = (Boolean) document.getPropertyValue(RetentionConstants.ENABLED_PROP);\n+        return Boolean.TRUE.equals(enabled);\n+    }\n+\n+    public boolean isEventBased() {\n+        return getStartingPointPolicy() == StartingPointPolicy.EVENT_BASED;\n+    }\n+\n+    public boolean isImmediate() {\n+        return getStartingPointPolicy() == StartingPointPolicy.IMMEDIATE;\n+    }\n+\n+    public boolean isManual() {\n+        return ApplicationPolicy.MANUAL.name().toLowerCase().equals(getApplicationPolicy());\n+    }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyMTg4MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386421880", "bodyText": "the semicolon is not required when there is no members in the enum", "author": "RSalem07", "createdAt": "2020-03-02T14:24:56Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/adapters/RetentionRule.java", "diffHunk": "@@ -0,0 +1,248 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.adapters;\n+\n+import java.io.Serializable;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Calendar;\n+import java.util.Collections;\n+import java.util.GregorianCalendar;\n+import java.util.List;\n+\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.schema.SchemaManager;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionRule {\n+\n+    public enum ApplicationPolicy {\n+        AUTO, MANUAL\n+    }\n+\n+    public enum StartingPointPolicy {\n+        IMMEDIATE, AFTER_DELAY, EVENT_BASED, METADATA_BASED;\n+    }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyODMyNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386428325", "bodyText": "I am wondering if we need these checks in org.nuxeo.retention.service.RetentionManagerImpl#checkCanAttachRule ?", "author": "RSalem07", "createdAt": "2020-03-02T14:35:49Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/operations/AttachRetentionRule.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.operations;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.annotations.Param;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.service.RetentionManager;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Operation(id = AttachRetentionRule.ID, category = Constants.CAT_DOCUMENT, label = \"Attach Retation Rule\", description = \"Attach the given retetention rule to the input document.\")\n+public class AttachRetentionRule {\n+\n+    public static final String ID = \"Retention.AttachRule\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @Context\n+    protected RetentionManager retentionManager;\n+\n+    @Param(name = \"rule\")\n+    protected DocumentModel rule;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel document) {\n+        if (!rule.hasFacet(RetentionConstants.RETENTION_RULE_FACET)) {\n+            throw new NuxeoException(\"Document is not a rule: \" + document);\n+        }\n+        RetentionRule rr = rule.getAdapter(RetentionRule.class);\n+        if (!rr.isManual()) {\n+            throw new IllegalArgumentException(\"Only manual rule can be manually attached\");\n+        }\n+        document = retentionManager.attachRule(document, rr, session);\n+        return document;\n+    }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMzQ2Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r388213467", "bodyText": "We'll probably see that when we'll be implementing auto attachment later on.", "author": "guirenard", "createdAt": "2020-03-05T10:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyODMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzMTM1MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386431350", "bodyText": "I am wondering about these different operations, if we need to add the management of the save or not. I had the remark on my operations for Glacier PRs, it's why I ask :):\n@Param(name = \"save\", required = false, values = \"false\")", "author": "RSalem07", "createdAt": "2020-03-02T14:40:51Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/operations/UnholdDocument.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.operations;\n+\n+import org.nuxeo.ecm.automation.core.Constants;\n+import org.nuxeo.ecm.automation.core.annotations.Context;\n+import org.nuxeo.ecm.automation.core.annotations.Operation;\n+import org.nuxeo.ecm.automation.core.annotations.OperationMethod;\n+import org.nuxeo.ecm.automation.core.collectors.DocumentModelCollector;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentRef;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Operation(id = UnholdDocument.ID, category = Constants.CAT_DOCUMENT, label = \"Unhold\", description = \"Remove a legal hold on the input document. Returns back the unhold document.\")\n+public class UnholdDocument {\n+\n+    public static final String ID = \"Document.Unhold\";\n+\n+    @Context\n+    protected CoreSession session;\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentRef doc) {\n+        session.setLegalHold(doc, false, null);\n+        return session.getDocument(doc);\n+    }\n+\n+    @OperationMethod(collector = DocumentModelCollector.class)\n+    public DocumentModel run(DocumentModel doc) {\n+        return run(doc.getRef());\n+    }\n+", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMDI1NQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r388220255", "bodyText": "Let's keep the same API than on 10.10 for now. If we identify use cases where it will needed, we'll change on both 10.10 and master with a dedicated JIRA ticket", "author": "guirenard", "createdAt": "2020-03-05T10:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzMTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNDI5MA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386434290", "bodyText": "currently the invalidate method seems unused", "author": "RSalem07", "createdAt": "2020-03-02T14:45:46Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManager.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * Retention service.\n+ *\n+ * @since 11.1\n+ */\n+public interface RetentionManager {\n+\n+    /**\n+     * Attaches a retention rule on a document. Only\n+     * {@link org.nuxeo.retention.adapters.RetentionRule.ApplicationPolicy#MANUAL} rules can be attached through this\n+     * method. Depending on the {@link org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy}. The document is\n+     * turned into a record and a retention date is computed according to the rule's\n+     * {@link org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy} and settings.\n+     *\n+     * @param document the document\n+     * @param rule the retention rule\n+     * @param session the core session\n+     * @return the record document with a retention expiration date\n+     * @since 11.1\n+     */\n+    DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session);\n+\n+    /**\n+     * Checks that the session has sufficient permission to attach the rule to the document.\n+     *\n+     * @param document the document\n+     * @param rule the rule\n+     * @param session the session\n+     * @return\n+     * @since 11.1\n+     */\n+    boolean canAttachRule(DocumentModel document, RetentionRule rule, CoreSession session);\n+\n+    /**\n+     * Triggers the evaluation of event-based retention rules that may be attached to the document ids.\n+     *\n+     * @param docsToCheckAndEvents map of document ids and set of events\n+     * @since 11.1\n+     */\n+    void evalRules(Map<String, Set<String>> docsToCheckAndEvents);\n+\n+    /**\n+     * Evaluates the event-based retention rules that may be attached to the given record document.\n+     *\n+     * @param record the record document\n+     * @param events the set of events\n+     * @param session the session\n+     * @since 11.1\n+     */\n+    void evalExpressionEventBasedRules(Record record, Set<String> events, CoreSession session);\n+\n+    /**\n+     * Returns the list of accepted platform core events for event-based retention rules.\n+     *\n+     * @return the list of accepted events.\n+     * @since 11.1\n+     */\n+    List<String> getAcceptedEvents();\n+\n+    /**\n+     * Invalidate service (useful in a test context).\n+     *\n+     * @since 11.1\n+     */\n+    void invalidate();\n+", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNTQ5Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r388225496", "bodyText": "True, but it may be useful for some custom developments", "author": "guirenard", "createdAt": "2020-03-05T11:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ0MTI3MQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386441271", "bodyText": "redundant declaration here: DocumentModel groupModel = userManager.getBareGroupModel();   and groupModel = userManager.getBareGroupModel();", "author": "RSalem07", "createdAt": "2020-03-02T14:56:42Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/service/RetentionManagerImpl.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.service;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+\n+import java.io.Serializable;\n+import java.util.Calendar;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.jboss.el.ExpressionFactoryImpl;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.automation.OperationContext;\n+import org.nuxeo.ecm.automation.OperationException;\n+import org.nuxeo.ecm.automation.core.operations.document.DeleteDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.LockDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.TrashDocument;\n+import org.nuxeo.ecm.automation.core.operations.document.UnlockDocument;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.NuxeoPrincipal;\n+import org.nuxeo.ecm.core.api.event.CoreEventConstants;\n+import org.nuxeo.ecm.core.api.event.DocumentEventCategories;\n+import org.nuxeo.ecm.core.api.model.Property;\n+import org.nuxeo.ecm.core.api.security.SecurityConstants;\n+import org.nuxeo.ecm.core.event.Event;\n+import org.nuxeo.ecm.core.event.EventService;\n+import org.nuxeo.ecm.core.event.impl.DocumentEventContext;\n+import org.nuxeo.ecm.core.schema.types.primitives.DateType;\n+import org.nuxeo.ecm.core.work.api.WorkManager;\n+import org.nuxeo.ecm.directory.Directory;\n+import org.nuxeo.ecm.directory.Session;\n+import org.nuxeo.ecm.directory.api.DirectoryService;\n+import org.nuxeo.ecm.platform.actions.ELActionContext;\n+import org.nuxeo.ecm.platform.el.ExpressionContext;\n+import org.nuxeo.ecm.platform.usermanager.UserManager;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.workers.RuleEvaluationWorker;\n+import org.nuxeo.runtime.api.Framework;\n+import org.nuxeo.runtime.model.ComponentContext;\n+import org.nuxeo.runtime.model.DefaultComponent;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class RetentionManagerImpl extends DefaultComponent implements RetentionManager {\n+\n+    private static final Logger log = LogManager.getLogger(RetentionManagerImpl.class);\n+\n+    @Override\n+    public DocumentModel attachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        checkCanAttachRule(document, rule, session);\n+        session.makeRecord(document.getRef());\n+        final Calendar retainUntil;\n+        if (rule.isImmediate()) {\n+            retainUntil = rule.getRetainUntilDateFromNow();\n+            log.debug(\"Attaching immediate rule until {}\", retainUntil::toInstant);\n+        } else if (rule.isAfterDelay()) {\n+            log.debug(\"Attaching after delay rule\");\n+            throw new UnsupportedOperationException(\"After delay not yet implemented\");\n+        } else if (rule.isEventBased()) {\n+            retainUntil = CoreSession.RETAIN_UNTIL_INDETERMINATE;\n+            log.debug(\"Attaching event-based rule on {} matching \\\"{}\\\"\", rule::getStartingPointEvent,\n+                    rule::getStartingPointExpression);\n+        } else if (rule.isMetadataBased()) {\n+            String xpath = rule.getMetadataXpath();\n+            if (StringUtils.isBlank(xpath)) {\n+                throw new NuxeoException(\"Metadata field is null\");\n+            }\n+            Property prop = document.getProperty(xpath);\n+            if (!(prop.getType() instanceof DateType)) {\n+                throw new NuxeoException(\n+                        String.format(\"Field %s of type %s is expected to have a DateType\", xpath, prop.getType()));\n+            }\n+            Calendar value = (Calendar) prop.getValue();\n+            if (value != null) {\n+                Calendar retainUntilCandidate = rule.getRetainUntilDateFrom(value);\n+                Calendar now = Calendar.getInstance();\n+                if (now.after(retainUntilCandidate)) {\n+                    log.info(\n+                            \"Metabased-based rule found past date {} as retention expiration date on {} from {} property. Ignoring...\",\n+                            retainUntilCandidate::toInstant,\n+                            document::getPathAsString, () -> xpath);\n+                    retainUntil = null;\n+                } else {\n+                    retainUntil = retainUntilCandidate;\n+                    log.debug(\"Attaching rule based on {} with value {}\", () -> xpath, retainUntil::toInstant);\n+                }\n+            } else {\n+                retainUntil = null;\n+                log.info(\"Attaching rule based on {}: empty value\", xpath);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown starting point policy: \" + rule.getStartingPointPolicy());\n+        }\n+        document.addFacet(RetentionConstants.RECORD_FACET);\n+        Record record = document.getAdapter(Record.class);\n+        record.setRule(rule, session);\n+        executeRuleBeginActions(record, session);\n+        if (retainUntil != null) {\n+            session.setRetainUntil(document.getRef(), retainUntil, null);\n+        }\n+        notifyAttachRule(record, rule, session);\n+        return session.getDocument(document.getRef());\n+    }\n+\n+    protected void notifyAttachRule(Record record, RetentionRule rule, CoreSession session) {\n+        DocumentModel doc = record.getDocument();\n+        DocumentEventContext ctx = new DocumentEventContext(session, session.getPrincipal(), doc);\n+        ctx.setProperty(CoreEventConstants.REPOSITORY_NAME, session.getRepositoryName());\n+        ctx.setProperty(CoreEventConstants.SESSION_ID, session.getSessionId());\n+        ctx.setProperty(DocumentEventContext.CATEGORY_PROPERTY_KEY, DocumentEventCategories.EVENT_DOCUMENT_CATEGORY);\n+        ctx.setProperty(DocumentEventContext.COMMENT_PROPERTY_KEY, rule.getDocument().getPathAsString());\n+        Event event = ctx.newEvent(RetentionConstants.RULE_ATTACHED_EVENT);\n+        Framework.getService(EventService.class).fireEvent(event);\n+    }\n+\n+    protected void checkCanAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        NuxeoPrincipal principal = session.getPrincipal();\n+        if (!principal.isAdministrator() && !principal.isMemberOf(RetentionConstants.RECORD_MANAGER_GROUP_NAME)) {\n+            if (!session.hasPermission(document.getRef(), SecurityConstants.MAKE_RECORD)\n+                    || !session.hasPermission(document.getRef(), SecurityConstants.SET_RETENTION))\n+                throw new NuxeoException(\"User is not authorized to attach retention rule\", SC_FORBIDDEN);\n+        }\n+        if (!rule.isEnabled()) {\n+            throw new NuxeoException(\"Rule is disabled\");\n+        }\n+        if (!rule.isDocTypeAccepted(document.getType())) {\n+            throw new NuxeoException(\"Rule does not accept this document type\");\n+        }\n+        if (rule.isMetadataBased()) {\n+            document.getProperty(rule.getMetadataXpath());\n+            // above throw an exception if property not found\n+        }\n+        if (document.hasFacet(RetentionConstants.RECORD_FACET)) {\n+            throw new NuxeoException(\"Document is already a record\");\n+        }\n+    }\n+\n+    @Override\n+    public boolean canAttachRule(DocumentModel document, RetentionRule rule, CoreSession session) {\n+        try {\n+            checkCanAttachRule(document, rule, session);\n+            return true;\n+        } catch (NuxeoException e) {\n+            log.info(\"Cannot attach rule {} on document {}\", () -> rule.getDocument().getPathAsString(),\n+                    document::getPathAsString);\n+            return false;\n+        }\n+    }\n+\n+    public void executeRuleBeginActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getBeginActions(), session);\n+        }\n+    }\n+\n+    public void executeRuleEndActions(Record record, CoreSession session) {\n+        RetentionRule rule = record.getRule(session);\n+        if (rule != null) {\n+            executeRuleActions(record.getDocument(), rule.getEndActions(), session);\n+        }\n+    }\n+\n+    protected void executeRuleActions(DocumentModel doc, List<String> actionIds, CoreSession session) {\n+        if (actionIds != null) {\n+            AutomationService automationService = Framework.getService(AutomationService.class);\n+            for (String operationId : actionIds) {\n+                log.debug(\"Executing {} action on {}\", () -> operationId, doc::getPathAsString);\n+                // Do not lock document if already locked, nor unlock if already unlocked (would trigger an error)\n+                // Also, if it's time to delete, unlock it first, etc.\n+                // (more generally, be ready to handle specific operations and context)\n+                switch (operationId) {\n+                case LockDocument.ID:\n+                    if (doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+                case UnlockDocument.ID:\n+                    if (!doc.isLocked()) {\n+                        continue;\n+                    }\n+                    break;\n+                case DeleteDocument.ID:\n+                case TrashDocument.ID:\n+                    if (doc.isLocked()) {\n+                        session.removeLock(doc.getRef());\n+                        doc = session.getDocument(doc.getRef());\n+                    }\n+                    break;\n+                default:\n+                    throw new NuxeoException(\"Invalid operation: \" + operationId);\n+                }\n+                OperationContext context = getExecutionContext(doc, session);\n+                try {\n+                    automationService.run(context, operationId);\n+                } catch (OperationException e) {\n+                    throw new NuxeoException(\"Error running operation: \" + operationId, e);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected OperationContext getExecutionContext(DocumentModel doc, CoreSession session) {\n+        OperationContext context = new OperationContext(session);\n+        context.put(\"document\", doc);\n+        context.setCommit(false); // no session save at end\n+        context.setInput(doc);\n+        return context;\n+    }\n+\n+    @Override\n+    public void evalRules(Map<String, Set<String>> docsToCheckAndEvents) {\n+        if (docsToCheckAndEvents.isEmpty()) {\n+            return;\n+        }\n+        RuleEvaluationWorker work = new RuleEvaluationWorker(docsToCheckAndEvents);\n+        Framework.getService(WorkManager.class).schedule(work, WorkManager.Scheduling.ENQUEUE);\n+    }\n+\n+    protected ELActionContext initActionContext(DocumentModel doc, CoreSession session) {\n+        ELActionContext ctx = new ELActionContext(new ExpressionContext(), new ExpressionFactoryImpl());\n+        ctx.setCurrentPrincipal(session.getPrincipal());\n+        doc.detach(true);\n+        ctx.setCurrentDocument(doc);\n+        return ctx;\n+    }\n+\n+    protected boolean evaluateConditionExpression(ELActionContext ctx, String expression) {\n+        Calendar now = Calendar.getInstance();\n+        if (StringUtils.isEmpty(expression)) {\n+            return true;\n+        }\n+        ctx.putLocalVariable(\"currentDate\", now);\n+        return ctx.checkCondition(expression);\n+    }\n+\n+    @Override\n+    public void evalExpressionEventBasedRules(Record record, Set<String> events, CoreSession session) {\n+        if (record == null) {\n+            return; // nothing to do\n+        }\n+        RetentionRule rule = record.getRule(session);\n+        if (rule == null) {\n+            return; // nothing to do\n+        }\n+        if (!rule.isEventBased()) {\n+            log.trace(\"Record is not event-based\");\n+            return;\n+        }\n+        log.debug(\"Evaluating event-based rules for record {}\", () -> record.getDocument().getPathAsString());\n+        if (record.isRetentionExpired()) {\n+            // retention expired, nothing to do\n+            log.debug(\"Evaluating event-based found retention expired\");\n+            proceedRetentionExpired(record, session);\n+            return;\n+\n+        }\n+        String startingPointEvent = rule.getStartingPointEvent();\n+        if (StringUtils.isBlank(startingPointEvent)) {\n+            log.warn(\"Evaluating event-based rules  on record {} found no event specified\",\n+                    () -> record.getDocument().getPathAsString());\n+            return;\n+        }\n+        if (events.contains(startingPointEvent)) {\n+            ELActionContext actionContext = initActionContext(record.getDocument(), session);\n+            String expression = rule.getStartingPointExpression();\n+            boolean startNow = evaluateConditionExpression(actionContext, expression);\n+            if (startNow) {\n+                session.setRetainUntil(record.getDocument().getRef(), rule.getRetainUntilDateFromNow(), null);\n+                log.debug(\"Evaluating event-based rules: expression {} matched on event {}\", expression,\n+                        startingPointEvent);\n+            } else {\n+                log.debug(\"Evaluating event-based rules: expression {} did not match on event {}\", expression,\n+                        startingPointEvent);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void proceedRetentionExpired(Record record, CoreSession session) {\n+        executeRuleEndActions(record, session);\n+    }\n+\n+    protected volatile List<String> acceptedEvents; // NOSONAR double-checked locking\n+\n+    @Override\n+    public List<String> getAcceptedEvents() {\n+        if (acceptedEvents == null) {\n+            synchronized (this) {\n+                if (acceptedEvents == null) {\n+                    DirectoryService directoryService = Framework.getService(DirectoryService.class);\n+                    Directory dir = directoryService.getDirectory(RetentionConstants.EVENTS_DIRECTORY_NAME);\n+                    try (Session session = dir.getSession()) {\n+                        Map<String, Serializable> filter = new HashMap<>();\n+                        filter.put(RetentionConstants.OBSOLETE_FIELD_ID, Long.valueOf(0));\n+                        List<String> evts = session.getProjection(filter, session.getIdField());\n+                        if (evts.isEmpty()) {\n+                            log.trace(\"Empty accepted events, not catching anything\");\n+                            return evts;\n+                        }\n+                        acceptedEvents = evts;\n+                        log.debug(\"Accepted events {}\", acceptedEvents::toString);\n+                    }\n+                }\n+\n+            }\n+        }\n+        return acceptedEvents;\n+    }\n+\n+    @Override\n+    public void invalidate() {\n+        synchronized (this) {\n+            acceptedEvents = null;\n+        }\n+    }\n+\n+    @Override\n+    public void start(ComponentContext context) {\n+        Framework.doPrivileged(() -> {\n+            UserManager userManager = Framework.getService(UserManager.class);\n+            if (userManager.getGroup(RetentionConstants.RECORD_MANAGER_GROUP_NAME) == null) {\n+                DocumentModel groupModel = userManager.getBareGroupModel();\n+                String groupSchemaName = userManager.getGroupSchemaName();\n+                groupModel = userManager.getBareGroupModel();\n+                groupModel.setPropertyValue(userManager.getGroupIdField(),", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ2ODU5Mw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386468593", "bodyText": "can we rename the string -> docId for more clarity", "author": "RSalem07", "createdAt": "2020-03-02T15:39:24Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(RuleEvaluationWorker.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected final Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {\n+        this.docsToCheckAndEvents = docsToCheckAndEvents;\n+        List<String> docs = new ArrayList<>();\n+        docs.addAll(docsToCheckAndEvents.keySet());\n+        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);\n+    }\n+\n+    @Override\n+    public String getTitle() {\n+        return TITLE;\n+    }\n+\n+    @Override\n+    public String getCategory() {\n+        return CATEGORY;\n+    }\n+\n+    @Override\n+    public void work() {\n+        openSystemSession();\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        for (String string : docIds) {\n+            DocumentModel doc;", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3MTE2Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386471166", "bodyText": "Perhaps I asked the question when I reviewed the 10.10 version,  what if we use session.exists(...):\n           if(!session.exists(new IdRef(string))) {\n                log.warn(\"Document impacted by retention no longer exists {}\", string);\n                continue;\n            }", "author": "RSalem07", "createdAt": "2020-03-02T15:43:18Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/main/java/org/nuxeo/retention/workers/RuleEvaluationWorker.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.workers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.DocumentNotFoundException;\n+import org.nuxeo.ecm.core.api.IdRef;\n+import org.nuxeo.ecm.core.api.repository.RepositoryManager;\n+import org.nuxeo.ecm.core.work.AbstractWork;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.api.Framework;\n+\n+/**\n+ * Worker scheduled to proceed {@link org.nuxeo.retention.service.RetentionManager#evalExpressionEventBasedRules}\n+ * on document ids with events set.\n+ *\n+ * @since 11.1\n+ */\n+public class RuleEvaluationWorker extends AbstractWork {\n+\n+    private static final Logger log = LogManager.getLogger(RuleEvaluationWorker.class);\n+\n+    private static final long serialVersionUID = 1L;\n+\n+    public static final String TITLE = \"Retention Rule Evaluation Work\";\n+\n+    public static final String CATEGORY = \"retentionRuleWork\";\n+\n+    protected final Map<String, Set<String>> docsToCheckAndEvents;\n+\n+    public RuleEvaluationWorker(Map<String, Set<String>> docsToCheckAndEvents) {\n+        this.docsToCheckAndEvents = docsToCheckAndEvents;\n+        List<String> docs = new ArrayList<>();\n+        docs.addAll(docsToCheckAndEvents.keySet());\n+        setDocuments(Framework.getService(RepositoryManager.class).getDefaultRepositoryName(), docs);\n+    }\n+\n+    @Override\n+    public String getTitle() {\n+        return TITLE;\n+    }\n+\n+    @Override\n+    public String getCategory() {\n+        return CATEGORY;\n+    }\n+\n+    @Override\n+    public void work() {\n+        openSystemSession();\n+        RetentionManager retentionManager = Framework.getService(RetentionManager.class);\n+        for (String string : docIds) {\n+            DocumentModel doc;\n+            try {\n+                doc = session.getDocument(new IdRef(string));\n+            } catch (DocumentNotFoundException e) {", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxNTkzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r388215933", "bodyText": "It would probably be equivalent but as mentioned let's try to keep the forward port as much similar as 10.10", "author": "guirenard", "createdAt": "2020-03-05T10:49:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3MTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NzU2OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386487569", "bodyText": "TransactionalFeature is not needed as it will be deployed by  AutomationFeature -> PlatformFeature -> CoreFeature -> TransactionalFeature", "author": "RSalem07", "createdAt": "2020-03-02T16:06:52Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NDE5Nw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r388244197", "bodyText": "\ud83d\udc4d thanks, if you can remove @Features({ AutomationFeature.class }) -> @Features(AutomationFeature.class) the unneeded curly brackets", "author": "RSalem07", "createdAt": "2020-03-05T11:48:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4NzU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5MzkzMw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386493933", "bodyText": "I am wondering if we can use transactionalFeature.nextTransaction(); instead of coreFeature.waitForAsyncCompletion(); my idea is mainly about the consistency as mainly I used transactionalFeature.nextTransaction() when I wait for asynchronous things.", "author": "RSalem07", "createdAt": "2020-03-02T16:16:34Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-vocabularies.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-content-template.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-service-framework.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-listeners.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-operations.xml\")\n+public abstract class RetentionTestCase {\n+\n+    @Inject\n+    protected RetentionManager service;\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    protected DocumentModel file;\n+\n+    @Before\n+    public void setup() {\n+        file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file = session.saveDocument(file);\n+    }\n+\n+    protected void assertStillUnderRetentionAfter(DocumentModel doc, RetentionRule rule, int timeoutMillis)\n+            throws InterruptedException {\n+        doc = service.attachRule(doc, rule, session);\n+        assertTrue(doc.isRecord());\n+\n+        awaitRetentionExpiration(timeoutMillis);\n+\n+        doc = session.getDocument(doc.getRef());\n+\n+        // it is still under retention and has a retention date\n+        assertTrue(session.isUnderRetentionOrLegalHold(doc.getRef()));\n+        assertNotNull(session.getRetainUntil(doc.getRef()));\n+    }\n+\n+    protected void awaitRetentionExpiration(long millis) throws InterruptedException {\n+        // wait a bit more than retention period to pass retention expiration date\n+        coreFeature.waitForAsyncCompletion();", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NDY5OQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386494699", "bodyText": "On master we can replace if you want :) by the use of the awaitility library you can have look at org.nuxeo.ecm.platform.comment.TestCommentsMigrator#runMigrationStep for an example", "author": "RSalem07", "createdAt": "2020-03-02T16:17:42Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-vocabularies.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-content-template.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-service-framework.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-listeners.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-operations.xml\")\n+public abstract class RetentionTestCase {\n+\n+    @Inject\n+    protected RetentionManager service;\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    protected DocumentModel file;\n+\n+    @Before\n+    public void setup() {\n+        file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file = session.saveDocument(file);\n+    }\n+\n+    protected void assertStillUnderRetentionAfter(DocumentModel doc, RetentionRule rule, int timeoutMillis)\n+            throws InterruptedException {\n+        doc = service.attachRule(doc, rule, session);\n+        assertTrue(doc.isRecord());\n+\n+        awaitRetentionExpiration(timeoutMillis);\n+\n+        doc = session.getDocument(doc.getRef());\n+\n+        // it is still under retention and has a retention date\n+        assertTrue(session.isUnderRetentionOrLegalHold(doc.getRef()));\n+        assertNotNull(session.getRetainUntil(doc.getRef()));\n+    }\n+\n+    protected void awaitRetentionExpiration(long millis) throws InterruptedException {\n+        // wait a bit more than retention period to pass retention expiration date\n+        coreFeature.waitForAsyncCompletion();\n+        Thread.sleep(millis);\n+        // trigger manually instead of waiting for scheduler", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NTMyNw==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386495327", "bodyText": "matadataXPath -> metadataXPath", "author": "RSalem07", "createdAt": "2020-03-02T16:18:38Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-vocabularies.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-content-template.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-service-framework.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-listeners.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-operations.xml\")\n+public abstract class RetentionTestCase {\n+\n+    @Inject\n+    protected RetentionManager service;\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    protected DocumentModel file;\n+\n+    @Before\n+    public void setup() {\n+        file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file = session.saveDocument(file);\n+    }\n+\n+    protected void assertStillUnderRetentionAfter(DocumentModel doc, RetentionRule rule, int timeoutMillis)\n+            throws InterruptedException {\n+        doc = service.attachRule(doc, rule, session);\n+        assertTrue(doc.isRecord());\n+\n+        awaitRetentionExpiration(timeoutMillis);\n+\n+        doc = session.getDocument(doc.getRef());\n+\n+        // it is still under retention and has a retention date\n+        assertTrue(session.isUnderRetentionOrLegalHold(doc.getRef()));\n+        assertNotNull(session.getRetainUntil(doc.getRef()));\n+    }\n+\n+    protected void awaitRetentionExpiration(long millis) throws InterruptedException {\n+        // wait a bit more than retention period to pass retention expiration date\n+        coreFeature.waitForAsyncCompletion();\n+        Thread.sleep(millis);\n+        // trigger manually instead of waiting for scheduler\n+        new RetentionExpiredFinderListener().handleEvent(null);\n+        assertTrue(\"Bulk action didn't finish\", bulkService.await(Duration.ofSeconds(60)));\n+        coreFeature.waitForAsyncCompletion();\n+    }\n+\n+    protected RetentionRule createRuleWithActions(RetentionRule.ApplicationPolicy policy,\n+            StartingPointPolicy startingPointPolicy, List<String> docTypes, String startingPointEventId,\n+            String startingPointExpression, String matadataXPath, long years, long months, long days,", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5NjUwMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386496501", "bodyText": "as the createRuleWithActions method take a long primitif type, you can just pass 0 instead of 0L   but if you want to keep the same things as the 10.10 we avoid this modification", "author": "RSalem07", "createdAt": "2020-03-02T16:20:26Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/RetentionTestCase.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Before;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.automation.test.AutomationFeature;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.bulk.BulkService;\n+import org.nuxeo.ecm.core.security.RetentionExpiredFinderListener;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.retention.adapters.RetentionRule.StartingPointPolicy;\n+import org.nuxeo.retention.service.RetentionManager;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+import org.nuxeo.runtime.test.runner.TransactionalFeature;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ TransactionalFeature.class, AutomationFeature.class })\n+@RepositoryConfig(init = DefaultRepositoryInit.class, cleanup = Granularity.METHOD)\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-adapters.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-vocabularies.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-content-template.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-service-framework.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-listeners.xml\")\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-operations.xml\")\n+public abstract class RetentionTestCase {\n+\n+    @Inject\n+    protected RetentionManager service;\n+\n+    @Inject\n+    protected CoreFeature coreFeature;\n+\n+    @Inject\n+    protected CoreSession session;\n+\n+    @Inject\n+    protected BulkService bulkService;\n+\n+    protected DocumentModel file;\n+\n+    @Before\n+    public void setup() {\n+        file = session.createDocumentModel(\"/\", \"File\", \"File\");\n+        file = session.createDocument(file);\n+        file = session.saveDocument(file);\n+    }\n+\n+    protected void assertStillUnderRetentionAfter(DocumentModel doc, RetentionRule rule, int timeoutMillis)\n+            throws InterruptedException {\n+        doc = service.attachRule(doc, rule, session);\n+        assertTrue(doc.isRecord());\n+\n+        awaitRetentionExpiration(timeoutMillis);\n+\n+        doc = session.getDocument(doc.getRef());\n+\n+        // it is still under retention and has a retention date\n+        assertTrue(session.isUnderRetentionOrLegalHold(doc.getRef()));\n+        assertNotNull(session.getRetainUntil(doc.getRef()));\n+    }\n+\n+    protected void awaitRetentionExpiration(long millis) throws InterruptedException {\n+        // wait a bit more than retention period to pass retention expiration date\n+        coreFeature.waitForAsyncCompletion();\n+        Thread.sleep(millis);\n+        // trigger manually instead of waiting for scheduler\n+        new RetentionExpiredFinderListener().handleEvent(null);\n+        assertTrue(\"Bulk action didn't finish\", bulkService.await(Duration.ofSeconds(60)));\n+        coreFeature.waitForAsyncCompletion();\n+    }\n+\n+    protected RetentionRule createRuleWithActions(RetentionRule.ApplicationPolicy policy,\n+            StartingPointPolicy startingPointPolicy, List<String> docTypes, String startingPointEventId,\n+            String startingPointExpression, String matadataXPath, long years, long months, long days,\n+            long durationMillis, List<String> beginActions, List<String> endActions) {\n+        DocumentModel doc = session.createDocumentModel(\"/RetentionRules\", \"testRule\", \"RetentionRule\");\n+        RetentionRule rule = doc.getAdapter(RetentionRule.class);\n+        rule.setDurationYears(years);\n+        rule.setDurationMonths(months);\n+        rule.setDurationDays(days);\n+        rule.setDurationMillis(durationMillis);\n+        rule.setApplicationPolicy(policy);\n+        rule.setStartingPointPolicy(startingPointPolicy);\n+        rule.setDocTypes(docTypes);\n+        rule.setStartingPointEvent(startingPointEventId);\n+        rule.setStartingPointExpression(startingPointExpression);\n+        rule.setMetadataXpath(matadataXPath);\n+        rule.setBeginActions(beginActions);\n+        rule.setEndActions(endActions);\n+        session.createDocument(doc);\n+        return session.saveDocument(rule.getDocument()).getAdapter(RetentionRule.class);\n+    }\n+\n+    protected RetentionRule createImmediateRuleMillis(RetentionRule.ApplicationPolicy policy, long durationMillis,\n+            List<String> beginActions, List<String> endActions) {\n+        return createRuleWithActions(policy, RetentionRule.StartingPointPolicy.IMMEDIATE, Arrays.asList(\"File\"), null,\n+                null, null, 0L, 0L, 0L, durationMillis, beginActions, endActions);\n+    }", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5Njc4Ng==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386496786", "bodyText": "curly bracket on @Features({ CoreFeature.class }) are not needed", "author": "RSalem07", "createdAt": "2020-03-02T16:20:54Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionAdapters.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.nuxeo.ecm.core.api.CoreSession;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.test.CoreFeature;\n+import org.nuxeo.ecm.core.test.DefaultRepositoryInit;\n+import org.nuxeo.ecm.core.test.annotations.Granularity;\n+import org.nuxeo.ecm.core.test.annotations.RepositoryConfig;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+import org.nuxeo.runtime.test.runner.Features;\n+import org.nuxeo.runtime.test.runner.FeaturesRunner;\n+\n+/**\n+ * @since 11.1\n+ */\n+@RunWith(FeaturesRunner.class)\n+@Features({ CoreFeature.class })\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-core-types.xml\")", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5Nzg2NA==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386497864", "bodyText": "automationService  seems unused.", "author": "RSalem07", "createdAt": "2020-03-02T16:22:28Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionManager.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this doc except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Calendar;\n+\n+import javax.inject.Inject;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.automation.AutomationService;\n+import org.nuxeo.ecm.core.api.DocumentModel;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.event.DocumentEventTypes;\n+import org.nuxeo.retention.adapters.Record;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+\n+/**\n+ * @since 11.1\n+ */\n+public class TestRetentionManager extends RetentionTestCase {\n+\n+    @Inject\n+    protected AutomationService automationService;", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMDkzNQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386500935", "bodyText": "can be replaced by (the use of acp.getOrCreateACL()...):\n        ACP acp = new ACPImpl();\n        acp.getOrCreateACL().add( new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true));\n        file.setACP(acp, true);\n        file = session.saveDocument(file);", "author": "RSalem07", "createdAt": "2020-03-02T16:27:12Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            assertEquals(\"User is not authorized to attach retention rule\", e.getMessage());\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            assertEquals(\"User is not authorized to attach retention rule\", e.getMessage());\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMTUxMQ==", "url": "https://github.com/nuxeo/nuxeo/pull/3736#discussion_r386501511", "bodyText": "same suggestion as above; the use of acp.getOrCreateACL()", "author": "RSalem07", "createdAt": "2020-03-02T16:28:08Z", "path": "addons/nuxeo-retention/nuxeo-retention-core/src/test/java/org/nuxeo/retention/test/TestRetentionSecurity.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * (C) Copyright 2019 Nuxeo (http://nuxeo.com/) and others.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ * Contributors:\n+ *     Guillaume RENARD\n+ */\n+package org.nuxeo.retention.test;\n+\n+import static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+import org.nuxeo.ecm.core.api.CloseableCoreSession;\n+import org.nuxeo.ecm.core.api.CoreInstance;\n+import org.nuxeo.ecm.core.api.NuxeoException;\n+import org.nuxeo.ecm.core.api.security.ACE;\n+import org.nuxeo.ecm.core.api.security.ACL;\n+import org.nuxeo.ecm.core.api.security.ACP;\n+import org.nuxeo.ecm.core.api.security.impl.ACLImpl;\n+import org.nuxeo.ecm.core.api.security.impl.ACPImpl;\n+import org.nuxeo.retention.RetentionConstants;\n+import org.nuxeo.retention.adapters.RetentionRule;\n+import org.nuxeo.runtime.test.runner.Deploy;\n+\n+/**\n+ * @since 11.1\n+ */\n+@Deploy(\"org.nuxeo.retention.core:OSGI-INF/retention-security.xml\")\n+public class TestRetentionSecurity extends RetentionTestCase {\n+\n+    @Test\n+    public void shouldBeAuthorizedToManageLegalHold() {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            assertEquals(\"User is not authorized to attach retention rule\", e.getMessage());\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldNotBeAuthorizedToAttachRule() {\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            service.attachRule(file, createManualImmediateRuleMillis(100), userSession);\n+            fail(\"Sould not be abe to attach rule\");\n+        } catch (NuxeoException e) {\n+            assertEquals(\"User is not authorized to attach retention rule\", e.getMessage());\n+            assertEquals(SC_FORBIDDEN, e.getStatusCode());\n+            assertFalse(session.isRecord(file.getRef()));\n+            assertFalse(session.isUnderRetentionOrLegalHold(file.getRef()));\n+            assertFalse(session.getDocument(file.getRef()).hasFacet(RetentionConstants.RECORD_FACET));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void shouldBeAuthorizedToAttachRule() {\n+        ACP acp = new ACPImpl();\n+        ACE allowAttachRule = new ACE(\"user\", RetentionConstants.MANAGE_RECORD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowAttachRule });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);\n+        try (CloseableCoreSession userSession = CoreInstance.openCoreSession(session.getRepositoryName(), \"user\")) {\n+            file = service.attachRule(file, createManualImmediateRuleMillis(5000), userSession);\n+            assertTrue(userSession.isUnderRetentionOrLegalHold(file.getRef()));\n+        }\n+    }\n+\n+    @Test\n+    public void shouldBeAuthorizedToSetLegalHold() {\n+        ACP acp = new ACPImpl();\n+        ACE allowLegalHold = new ACE(\"user\", RetentionConstants.MANAGE_LEGAL_HOLD_PERMISSION, true);\n+        ACL acl = new ACLImpl();\n+        acl.setACEs(new ACE[] { allowLegalHold });\n+        acp.addACL(acl);\n+        file.setACP(acp, true);\n+        file = session.saveDocument(file);", "originalCommit": "7aac3d5b6773c0bfde6a1287e4605d056476545f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f65bfe19410a25043e5a89d8c54c1c9bb79252b", "url": "https://github.com/nuxeo/nuxeo/commit/0f65bfe19410a25043e5a89d8c54c1c9bb79252b", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-03-05T11:22:37Z", "type": "forcePushed"}, {"oid": "23c27774394a43ae6973907375d24bea64a16e17", "url": "https://github.com/nuxeo/nuxeo/commit/23c27774394a43ae6973907375d24bea64a16e17", "message": "NXP-27692: add retention addon", "committedDate": "2020-03-05T12:02:06Z", "type": "commit"}, {"oid": "3fa844c76d887560cd78ce0f53b4c22979b5a3f0", "url": "https://github.com/nuxeo/nuxeo/commit/3fa844c76d887560cd78ce0f53b4c22979b5a3f0", "message": "NXP-28135: null or past metadata retention just turn doc into record", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "7697b54df27c26c288e94be73c8804c439792495", "url": "https://github.com/nuxeo/nuxeo/commit/7697b54df27c26c288e94be73c8804c439792495", "message": "NXP-28367: fix label and style of retention actions", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "2a2442583cf0f966e3343f250e3521824a93dab5", "url": "https://github.com/nuxeo/nuxeo/commit/2a2442583cf0f966e3343f250e3521824a93dab5", "message": "NXP-28367: fix retention layouts", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "9b0a51ff4a4048a5121e8126b144ab7ddf11bbc8", "url": "https://github.com/nuxeo/nuxeo/commit/9b0a51ff4a4048a5121e8126b144ab7ddf11bbc8", "message": "NXP-28367: blacklist RetentionRule and RetentionRules for import in Web UI", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "9649281e990ff66da0572d7e81e9510e61aa4062", "url": "https://github.com/nuxeo/nuxeo/commit/9649281e990ff66da0572d7e81e9510e61aa4062", "message": "NXP-28367: optimize doc type and schema fetching", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "4b7dbb899462658b23ad6bee54aa1bda88dbb7bf", "url": "https://github.com/nuxeo/nuxeo/commit/4b7dbb899462658b23ad6bee54aa1bda88dbb7bf", "message": "NXP-28367: remove nuxeo-retention-rules", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "2a8923f30ab403b34a005ffdffce560ce8dc469f", "url": "https://github.com/nuxeo/nuxeo/commit/2a8923f30ab403b34a005ffdffce560ce8dc469f", "message": "NXP-28000: align on 11.1-SNAPSHOT", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "c5ce68d6e0ce12de5bdbb3d83c7619cfbb097c4c", "url": "https://github.com/nuxeo/nuxeo/commit/c5ce68d6e0ce12de5bdbb3d83c7619cfbb097c4c", "message": "NXP-28000: remove 10.10 web ui prop to enforce commentable facet check", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "3e5133b68d4f80045386adfcc5beb80025944d4d", "url": "https://github.com/nuxeo/nuxeo/commit/3e5133b68d4f80045386adfcc5beb80025944d4d", "message": "NXP-28000: align on NXP-26911 -> fix inconsistent post commit listeners", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "b0c9c277a09db5859d583610e601528f61ff9e50", "url": "https://github.com/nuxeo/nuxeo/commit/b0c9c277a09db5859d583610e601528f61ff9e50", "message": "NXP-28000: move web ui res to web ui repo", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "489a92929f02af89e905da824cef78a4a5b2a60c", "url": "https://github.com/nuxeo/nuxeo/commit/489a92929f02af89e905da824cef78a4a5b2a60c", "message": "NXP-28000: add retention package", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "3751bc85b3e3e23832f32ca0f75bed17ffe22760", "url": "https://github.com/nuxeo/nuxeo/commit/3751bc85b3e3e23832f32ca0f75bed17ffe22760", "message": "NXP-28552:  log retention events in audit", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "789a2709afc3f5097d3ac28e7af18e25e2fa81d0", "url": "https://github.com/nuxeo/nuxeo/commit/789a2709afc3f5097d3ac28e7af18e25e2fa81d0", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-03-05T12:02:11Z", "type": "commit"}, {"oid": "789a2709afc3f5097d3ac28e7af18e25e2fa81d0", "url": "https://github.com/nuxeo/nuxeo/commit/789a2709afc3f5097d3ac28e7af18e25e2fa81d0", "message": "NXP-28640: upgrade ant assembly version to 2.1.4", "committedDate": "2020-03-05T12:02:11Z", "type": "forcePushed"}]}